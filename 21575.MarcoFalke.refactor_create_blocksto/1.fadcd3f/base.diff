[33mdiff --git a/src/Makefile.am b/src/Makefile.am[m
[33mindex 4e09c86ebd..f0da4937e5 100644[m
[33m--- a/src/Makefile.am[m
[33m+++ b/src/Makefile.am[m
[36m@@ -174,6 +174,7 @@[m [mBITCOIN_CORE_H = \[m
   netaddress.h \[m
   netbase.h \[m
   netmessagemaker.h \[m
[32m+[m[32m  node/blockstorage.h \[m
   node/coin.h \[m
   node/coinstats.h \[m
   node/context.h \[m
[36m@@ -324,6 +325,7 @@[m [mlibbitcoin_server_a_SOURCES = \[m
   miner.cpp \[m
   net.cpp \[m
   net_processing.cpp \[m
[32m+[m[32m  node/blockstorage.cpp \[m
   node/coin.cpp \[m
   node/coinstats.cpp \[m
   node/context.cpp \[m
[33mdiff --git a/src/index/base.cpp b/src/index/base.cpp[m
[33mindex 25644c3b41..9e637c9c6f 100644[m
[33m--- a/src/index/base.cpp[m
[33m+++ b/src/index/base.cpp[m
[36m@@ -4,12 +4,13 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/base.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/ui_interface.h>[m
 #include <shutdown.h>[m
 #include <tinyformat.h>[m
 #include <util/system.h>[m
 #include <util/translation.h>[m
[31m-#include <validation.h>[m
[32m+[m[32m#include <validation.h> // For g_chainman[m
 #include <warnings.h>[m
 [m
 constexpr char DB_BEST_BLOCK = 'B';[m
[33mdiff --git a/src/index/blockfilterindex.cpp b/src/index/blockfilterindex.cpp[m
[33mindex 32271fb7ab..154d7a7027 100644[m
[33m--- a/src/index/blockfilterindex.cpp[m
[33m+++ b/src/index/blockfilterindex.cpp[m
[36m@@ -6,8 +6,8 @@[m
 [m
 #include <dbwrapper.h>[m
 #include <index/blockfilterindex.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <util/system.h>[m
[31m-#include <validation.h>[m
 [m
 /* The index database stores three items for each block: the disk location of the encoded filter,[m
  * its dSHA256 hash, and the header. Those belonging to blocks on the active chain are indexed by[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex 17b216573f..c7e8699d6b 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -16,7 +16,6 @@[m
 #include <chain.h>[m
 #include <chainparams.h>[m
 #include <compat/sanity.h>[m
[31m-#include <consensus/validation.h>[m
 #include <fs.h>[m
 #include <hash.h>[m
 #include <httprpc.h>[m
[36m@@ -32,6 +31,7 @@[m
 #include <net_permissions.h>[m
 #include <net_processing.h>[m
 #include <netbase.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/context.h>[m
 #include <node/ui_interface.h>[m
 #include <policy/feerate.h>[m
[36m@@ -61,7 +61,6 @@[m
 #include <util/threadnames.h>[m
 #include <util/translation.h>[m
 #include <validation.h>[m
[31m-[m
 #include <validationinterface.h>[m
 #include <walletinitinterface.h>[m
 [m
[36m@@ -90,7 +89,6 @@[m
 [m
 static const bool DEFAULT_PROXYRANDOMIZE = true;[m
 static const bool DEFAULT_REST_ENABLE = false;[m
[31m-static const bool DEFAULT_STOPAFTERBLOCKIMPORT = false;[m
 [m
 #ifdef WIN32[m
 // Win32 LevelDB doesn't use filedescriptors, and the ones used for[m
[36m@@ -155,8 +153,6 @@[m [mstatic fs::path GetPidFile(const ArgsManager& args)[m
 [m
 static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;[m
 [m
[31m-static std::thread g_load_block;[m
[31m-[m
 void Interrupt(NodeContext& node)[m
 {[m
     InterruptHTTPServer();[m
[36m@@ -220,7 +216,7 @@[m [mvoid Shutdown(NodeContext& node)[m
     // After everything has been shut down, but before things get flushed, stop the[m
     // CScheduler/checkqueue, scheduler and load block thread.[m
     if (node.scheduler) node.scheduler->stop();[m
[31m-    if (g_load_block.joinable()) g_load_block.join();[m
[32m+[m[32m    if (node.chainman && node.chainman->m_load_block.joinable()) node.chainman->m_load_block.join();[m
     StopScriptCheckWorkerThreads();[m
 [m
     // After the threads that potentially access these pointers have been stopped,[m
[36m@@ -627,20 +623,6 @@[m [mstatic void BlockNotifyGenesisWait(const CBlockIndex* pBlockIndex)[m
     }[m
 }[m
 [m
[31m-struct CImportingNow[m
[31m-{[m
[31m-    CImportingNow() {[m
[2;3m-        assert(fImporting == false);[m
[2;3m-        fImporting = true;[m
[2;3m-    }[m
[2;3m-[m
[31m-    ~CImportingNow() {[m
[2m-        assert(fImporting == true);[m
[2m-        fImporting = false;[m
[2m-    }[m
[2m-};[m
[2m-[m
[31m-[m
 // If we're using -prune with -reindex, then delete block files that will be ignored by the[m
 // reindex.  Since reindexing works by starting at block file 0 and looping until a blockfile[m
 // is missing, do the same here to delete any later block files after a gap.  Also delete all[m
[36m@@ -693,77 +675,6 @@[m [mstatic void StartupNotify(const ArgsManager& args)[m
 }[m
 #endif[m
 [m
[31m-static void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args)[m
[2m-{[m
[2m-    const CChainParams& chainparams = Params();[m
[2m-    ScheduleBatchPriority();[m
[2m-[m
[2m-    {[m
[31m-    CImportingNow imp;[m
[31m-[m
[31m-    // -reindex[m
[31m-    if (fReindex) {[m
[31m-        int nFile = 0;[m
[31m-        while (true) {[m
[31m-            FlatFilePos pos(nFile, 0);[m
[31m-            if (!fs::exists(GetBlockPosFilename(pos)))[m
[31m-                break; // No block files left to reindex[m
[31m-            FILE *file = OpenBlockFile(pos, true);[m
[31m-            if (!file)[m
[31m-                break; // This error is logged in OpenBlockFile[m
[31m-            LogPrintf("Reindexing block file blk%05u.dat...\n", (unsigned int)nFile);[m
[31m-            ::ChainstateActive().LoadExternalBlockFile(chainparams, file, &pos);[m
[31m-            if (ShutdownRequested()) {[m
[31m-                LogPrintf("Shutdown requested. Exit %s\n", __func__);[m
[31m-                return;[m
[31m-            }[m
[31m-            nFile++;[m
[31m-        }[m
[31m-        pblocktree->WriteReindexing(false);[m
[31m-        fReindex = false;[m
[31m-        LogPrintf("Reindexing finished\n");[m
[31m-        // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):[m
[31m-        ::ChainstateActive().LoadGenesisBlock(chainparams);[m
[31m-    }[m
[31m-[m
[31m-    // -loadblock=[m
[31m-    for (const fs::path& path : vImportFiles) {[m
[31m-        FILE *file = fsbridge::fopen(path, "rb");[m
[31m-        if (file) {[m
[31m-            LogPrintf("Importing blocks file %s...\n", path.string());[m
[31m-            ::ChainstateActive().LoadExternalBlockFile(chainparams, file);[m
[31m-            if (ShutdownRequested()) {[m
[31m-                LogPrintf("Shutdown requested. Exit %s\n", __func__);[m
[31m-                return;[m
[31m-            }[m
[31m-        } else {[m
[31m-            LogPrintf("Warning: Could not open blocks file %s\n", path.string());[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    // scan for better chains in the block chain database, that are not yet connected in the active best chain[m
[31m-[m
[31m-    // We can't hold cs_main during ActivateBestChain even though we're accessing[m
[31m-    // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve[m
[31m-    // the relevant pointers before the ABC call.[m
[31m-    for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {[m
[31m-        BlockValidationState state;[m
[31m-        if (!chainstate->ActivateBestChain(state, chainparams, nullptr)) {[m
[31m-            LogPrintf("Failed to connect best block (%s)\n", state.ToString());[m
[31m-            StartShutdown();[m
[31m-            return;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    if (args.GetBoolArg("-stopafterblockimport", DEFAULT_STOPAFTERBLOCKIMPORT)) {[m
[31m-        LogPrintf("Stopping after block import\n");[m
[31m-        StartShutdown();[m
[31m-        return;[m
[31m-    }[m
[2m-    } // End scope of CImportingNow[m
[2m-    chainman.ActiveChainstate().LoadMempool(args);[m
[2m-}[m
[31m-[m
 /** Sanity checks[m
  *  Ensure that Bitcoin is running in a usable environment with all[m
  *  necessary library support.[m
[36m@@ -1880,7 +1791,7 @@[m [mbool AppInitMain(const std::any& context, NodeContext& node, interfaces::BlockAn[m
         vImportFiles.push_back(strFile);[m
     }[m
 [m
[31m-    g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {[m
[32m+[m[32m    chainman.m_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {[m
         ThreadImport(chainman, vImportFiles, args);[m
     });[m
 [m
[33mdiff --git a/src/net_processing.cpp b/src/net_processing.cpp[m
[33mindex 4108de2c8a..61faf7e1ee 100644[m
[33m--- a/src/net_processing.cpp[m
[33m+++ b/src/net_processing.cpp[m
[36m@@ -16,6 +16,7 @@[m
 #include <merkleblock.h>[m
 #include <netbase.h>[m
 #include <netmessagemaker.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <policy/fees.h>[m
 #include <policy/policy.h>[m
 #include <primitives/block.h>[m
[33mdiff --git a/src/node/README.md b/src/node/README.md[m
[33mindex e99a717534..ab5979594d 100644[m
[33m--- a/src/node/README.md[m
[33m+++ b/src/node/README.md[m
[36m@@ -15,8 +15,7 @@[m [mAs a rule of thumb, code in one of the [`src/node/`](./),[m
 calling code in the other directories directly, and only invoke it indirectly[m
 through the more limited [`src/interfaces/`](../interfaces/) classes.[m
 [m
[31m-The [`src/node/`](./) directory is a new directory introduced in[m
[31m-[#14978](https://github.com/bitcoin/bitcoin/pull/14978) and at the moment is[m
[32m+[m[32mThis directory is at the moment[m
 sparsely populated. Eventually more substantial files like[m
 [`src/validation.cpp`](../validation.cpp) and[m
 [`src/txmempool.cpp`](../txmempool.cpp) might be moved there.[m
[33mdiff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..daed6605e8[m
[33m--- /dev/null[m
[33m+++ b/src/node/blockstorage.cpp[m
[36m@@ -0,0 +1,244 @@[m
[32m+[m[32m// Copyright (c) 2011-2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <node/blockstorage.h>[m
[32m+[m
[32m+[m[32m#include <chain.h>[m
[32m+[m[32m#include <chainparams.h>[m
[32m+[m[32m#include <flatfile.h>[m
[32m+[m[32m#include <fs.h>[m
[32m+[m[32m#include <pow.h>[m
[32m+[m[32m#include <shutdown.h>[m
[32m+[m[32m#include <signet.h>[m
[32m+[m[32m#include <streams.h>[m
[32m+[m[32m#include <util/system.h>[m
[32m+[m[32m#include <validation.h>[m
[32m+[m
[32m+[m[32m// From validation. TODO move here[m
[32m+[m[32mbool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false);[m
[2m+[m
[2m+[m[2mstatic bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)[m
[2m+[m[2m{[m
[2m+[m[2m    // Open history file to append[m
[2m+[m[2m    CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);[m
[32m+[m[32m    if (fileout.IsNull()) {[m
[2;3m+[m[2;3m        return error("WriteBlockToDisk: OpenBlockFile failed");[m
[32m+[m[32m    }[m
[32m+[m
[2;3m+[m[2;3m    // Write index header[m
[2;3m+[m[2;3m    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());[m
[2;3m+[m[2;3m    fileout << messageStart << nSize;[m
[2;3m+[m
[2;3m+[m[2;3m    // Write block[m
[2;3m+[m[2;3m    long fileOutPos = ftell(fileout.Get());[m
[32m+[m[32m    if (fileOutPos < 0) {[m
[2m+[m[2m        return error("WriteBlockToDisk: ftell failed");[m
[32m+[m[32m    }[m
[2m+[m[2m    pos.nPos = (unsigned int)fileOutPos;[m
[2m+[m[2m    fileout << block;[m
[2m+[m
[2m+[m[2m    return true;[m
[2m+[m[2m}[m
[2m+[m
[2m+[m[2mbool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams)[m
[2m+[m[2m{[m
[2m+[m[2m    block.SetNull();[m
[2m+[m
[2m+[m[2m    // Open history file to read[m
[2m+[m[2m    CAutoFile filein(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);[m
[32m+[m[32m    if (filein.IsNull()) {[m
[2m+[m[2m        return error("ReadBlockFromDisk: OpenBlockFile failed for %s", pos.ToString());[m
[32m+[m[32m    }[m
[32m+[m
[2m+[m[2m    // Read block[m
[2m+[m[2m    try {[m
[2m+[m[2m        filein >> block;[m
[32m+[m[32m    } catch (const std::exception& e) {[m
[2;3m+[m[2;3m        return error("%s: Deserialize or I/O error - %s at %s", __func__, e.what(), pos.ToString());[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m    // Check the header[m
[32m+[m[32m    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams)) {[m
[2m+[m[2m        return error("ReadBlockFromDisk: Errors in block header at %s", pos.ToString());[m
[32m+[m[32m    }[m
[32m+[m
[2m+[m[2m    // Signet only: check block solution[m
[2m+[m[2m    if (consensusParams.signet_blocks && !CheckSignetBlockSolution(block, consensusParams)) {[m
[2m+[m[2m        return error("ReadBlockFromDisk: Errors in block solution at %s", pos.ToString());[m
[2m+[m[2m    }[m
[2m+[m
[2m+[m[2m    return true;[m
[2m+[m[2m}[m
[2m+[m
[2m+[m[2mbool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)[m
[2m+[m[2m{[m
[2m+[m[2m    FlatFilePos blockPos;[m
[2m+[m[2m    {[m
[2m+[m[2m        LOCK(cs_main);[m
[2m+[m[2m        blockPos = pindex->GetBlockPos();[m
[2m+[m[2m    }[m
[2m+[m
[32m+[m[32m    if (!ReadBlockFromDisk(block, blockPos, consensusParams)) {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (block.GetHash() != pindex->GetBlockHash()) {[m
[2;3m+[m[2;3m        return error("ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s",[m
[32m+[m[32m                     pindex->ToString(), pindex->GetBlockPos().ToString());[m
[32m+[m[32m    }[m
[2;3m+[m[2;3m    return true;[m
[2;3m+[m[2;3m}[m
[2;3m+[m
[2;3m+[m[2;3mbool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start)[m
[2;3m+[m[2;3m{[m
[2;3m+[m[2;3m    FlatFilePos hpos = pos;[m
[2;3m+[m[2;3m    hpos.nPos -= 8; // Seek back 8 bytes for meta header[m
[2;3m+[m[2;3m    CAutoFile filein(OpenBlockFile(hpos, true), SER_DISK, CLIENT_VERSION);[m
[2;3m+[m[2;3m    if (filein.IsNull()) {[m
[2;3m+[m[2;3m        return error("%s: OpenBlockFile failed for %s", __func__, pos.ToString());[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m    try {[m
[2;3m+[m[2;3m        CMessageHeader::MessageStartChars blk_start;[m
[2;3m+[m[2;3m        unsigned int blk_size;[m
[2;3m+[m
[2;3m+[m[2;3m        filein >> blk_start >> blk_size;[m
[2;3m+[m
[2;3m+[m[2;3m        if (memcmp(blk_start, message_start, CMessageHeader::MESSAGE_START_SIZE)) {[m
[2;3m+[m[2;3m            return error("%s: Block magic mismatch for %s: %s versus expected %s", __func__, pos.ToString(),[m
[32m+[m[32m                         HexStr(blk_start),[m
[32m+[m[32m                         HexStr(message_start));[m
[2m+[m[2m        }[m
[2m+[m
[2m+[m[2m        if (blk_size > MAX_SIZE) {[m
[2m+[m[2m            return error("%s: Block data is larger than maximum deserialization size for %s: %s versus %s", __func__, pos.ToString(),[m
[32m+[m[32m                         blk_size, MAX_SIZE);[m
[2;3m+[m[2;3m        }[m
[2;3m+[m
[2;3m+[m[2;3m        block.resize(blk_size); // Zeroing of memory is intentional here[m
[2;3m+[m[2;3m        filein.read((char*)block.data(), blk_size);[m
[32m+[m[32m    } catch (const std::exception& e) {[m
[2m+[m[2m        return error("%s: Read from block file failed: %s for %s", __func__, e.what(), pos.ToString());[m
[2m+[m[2m    }[m
[2m+[m
[2m+[m[2m    return true;[m
[2m+[m[2m}[m
[2m+[m
[2m+[m[2mbool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start)[m
[2m+[m[2m{[m
[2m+[m[2m    FlatFilePos block_pos;[m
[2m+[m[2m    {[m
[2m+[m[2m        LOCK(cs_main);[m
[2m+[m[2m        block_pos = pindex->GetBlockPos();[m
[2m+[m[2m    }[m
[2m+[m
[2m+[m[2m    return ReadRawBlockFromDisk(block, block_pos, message_start);[m
[2m+[m[2m}[m
[1;36m+[m
[1;33m+[m[1;33m/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */[m
[32m+[m[32mFlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp)[m
[32m+[m[32m{[m
[2;3m+[m[2;3m    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);[m
[2;3m+[m[2;3m    FlatFilePos blockPos;[m
[32m+[m[32m    if (dbp != nullptr) {[m
[32m+[m[32m        blockPos = *dbp;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!FindBlockPos(blockPos, nBlockSize + 8, nHeight, active_chain, block.GetBlockTime(), dbp != nullptr)) {[m
[2m+[m[2m        error("%s: FindBlockPos failed", __func__);[m
[2m+[m[2m        return FlatFilePos();[m
[2m+[m[2m    }[m
[2m+[m[2m    if (dbp == nullptr) {[m
[2m+[m[2m        if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart())) {[m
[2m+[m[2m            AbortNode("Failed to write block");[m
[2m+[m[2m            return FlatFilePos();[m
[2m+[m[2m        }[m
[2m+[m[2m    }[m
[2m+[m[2m    return blockPos;[m
[2m+[m[2m}[m
[2m+[m
[32m+[m[32mstruct CImportingNow {[m
[32m+[m[32m    CImportingNow()[m
[32m+[m[32m    {[m
[2m+[m[2m        assert(fImporting == false);[m
[2m+[m[2m        fImporting = true;[m
[2m+[m[2m    }[m
[2m+[m
[32m+[m[32m    ~CImportingNow()[m
[32m+[m[32m    {[m
[2m+[m[2m        assert(fImporting == true);[m
[2m+[m[2m        fImporting = false;[m
[2m+[m[2m    }[m
[2m+[m[2m};[m
[2m+[m
[32m+[m[32mvoid ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args)[m
[2;3m+[m[2;3m{[m
[2;3m+[m[2;3m    const CChainParams& chainparams = Params();[m
[2;3m+[m[2;3m    ScheduleBatchPriority();[m
[2;3m+[m
[2;3m+[m[2;3m    {[m
[32m+[m[32m        CImportingNow imp;[m
[32m+[m
[32m+[m[32m        // -reindex[m
[32m+[m[32m        if (fReindex) {[m
[32m+[m[32m            int nFile = 0;[m
[32m+[m[32m            while (true) {[m
[32m+[m[32m                FlatFilePos pos(nFile, 0);[m
[32m+[m[32m                if (!fs::exists(GetBlockPosFilename(pos))) {[m
[32m+[m[32m                    break; // No block files left to reindex[m
[32m+[m[32m                }[m
[32m+[m[32m                FILE* file = OpenBlockFile(pos, true);[m
[32m+[m[32m                if (!file) {[m
[32m+[m[32m                    break; // This error is logged in OpenBlockFile[m
[32m+[m[32m                }[m
[32m+[m[32m                LogPrintf("Reindexing block file blk%05u.dat...\n", (unsigned int)nFile);[m
[32m+[m[32m                chainman.ActiveChainstate().LoadExternalBlockFile(chainparams, file, &pos);[m
[32m+[m[32m                if (ShutdownRequested()) {[m
[32m+[m[32m                    LogPrintf("Shutdown requested. Exit %s\n", __func__);[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m                nFile++;[m
[32m+[m[32m            }[m
[32m+[m[32m            pblocktree->WriteReindexing(false);[m
[32m+[m[32m            fReindex = false;[m
[32m+[m[32m            LogPrintf("Reindexing finished\n");[m
[32m+[m[32m            // To avoid ending up in a situation without genesis block, re-try initializing (no-op if reindexing worked):[m
[32m+[m[32m            chainman.ActiveChainstate().LoadGenesisBlock(chainparams);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // -loadblock=[m
[32m+[m[32m        for (const fs::path& path : vImportFiles) {[m
[32m+[m[32m            FILE* file = fsbridge::fopen(path, "rb");[m
[32m+[m[32m            if (file) {[m
[32m+[m[32m                LogPrintf("Importing blocks file %s...\n", path.string());[m
[32m+[m[32m                chainman.ActiveChainstate().LoadExternalBlockFile(chainparams, file);[m
[32m+[m[32m                if (ShutdownRequested()) {[m
[32m+[m[32m                    LogPrintf("Shutdown requested. Exit %s\n", __func__);[m
[32m+[m[32m                    return;[m
[32m+[m[32m                }[m
[32m+[m[32m            } else {[m
[32m+[m[32m                LogPrintf("Warning: Could not open blocks file %s\n", path.string());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // scan for better chains in the block chain database, that are not yet connected in the active best chain[m
[32m+[m
[32m+[m[32m        // We can't hold cs_main during ActivateBestChain even though we're accessing[m
[32m+[m[32m        // the chainman unique_ptrs since ABC requires us not to be holding cs_main, so retrieve[m
[32m+[m[32m        // the relevant pointers before the ABC call.[m
[32m+[m[32m        for (CChainState* chainstate : WITH_LOCK(::cs_main, return chainman.GetAll())) {[m
[32m+[m[32m            BlockValidationState state;[m
[32m+[m[32m            if (!chainstate->ActivateBestChain(state, chainparams, nullptr)) {[m
[32m+[m[32m                LogPrintf("Failed to connect best block (%s)\n", state.ToString());[m
[32m+[m[32m                StartShutdown();[m
[32m+[m[32m                return;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (args.GetBoolArg("-stopafterblockimport", DEFAULT_STOPAFTERBLOCKIMPORT)) {[m
[32m+[m[32m            LogPrintf("Stopping after block import\n");[m
[32m+[m[32m            StartShutdown();[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[2;3m+[m[2;3m    } // End scope of CImportingNow[m
[2;3m+[m[2;3m    chainman.ActiveChainstate().LoadMempool(args);[m
[2;3m+[m[2;3m}[m
[33mdiff --git a/src/node/blockstorage.h b/src/node/blockstorage.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..3b546f0719[m
[33m--- /dev/null[m
[33m+++ b/src/node/blockstorage.h[m
[36m@@ -0,0 +1,40 @@[m
[32m+[m[32m// Copyright (c) 2011-2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_NODE_BLOCKSTORAGE_H[m
[32m+[m[32m#define BITCOIN_NODE_BLOCKSTORAGE_H[m
[32m+[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32m#include <fs.h>[m
[32m+[m[32m#include <protocol.h> // For CMessageHeader::MessageStartChars[m
[32m+[m
[32m+[m[32mclass ArgsManager;[m
[32m+[m[32mclass CBlock;[m
[32m+[m[32mclass CBlockIndex;[m
[32m+[m[32mclass CBlockUndo;[m
[32m+[m[32mclass CChain;[m
[32m+[m[32mclass CChainParams;[m
[32m+[m[32mclass ChainstateManager;[m
[32m+[m[32mstruct FlatFilePos;[m
[32m+[m[32mnamespace Consensus {[m
[32m+[m[32mstruct Params;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic constexpr bool DEFAULT_STOPAFTERBLOCKIMPORT{false};[m
[2;3m+[m
[2;3m+[m[2;3m/** Functions for disk access for blocks */[m
[2;3m+[m[2;3mbool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams);[m
[2;3m+[m[2;3mbool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);[m
[2;3m+[m[2;3mbool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start);[m
[2;3m+[m[2;3mbool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);[m
[2;3m+[m
[2;3m+[m[2;3mbool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);[m
[2;3m+[m
[32m+[m[32mFlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);[m
[32m+[m
[32m+[m[32mvoid ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args);[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_NODE_BLOCKSTORAGE_H[m
[33mdiff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp[m
[33mindex 7ad02f81dc..264bec58f9 100644[m
[33m--- a/src/node/interfaces.cpp[m
[33m+++ b/src/node/interfaces.cpp[m
[36m@@ -4,7 +4,6 @@[m
 [m
 #include <addrdb.h>[m
 #include <banman.h>[m
[2m-#include <boost/signals2/signal.hpp>[m
 #include <chain.h>[m
 #include <chainparams.h>[m
 #include <init.h>[m
[36m@@ -17,6 +16,7 @@[m
 #include <net_processing.h>[m
 #include <netaddress.h>[m
 #include <netbase.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/coin.h>[m
 #include <node/context.h>[m
 #include <node/transaction.h>[m
[36m@@ -53,6 +53,8 @@[m
 #include <optional>[m
 #include <utility>[m
 [m
[2m+[m[2m#include <boost/signals2/signal.hpp>[m
[32m+[m
 using interfaces::BlockTip;[m
 using interfaces::Chain;[m
 using interfaces::FoundBlock;[m
[33mdiff --git a/src/rest.cpp b/src/rest.cpp[m
[33mindex aa97470ca7..1398de19e3 100644[m
[33m--- a/src/rest.cpp[m
[33m+++ b/src/rest.cpp[m
[36m@@ -8,6 +8,7 @@[m
 #include <core_io.h>[m
 #include <httpserver.h>[m
 #include <index/txindex.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/context.h>[m
 #include <primitives/block.h>[m
 #include <primitives/transaction.h>[m
[33mdiff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp[m
[33mindex e1501d7254..183fa50228 100644[m
[33m--- a/src/rpc/blockchain.cpp[m
[33m+++ b/src/rpc/blockchain.cpp[m
[36m@@ -14,6 +14,7 @@[m
 #include <core_io.h>[m
 #include <hash.h>[m
 #include <index/blockfilterindex.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/coinstats.h>[m
 #include <node/context.h>[m
 #include <node/utxo_snapshot.h>[m
[33mdiff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp[m
[33mindex 7932bd2915..527e9be87c 100644[m
[33m--- a/src/rpc/rawtransaction.cpp[m
[33m+++ b/src/rpc/rawtransaction.cpp[m
[36m@@ -10,6 +10,7 @@[m
 #include <index/txindex.h>[m
 #include <key_io.h>[m
 #include <merkleblock.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/coin.h>[m
 #include <node/context.h>[m
 #include <node/psbt.h>[m
[33mdiff --git a/src/shutdown.cpp b/src/shutdown.cpp[m
[33mindex 2fc195e2d1..35faf3c412 100644[m
[33m--- a/src/shutdown.cpp[m
[33m+++ b/src/shutdown.cpp[m
[36m@@ -6,7 +6,9 @@[m
 #include <shutdown.h>[m
 [m
 #include <logging.h>[m
[32m+[m[32m#include <node/ui_interface.h>[m
 #include <util/tokenpipe.h>[m
[32m+[m[32m#include <warnings.h>[m
 [m
 #include <config/bitcoin-config.h>[m
 [m
[36m@@ -16,6 +18,18 @@[m
 #include <condition_variable>[m
 #endif[m
 [m
[32m+[m[32mbool AbortNode(const std::string& strMessage, bilingual_str user_message)[m
[2m+[m[2m{[m
[2m+[m[2m    SetMiscWarning(Untranslated(strMessage));[m
[2m+[m[2m    LogPrintf("*** %s\n", strMessage);[m
[2m+[m[2m    if (user_message.empty()) {[m
[2m+[m[2m        user_message = _("A fatal internal error occurred, see debug.log for details");[m
[2m+[m[2m    }[m
[2m+[m[2m    AbortError(user_message);[m
[2m+[m[2m    StartShutdown();[m
[2m+[m[2m    return false;[m
[2m+[m[2m}[m
[2m+[m
 static std::atomic<bool> fRequestShutdown(false);[m
 #ifdef WIN32[m
 /** On windows it is possible to simply use a condition variable. */[m
[33mdiff --git a/src/shutdown.h b/src/shutdown.h[m
[33mindex b2fbdb8cfb..ff56c6bd87 100644[m
[33m--- a/src/shutdown.h[m
[33m+++ b/src/shutdown.h[m
[36m@@ -6,6 +6,11 @@[m
 #ifndef BITCOIN_SHUTDOWN_H[m
 #define BITCOIN_SHUTDOWN_H[m
 [m
[32m+[m[32m#include <util/translation.h> // For bilingual_str[m
[32m+[m
[32m+[m[32m/** Abort with a message */[m
[32m+[m[32mbool AbortNode(const std::string& strMessage, bilingual_str user_message = bilingual_str{});[m
[32m+[m
 /** Initialize shutdown state. This must be called before using either StartShutdown(),[m
  * AbortShutdown() or WaitForShutdown(). Calling ShutdownRequested() is always safe.[m
  */[m
[33mdiff --git a/src/test/util/blockfilter.cpp b/src/test/util/blockfilter.cpp[m
[33mindex bccff5e5a6..b8ab9d2344 100644[m
[33m--- a/src/test/util/blockfilter.cpp[m
[33m+++ b/src/test/util/blockfilter.cpp[m
[36m@@ -5,6 +5,7 @@[m
 #include <test/util/blockfilter.h>[m
 [m
 #include <chainparams.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <validation.h>[m
 [m
 [m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex 19363c0efb..652282920e 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -21,6 +21,7 @@[m
 #include <index/txindex.h>[m
 #include <logging.h>[m
 #include <logging/timer.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <node/coinstats.h>[m
 #include <node/ui_interface.h>[m
 #include <policy/policy.h>[m
[36m@@ -1148,123 +1149,6 @@[m [mCTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMe[m
     return nullptr;[m
 }[m
 [m
[31m-//////////////////////////////////////////////////////////////////////////////[m
[31m-//[m
[31m-// CBlock and CBlockIndex[m
[31m-//[m
[2m-[m
[2m-static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)[m
[2m-{[m
[2m-    // Open history file to append[m
[2m-    CAutoFile fileout(OpenBlockFile(pos), SER_DISK, CLIENT_VERSION);[m
[31m-    if (fileout.IsNull())[m
[1;34m-        return error("WriteBlockToDisk: OpenBlockFile failed");[m
[1;35m-[m
[2m-    // Write index header[m
[2m-    unsigned int nSize = GetSerializeSize(block, fileout.GetVersion());[m
[2m-    fileout << messageStart << nSize;[m
[2m-[m
[2m-    // Write block[m
[2m-    long fileOutPos = ftell(fileout.Get());[m
[31m-    if (fileOutPos < 0)[m
[1;34m-        return error("WriteBlockToDisk: ftell failed");[m
[1;35m-    pos.nPos = (unsigned int)fileOutPos;[m
[2m-    fileout << block;[m
[2m-[m
[2m-    return true;[m
[2m-}[m
[2m-[m
[2m-bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams)[m
[2m-{[m
[2m-    block.SetNull();[m
[2m-[m
[2m-    // Open history file to read[m
[2m-    CAutoFile filein(OpenBlockFile(pos, true), SER_DISK, CLIENT_VERSION);[m
[31m-    if (filein.IsNull())[m
[1;34m-        return error("ReadBlockFromDisk: OpenBlockFile failed for %s", pos.ToString());[m
[1;35m-[m
[2m-    // Read block[m
[2m-    try {[m
[2m-        filein >> block;[m
[31m-    }[m
[31m-    catch (const std::exception& e) {[m
[2m-        return error("%s: Deserialize or I/O error - %s at %s", __func__, e.what(), pos.ToString());[m
[2m-    }[m
[2m-[m
[2m-    // Check the header[m
[31m-    if (!CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))[m
[1;34m-        return error("ReadBlockFromDisk: Errors in block header at %s", pos.ToString());[m
[1;35m-[m
[2m-    // Signet only: check block solution[m
[2m-    if (consensusParams.signet_blocks && !CheckSignetBlockSolution(block, consensusParams)) {[m
[2m-        return error("ReadBlockFromDisk: Errors in block solution at %s", pos.ToString());[m
[2m-    }[m
[2m-[m
[2m-    return true;[m
[2m-}[m
[2m-[m
[2m-bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)[m
[2m-{[m
[2m-    FlatFilePos blockPos;[m
[2m-    {[m
[2m-        LOCK(cs_main);[m
[2m-        blockPos = pindex->GetBlockPos();[m
[2m-    }[m
[2m-[m
[31m-    if (!ReadBlockFromDisk(block, blockPos, consensusParams))[m
[31m-        return false;[m
[31m-    if (block.GetHash() != pindex->GetBlockHash())[m
[2m-        return error("ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s",[m
[31m-                pindex->ToString(), pindex->GetBlockPos().ToString());[m
[2;3m-    return true;[m
[2;3m-}[m
[2;3m-[m
[2;3m-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start)[m
[2;3m-{[m
[2;3m-    FlatFilePos hpos = pos;[m
[2;3m-    hpos.nPos -= 8; // Seek back 8 bytes for meta header[m
[2;3m-    CAutoFile filein(OpenBlockFile(hpos, true), SER_DISK, CLIENT_VERSION);[m
[2;3m-    if (filein.IsNull()) {[m
[2;3m-        return error("%s: OpenBlockFile failed for %s", __func__, pos.ToString());[m
[2;3m-    }[m
[2;3m-[m
[2;3m-    try {[m
[2;3m-        CMessageHeader::MessageStartChars blk_start;[m
[2;3m-        unsigned int blk_size;[m
[2;3m-[m
[2;3m-        filein >> blk_start >> blk_size;[m
[2;3m-[m
[2;3m-        if (memcmp(blk_start, message_start, CMessageHeader::MESSAGE_START_SIZE)) {[m
[2;3m-            return error("%s: Block magic mismatch for %s: %s versus expected %s", __func__, pos.ToString(),[m
[31m-                    HexStr(blk_start),[m
[31m-                    HexStr(message_start));[m
[2m-        }[m
[2m-[m
[2m-        if (blk_size > MAX_SIZE) {[m
[2m-            return error("%s: Block data is larger than maximum deserialization size for %s: %s versus %s", __func__, pos.ToString(),[m
[31m-                    blk_size, MAX_SIZE);[m
[2;3m-        }[m
[2;3m-[m
[2;3m-        block.resize(blk_size); // Zeroing of memory is intentional here[m
[2;3m-        filein.read((char*)block.data(), blk_size);[m
[31m-    } catch(const std::exception& e) {[m
[2m-        return error("%s: Read from block file failed: %s for %s", __func__, e.what(), pos.ToString());[m
[2m-    }[m
[2m-[m
[2m-    return true;[m
[2m-}[m
[2m-[m
[2m-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start)[m
[2m-{[m
[2m-    FlatFilePos block_pos;[m
[2m-    {[m
[2m-        LOCK(cs_main);[m
[2m-        block_pos = pindex->GetBlockPos();[m
[2m-    }[m
[2m-[m
[2m-    return ReadRawBlockFromDisk(block, block_pos, message_start);[m
[2m-}[m
[2m-[m
 CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)[m
 {[m
     int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;[m
[36m@@ -1636,19 +1520,6 @@[m [mbool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)[m
     return true;[m
 }[m
 [m
[31m-/** Abort with a message */[m
[31m-static bool AbortNode(const std::string& strMessage, bilingual_str user_message = bilingual_str())[m
[2;3m-{[m
[2;3m-    SetMiscWarning(Untranslated(strMessage));[m
[2;3m-    LogPrintf("*** %s\n", strMessage);[m
[2;3m-    if (user_message.empty()) {[m
[2;3m-        user_message = _("A fatal internal error occurred, see debug.log for details");[m
[2;3m-    }[m
[2;3m-    AbortError(user_message);[m
[2;3m-    StartShutdown();[m
[2;3m-    return false;[m
[2;3m-}[m
[2;3m-[m
 static bool AbortNode(BlockValidationState& state, const std::string& strMessage, const bilingual_str& userMessage = bilingual_str())[m
 {[m
     AbortNode(strMessage, userMessage);[m
[36m@@ -3231,7 +3102,8 @@[m [mvoid CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi[m
     }[m
 }[m
 [m
[31m-static bool FindBlockPos(FlatFilePos &pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)[m
[32m+[m[32m// TODO move to blockstorage[m
[32m+[m[32mbool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)[m
 {[m
     LOCK(cs_LastBlockFile);[m
 [m
[36m@@ -3708,25 +3580,6 @@[m [mbool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&[m
     return true;[m
 }[m
 [m
[2m-/** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */[m
[31m-static FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp) {[m
[2;3m-    unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);[m
[2;3m-    FlatFilePos blockPos;[m
[31m-    if (dbp != nullptr)[m
[31m-        blockPos = *dbp;[m
[31m-    if (!FindBlockPos(blockPos, nBlockSize+8, nHeight, active_chain, block.GetBlockTime(), dbp != nullptr)) {[m
[2;3m-        error("%s: FindBlockPos failed", __func__);[m
[2;3m-        return FlatFilePos();[m
[2;3m-    }[m
[2;3m-    if (dbp == nullptr) {[m
[2;3m-        if (!WriteBlockToDisk(block, blockPos, chainparams.MessageStart())) {[m
[2;3m-            AbortNode("Failed to write block");[m
[2;3m-            return FlatFilePos();[m
[2;3m-        }[m
[2;3m-    }[m
[2;3m-    return blockPos;[m
[2;3m-}[m
[2;3m-[m
 /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */[m
 bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock)[m
 {[m
[33mdiff --git a/src/validation.h b/src/validation.h[m
[33mindex 21e63947fa..1eb010889d 100644[m
[33m--- a/src/validation.h[m
[33m+++ b/src/validation.h[m
[36m@@ -35,6 +35,7 @@[m
 #include <set>[m
 #include <stdint.h>[m
 #include <string>[m
[32m+[m[32m#include <thread>[m
 #include <utility>[m
 #include <vector>[m
 [m
[36m@@ -299,15 +300,6 @@[m [mpublic:[m
 /** Initializes the script-execution cache */[m
 void InitScriptExecutionCache();[m
 [m
[2m-[m
[2m-/** Functions for disk access for blocks */[m
[2m-bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::Params& consensusParams);[m
[2m-bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams);[m
[2m-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, const CMessageHeader::MessageStartChars& message_start);[m
[2m-bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);[m
[2m-[m
[2m-bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);[m
[2m-[m
 /** Functions for validating blocks and updating the block tree */[m
 [m
 /** Context-independent validity checks */[m
[36m@@ -869,6 +861,7 @@[m [mprivate:[m
     friend CChain& ChainActive();[m
 [m
 public:[m
[32m+[m[32m    std::thread m_load_block;[m
     //! A single BlockManager instance is shared across each constructed[m
     //! chainstate to avoid duplicating block metadata.[m
     BlockManager m_blockman GUARDED_BY(::cs_main);[m
[33mdiff --git a/src/zmq/zmqpublishnotifier.cpp b/src/zmq/zmqpublishnotifier.cpp[m
[33mindex 168ba841c8..25afa94d0f 100644[m
[33m--- a/src/zmq/zmqpublishnotifier.cpp[m
[33m+++ b/src/zmq/zmqpublishnotifier.cpp[m
[36m@@ -6,10 +6,11 @@[m
 [m
 #include <chain.h>[m
 #include <chainparams.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
 #include <rpc/server.h>[m
 #include <streams.h>[m
 #include <util/system.h>[m
[31m-#include <validation.h>[m
[32m+[m[32m#include <validation.h> // For cs_main[m
 #include <zmq/zmqutil.h>[m
 [m
 #include <zmq.h>[m
[33mdiff --git a/test/lint/lint-circular-dependencies.sh b/test/lint/lint-circular-dependencies.sh[m
[33mindex 0b15f99448..ad2333a808 100755[m
[33m--- a/test/lint/lint-circular-dependencies.sh[m
[33m+++ b/test/lint/lint-circular-dependencies.sh[m
[36m@@ -11,7 +11,9 @@[m [mexport LC_ALL=C[m
 EXPECTED_CIRCULAR_DEPENDENCIES=([m
     "chainparamsbase -> util/system -> chainparamsbase"[m
     "index/txindex -> validation -> index/txindex"[m
[31m-    "index/blockfilterindex -> validation -> index/blockfilterindex"[m
[32m+[m[32m    "node/blockstorage -> validation -> node/blockstorage"[m
[32m+[m[32m    "index/blockfilterindex -> node/blockstorage -> validation -> index/blockfilterindex"[m
[32m+[m[32m    "index/base -> validation -> index/blockfilterindex -> index/base"[m
     "policy/fees -> txmempool -> policy/fees"[m
     "qt/addresstablemodel -> qt/walletmodel -> qt/addresstablemodel"[m
     "qt/bitcoingui -> qt/walletframe -> qt/bitcoingui"[m