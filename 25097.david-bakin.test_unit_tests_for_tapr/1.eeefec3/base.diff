[33mdiff --git a/src/Makefile.test.include b/src/Makefile.test.include[m
[33mindex ebd9e860cf..bd62c4dbc0 100644[m
[33m--- a/src/Makefile.test.include[m
[33m+++ b/src/Makefile.test.include[m
[36m@@ -126,6 +126,7 @@[m [mBITCOIN_TESTS =\[m
   test/script_parse_tests.cpp \[m
   test/script_segwit_tests.cpp \[m
   test/script_standard_tests.cpp \[m
[32m+[m[32m  test/script_tapscript_tests.cpp \[m
   test/script_tests.cpp \[m
   test/scriptnum10.h \[m
   test/scriptnum_tests.cpp \[m
[36m@@ -139,6 +140,7 @@[m [mBITCOIN_TESTS =\[m
   test/streams_tests.cpp \[m
   test/sync_tests.cpp \[m
   test/system_tests.cpp \[m
[32m+[m[32m  test/test_util_tests.cpp \[m
   test/timedata_tests.cpp \[m
   test/torcontrol_tests.cpp \[m
   test/transaction_tests.cpp \[m
[33mdiff --git a/src/Makefile.test_util.include b/src/Makefile.test_util.include[m
[33mindex 9306bb6fcc..bde8af8f16 100644[m
[33m--- a/src/Makefile.test_util.include[m
[33m+++ b/src/Makefile.test_util.include[m
[36m@@ -9,15 +9,19 @@[m [mEXTRA_LIBRARIES += \[m
 [m
 TEST_UTIL_H = \[m
     test/util/blockfilter.h \[m
[32m+[m[32m    test/util/boost_test_boosts.h \[m
     test/util/chainstate.h \[m
     test/util/logging.h \[m
     test/util/mining.h \[m
     test/util/net.h \[m
[32m+[m[32m    test/util/pretty_data.h \[m
     test/util/script.h \[m
     test/util/setup_common.h \[m
     test/util/str.h \[m
[32m+[m[32m    test/util/traits.h \[m
     test/util/transaction_utils.h \[m
     test/util/validation.h \[m
[32m+[m[32m    test/util/vector.h \[m
     test/util/wallet.h[m
 [m
 libtest_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(NATPMP_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)[m
[36m@@ -27,6 +31,7 @@[m [mlibtest_util_a_SOURCES = \[m
   test/util/logging.cpp \[m
   test/util/mining.cpp \[m
   test/util/net.cpp \[m
[32m+[m[32m  test/util/pretty_data.cpp \[m
   test/util/script.cpp \[m
   test/util/setup_common.cpp \[m
   test/util/str.cpp \[m
[33mdiff --git a/src/test/fuzz/script_assets_test_minimizer.cpp b/src/test/fuzz/script_assets_test_minimizer.cpp[m
[33mindex 35d7246ed8..249a393ad5 100644[m
[33m--- a/src/test/fuzz/script_assets_test_minimizer.cpp[m
[33m+++ b/src/test/fuzz/script_assets_test_minimizer.cpp[m
[36m@@ -9,11 +9,13 @@[m
 #include <script/interpreter.h>[m
 #include <serialize.h>[m
 #include <streams.h>[m
[32m+[m[32m#include <test/util/pretty_data.h>[m
 #include <univalue.h>[m
 #include <util/strencodings.h>[m
 #include <util/string.h>[m
 [m
 #include <cstdint>[m
[32m+[m[32m#include <optional>[m
 #include <string>[m
 #include <vector>[m
 [m
[36m@@ -88,16 +90,6 @@[m [mCScriptWitness ScriptWitnessFromJSON(const UniValue& univalue)[m
     return scriptwitness;[m
 }[m
 [m
[31m-const std::map<std::string, unsigned int> FLAG_NAMES = {[m
[31m-    {std::string("P2SH"), (unsigned int)SCRIPT_VERIFY_P2SH},[m
[31m-    {std::string("DERSIG"), (unsigned int)SCRIPT_VERIFY_DERSIG},[m
[31m-    {std::string("NULLDUMMY"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},[m
[31m-    {std::string("CHECKLOCKTIMEVERIFY"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},[m
[31m-    {std::string("CHECKSEQUENCEVERIFY"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},[m
[31m-    {std::string("WITNESS"), (unsigned int)SCRIPT_VERIFY_WITNESS},[m
[31m-    {std::string("TAPROOT"), (unsigned int)SCRIPT_VERIFY_TAPROOT},[m
[31m-};[m
[31m-[m
 std::vector<unsigned int> AllFlags()[m
 {[m
     std::vector<unsigned int> ret;[m
[36m@@ -125,22 +117,6 @@[m [mstd::vector<unsigned int> AllFlags()[m
 [m
 const std::vector<unsigned int> ALL_FLAGS = AllFlags();[m
 [m
[31m-unsigned int ParseScriptFlags(const std::string& str)[m
[31m-{[m
[31m-    if (str.empty()) return 0;[m
[31m-[m
[31m-    unsigned int flags = 0;[m
[31m-    std::vector<std::string> words = SplitString(str, ',');[m
[2m-[m
[2m-    for (const std::string& word : words) {[m
[31m-        auto it = FLAG_NAMES.find(word);[m
[31m-        if (it == FLAG_NAMES.end()) throw std::runtime_error("Unknown verification flag " + word);[m
[31m-        flags |= it->second;[m
[31m-    }[m
[31m-[m
[31m-    return flags;[m
[31m-}[m
[31m-[m
 void Test(const std::string& str)[m
 {[m
     UniValue test;[m
[36m@@ -151,7 +127,8 @@[m [mvoid Test(const std::string& str)[m
     if (prevouts.size() != tx.vin.size()) throw std::runtime_error("Incorrect number of prevouts");[m
     size_t idx = test["index"].getInt<int64_t>();[m
     if (idx >= tx.vin.size()) throw std::runtime_error("Invalid index");[m
[31m-    unsigned int test_flags = ParseScriptFlags(test["flags"].get_str());[m
[32m+[m[32m    auto test_flags = ParseScriptFlags(test["flags"].get_str());[m
[32m+[m[32m    if (!test_flags) throw std::runtime_error("Invalid flag string");[m
     bool final = test.exists("final") && test["final"].get_bool();[m
 [m
     if (test.exists("success")) {[m
[36m@@ -163,7 +140,7 @@[m [mvoid Test(const std::string& str)[m
         for (const auto flags : ALL_FLAGS) {[m
             // "final": true tests are valid for all flags. Others are only valid with flags that are[m
             // a subset of test_flags.[m
[31m-            if (final || ((flags & test_flags) == flags)) {[m
[32m+[m[32m            if (final || ((flags & test_flags.value()) == flags)) {[m
                 (void)VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
             }[m
         }[m
[36m@@ -177,7 +154,7 @@[m [mvoid Test(const std::string& str)[m
         MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);[m
         for (const auto flags : ALL_FLAGS) {[m
             // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.[m
[31m-            if ((flags & test_flags) == test_flags) {[m
[32m+[m[32m            if ((flags & test_flags.value()) == test_flags.value()) {[m
                 (void)VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
             }[m
         }[m
[33mdiff --git a/src/test/script_tapscript_tests.cpp b/src/test/script_tapscript_tests.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..fd79750d4f[m
[33m--- /dev/null[m
[33m+++ b/src/test/script_tapscript_tests.cpp[m
[36m@@ -0,0 +1,1711 @@[m
[32m+[m[32m// Copyright (c) 2011-2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m// TODO: Don't know whether Taproot/Tapscript tests should be exercising[m
[32m+[m[32m// `libconsensus` the way the tests in `script_tests` do[m
[32m+[m
[32m+[m[32m#include <core_io.h>[m
[32m+[m[32m#include <hash.h>[m
[32m+[m[32m#include <pubkey.h>[m
[32m+[m[32m#include <script/interpreter.h>[m
[32m+[m[32m#include <script/script.h>[m
[32m+[m[32m#include <script/script_error.h>[m
[32m+[m[32m#include <span.h>[m
[32m+[m[32m#include <test/util/boost_test_boosts.h>[m
[32m+[m[32m#include <test/util/pretty_data.h>[m
[32m+[m[32m#include <test/util/setup_common.h>[m
[32m+[m[32m#include <test/util/transaction_utils.h>[m
[32m+[m[32m#include <test/util/vector.h>[m
[32m+[m[32m#include <univalue.h>[m
[32m+[m[32m#include <util/strencodings.h>[m
[32m+[m
[32m+[m[32m#include <boost/test/execution_monitor.hpp>[m
[32m+[m[32m#include <boost/test/unit_test.hpp>[m
[32m+[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32m#include <array>[m
[32m+[m[32m#include <charconv>[m
[32m+[m[32m#include <cstddef>[m
[32m+[m[32m#include <iomanip>[m
[32m+[m[32m#include <iterator>[m
[32m+[m[32m#include <limits>[m
[32m+[m[32m#include <ostream>[m
[32m+[m[32m#include <set>[m
[32m+[m[32m#include <stdexcept>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <string_view>[m
[32m+[m[32m#include <tuple>[m
[32m+[m[32m#include <type_traits>[m
[32m+[m[32m#include <utility>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32musing namespace std::literals::string_literals;[m
[32m+[m[32musing namespace std::literals::string_view_literals;[m
[32m+[m[32musing namespace test::util::literals;[m
[32m+[m
[32m+[m[32mnamespace {[m
[32m+[m
[32m+[m[32mtypedef std::vector<unsigned char> valtype;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Value/Name pair used in data-driven tests[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename V>[m
[32m+[m[32mstruct vn_pair {[m
[32m+[m[32m    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}[m
[32m+[m
[32m+[m[32m    const V m_value;[m
[32m+[m[32m    const std::string_view m_name;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Sequence of value/name pairs used in data-driven tests[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename V>[m
[32m+[m[32musing vn_sequence = std::vector<vn_pair<V>>;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Invokes undefined behavior.  See `std::unreachable` in C++23.[m
[32m+[m[32m */[m
[32m+[m[32m[[noreturn]] inline void declare_unreachable()[m
[32m+[m[32m{[m
[32m+[m[32m#ifdef _MSC_VER[m
[32m+[m[32m    __assume(false);[m
[32m+[m[32m#else[m
[32m+[m[32m    // Assume all other compilers than MSVC implement this GCC builtin.[m
[32m+[m[32m    __builtin_unreachable();[m
[32m+[m[32m#endif[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Representation changer to fill an integral type with a known pattern.[m
[32m+[m[32m *[m
[32m+[m[32m * Pattern is successive byte values given a starting point.  Endianness doesn't[m
[32m+[m[32m * matter.[m
[32m+[m[32m */[m
[32m+[m[32munion FillWithPattern {[m
[32m+[m[32m    uint256 u256{0};[m
[32m+[m[32m    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];[m
[32m+[m[32m    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];[m
[32m+[m[32m    int32_t i32[sizeof(uint256) / sizeof(int32_t)];[m
[32m+[m[32m    uint8_t u8[sizeof(uint256)];[m
[32m+[m
[32m+[m[32m    constexpr FillWithPattern(uint8_t start)[m
[32m+[m[32m    {[m
[32m+[m[32m        for (auto it = std::begin(u8); it != std::end(u8); ++it) {[m
[32m+[m[32m            *it = start++;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    uint64_t u64() const[m
[32m+[m[32m    {[m
[32m+[m[32m        // It is desirable to force high bit off[m
[32m+[m[32m        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * The two possible actions for our mock signature checker[m
[32m+[m[32m */[m
[32m+[m[32menum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,[m
[32m+[m[32m                                ALWAYS_FAILS };[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * For these tests don't need _real_ signature/pubkey validation.  That is[m
[32m+[m[32m * tested elsewhere.  So we just _mock_ the signature checker and force it[m
[32m+[m[32m * to answer valid/invalid as we wish.[m
[32m+[m[32m */[m
[32m+[m[32mclass SignatureCheckerMock : public BaseSignatureChecker[m
[32m+[m[32m{[m
[32m+[m[32m    //! What kind of mock checker is this?[m
[32m+[m[32m    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;[m
[32m+[m
[32m+[m[32m    //! True _iff_ CheckSchnorrSignature was actually called[m
[32m+[m[32m    mutable bool m_was_called = false;[m
[32m+[m
[32m+[m[32mpublic:[m
[32m+[m[32m    //! Whether this mock always validates, or always fails, the signature/pubkey check.[m
[32m+[m[32m    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}[m
[32m+[m
[32m+[m[32m    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing[m
[32m+[m[32m    bool CheckSchnorrSignature(Span<const unsigned char> sig,[m
[32m+[m[32m                               Span<const unsigned char> pubkey,[m
[32m+[m[32m                               SigVersion sigversion,[m
[32m+[m[32m                               ScriptExecutionData& execdata,[m
[32m+[m[32m                               ScriptError* serror = nullptr) const override[m
[32m+[m[32m    {[m
[32m+[m[32m        m_was_called = true;[m
[32m+[m[32m        switch (m_kind) {[m
[32m+[m[32m        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:[m
[32m+[m[32m            if (serror) *serror = SCRIPT_ERR_OK;[m
[32m+[m[32m            return true;[m
[32m+[m
[32m+[m[32m        case CHECKER_VALIDATION::ALWAYS_FAILS:[m
[32m+[m[32m            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m        declare_unreachable();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    bool CheckerWasCalled() const[m
[32m+[m[32m    {[m
[32m+[m[32m        return m_was_called;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m} // namespace[m
[32m+[m
[32m+[m[32mBOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in[m
[32m+[m[32m * interpreter.cpp, against the BIP342 "Rules for signature opcodes".[m
[32m+[m[32m */[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)[m
[32m+[m[32m{[m
[32m+[m[32m    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}![m
[32m+[m[32m    const valtype SIG_65BYTES(65, 0);[m
[32m+[m[32m    const valtype SIG_EMPTY{};[m
[32m+[m
[32m+[m[32m    const valtype PUBKEY_32BYTES(32, 0);[m
[32m+[m[32m    const valtype PUBKEY_15BYTES(15, 0);[m
[32m+[m[32m    const valtype PUBKEY_EMPTY{};[m
[32m+[m
[32m+[m[32m    constexpr int64_t TEST_NUM = 10;[m
[32m+[m
[32m+[m[32m    constexpr int64_t START_VALIDATION_WEIGHT{90};[m
[32m+[m[32m    constexpr int64_t BIP342_SIGOPS_LIMIT{50};[m
[32m+[m[32m    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A fluent API for running these tests.[m
[32m+[m[32m     *[m
[32m+[m[32m     * (Easiest way to understand this class is to look at the actual tests[m
[32m+[m[32m     * that follow in this function.)[m
[32m+[m[32m     */[m
[32m+[m[32m    struct Context {[m
[32m+[m[32m        explicit Context(std::string_view descr) : m_test_description(descr)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_execdata.m_validation_weight_left_init = true;[m
[32m+[m[32m            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        std::string m_test_description;[m
[32m+[m[32m        SigVersion m_sig_version = SigVersion::TAPSCRIPT;[m
[32m+[m[32m        uint32_t m_flags = 0;[m
[32m+[m[32m        CScript m_script;[m
[32m+[m[32m        ScriptError m_err = SCRIPT_ERR_OK;[m
[32m+[m[32m        std::vector<valtype> m_stack;[m
[32m+[m[32m        ScriptExecutionData m_execdata;[m
[32m+[m[32m        CHECKER_VALIDATION m_kind;[m
[32m+[m[32m        bool m_sigchecker_was_called = false;[m
[32m+[m[32m        int64_t m_caller_line = 0;[m
[32m+[m[32m        bool m_result = false;[m
[32m+[m
[32m+[m[32m        Context& SetVersion(SigVersion v)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_sig_version = v;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetChecker(CHECKER_VALIDATION kind)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_kind = kind;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetRemainingWeight(int64_t w)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_execdata.m_validation_weight_left = w;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& AddFlags(uint32_t f)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_flags |= f;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        CScript& SetScript()[m
[32m+[m[32m        {[m
[32m+[m[32m            return m_script;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& DoTest(int64_t line)[m
[32m+[m[32m        {[m
[32m+[m[32m            SignatureCheckerMock checker_mock(m_kind);[m
[32m+[m[32m            m_caller_line = line;[m
[32m+[m[32m            m_result = EvalScript(m_stack, m_script,[m
[32m+[m[32m                                  SCRIPT_VERIFY_TAPROOT | m_flags,[m
[32m+[m[32m                                  checker_mock,[m
[32m+[m[32m                                  m_sig_version,[m
[32m+[m[32m                                  m_execdata,[m
[32m+[m[32m                                  &m_err);[m
[32m+[m[32m            m_sigchecker_was_called = checker_mock.CheckerWasCalled();[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckCallSucceeded()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_result,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": EvalScript succeeded, as expected");[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": Error code expected OK, actual was "[m
[32m+[m[32m                                    << ScriptErrorString(m_err));[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckCallFailed(ScriptError expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(!m_result,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": EvalScript failed, as expected");[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_err == expected,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": Error code expected " << ScriptErrorString(expected)[m
[32m+[m[32m                                    << ", actual was " << ScriptErrorString(m_err));[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckSignatureWasValidated()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,[m
[32m+[m[32m                                Descr() << ": CheckSchnorrSignature was called, as expected");[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckSignatureWasNotValidated()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,[m
[32m+[m[32m                                Descr() << ": CheckSchnorrSignature was not called, as expected");[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckRemainingValidationWeight(int64_t expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": Remaining validation weight expected "[m
[32m+[m[32m                                    << expected << ", actual was "[m
[32m+[m[32m                                    << m_execdata.m_validation_weight_left);[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckStackDepth(std::size_t expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_stack.size() == expected,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": Stack depth expected " << expected[m
[32m+[m[32m                                    << ", actual was " << m_stack.size());[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckTOS(int64_t expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(!m_stack.empty(),[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": Stack expected at least one item, actually was empty");[m
[32m+[m[32m            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(expected == actual,[m
[32m+[m[32m                                Descr()[m
[32m+[m[32m                                    << ": Top-of-stack expected " << expected[m
[32m+[m[32m                                    << ", actual was " << actual);[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    private:[m
[32m+[m[32m        std::string Descr()[m
[32m+[m[32m        {[m
[32m+[m[32m            std::string descr;[m
[32m+[m[32m            descr.reserve(m_test_description.size() + 20);[m
[32m+[m[32m            descr += m_test_description;[m
[32m+[m[32m            descr += " (@";[m
[32m+[m[32m            descr += as_string(m_caller_line);[m
[32m+[m[32m            descr += ")";[m
[32m+[m[32m            return descr;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("SigVersion must not be BASE");[m
[32m+[m[32m        ctx.SetVersion(SigVersion::BASE).SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("SigVersion must not be WITNESS_V0");[m
[32m+[m[32m        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Minimum stack height 3 for OP_CHECKSIGADD");[m
[32m+[m[32m        ctx.SetScript()[m
[32m+[m[32m            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)[m
[32m+[m[32m            .CheckStackDepth(2);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("`n` (2nd arg) size > 4 must fail");[m
[32m+[m[32m        // This is probably meant to be a check on the _encoding_ - that it is[m
[32m+[m[32m        // minimal, but it can also be a check on the _value_.  BIP342 doesn't[m
[32m+[m[32m        // say which.  Could be both...[m
[32m+[m[32m        ctx.SetScript()[m
[32m+[m[32m            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            // (IMO this is an _unsatisfactory_ error code to return for a required[m
[32m+[m[32m            // BIP342 check, but see the `catch` clause in `EvalScript`)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Empty sig + empty pubkey");[m
[32m+[m[32m        ctx.SetScript()[m
[32m+[m[32m            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Sig + empty pubkey");[m
[32m+[m[32m        ctx.SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Insufficient validation weight remaining");[m
[32m+[m[32m        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Empty sig + 32byte pubkey skips validation");[m
[32m+[m[32m        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureWasNotValidated()[m
[32m+[m[32m            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)[m
[32m+[m[32m            .CheckStackDepth(1)[m
[32m+[m[32m            .CheckTOS(TEST_NUM);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Empty sig + non32byte pubkey skips validation");[m
[32m+[m[32m        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureWasNotValidated()[m
[32m+[m[32m            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)[m
[32m+[m[32m            .CheckStackDepth(1)[m
[32m+[m[32m            .CheckTOS(TEST_NUM);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails");[m
[32m+[m[32m        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)[m
[32m+[m[32m            .CheckSignatureWasNotValidated()[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("32byte pubkey + sig with validation failure forced");[m
[32m+[m[32m        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)[m
[32m+[m[32m            .CheckSignatureWasValidated()[m
[32m+[m[32m            .CheckStackDepth(3);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("32byte pubkey + sig with validation success forced");[m
[32m+[m[32m        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureWasValidated()[m
[32m+[m[32m            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)[m
[32m+[m[32m            .CheckStackDepth(1)[m
[32m+[m[32m            .CheckTOS(TEST_NUM + 1);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("non32byte pubkey + empty sig with validation success forced");[m
[32m+[m[32m        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m                .SetScript()[m
[32m+[m[32m            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;[m
[32m+[m[32m        ctx.DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureWasNotValidated()[m
[32m+[m[32m            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)[m
[32m+[m[32m            .CheckStackDepth(1)[m
[32m+[m[32m            .CheckTOS(TEST_NUM);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)[m
[32m+[m[32m{[m
[32m+[m[32m    // As defined by BIP-341 Signature Validation Rules[m
[32m+[m[32m    // Here we pick an acceptable SigVersion[m
[32m+[m[32m    const SigVersion sigversion = SigVersion::TAPROOT;[m
[32m+[m
[32m+[m[32m    CMutableTransaction tx_to_m;[m
[32m+[m[32m    tx_to_m.vin.push_back(CTxIn());[m
[32m+[m[32m    const uint32_t in_pos{0};[m
[32m+[m
[32m+[m[32m    PrecomputedTransactionData cache;[m
[32m+[m[32m    cache.m_bip341_taproot_ready = true;[m
[32m+[m[32m    cache.m_spent_outputs_ready = true;[m
[32m+[m
[32m+[m[32m    ScriptExecutionData execdata;[m
[32m+[m[32m    execdata.m_annex_init = true;[m
[32m+[m[32m    execdata.m_annex_present = false;[m
[32m+[m[32m    execdata.m_annex_hash = uint256::ZERO;[m
[32m+[m[32m    execdata.m_tapleaf_hash_init = false;[m
[32m+[m[32m    execdata.m_codeseparator_pos_init = true;[m
[32m+[m
[32m+[m[32m    uint256 hash_out{0};[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Check all invalid hash_type codes rejected[m
[32m+[m[32m        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};[m
[32m+[m[32m        for (unsigned ht = 0; ht <= 255; ht++) {[m
[32m+[m[32m            const uint8_t hash_type = static_cast<uint8_t>(ht);[m
[32m+[m[32m            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;[m
[32m+[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,[m
[32m+[m[32m                                                      hash_type, sigversion, cache,[m
[32m+[m[32m                                                      MissingDataBehavior::FAIL),[m
[32m+[m[32m                                "hash_type = " << Hex(hash_type) << " expected to fail");[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Check that if hash_type == SIGHASH_SINGLE then missing a "corresponding[m
[32m+[m[32m        // output" fails.[m
[32m+[m[32m        CMutableTransaction tx_to_m;[m
[32m+[m[32m        tx_to_m.vin.push_back(CTxIn());[m
[32m+[m[32m        tx_to_m.vin.push_back(CTxIn());[m
[32m+[m[32m        tx_to_m.vin.push_back(CTxIn());[m
[32m+[m
[32m+[m[32m        uint8_t in_pos = 1;[m
[32m+[m[32m        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL),[m
[32m+[m[32m                            "SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail");[m
[32m+[m
[32m+[m[32m        tx_to_m.vout.push_back(CTxOut());[m
[32m+[m[32m        in_pos = 2;[m
[32m+[m[32m        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL),[m
[32m+[m[32m                            "SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail");[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)[m
[32m+[m[32m{[m
[32m+[m[32m    // Our approach here will be to follow BIP-341's signature algorithm (with[m
[32m+[m[32m    // the BIP-342 extension) doing two things at once:[m
[32m+[m[32m    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function[m
[32m+[m[32m    //      being tested, _and_[m
[32m+[m[32m    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as[m
[32m+[m[32m    //      it is described in BIP-341 and BIP-342.[m
[32m+[m[32m    // Then we can compare the two.  We'll do this in a data-driven way for each[m
[32m+[m[32m    // of the different scenarios that the algorithm supports.[m
[32m+[m[32m    //[m
[32m+[m[32m    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`[m
[32m+[m[32m    // (not just 100% _branch_ coverage).[m
[32m+[m[32m    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few[m
[32m+[m[32m    //   red `-` marks left.  This is because:[m
[32m+[m[32m    //   1. `lcov` wasn't designed to handle death tests.[m
[32m+[m[32m    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,[m
[32m+[m[32m    //      possibly due to `lcov` limitations.  You can see by the test output[m
[32m+[m[32m    //      (`-log_level=all`) or within a debugger that in fact _all_ branches[m
[32m+[m[32m    //      are taken when executing all the tests in this file.[m
[32m+[m
[32m+[m[32m    // Here we define, and then generate, all combinations of the alternatives[m
[32m+[m[32m    // for the parameters that vary the signature combination algorithm[m
[32m+[m
[32m+[m[32m    const vn_sequence<SigVersion> SigVersion_alternatives{[m
[32m+[m[32m        {SigVersion::TAPROOT, "TAPROOT"sv},[m
[32m+[m[32m        {SigVersion::TAPSCRIPT, "TAPSCRIPT"sv}};[m
[32m+[m
[32m+[m[32m    const vn_sequence<uint32_t> hash_type_output_alternatives{[m
[32m+[m[32m        {SIGHASH_DEFAULT, "SIGHASH_DEFAULT"sv},[m
[32m+[m[32m        {SIGHASH_ALL, "SIGHASH_ALL"sv},[m
[32m+[m[32m        {SIGHASH_NONE, "SIGHASH_NONE"sv},[m
[32m+[m[32m        {SIGHASH_SINGLE, "SIGHASH_SINGLE"sv}};[m
[32m+[m
[32m+[m[32m    const vn_sequence<uint32_t> hash_type_input_alternatives{[m
[32m+[m[32m        {0, "N/A"sv},[m
[32m+[m[32m        {SIGHASH_ANYONECANPAY, "SIGHASH_ANYONECANPAY"sv}};[m
[32m+[m
[32m+[m[32m    const vn_sequence<uint8_t> annex_alternatives{[m
[32m+[m[32m        {0, "no annex"sv},[m
[32m+[m[32m        {1, "annex present"sv}};[m
[32m+[m
[32m+[m[32m    const vn_sequence<bool> output_hash_alternatives{[m
[32m+[m[32m        {false, "output hash missing"sv},[m
[32m+[m[32m        {true, "output hash provided"sv}};[m
[32m+[m
[32m+[m[32m    for (const auto& sigversion_alternative : SigVersion_alternatives)[m
[32m+[m[32m        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)[m
[32m+[m[32m            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)[m
[32m+[m[32m                for (const auto& annex_alternative : annex_alternatives)[m
[32m+[m[32m                    for (const auto& output_hash_alternative : output_hash_alternatives) {[m
[32m+[m[32m                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY[m
[32m+[m[32m                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;[m
[32m+[m
[32m+[m[32m                        // We're going to want to know which scenario it is if a check actually[m
[32m+[m[32m                        // fails ...[m
[32m+[m[32m                        std::string scenario_description;[m
[32m+[m[32m                        {[m
[32m+[m[32m                            std::ostringstream oss;[m
[32m+[m[32m                            oss << sigversion_alternative.m_name << ", "[m
[32m+[m[32m                                << hash_type_output_alternative.m_name << ", "[m
[32m+[m[32m                                << hash_type_input_alternative.m_name << ", "[m
[32m+[m[32m                                << annex_alternative.m_name << ", "[m
[32m+[m[32m                                << output_hash_alternative.m_name;[m
[32m+[m[32m                            scenario_description = oss.str();[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // Set up the scenario we're running now - these 4 variables define the scenario[m
[32m+[m[32m                        const SigVersion sigversion{sigversion_alternative.m_value};[m
[32m+[m[32m                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};[m
[32m+[m[32m                        const uint8_t annex_present{annex_alternative.m_value};[m
[32m+[m[32m                        const bool have_output_hash{output_hash_alternative.m_value};[m
[32m+[m
[32m+[m[32m                        // Compute some helper values that depend on scenario[m
[32m+[m[32m                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};[m
[32m+[m[32m                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};[m
[32m+[m[32m                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};[m
[32m+[m[32m                        const uint8_t spend_type = (ext_flag * 2) + annex_present;[m
[32m+[m
[32m+[m[32m                        // Fixed values (by algorithm)[m
[32m+[m[32m                        const uint8_t epoch{0x00};[m
[32m+[m[32m                        const uint8_t key_version{0};[m
[32m+[m
[32m+[m[32m                        // Mocked values fixed for purposes of this unit test.  This is a long[m
[32m+[m[32m                        // list of crufty things but that's because `SignatureHashSchnorr`, the[m
[32m+[m[32m                        // function being tested, takes as arguments not just the transaction[m
[32m+[m[32m                        // being signed (plus control data) but also some _precomputed values_[m
[32m+[m[32m                        // in two different structs: `PrecomputedTransactionData`, and[m
[32m+[m[32m                        // `ScriptExecutionData`.  On the one hand this is nice because a lot[m
[32m+[m[32m                        // of complexity of the signature algorithm doesn't have to be duplicated[m
[32m+[m[32m                        // here in this test: we can just use mocked values.  On the other hand,[m
[32m+[m[32m                        // there's a lot of icky setup to do to get all the values in the right[m
[32m+[m[32m                        // places both for our "by the book" implementation and to be set up to[m
[32m+[m[32m                        // call `SignatureHashSchnorr`.[m
[32m+[m[32m                        //[m
[32m+[m[32m                        // Try to make things simpler by at least using the same names for the[m
[32m+[m[32m                        // setup variables as for the fields in the parameter structs.[m
[32m+[m
[32m+[m[32m                        const uint32_t in_pos{1};[m
[32m+[m[32m                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};[m
[32m+[m[32m                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};[m
[32m+[m[32m                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};[m
[32m+[m[32m                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};[m
[32m+[m[32m                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};[m
[32m+[m[32m                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};[m
[32m+[m[32m                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};[m
[32m+[m[32m                        const uint256 output_hash{FillWithPattern(0x40).u256};[m
[32m+[m[32m                        const uint256 annex_hash{FillWithPattern(0x48).u256};[m
[32m+[m[32m                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};[m
[32m+[m[32m                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};[m
[32m+[m[32m                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,[m
[32m+[m[32m                                                                FillWithPattern(0x68).u32[0]};[m
[32m+[m[32m                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};[m
[32m+[m[32m                        CTxOut spent_output_at_pos;[m
[32m+[m[32m                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();[m
[32m+[m[32m                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/[m
[32m+[m[32m                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;[m
[32m+[m[32m                        CTxOut tx_output_at_pos;[m
[32m+[m[32m                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();[m
[32m+[m[32m                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/[m
[32m+[m[32m                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;[m
[32m+[m
[32m+[m[32m                        // Now set up the arguments that are going to be passed to[m
[32m+[m[32m                        // `SignatureHashSchnorr`[m
[32m+[m
[32m+[m[32m                        CMutableTransaction tx_to;[m
[32m+[m[32m                        tx_to.nVersion = tx_version;[m
[32m+[m[32m                        tx_to.nLockTime = tx_lock_time;[m
[32m+[m[32m                        for (uint32_t i = 0; i < in_pos + 2; i++) {[m
[32m+[m[32m                            tx_to.vin.push_back(CTxIn());[m
[32m+[m[32m                            tx_to.vout.push_back(CTxOut());[m
[32m+[m[32m                        }[m
[32m+[m[32m                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;[m
[32m+[m[32m                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;[m
[32m+[m[32m                        tx_to.vout[in_pos] = tx_output_at_pos;[m
[32m+[m
[32m+[m[32m                        PrecomputedTransactionData cache;[m
[32m+[m[32m                        cache.m_bip341_taproot_ready = true;[m
[32m+[m[32m                        cache.m_prevouts_single_hash = prevouts_single_hash;[m
[32m+[m[32m                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;[m
[32m+[m[32m                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;[m
[32m+[m[32m                        cache.m_sequences_single_hash = sequences_single_hash;[m
[32m+[m[32m                        cache.m_spent_outputs_ready = true;[m
[32m+[m[32m                        for (uint32_t i = 0; i < in_pos + 2; i++) {[m
[32m+[m[32m                            cache.m_spent_outputs.push_back(CTxOut());[m
[32m+[m[32m                        }[m
[32m+[m[32m                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;[m
[32m+[m[32m                        cache.m_outputs_single_hash = outputs_single_hash;[m
[32m+[m
[32m+[m[32m                        ScriptExecutionData execdata;[m
[32m+[m[32m                        execdata.m_annex_init = true;[m
[32m+[m[32m                        execdata.m_annex_present = !!annex_present;[m
[32m+[m[32m                        execdata.m_annex_hash = annex_hash;[m
[32m+[m[32m                        execdata.m_output_hash.reset();[m
[32m+[m[32m                        if (have_output_hash) {[m
[32m+[m[32m                            execdata.m_output_hash = output_hash;[m
[32m+[m[32m                        }[m
[32m+[m[32m                        if (sigversion == SigVersion::TAPSCRIPT) {[m
[32m+[m[32m                            execdata.m_tapleaf_hash_init = true;[m
[32m+[m[32m                            execdata.m_tapleaf_hash = tapleaf_hash;[m
[32m+[m[32m                            execdata.m_codeseparator_pos_init = true;[m
[32m+[m[32m                            execdata.m_codeseparator_pos = codeseparator_pos;[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // Now here is where we take all that data - _not_ the arguments to[m
[32m+[m[32m                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,[m
[32m+[m[32m                        // the values fixed by the algorithm, and our mocked values, and actually[m
[32m+[m[32m                        // follow the BIP-341/BIP-342 signature calculation algorithm right from[m
[32m+[m[32m                        // the spec ...[m
[32m+[m
[32m+[m[32m                        // Start with a tagged hasher with the correct tag[m
[32m+[m[32m                        CHashWriter hasher = TaggedHash("TapSighash");[m
[32m+[m
[32m+[m[32m                        // First byte to hash is always the "epoch", 0x00 (BIP-341, footnote 20)[m
[32m+[m[32m                        hasher << epoch;[m
[32m+[m
[32m+[m[32m                        // Next: hash_type (1 byte)[m
[32m+[m[32m                        hasher << hash_type;[m
[32m+[m
[32m+[m[32m                        // Next: transaction version (4 bytes)[m
[32m+[m[32m                        hasher << tx_version;[m
[32m+[m
[32m+[m[32m                        // Next: transaction lock time (4 bytes)[m
[32m+[m[32m                        hasher << tx_lock_time;[m
[32m+[m
[32m+[m[32m                        // Next if _not_ SIGHASH_ANYONECANPAY:[m
[32m+[m[32m                        // a) SHA256 of the serialization of all input outpoints (32 bytes)[m
[32m+[m[32m                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)[m
[32m+[m[32m                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_[m
[32m+[m[32m                        //    serialized as script (32 bytes)[m
[32m+[m[32m                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)[m
[32m+[m[32m                        if (hash_input_type != SIGHASH_ANYONECANPAY) {[m
[32m+[m[32m                            hasher << prevouts_single_hash;[m
[32m+[m[32m                            hasher << spent_amounts_single_hash;[m
[32m+[m[32m                            hasher << spent_scripts_single_hash;[m
[32m+[m[32m                            hasher << sequences_single_hash;[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:[m
[32m+[m[32m                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)[m
[32m+[m[32m                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {[m
[32m+[m[32m                            hasher << outputs_single_hash;[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // Now, data about input/prevout being spent[m
[32m+[m
[32m+[m[32m                        // The "spend_type" (1 byte) which is a function of ext_flag (above) and[m
[32m+[m[32m                        // whether there is an annex present (here: no)[m
[32m+[m[32m                        hasher << spend_type;[m
[32m+[m
[32m+[m[32m                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of[m
[32m+[m[32m                        // the input in the transaction input vector (4 bytes). There must be a[m
[32m+[m[32m                        // input transaction at this index but _in this scenario_ it doesn't have[m
[32m+[m[32m                        // to have any data (it is never inspected).  Same for output transactions.[m
[32m+[m[32m                        //[m
[32m+[m[32m                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the[m
[32m+[m[32m                        // `COutPoint` of this input (36 bytes), the value of the previous[m
[32m+[m[32m                        // output spent by this input (8 bytes), the `ScriptPubKey` of the[m
[32m+[m[32m                        // previous output spent by this input (35 bytes), and the `nSequence`[m
[32m+[m[32m                        // of this input.  These values are all precomputed and made available[m
[32m+[m[32m                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.[m
[32m+[m[32m                        if (hash_input_type == SIGHASH_ANYONECANPAY) {[m
[32m+[m[32m                            hasher << tx_input_at_pos_prevout;[m
[32m+[m[32m                            hasher << spent_output_at_pos.nValue;[m
[32m+[m[32m                            hasher << spent_output_at_pos.scriptPubKey;[m
[32m+[m[32m                            hasher << tx_input_at_pos_nsequence;[m
[32m+[m[32m                        } else {[m
[32m+[m[32m                            hasher << in_pos;[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // Now, if there is an "annex", add its hash (32 byte).  This is[m
[32m+[m[32m                        // precomputed and we don't actually have to have an actual annex to[m
[32m+[m[32m                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.[m
[32m+[m[32m                        if (annex_present) {[m
[32m+[m[32m                            hasher << annex_hash;[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the[m
[32m+[m[32m                        // corresponding transaction output (32 bytes).  The wrinkle here is that[m
[32m+[m[32m                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_[m
[32m+[m[32m                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is[m
[32m+[m[32m                        // provided or compute it from the corresponding output itself. (For our[m
[32m+[m[32m                        // purposes in this test the output need not be valid - it just must be[m
[32m+[m[32m                        // present.)[m
[32m+[m[32m                        if (hash_output_type == SIGHASH_SINGLE) {[m
[32m+[m[32m                            if (!have_output_hash) {[m
[32m+[m[32m                                CHashWriter hasher2(SER_GETHASH, 0);[m
[32m+[m[32m                                hasher2 << tx_output_at_pos;[m
[32m+[m[32m                                hasher << hasher2.GetSHA256();[m
[32m+[m[32m                            } else {[m
[32m+[m[32m                                hasher << output_hash;[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // This is the TAPSCRIPT extension from BIP-342.  If the version is[m
[32m+[m[32m                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1[m
[32m+[m[32m                        // byte, fixed value of 0x00), and the "opcode position of the last[m
[32m+[m[32m                        // executed OP_CODESEPARATOR before the currently executed signature[m
[32m+[m[32m                        // opcode" (4 bytes).  The tapleaf hash and the code separator position[m
[32m+[m[32m                        // are both precomputed values.[m
[32m+[m[32m                        if (sigversion == SigVersion::TAPSCRIPT) {[m
[32m+[m[32m                            hasher << tapleaf_hash;[m
[32m+[m[32m                            hasher << key_version;[m
[32m+[m[32m                            hasher << codeseparator_pos;[m
[32m+[m[32m                        }[m
[32m+[m
[32m+[m[32m                        // That's all that goes into the hasher for this signature[m
[32m+[m[32m                        const uint256 expected_hash_out = hasher.GetSHA256();[m
[32m+[m
[32m+[m[32m                        // Now, _finally_, we test the actual implemented algorithm under test:[m
[32m+[m[32m                        uint256 actual_hash_out{0};[m
[32m+[m[32m                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,[m
[32m+[m[32m                                                        execdata, tx_to, in_pos,[m
[32m+[m[32m                                                        hash_type, sigversion, cache,[m
[32m+[m[32m                                                        MissingDataBehavior::FAIL),[m
[32m+[m[32m                                   "Scenario: " << scenario_description);[m
[32m+[m[32m                        BOOST_TEST(expected_hash_out == actual_hash_out,[m
[32m+[m[32m                                   "Scenario: " << scenario_description[m
[32m+[m[32m                                                << " - expected " << expected_hash_out.ToString()[m
[32m+[m[32m                                                << " == actual " << actual_hash_out.ToString());[m
[32m+[m[32m                    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mnamespace {[m
[32m+[m
[32m+[m[32m// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)[m
[32m+[m
[32m+[m[32mstruct SchnorrTriplet {[m
[32m+[m[32m    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)[m
[32m+[m[32m        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}[m
[32m+[m[32m    valtype m_pubkey;[m
[32m+[m[32m    uint256 m_sighash;[m
[32m+[m[32m    valtype m_sig;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstatic const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {[m
[32m+[m[32m    {"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9", "0000000000000000000000000000000000000000000000000000000000000000", "E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0"},[m
[32m+[m[32m    {"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A"},[m
[32m+[m[32m    {"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8", "7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C", "5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7"},[m
[32m+[m[32m    {"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3"},[m
[32m+[m[32m    {"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9", "4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703", "00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4"},[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m} // namespace[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)[m
[32m+[m[32m{[m
[32m+[m[32m    for (const auto& triplet : SCHNORR_TRIPLETS) {[m
[32m+[m[32m        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(verify_schnorr_signature)[m
[32m+[m[32m{[m
[32m+[m[32m    // Defeat, for test purposes, the protected access of[m
[32m+[m[32m    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`[m
[32m+[m[32m    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {[m
[32m+[m[32m        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;[m
[32m+[m[32m        using MutableTransactionSignatureChecker::VerifySchnorrSignature;[m
[32m+[m[32m    };[m
[32m+[m[32m    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};[m
[32m+[m
[32m+[m[32m    // Positive tests: triplets which verify[m
[32m+[m[32m    for (const auto& triplet : SCHNORR_TRIPLETS) {[m
[32m+[m[32m        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,[m
[32m+[m[32m                                              XOnlyPubKey{triplet.m_pubkey},[m
[32m+[m[32m                                              triplet.m_sighash));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Negative tests: triplets which fail to verify (get these failing triplets[m
[32m+[m[32m    // by modifying a valid triplet, one field at a time)[m
[32m+[m[32m    auto diddle_front_byte = [](auto v) { v[0]++; return v; };[m
[32m+[m[32m    auto& triplet = SCHNORR_TRIPLETS[0];[m
[32m+[m[32m    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),[m
[32m+[m[32m                                           XOnlyPubKey{triplet.m_pubkey},[m
[32m+[m[32m                                           triplet.m_sighash));[m
[32m+[m[32m    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,[m
[32m+[m[32m                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},[m
[32m+[m[32m                                           triplet.m_sighash));[m
[32m+[m[32m    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,[m
[32m+[m[32m                                           XOnlyPubKey{triplet.m_pubkey},[m
[32m+[m[32m                                           uint256::ONE));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(check_schnorr_signature)[m
[32m+[m[32m{[m
[32m+[m[32m    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`[m
[32m+[m[32m    // that mocks `VerifySchnorrSignature` so we can more easily test[m
[32m+[m[32m    // `CheckSchnorrSignature` without going to the trouble of having a valid[m
[32m+[m[32m    // transaction (which is unnecessary for this _unit_ test.)[m
[32m+[m[32m    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {[m
[32m+[m[32m        uint256 m_expected_sighash = []() {[m
[32m+[m[32m            uint256 h{};[m
[32m+[m[32m            // This is the known sighash of the Tx and input data we set up (precomputed)[m
[32m+[m[32m            h.SetHex("f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c");[m
[32m+[m[32m            return h;[m
[32m+[m[32m        }();[m
[32m+[m
[32m+[m[32m        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;[m
[32m+[m
[32m+[m[32m        enum class if_as_expected_return { False,[m
[32m+[m[32m                                           True };[m
[32m+[m[32m        if_as_expected_return m_iae{if_as_expected_return::True};[m
[32m+[m[32m        void SetExpectation(if_as_expected_return iaer) { m_iae = iaer; }[m
[32m+[m
[32m+[m[32m        bool VerifySchnorrSignature(Span<const unsigned char> sig,[m
[32m+[m[32m                                    const XOnlyPubKey& pubkey,[m
[32m+[m[32m                                    const uint256& sighash) const override[m
[32m+[m[32m        {[m
[32m+[m[32m            // Following line used only to determine the known canned `expected_sighash` above:[m
[32m+[m[32m            // BOOST_TEST_MESSAGE("MockVerifySchnorrSignature: sighash == " << sighash.ToString());[m
[32m+[m
[32m+[m[32m            bool as_expected = sighash == m_expected_sighash;[m
[32m+[m[32m            if (m_iae == if_as_expected_return::True)[m
[32m+[m[32m                return as_expected;[m
[32m+[m[32m            else[m
[32m+[m[32m                return !as_expected;[m
[32m+[m[32m        };[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    const auto triplet = SCHNORR_TRIPLETS[0];[m
[32m+[m[32m    const CMutableTransaction txToIn{};[m
[32m+[m[32m    ScriptExecutionData execdata{};[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Signature must be 64 or 65 bytes long[m
[32m+[m[32m        for (size_t i = 0; i <= 99; i++) {[m
[32m+[m[32m            valtype testsig(i, i);[m
[32m+[m[32m            if (testsig.size() == 64 || testsig.size() == 65) continue;[m
[32m+[m[32m            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);[m
[32m+[m[32m            ScriptError serror{SCRIPT_ERR_OK};[m
[32m+[m[32m            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));[m
[32m+[m[32m            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342[m
[32m+[m[32m        {[m
[32m+[m[32m            // Negative test: last byte _is_ SIGHASH_DEFAULT[m
[32m+[m[32m            valtype testsig(65, 65);[m
[32m+[m[32m            testsig.back() = SIGHASH_DEFAULT;[m
[32m+[m
[32m+[m[32m            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);[m
[32m+[m[32m            ScriptError serror{SCRIPT_ERR_OK};[m
[32m+[m[32m            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));[m
[32m+[m[32m            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);[m
[32m+[m[32m        }[m
[32m+[m[32m        {[m
[32m+[m[32m            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing[m
[32m+[m[32m            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how[m
[32m+[m[32m            // `CheckSchnorrSignature` is written).[m
[32m+[m[32m            for (size_t i = 1; i <= 255; i++) {[m
[32m+[m[32m                valtype testsig(65, i);[m
[32m+[m
[32m+[m[32m                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);[m
[32m+[m[32m                ScriptError serror{SCRIPT_ERR_OK};[m
[32m+[m[32m                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));[m
[32m+[m[32m                BOOST_TEST(serror == SCRIPT_ERR_OK);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.[m
[32m+[m[32m        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on[m
[32m+[m[32m        // _that_ result `SignatureHashSchnorr` either succeeds or fails.[m
[32m+[m[32m        //[m
[32m+[m[32m        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters[m
[32m+[m[32m        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with[m
[32m+[m[32m        // `VerifySchnorrSignature`.[m
[32m+[m
[32m+[m[32m        const uint32_t in_pos{0};[m
[32m+[m[32m        CMutableTransaction txToIn{};[m
[32m+[m[32m        txToIn.nVersion = 0;[m
[32m+[m[32m        txToIn.nLockTime = 0;[m
[32m+[m[32m        txToIn.vin.push_back(CTxIn());[m
[32m+[m[32m        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);[m
[32m+[m[32m        txToIn.vin[in_pos].nSequence = 0;[m
[32m+[m[32m        txToIn.vout.push_back(CTxOut());[m
[32m+[m
[32m+[m[32m        PrecomputedTransactionData txDataIn{};[m
[32m+[m[32m        txDataIn.m_bip341_taproot_ready = true;[m
[32m+[m[32m        txDataIn.m_prevouts_single_hash = uint256::ZERO;[m
[32m+[m[32m        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;[m
[32m+[m[32m        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;[m
[32m+[m[32m        txDataIn.m_sequences_single_hash = uint256::ZERO;[m
[32m+[m[32m        txDataIn.m_spent_outputs_ready = true;[m
[32m+[m[32m        txDataIn.m_spent_outputs.push_back(CTxOut());[m
[32m+[m[32m        txDataIn.m_spent_outputs[in_pos].nValue = 0;[m
[32m+[m[32m        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;[m
[32m+[m[32m        txDataIn.m_outputs_single_hash = uint256::ZERO;[m
[32m+[m
[32m+[m[32m        ScriptExecutionData execdata{};[m
[32m+[m[32m        execdata.m_annex_init = true;[m
[32m+[m[32m        execdata.m_annex_present = true;[m
[32m+[m[32m        execdata.m_annex_hash = uint256::ZERO;[m
[32m+[m[32m        execdata.m_output_hash.reset();[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)[m
[32m+[m[32m            PrecomputedTransactionData txDataIn{};[m
[32m+[m[32m            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);[m
[32m+[m[32m            ScriptError serror{SCRIPT_ERR_OK};[m
[32m+[m[32m            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));[m
[32m+[m[32m            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`[m
[32m+[m[32m            // and show it returns the correct error.[m
[32m+[m[32m            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);[m
[32m+[m[32m            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);[m
[32m+[m[32m            ScriptError serror{SCRIPT_ERR_OK};[m
[32m+[m[32m            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));[m
[32m+[m[32m            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and[m
[32m+[m[32m            // show now that `CheckSchnorrSignature` finally succeeds.[m
[32m+[m[32m            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);[m
[32m+[m[32m            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);[m
[32m+[m[32m            ScriptError serror{SCRIPT_ERR_OK};[m
[32m+[m[32m            BOOST_TEST(sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));[m
[32m+[m[32m            BOOST_TEST(serror == SCRIPT_ERR_OK);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(compute_tapleaf_hash)[m
[32m+[m[32m{[m
[32m+[m[32m    // Try two examples, reimplementing the BIP-341 specification[m
[32m+[m[32m    {[m
[32m+[m[32m        uint8_t leaf_version = 0;[m
[32m+[m[32m        CScript cs{};[m
[32m+[m[32m        auto expected = (TaggedHash("TapLeaf") << leaf_version << CScript()).GetSHA256();[m
[32m+[m[32m        auto actual = ComputeTapleafHash(leaf_version, CScript());[m
[32m+[m[32m        BOOST_TEST(expected == actual,[m
[32m+[m[32m                   "leaf version 0, empty CScript - expected "[m
[32m+[m[32m                       << expected.ToString() << " actual " << actual.ToString());[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        uint8_t leaf_version = 0x4a;[m
[32m+[m[32m        CScript cs{};[m
[32m+[m[32m        cs << OP_CHECKLOCKTIMEVERIFY << OP_CHECKSIGADD; // just a random CScript[m
[32m+[m[32m        auto expected = (TaggedHash("TapLeaf") << leaf_version << cs).GetSHA256();[m
[32m+[m[32m        auto actual = ComputeTapleafHash(leaf_version, cs);[m
[32m+[m[32m        BOOST_TEST(expected == actual,[m
[32m+[m[32m                   "leaf version 0x4A, CScript w/ 2 opcodes - expected "[m
[32m+[m[32m                       << expected.ToString() << " actual " << actual.ToString());[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(compute_taproot_merkle_root)[m
[32m+[m[32m{[m
[32m+[m[32m    using namespace test::util::vector_ops;[m
[32m+[m
[32m+[m[32m    // Test by using a small enhancement to a `vector<unsigned char>` that makes[m
[32m+[m[32m    // it easy to convert to/from strings so the tests are more easily readable,[m
[32m+[m[32m    // and also adds directly the two necessary operations from BIP-340: byte[m
[32m+[m[32m    // vector concatenation and byte vector select subrange.[m
[32m+[m
[32m+[m[32m    // Use an arbitrary tapleaf hash throughout[m
[32m+[m[32m    const uint256 tapleaf_hash1 = ComputeTapleafHash(0x10, CScript{} << OP_CHECKMULTISIG);[m
[32m+[m[32m    const uint256 tapleaf_hash2 = ComputeTapleafHash(0x20, CScript{} << OP_CHECKSEQUENCEVERIFY);[m
[32m+[m
[32m+[m[32m    //                         ".........|.........|.........|..."      33 bytes[m
[32m+[m[32m    const auto control_base1 = "[point (#1) - 33 bytes of junk!!>"_bv;[m
[32m+[m[32m    const auto control_base2 = "[point (#2) - 33 more bad bytes!>"_bv;[m
[32m+[m[32m    assert(control_base1.size() == 33 && control_base2.size() == 33);[m
[32m+[m
[32m+[m[32m    // Nodes `node_low` and `node_high` are constructed to be _forced_ lower/higher[m
[32m+[m[32m    // (respectively) than arbitrary hash.  This isn't exactly true, of course:[m
[32m+[m[32m    // only the _first byte_ of these nodes are low or high.  If the first byte[m
[32m+[m[32m    // of the "arbitrary" hash is `0x00` or `0xff` we've got a problem .. but[m
[32m+[m[32m    // this isn't the case for this test data.[m
[32m+[m
[32m+[m[32m    //                                     ".........|.........|.........|.."       32 bytes[m
[32m+[m[32m    const auto node_low = []() { auto r  = "(this is node to-be-diddled low)"_bv; r.front() = 0x00; return r; }();[m
[32m+[m[32m    const auto node_high = []() { auto r = "(this is nod to-be-diddled high)"_bv; r.front() = 0xFF; return r; }();[m
[32m+[m[32m    assert(node_low.size() == 32 && node_high.size() == 32);[m
[32m+[m
[32m+[m[32m    assert(node_low < from_base_blob(tapleaf_hash1) && from_base_blob(tapleaf_hash1) < node_high);[m
[32m+[m[32m    assert(node_low < from_base_blob(tapleaf_hash2) && from_base_blob(tapleaf_hash2) < node_high);[m
[32m+[m
[32m+[m[32m    const CHashWriter hw_branch{TaggedHash("TapBranch")};[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Control block contains only the initial point, no nodes - always returns[m
[32m+[m[32m        // the tapleaf hash, doesn't matter what the control block is[m
[32m+[m[32m        uint256 expected1 = tapleaf_hash1;[m
[32m+[m[32m        uint256 actual1a = ComputeTaprootMerkleRoot(control_base1, tapleaf_hash1);[m
[32m+[m[32m        BOOST_TEST(expected1 == actual1a,[m
[32m+[m[32m                   "expected " << HexStr(expected1) << ", actual " << HexStr(actual1a));[m
[32m+[m[32m        uint256 actual1b = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash1);[m
[32m+[m[32m        BOOST_TEST(expected1 == actual1b,[m
[32m+[m[32m                   "expected " << HexStr(expected1) << ", actual " << HexStr(actual1b));[m
[32m+[m[32m        uint256 expected2 = tapleaf_hash2;[m
[32m+[m[32m        uint256 actual2 = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash2);[m
[32m+[m[32m        BOOST_TEST(expected2 == actual2,[m
[32m+[m[32m                   "expected " << HexStr(expected2) << ", actual " << HexStr(actual2));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Control block contains one node - check both lexicographic orders[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << tapleaf_hash1).GetSHA256();[m
[32m+[m[32m            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_low}, tapleaf_hash1);[m
[32m+[m[32m            BOOST_TEST(expected == actual,[m
[32m+[m[32m                    "expected " << HexStr(expected) << ", actual " << HexStr(actual));[m
[32m+[m[32m        }[m
[32m+[m[32m        {[m
[32m+[m[32m            uint256 expected = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();[m
[32m+[m[32m            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_high}, tapleaf_hash1);[m
[32m+[m[32m            BOOST_TEST(expected == actual,[m
[32m+[m[32m                    "expected " << HexStr(expected) << ", actual " << HexStr(actual));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // With a control block with more than one node (here: two nodes), each subsequent node[m
[32m+[m[32m        // is hashed with the hash of the previous nodes in _lexicographic_ order.[m
[32m+[m
[32m+[m[32m        // Control block is going to be `point1 || node_high || node_{low,high}`[m
[32m+[m[32m        uint256 intermediate_k = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();[m
[32m+[m
[32m+[m[32m        // Verify that the intermediate hash is less than `node_high`[m
[32m+[m[32m        assert(from_base_blob(intermediate_k) < node_high);[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // 2nd node lexicographically _less than_ intermediate hash[m
[32m+[m[32m            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << intermediate_k).GetSHA256();[m
[32m+[m[32m            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_low, tapleaf_hash1);[m
[32m+[m[32m            BOOST_TEST(expected == actual,[m
[32m+[m[32m                    "expected " << HexStr(expected) << ", actual " << HexStr(actual));[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // 2nd node lexicographically _greater than_ intermediate hash[m
[32m+[m[32m            uint256 expected = (CHashWriter{hw_branch} << intermediate_k << Span{node_high}).GetSHA256();[m
[32m+[m[32m            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_high, tapleaf_hash1);[m
[32m+[m[32m            BOOST_TEST(expected == actual,[m
[32m+[m[32m                    "expected " << HexStr(expected) << ", actual " << HexStr(actual));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(taproot_v1_verify_script)[m
[32m+[m[32m{[m
[32m+[m[32m    // Testing Taproot code paths in `VerifyWitnessProgram` and[m
[32m+[m[32m    // `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`.[m
[32m+[m
[32m+[m[32m    // Both `VerifyWitnessProgram` and `ExecuteWitnessScript` are `static`[m
[32m+[m[32m    // inside of `interpreter.cpp` and thus inaccessible to a unit test.[m
[32m+[m[32m    // The way to get to them is indirectly via `VerifyScript`.[m
[32m+[m
[32m+[m[32m    // Tests all success and failure paths mentioned in BIP-341 and[m
[32m+[m[32m    // BIP-342.[m
[32m+[m
[32m+[m[32m    // This is a _unit test_ not a _functional test_ and the unit being[m
[32m+[m[32m    // tested here does _not_ include actually verifying the signature.[m
[32m+[m[32m    // That is tested elsewhere (e.g., by tests `verify_schnorr_signature`[m
[32m+[m[32m    // and `check_schnorr_signature` in this file).  _This_ test _mocks_[m
[32m+[m[32m    // the Schnorr signature verfication.  Thus the test data need not[m
[32m+[m[32m    // actually have valid signatures (and is thus easier to prepare).[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * A fluent API for running these tests.  Swiped and adapted from[m
[32m+[m[32m     * `script_tests.cpp`.[m
[32m+[m[32m     *[m
[32m+[m[32m     * (Easiest way to understand this class is to look at the actual tests[m
[32m+[m[32m     * that follow in this function.)[m
[32m+[m[32m     */[m
[32m+[m
[32m+[m[32m    struct Context {[m
[32m+[m[32m        // raw key data from `key_tests.cpp` @305[m
[32m+[m[32m        valtype m_sec{ParseHex("0000000000000000000000000000000000000000000000000000000000000003")};[m
[32m+[m[32m        valtype m_pub{ParseHex("F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9")};[m
[32m+[m[32m        valtype m_sig{ParseHex("E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0")};[m
[32m+[m
[32m+[m[32m        CKey m_sec_key;[m
[32m+[m[32m        XOnlyPubKey m_pub_key;[m
[32m+[m
[32m+[m[32m    private:[m
[32m+[m[32m        void SetupKeys()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_TEST(m_sec.size() == 32);[m
[32m+[m[32m            BOOST_TEST(m_pub.size() == 32);[m
[32m+[m[32m            BOOST_TEST(m_sig.size() == 64);[m
[32m+[m
[32m+[m[32m            m_sec_key.Set(m_sec.begin(), m_sec.end(), true /*compressed*/);[m
[32m+[m[32m            m_pub_key = XOnlyPubKey(m_sec_key.GetPubKey());[m
[32m+[m
[32m+[m[32m            BOOST_TEST(m_pub_key.IsFullyValid());[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    public:[m
[32m+[m[32m        explicit Context(std::string_view descr) : m_test_description(descr)[m
[32m+[m[32m        {[m
[32m+[m[32m            SetupKeys();[m
[32m+[m
[32m+[m[32m            // For Taproot v1 force SegWit version 1[m
[32m+[m[32m            m_scriptPubKey << OP_1;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        const std::string m_test_description;[m
[32m+[m
[32m+[m[32m        bool m_p2sh_wrapped = false;[m
[32m+[m[32m        CScript m_scriptPubKey;[m
[32m+[m[32m        unsigned int m_hash_type = SIGHASH_DEFAULT;[m
[32m+[m[32m        valtype m_annex;[m
[32m+[m[32m        std::vector<valtype> m_initial_witness_stack;[m
[32m+[m[32m        valtype m_witness_signature;[m
[32m+[m[32m        bool m_witness_init = false;[m
[32m+[m[32m        CScriptWitness m_witness;[m
[32m+[m[32m        CScript m_tapscript;[m
[32m+[m[32m        bool m_control_block_init = false;[m
[32m+[m[32m        valtype m_control_block;[m
[32m+[m[32m        unsigned int m_leaf_version = 0;[m
[32m+[m[32m        unsigned int m_pubkey_parity = 0;[m
[32m+[m[32m        valtype m_taproot_internal_key;[m
[32m+[m[32m        valtype m_control_block_field;[m
[32m+[m[32m        unsigned int m_flags = 0;[m
[32m+[m[32m        CHECKER_VALIDATION m_checker_validation = CHECKER_VALIDATION::ALWAYS_FAILS;[m
[32m+[m
[32m+[m[32m        int64_t m_caller_line = 0;[m
[32m+[m[32m        bool m_result = false;[m
[32m+[m[32m        ScriptError m_serror = SCRIPT_ERR_OK;[m
[32m+[m[32m        bool m_checker_was_called = false;[m
[32m+[m
[32m+[m[32m        //[m
[32m+[m[32m        // N.B.: Some methods herein temporarily marked [[maybe_unused]][m
[32m+[m[32m        // until the Tapscript tests get written[m
[32m+[m[32m        //[m
[32m+[m
[32m+[m[32m        Context& SetValidPublicKey()[m
[32m+[m[32m        {[m
[32m+[m[32m            m_scriptPubKey << m_pub;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& SetPublicKey(valtype key)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_TEST(key.size() == 32);[m
[32m+[m[32m            m_scriptPubKey << key;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetNBytePublicKey(size_t n)[m
[32m+[m[32m        {[m
[32m+[m[32m            valtype pub(n, 0xAB);[m
[32m+[m[32m            m_scriptPubKey << pub;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetSignatureAnnex(const valtype& annex_without_suffix)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_annex.push_back(0x50); // by definition of annex[m
[32m+[m[32m            m_annex.insert(m_annex.end(), annex_without_suffix.begin(), annex_without_suffix.end());[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Used to directly set a witness (presumably, invalid for Taproot key path spending)[m
[32m+[m[32m        Context& SetWitness(const std::vector<valtype>& witness)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_witness_init = true;[m
[32m+[m[32m            m_witness.stack = witness;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& PushToWitnessStack(const valtype& v)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_initial_witness_stack.push_back(v);[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetValidSignatureInWitness(unsigned char hash_type = SIGHASH_DEFAULT)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_hash_type = hash_type;[m
[32m+[m[32m            m_witness_signature = m_sig;[m
[32m+[m[32m            if (hash_type) m_witness_signature.push_back(hash_type);[m
[32m+[m
[32m+[m[32m            BOOST_TEST((hash_type ? m_witness_signature.size() == 65 : m_witness_signature.size() == 64));[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Used to directly set the signature in the witness (presumably, invalid for Taproot key path spending)[m
[32m+[m[32m        Context& SetSignatureInWitness(const valtype& sig)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_hash_type = SIGHASH_DEFAULT;[m
[32m+[m[32m            m_witness_signature = sig;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] CScript& SetTapscript()[m
[32m+[m[32m        {[m
[32m+[m[32m            return m_tapscript;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& SetTapscriptLeafVersion()[m
[32m+[m[32m        {[m
[32m+[m[32m            m_leaf_version = 0xC0;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& SetLeafVersion(unsigned int lv, unsigned int pubkey_parity)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_TEST(lv < 256);[m
[32m+[m[32m            BOOST_TEST(pubkey_parity < 2);[m
[32m+[m
[32m+[m[32m            m_leaf_version = lv;[m
[32m+[m[32m            m_pubkey_parity = pubkey_parity;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& SetTaprootInternalKey(const valtype& p)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_TEST(p.size() == 32);[m
[32m+[m[32m            m_taproot_internal_key = p;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& AddControlBlockField(const valtype& f)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_TEST(f.size() = 32);[m
[32m+[m[32m            m_control_block_field.insert(m_control_block_field.end(), f.begin(), f.end());[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [[maybe_unused]] Context& SetControlBlock(const valtype& cb)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_control_block_init = true;[m
[32m+[m[32m            m_control_block = cb;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Used to directly set the flags (presumably, not the usual Taproot key path spending flags)[m
[32m+[m[32m        Context& SetVerifyFlags(unsigned int flags)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_flags = flags;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetSchnorrSignatureValidation(CHECKER_VALIDATION checker_validation)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_checker_validation = checker_validation;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& SetP2SHWrapped()[m
[32m+[m[32m        {[m
[32m+[m[32m            m_p2sh_wrapped = true;[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& DoTest(int64_t line)[m
[32m+[m[32m        {[m
[32m+[m[32m            m_caller_line = line;[m
[32m+[m
[32m+[m[32m            BOOST_TEST_MESSAGE(Descr() << "doing test");[m
[32m+[m
[32m+[m[32m            // Build control block[m
[32m+[m[32m            bool have_control_block = m_control_block_init;[m
[32m+[m[32m            valtype control_block(m_control_block);[m
[32m+[m[32m            if (!have_control_block) {[m
[32m+[m[32m                BOOST_TEST_MESSAGE("maybe building control block");[m
[32m+[m[32m                if (m_leaf_version) {[m
[32m+[m[32m                    BOOST_TEST_MESSAGE("have !=0 leaf version, definitely building control block");[m
[32m+[m[32m                    have_control_block = true;[m
[32m+[m[32m                    control_block.push_back(static_cast<unsigned char>(m_leaf_version | m_pubkey_parity));[m
[32m+[m[32m                    control_block.insert(control_block.end(), m_taproot_internal_key.begin(), m_taproot_internal_key.end());[m
[32m+[m[32m                    control_block.insert(control_block.end(), m_control_block_field.begin(), m_control_block_field.end());[m
[32m+[m[32m                    BOOST_TEST_MESSAGE("control block size " << control_block.size());[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // build the witness if necessary[m
[32m+[m[32m            if (!m_witness_init) {[m
[32m+[m[32m                if (have_control_block) {[m
[32m+[m[32m                    // Taproot script path spend[m
[32m+[m[32m                    for (const auto& elem : m_initial_witness_stack)[m
[32m+[m[32m                        m_witness.stack.push_back(elem);[m
[32m+[m[32m                    m_witness.stack.push_back(valtype(m_tapscript.begin(), m_tapscript.end()));[m
[32m+[m[32m                    m_witness.stack.push_back(control_block);[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    // Taproot key path spend[m
[32m+[m[32m                    if (!m_witness_signature.empty()) m_witness.stack.push_back(m_witness_signature);[m
[32m+[m[32m                }[m
[32m+[m[32m                if (!m_annex.empty()) m_witness.stack.push_back(m_annex);[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            if (!m_flags) {[m
[32m+[m[32m                m_flags = SCRIPT_VERIFY_SIGPUSHONLY | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_TAPROOT;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            SignatureCheckerMock checker_mock(m_checker_validation);[m
[32m+[m[32m            CScript script_sig; // must be empty for actual Taproot[m
[32m+[m[32m            if (m_p2sh_wrapped) {[m
[32m+[m[32m                // But BIP-341 allows all SegWit v1 P2SH-wrapped outputs to pass[m
[32m+[m[32m                valtype fake_hash(20, 0x00);[m
[32m+[m[32m                script_sig << OP_0 << fake_hash;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            m_result = VerifyScript(script_sig,[m
[32m+[m[32m                                    m_scriptPubKey,[m
[32m+[m[32m                                    &m_witness,[m
[32m+[m[32m                                    m_flags,[m
[32m+[m[32m                                    checker_mock,[m
[32m+[m[32m                                    &m_serror);[m
[32m+[m
[32m+[m[32m            m_checker_was_called = checker_mock.CheckerWasCalled();[m
[32m+[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckCallSucceeded()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_result,[m
[32m+[m[32m                                Descr() << ": VerifyScript succeeded, as expected");[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_serror == SCRIPT_ERR_OK,[m
[32m+[m[32m                                Descr() << ": error code expected OK, actual was "[m
[32m+[m[32m                                        << ScriptErrorString(m_serror));[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckCallFailed(ScriptError expected)[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(!m_result,[m
[32m+[m[32m                                Descr() << ": VerifyScript failed, as expected");[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_serror == expected,[m
[32m+[m[32m                                Descr() << ": Error code expected " << ScriptErrorString(expected)[m
[32m+[m[32m                                        << ", actual was " << ScriptErrorString(m_serror));[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckSignatureCheckerWasCalled()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(m_checker_was_called,[m
[32m+[m[32m                                Descr() << ": Schnoor signature checker was called, as expected");[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        Context& CheckSignatureCheckerWasNotCalled()[m
[32m+[m[32m        {[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(!m_checker_was_called,[m
[32m+[m[32m                                Descr() << ": Schnoor signature checker was not called, as expected");[m
[32m+[m[32m            return *this;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    private:[m
[32m+[m[32m        std::string Descr()[m
[32m+[m[32m        {[m
[32m+[m[32m            std::string descr;[m
[32m+[m[32m            descr.reserve(m_test_description.size() + 20);[m
[32m+[m[32m            descr += m_test_description;[m
[32m+[m[32m            descr += " (@";[m
[32m+[m[32m            descr += as_string(m_caller_line);[m
[32m+[m[32m            descr += ")";[m
[32m+[m[32m            return descr;[m
[32m+[m[32m        }[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Valid Taproot v1 key path spend, hash_type == default, verifies");[m
[32m+[m[32m        ctx.SetValidPublicKey()[m
[32m+[m[32m            .SetValidSignatureInWitness(SIGHASH_DEFAULT)[m
[32m+[m[32m            .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m            .DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureCheckerWasCalled();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Valid Taproot v1 key path spend, hash_type == default, with annex, verifies");[m
[32m+[m[32m        ctx.SetValidPublicKey()[m
[32m+[m[32m            .SetValidSignatureInWitness(SIGHASH_DEFAULT)[m
[32m+[m[32m            .SetSignatureAnnex({0x01, 0x02, 0x03, 0x04, 0xFC, 0xFD, 0xFE, 0xFF})[m
[32m+[m[32m            .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)[m
[32m+[m[32m            .DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureCheckerWasCalled();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Taproot v1 but witness program (scriptPubKey push) is NOT 32 bytes exactly: anything goes.[m
[32m+[m[32m        // Witness programs size ∈ [2,40], per BIP-141[m
[32m+[m[32m        {[m
[32m+[m[32m            // Verifies even with arbitrary bad signature[m
[32m+[m[32m            for (size_t n = 2; n <= 40; ++n){[m
[32m+[m[32m                if (n == 32) continue;[m
[32m+[m[32m                Context ctx("Taproot v1 with non-32-byte witness program verifies (bad signature)");[m
[32m+[m[32m                ctx.SetNBytePublicKey(n)[m
[32m+[m[32m                    .SetSignatureInWitness({1, 2, 3, 4, 5})[m
[32m+[m[32m                    .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m                    .DoTest(__LINE__)[m
[32m+[m[32m                    .CheckCallSucceeded()[m
[32m+[m[32m                    .CheckSignatureCheckerWasNotCalled();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Verifies even if witness blows out stack[m
[32m+[m[32m            const valtype dummy_stack_element{0x00, 0x01, 0x02, 0x03, 0x04};[m
[32m+[m[32m            std::vector<valtype> ginormous_witness(1100, dummy_stack_element);[m
[32m+[m[32m            for (size_t n = 2; n <= 40; ++n) {[m
[32m+[m[32m                if (n == 32) continue;[m
[32m+[m[32m                Context ctx("Taproot v1 with non-32-byte witness program verifies (bad witness stack height)");[m
[32m+[m[32m                ctx.SetNBytePublicKey(n)[m
[32m+[m[32m                    .SetWitness(ginormous_witness)[m
[32m+[m[32m                    .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m                    .DoTest(__LINE__)[m
[32m+[m[32m                    .CheckCallSucceeded()[m
[32m+[m[32m                    .CheckSignatureCheckerWasNotCalled();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        {[m
[32m+[m[32m            // Verifies even if witness stack elements are too big[m
[32m+[m[32m            const valtype dummy_stack_element(1000, 0x00);[m
[32m+[m[32m            std::vector<valtype> ginormous_witness(1, dummy_stack_element);[m
[32m+[m[32m            for (size_t n = 2; n <= 40; ++n) {[m
[32m+[m[32m                if (n == 32) continue;[m
[32m+[m[32m                Context ctx("Taproot v1 with non-32-byte witness program verifies (bad witness stack element size)");[m
[32m+[m[32m                ctx.SetNBytePublicKey(n)[m
[32m+[m[32m                    .SetWitness(ginormous_witness)[m
[32m+[m[32m                    .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m                    .DoTest(__LINE__)[m
[32m+[m[32m                    .CheckCallSucceeded()[m
[32m+[m[32m                    .CheckSignatureCheckerWasNotCalled();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Taproot v1 P2SH-wrapped verifies");[m
[32m+[m[32m        ctx.SetValidPublicKey()[m
[32m+[m[32m            .SetValidSignatureInWitness(SIGHASH_DEFAULT)[m
[32m+[m[32m            .SetP2SHWrapped()[m
[32m+[m[32m            .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m            .SetVerifyFlags(SCRIPT_VERIFY_SIGPUSHONLY | SCRIPT_VERIFY_TAPROOT) // can't verify WITNESS here because that implies verify !P2SH[m
[32m+[m[32m            .DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureCheckerWasNotCalled();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Taproot v1 with empty witness stack fails");[m
[32m+[m[32m        ctx.SetValidPublicKey()[m
[32m+[m[32m            .SetWitness({})[m
[32m+[m[32m            .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m            .DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY)[m
[32m+[m[32m            .CheckSignatureCheckerWasNotCalled();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Taproot v1 key path spend where signature verification fails");[m
[32m+[m[32m        ctx.SetValidPublicKey()[m
[32m+[m[32m            .SetValidSignatureInWitness(SIGHASH_DEFAULT)[m
[32m+[m[32m            .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m            .DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)[m
[32m+[m[32m            .CheckSignatureCheckerWasCalled();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // BIP-341 calls for checking that the `hash_type` is valid, also that if the[m
[32m+[m[32m    // `hash_type == SIGHASH_SINGLE` that there's a corresponding output: these[m
[32m+[m[32m    // checks are tested in test `signature_hash_schnorr_failure_cases`.[m
[32m+[m
[32m+[m[32m    // Additional checks for code coverage (white box tests)[m
[32m+[m[32m    {[m
[32m+[m[32m        Context ctx("Taproot v1 key path spend with empty witness stack but no VERIFY_TAPROOT flag succeeds");[m
[32m+[m[32m        ctx.SetValidPublicKey()[m
[32m+[m[32m            .SetWitness({})[m
[32m+[m[32m            .SetSchnorrSignatureValidation(CHECKER_VALIDATION::ALWAYS_FAILS)[m
[32m+[m[32m            .SetVerifyFlags(SCRIPT_VERIFY_SIGPUSHONLY | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS)[m
[32m+[m[32m            .DoTest(__LINE__)[m
[32m+[m[32m            .CheckCallSucceeded()[m
[32m+[m[32m            .CheckSignatureCheckerWasNotCalled();[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m///////////////////////////////////////////////[m
[32m+[m[32m// 🡆🡆🡆 DEATH TESTS ONLY PAST THIS POINT 🡄🡄🡄[m
[32m+[m[32m///////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// See `src/test/util/boost_test_boosts.h` for explanation of the[m
[32m+[m[32m// `BOOST_CHECK_SIGABRT` macro.  Note that for each such assertion below a[m
[32m+[m[32m// message will be issued to the log along the lines of "... Assertion ...[m
[32m+[m[32m// failed.".  For these tests that is an _expected_ result.  The tests succeed[m
[32m+[m[32m// iff those asserts fail (and print that message, in failing).[m
[32m+[m
[32m+[m[32m#if defined(OK_TO_TEST_ASSERT_FUNCTION)[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(signature_hash_schnorr_assert_cases)[m
[32m+[m[32m{[m
[32m+[m[32m    const SigVersion sigversion = SigVersion::TAPROOT;[m
[32m+[m[32m    const uint8_t hash_type{SIGHASH_SINGLE};[m
[32m+[m
[32m+[m[32m    // Here we pass the assert[m
[32m+[m[32m    CMutableTransaction tx_to_m;[m
[32m+[m[32m    tx_to_m.vin.push_back(CTxIn());[m
[32m+[m[32m    tx_to_m.vout.push_back(CTxOut());[m
[32m+[m[32m    uint32_t in_pos{0};[m
[32m+[m
[32m+[m[32m    PrecomputedTransactionData cache;[m
[32m+[m[32m    cache.m_bip341_taproot_ready = true;[m
[32m+[m[32m    cache.m_spent_outputs_ready = true;[m
[32m+[m[32m    cache.m_spent_outputs.push_back(CTxOut());[m
[32m+[m
[32m+[m[32m    ScriptExecutionData execdata;[m
[32m+[m[32m    execdata.m_annex_init = true;[m
[32m+[m[32m    execdata.m_annex_present = false;[m
[32m+[m[32m    execdata.m_annex_hash = uint256::ZERO;[m
[32m+[m
[32m+[m[32m    uint256 hash_out{0};[m
[32m+[m
[32m+[m[32m    // (Deliberate variable shadowing follows for ease in writing separate tests[m
[32m+[m[32m    // with mainly the same setup.)[m
[32m+[m[32m    {[m
[32m+[m[32m        // Check that an invalid SigVersion asserts.[m
[32m+[m[32m        const SigVersion sigversion = SigVersion::BASE;[m
[32m+[m[32m        BOOST_CHECK_SIGABRT(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, hash_type, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Check that in_pos must be valid w.r.t. #inputs[m
[32m+[m[32m        const uint32_t in_pos{2};[m
[32m+[m[32m        BOOST_CHECK_SIGABRT(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, hash_type, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Check that annex_init must be true[m
[32m+[m[32m        ScriptExecutionData execdata;[m
[32m+[m[32m        execdata.m_annex_init = false;[m
[32m+[m[32m        BOOST_CHECK_SIGABRT(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, hash_type, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Check that tapleaf_hash_init and codeseparator_pos_init must be true[m
[32m+[m[32m        // if version == TAPSCRIPT[m
[32m+[m[32m        const SigVersion sigversion = SigVersion::TAPSCRIPT;[m
[32m+[m[32m        ScriptExecutionData execdata;[m
[32m+[m[32m        execdata.m_annex_init = true;[m
[32m+[m[32m        execdata.m_annex_present = false;[m
[32m+[m[32m        execdata.m_annex_hash = uint256::ZERO;[m
[32m+[m[32m        execdata.m_tapleaf_hash_init = false;[m
[32m+[m[32m        execdata.m_codeseparator_pos_init = true;[m
[32m+[m[32m        BOOST_CHECK_SIGABRT(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, hash_type, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL));[m
[32m+[m[32m        execdata.m_tapleaf_hash_init = true;[m
[32m+[m[32m        execdata.m_codeseparator_pos_init = false;[m
[32m+[m[32m        BOOST_CHECK_SIGABRT(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,[m
[32m+[m[32m                                                  in_pos, hash_type, sigversion, cache,[m
[32m+[m[32m                                                  MissingDataBehavior::FAIL));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(handle_missing_data)[m
[32m+[m[32m{[m
[32m+[m[32m    // `HandleMissingData` is a static free function inside of `interpreter.cpp`.[m
[32m+[m[32m    // Easiest way to get to it is via `SignatureHashSchnorr<CMutableTransaction>`[m
[32m+[m[32m    // which takes an explicit `MissingDataBehavior` value which is what is[m
[32m+[m[32m    // needed to exercise `HandleMissingData`.[m
[32m+[m
[32m+[m[32m    // N.B.: This is somewhat fragile.  We are just finding a path through[m
[32m+[m[32m    // `SignatureHashSchnorr` that definitely gets to `HandleMissingData`. If[m
[32m+[m[32m    // the code in `SignatureHashSchnorr` changes for whatever reason the[m
[32m+[m[32m    // setup code below may no longer pick out that path.[m
[32m+[m
[32m+[m[32m    // Here we pick an acceptable SigVersion and hash type[m
[32m+[m[32m    const SigVersion sigversion = SigVersion::TAPROOT;[m
[32m+[m[32m    const uint8_t hash_type{SIGHASH_DEFAULT};[m
[32m+[m
[32m+[m[32m    // Here we pass the assert[m
[32m+[m[32m    CMutableTransaction tx_to_m;[m
[32m+[m[32m    tx_to_m.vin.push_back(CTxIn());[m
[32m+[m[32m    const CTransaction tx_to(tx_to_m);[m
[32m+[m[32m    const uint32_t in_pos{0};[m
[32m+[m
[32m+[m[32m    // Here we take the `then` clause of the `if`[m
[32m+[m[32m    PrecomputedTransactionData cache;[m
[32m+[m[32m    cache.m_bip341_taproot_ready = false;[m
[32m+[m[32m    cache.m_spent_outputs_ready = false;[m
[32m+[m
[32m+[m[32m    uint256 hash_out{0};[m
[32m+[m[32m    ScriptExecutionData execdata;[m
[32m+[m
[32m+[m[32m    // `MissingDataBehavior::FAIL` simply returns false[m
[32m+[m[32m    BOOST_CHECK(!SignatureHashSchnorr(hash_out, execdata, tx_to, in_pos,[m
[32m+[m[32m                                      hash_type, sigversion, cache,[m
[32m+[m[32m                                      MissingDataBehavior::FAIL));[m
[32m+[m[32m    // Any other value for `MissingDataBehavior` triggers an `assert` function[m
[32m+[m[32m    // which (on Linux) signals SIGABRT.[m
[32m+[m[32m    BOOST_CHECK_SIGABRT(SignatureHashSchnorr(hash_out, execdata, tx_to, in_pos,[m
[32m+[m[32m                                             hash_type, sigversion, cache,[m
[32m+[m[32m                                             MissingDataBehavior::ASSERT_FAIL));[m
[32m+[m[32m    BOOST_CHECK_SIGABRT(SignatureHashSchnorr(hash_out, execdata, tx_to, in_pos,[m
[32m+[m[32m                                             hash_type, sigversion, cache,[m
[32m+[m[32m                                             static_cast<MissingDataBehavior>(25)));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_SUITE_END()[m
[33mdiff --git a/src/test/script_tests.cpp b/src/test/script_tests.cpp[m
[33mindex 05bb89ab55..75364a78d2 100644[m
[33m--- a/src/test/script_tests.cpp[m
[33m+++ b/src/test/script_tests.cpp[m
[36m@@ -15,6 +15,7 @@[m
 #include <script/sign.h>[m
 #include <script/signingprovider.h>[m
 #include <streams.h>[m
[32m+[m[32m#include <test/util/pretty_data.h>[m
 #include <test/util/setup_common.h>[m
 #include <test/util/transaction_utils.h>[m
 #include <util/strencodings.h>[m
[36m@@ -26,6 +27,7 @@[m
 [m
 #include <cstdint>[m
 #include <fstream>[m
[32m+[m[32m#include <optional>[m
 #include <string>[m
 #include <vector>[m
 [m
[36m@@ -38,9 +40,6 @@[m
 [m
 static const unsigned int gFlags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;[m
 [m
[31m-unsigned int ParseScriptFlags(std::string strFlags);[m
[2m-std::string FormatScriptFlags(unsigned int flags);[m
[2m-[m
 UniValue read_json(const std::string& jsondata)[m
 {[m
     UniValue v;[m
[36m@@ -53,76 +52,6 @@[m [mUniValue read_json(const std::string& jsondata)[m
     return v.get_array();[m
 }[m
 [m
[31m-struct ScriptErrorDesc[m
[31m-{[m
[31m-    ScriptError_t err;[m
[31m-    const char *name;[m
[31m-};[m
[31m-[m
[31m-static ScriptErrorDesc script_errors[]={[m
[31m-    {SCRIPT_ERR_OK, "OK"},[m
[31m-    {SCRIPT_ERR_UNKNOWN_ERROR, "UNKNOWN_ERROR"},[m
[31m-    {SCRIPT_ERR_EVAL_FALSE, "EVAL_FALSE"},[m
[31m-    {SCRIPT_ERR_OP_RETURN, "OP_RETURN"},[m
[31m-    {SCRIPT_ERR_SCRIPT_SIZE, "SCRIPT_SIZE"},[m
[31m-    {SCRIPT_ERR_PUSH_SIZE, "PUSH_SIZE"},[m
[31m-    {SCRIPT_ERR_OP_COUNT, "OP_COUNT"},[m
[31m-    {SCRIPT_ERR_STACK_SIZE, "STACK_SIZE"},[m
[31m-    {SCRIPT_ERR_SIG_COUNT, "SIG_COUNT"},[m
[31m-    {SCRIPT_ERR_PUBKEY_COUNT, "PUBKEY_COUNT"},[m
[31m-    {SCRIPT_ERR_VERIFY, "VERIFY"},[m
[31m-    {SCRIPT_ERR_EQUALVERIFY, "EQUALVERIFY"},[m
[31m-    {SCRIPT_ERR_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY"},[m
[31m-    {SCRIPT_ERR_CHECKSIGVERIFY, "CHECKSIGVERIFY"},[m
[31m-    {SCRIPT_ERR_NUMEQUALVERIFY, "NUMEQUALVERIFY"},[m
[31m-    {SCRIPT_ERR_BAD_OPCODE, "BAD_OPCODE"},[m
[31m-    {SCRIPT_ERR_DISABLED_OPCODE, "DISABLED_OPCODE"},[m
[31m-    {SCRIPT_ERR_INVALID_STACK_OPERATION, "INVALID_STACK_OPERATION"},[m
[31m-    {SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "INVALID_ALTSTACK_OPERATION"},[m
[31m-    {SCRIPT_ERR_UNBALANCED_CONDITIONAL, "UNBALANCED_CONDITIONAL"},[m
[31m-    {SCRIPT_ERR_NEGATIVE_LOCKTIME, "NEGATIVE_LOCKTIME"},[m
[31m-    {SCRIPT_ERR_UNSATISFIED_LOCKTIME, "UNSATISFIED_LOCKTIME"},[m
[31m-    {SCRIPT_ERR_SIG_HASHTYPE, "SIG_HASHTYPE"},[m
[31m-    {SCRIPT_ERR_SIG_DER, "SIG_DER"},[m
[31m-    {SCRIPT_ERR_MINIMALDATA, "MINIMALDATA"},[m
[31m-    {SCRIPT_ERR_SIG_PUSHONLY, "SIG_PUSHONLY"},[m
[31m-    {SCRIPT_ERR_SIG_HIGH_S, "SIG_HIGH_S"},[m
[31m-    {SCRIPT_ERR_SIG_NULLDUMMY, "SIG_NULLDUMMY"},[m
[31m-    {SCRIPT_ERR_PUBKEYTYPE, "PUBKEYTYPE"},[m
[31m-    {SCRIPT_ERR_CLEANSTACK, "CLEANSTACK"},[m
[31m-    {SCRIPT_ERR_MINIMALIF, "MINIMALIF"},[m
[31m-    {SCRIPT_ERR_SIG_NULLFAIL, "NULLFAIL"},[m
[31m-    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "DISCOURAGE_UPGRADABLE_NOPS"},[m
[31m-    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, "DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"},[m
[31m-    {SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH, "WITNESS_PROGRAM_WRONG_LENGTH"},[m
[31m-    {SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY, "WITNESS_PROGRAM_WITNESS_EMPTY"},[m
[31m-    {SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH, "WITNESS_PROGRAM_MISMATCH"},[m
[31m-    {SCRIPT_ERR_WITNESS_MALLEATED, "WITNESS_MALLEATED"},[m
[31m-    {SCRIPT_ERR_WITNESS_MALLEATED_P2SH, "WITNESS_MALLEATED_P2SH"},[m
[31m-    {SCRIPT_ERR_WITNESS_UNEXPECTED, "WITNESS_UNEXPECTED"},[m
[31m-    {SCRIPT_ERR_WITNESS_PUBKEYTYPE, "WITNESS_PUBKEYTYPE"},[m
[31m-    {SCRIPT_ERR_OP_CODESEPARATOR, "OP_CODESEPARATOR"},[m
[31m-    {SCRIPT_ERR_SIG_FINDANDDELETE, "SIG_FINDANDDELETE"},[m
[31m-};[m
[31m-[m
[31m-static std::string FormatScriptError(ScriptError_t err)[m
[2m-{[m
[2m-    for (const auto& se : script_errors)[m
[2m-        if (se.err == err)[m
[31m-            return se.name;[m
[31m-    BOOST_ERROR("Unknown scripterror enumeration value, update script_errors in script_tests.cpp.");[m
[31m-    return "";[m
[31m-}[m
[31m-[m
[31m-static ScriptError_t ParseScriptError(const std::string& name)[m
[2m-{[m
[2m-    for (const auto& se : script_errors)[m
[2m-        if (se.name == name)[m
[2m-            return se.err;[m
[31m-    BOOST_ERROR("Unknown scripterror \"" << name << "\" in test description");[m
[31m-    return SCRIPT_ERR_UNKNOWN_ERROR;[m
[31m-}[m
[31m-[m
 BOOST_FIXTURE_TEST_SUITE(script_tests, BasicTestingSetup)[m
 [m
 void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, uint32_t flags, const std::string& message, int scriptError, CAmount nValue = 0)[m
[36m@@ -137,7 +66,7 @@[m [mvoid DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript[m
     CMutableTransaction tx = BuildSpendingTransaction(scriptSig, scriptWitness, txCredit);[m
     CMutableTransaction tx2 = tx;[m
     BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue, MissingDataBehavior::ASSERT_FAIL), &err) == expect, message);[m
[31m-    BOOST_CHECK_MESSAGE(err == scriptError, FormatScriptError(err) + " where " + FormatScriptError((ScriptError_t)scriptError) + " expected: " + message);[m
[32m+[m[32m    BOOST_CHECK_MESSAGE(err == scriptError, FormatScriptError(err).value() + " where " + FormatScriptError((ScriptError_t)scriptError).value() + " expected: " + message);[m
 [m
     // Verify that removing flags from a passing test or adding flags to a failing test does not change the result.[m
     for (int i = 0; i < 16; ++i) {[m
[36m@@ -429,7 +358,7 @@[m [mpublic:[m
         array.push_back(FormatScript(spendTx.vin[0].scriptSig));[m
         array.push_back(FormatScript(creditTx->vout[0].scriptPubKey));[m
         array.push_back(FormatScriptFlags(flags));[m
[31m-        array.push_back(FormatScriptError((ScriptError_t)scriptError));[m
[32m+[m[32m        array.push_back(FormatScriptError((ScriptError_t)scriptError).value());[m
         array.push_back(comment);[m
         return array;[m
     }[m
[36m@@ -966,10 +895,15 @@[m [mBOOST_AUTO_TEST_CASE(script_json_test)[m
         CScript scriptSig = ParseScript(scriptSigString);[m
         std::string scriptPubKeyString = test[pos++].get_str();[m
         CScript scriptPubKey = ParseScript(scriptPubKeyString);[m
[31m-        unsigned int scriptflags = ParseScriptFlags(test[pos++].get_str());[m
[31m-        int scriptError = ParseScriptError(test[pos++].get_str());[m
[32m+[m[32m        auto flagWord = test[pos++].get_str();[m
[32m+[m[32m        auto scriptflags = ParseScriptFlags(flagWord);[m
[32m+[m[32m        if (!scriptflags) BOOST_ERROR("Bad test: unknown verification flag '" << flagWord << "'");[m
[32m+[m
[32m+[m[32m        auto errorWord = test[pos++].get_str();[m
[32m+[m[32m        auto scriptError = ParseScriptError(errorWord);[m
[32m+[m[32m        if (!scriptError) BOOST_ERROR("Bad test: unknown script error value '" << errorWord << "'");[m
 [m
[31m-        DoTest(scriptPubKey, scriptSig, witness, scriptflags, strTest, scriptError, nValue);[m
[32m+[m[32m        DoTest(scriptPubKey, scriptSig, witness, scriptflags.value(), strTest, scriptError.value(), nValue);[m
     }[m
 }[m
 [m
[36m@@ -1679,7 +1613,10 @@[m [mstatic void AssetTest(const UniValue& test)[m
     const std::vector<CTxOut> prevouts = TxOutsFromJSON(test["prevouts"]);[m
     BOOST_CHECK(prevouts.size() == mtx.vin.size());[m
     size_t idx = test["index"].getInt<int64_t>();[m
[31m-    uint32_t test_flags{ParseScriptFlags(test["flags"].get_str())};[m
[32m+[m[32m    auto flags_word = test["flags"].get_str();[m
[32m+[m[32m    auto test_flags{ParseScriptFlags(flags_word)};[m
[32m+[m[32m    if (!test_flags) BOOST_ERROR("Bad test: unknown verification flag '" << flags_word << "'");[m
[32m+[m
     bool fin = test.exists("final") && test["final"].get_bool();[m
 [m
     if (test.exists("success")) {[m
[36m@@ -1692,7 +1629,7 @@[m [mstatic void AssetTest(const UniValue& test)[m
         for (const auto flags : ALL_CONSENSUS_FLAGS) {[m
             // "final": true tests are valid for all flags. Others are only valid with flags that are[m
             // a subset of test_flags.[m
[31m-            if (fin || ((flags & test_flags) == flags)) {[m
[32m+[m[32m            if (fin || ((flags & test_flags.value()) == flags)) {[m
                 bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
                 BOOST_CHECK(ret);[m
             }[m
[36m@@ -1708,7 +1645,7 @@[m [mstatic void AssetTest(const UniValue& test)[m
         CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);[m
         for (const auto flags : ALL_CONSENSUS_FLAGS) {[m
             // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.[m
[31m-            if ((flags & test_flags) == test_flags) {[m
[32m+[m[32m            if ((flags & test_flags.value()) == test_flags.value()) {[m
                 bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
                 BOOST_CHECK(!ret);[m
             }[m
[33mdiff --git a/src/test/test_util_tests.cpp b/src/test/test_util_tests.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..9b0370b32b[m
[33m--- /dev/null[m
[33m+++ b/src/test/test_util_tests.cpp[m
[36m@@ -0,0 +1,308 @@[m
[32m+[m[32m// Copyright (c) 2011-2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <span.h>[m
[32m+[m[32m#include <test/util/pretty_data.h>[m
[32m+[m[32m#include <test/util/setup_common.h>[m
[32m+[m[32m#include <test/util/traits.h>[m
[32m+[m[32m#include <test/util/vector.h>[m
[32m+[m[32m#include <uint256.h>[m
[32m+[m
[32m+[m[32m#include <boost/test/unit_test.hpp>[m
[32m+[m
[32m+[m[32m#include <iomanip>[m
[32m+[m[32m#include <memory>[m
[32m+[m[32m#include <sstream>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <string_view>[m
[32m+[m[32m#include <type_traits>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32musing namespace std::literals::string_literals;[m
[32m+[m[32musing namespace std::literals::string_view_literals;[m
[32m+[m[32musing namespace test::util::literals;[m
[32m+[m
[32m+[m[32mBOOST_FIXTURE_TEST_SUITE(test_util_tests, BasicTestingSetup)[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(as_string_tests)[m
[32m+[m[32m{[m
[32m+[m[32m    // Some typical values, independent of integral type[m
[32m+[m[32m    BOOST_TEST(as_string(0) == "0"s);[m
[32m+[m[32m    BOOST_TEST(as_string(1) == "1"s);[m
[32m+[m[32m    BOOST_TEST(as_string(-1) == "-1"s);[m
[32m+[m[32m    BOOST_TEST(as_string(12) == "12"s);[m
[32m+[m[32m    BOOST_TEST(as_string(123) == "123"s);[m
[32m+[m[32m    BOOST_TEST(as_string(1234) == "1234"s);[m
[32m+[m
[32m+[m[32m    // Now some larger values[m
[32m+[m[32m    BOOST_TEST(as_string(1'000'000'000'000ULL) == "1000000000000"s);[m
[32m+[m[32m    BOOST_TEST(as_string(-1'234'567'890'123LL) == "-1234567890123"s);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(hex_to_stream)[m
[32m+[m[32m{[m
[32m+[m[32m    auto ToStream = [](auto v) {[m
[32m+[m[32m        std::ostringstream oss;[m
[32m+[m[32m        oss << Hex(v);[m
[32m+[m[32m        return oss.str();[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // integral types[m
[32m+[m[32m        BOOST_TEST(ToStream(static_cast<int8_t>(0x75)) == "0x75");[m
[32m+[m[32m        BOOST_TEST(ToStream(static_cast<uint8_t>(0x75)) == "0x75");[m
[32m+[m[32m        BOOST_TEST(ToStream(0x75) == "0x00000075");[m
[32m+[m[32m        BOOST_TEST(ToStream(0x75U) == "0x00000075");[m
[32m+[m[32m        BOOST_TEST(ToStream(0x75LL) == "0x0000000000000075");[m
[32m+[m[32m        BOOST_TEST(ToStream(0x75ULL) == "0x0000000000000075");[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // `uint256` which acts like a container[m
[32m+[m[32m        BOOST_TEST(ToStream(uint256::ZERO) == "0x0000000000000000000000000000000000000000000000000000000000000000");[m
[32m+[m[32m        BOOST_TEST(ToStream(uint256::ONE) == "0x0000000000000000000000000000000000000000000000000000000000000001");[m
[32m+[m[32m        BOOST_TEST(ToStream(uint256S("fedcba9876543210"s)) == "0x000000000000000000000000000000000000000000000000fedcba9876543210");[m
[32m+[m[32m        BOOST_TEST(ToStream(uint256S("0123456789abcdef00000000000000000000000000000000fedcba9876543210")) == "0x0123456789abcdef00000000000000000000000000000000fedcba9876543210");[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // `uint160` also acts like a container[m
[32m+[m
[32m+[m[32m        // when initialized from a vector it is little-endian; but when written as a hex string it is big-endian[m
[32m+[m[32m        std::vector<unsigned char> v160{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,[m
[32m+[m[32m                                        0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6};[m
[32m+[m[32m        BOOST_TEST(ToStream(uint160(v160)) == "0xf6f7f8f9fafbfcfdfeff0a090807060504030201");[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Span of unsigned char[m
[32m+[m[32m        std::vector<unsigned char> v{0x10, 0x11, 0x12, 0x13, 0x14, 0x15};[m
[32m+[m[32m        BOOST_TEST(ToStream(Span(v)) == "0x101112131415");[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(string_hex_to_bytes_and_back)[m
[32m+[m[32m{[m
[32m+[m[32m    using valtype = std::vector<unsigned char>;[m
[32m+[m
[32m+[m[32m    // hex strings to byte vector[m
[32m+[m[32m    BOOST_TEST("0A"_hex == valtype(1, 0x0a));[m
[32m+[m[32m    BOOST_TEST("0a"_hex == valtype(1, 0x0a));[m
[32m+[m[32m    BOOST_TEST("A0"_hex == valtype(1, 0xa0));[m
[32m+[m[32m    BOOST_TEST("a0"_hex == valtype(1, 0xa0));[m
[32m+[m[32m    BOOST_TEST("aA"_hex == valtype(1, 0xaa));[m
[32m+[m[32m    BOOST_TEST("Aa"_hex == valtype(1, 0xaa));[m
[32m+[m
[32m+[m[32m    BOOST_TEST(("12"_hex == valtype{0x12}));[m
[32m+[m[32m    BOOST_TEST(("1234"_hex == valtype{0x12, 0x34}));[m
[32m+[m[32m    BOOST_TEST(("123456"_hex == valtype{0x12, 0x34, 0x56}));[m
[32m+[m
[32m+[m[32m    // Invalid hex string literals[m
[32m+[m[32m    BOOST_CHECK_THROW("1"_hex, std::logic_error);[m
[32m+[m[32m    BOOST_CHECK_THROW("123"_hex, std::logic_error);[m
[32m+[m[32m    BOOST_CHECK_THROW("1234xyz"_hex, std::logic_error);[m
[32m+[m
[32m+[m[32m    // Binary to hex string[m
[32m+[m[32m    BOOST_TEST("12345678abcd"s == HexStr("12345678abcd"_hex));[m
[32m+[m[32m    BOOST_TEST(std::string(64, '0') == HexStr(uint256::ZERO));[m
[32m+[m[32m    BOOST_TEST((std::string{'0', '1'} + std::string(62, '0') == HexStr(uint256::ONE)));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(string_to_bytes)[m
[32m+[m[32m{[m
[32m+[m[32m    using valtype = std::vector<unsigned char>;[m
[32m+[m
[32m+[m[32m    BOOST_TEST(("Aa"_bv == valtype{'A', 'a'}));[m
[32m+[m[32m    BOOST_TEST(("ABCD-0123-xyz"_bv == valtype{'A', 'B', 'C', 'D', '-', '0', '1', '2', '3', '-', 'x', 'y', 'z'}));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(HexStr_problem)[m
[32m+[m[32m{[m
[32m+[m[32m    std::vector<unsigned char> a5(1, 0xa5);[m
[32m+[m[32m    auto a5_r = HexStr(Span<unsigned char>(a5));[m
[32m+[m[32m    BOOST_TEST(a5_r == "a5"s);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(ex_vector_tests)[m
[32m+[m[32m{[m
[32m+[m[32m    using valtype = std::vector<unsigned char>;[m
[32m+[m
[32m+[m[32m    using namespace test::util::vector_ops;[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Conversion via unary `+`[m
[32m+[m[32m        std::vector<int> v{10, 20, 30};[m
[32m+[m[32m        auto ev = +v;[m
[32m+[m[32m        BOOST_TEST(ev == v);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Subrange operation[m
[32m+[m[32m        ex_vector<unsigned char> c1{"ABCDEFGH"_bv};[m
[32m+[m
[32m+[m[32m        BOOST_TEST((c1[{0, 2}] == "AB"_bv));[m
[32m+[m[32m        BOOST_TEST((c1[{1, 4}] == "BCD"_bv));[m
[32m+[m[32m        BOOST_TEST((c1[{3, 7}] == "DEFG"_bv));[m
[32m+[m[32m        BOOST_TEST((c1[{0, 8}] == c1));[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Creating ex_vector from a `uint256`.[m
[32m+[m[32m        //[m
[32m+[m[32m        // (w.r.t. these tests note there is an endianness issue - HexStr will print little-endian,[m
[32m+[m[32m        // as a byte array, NOT big-endian like an integer[m
[32m+[m[32m        ex_vector<unsigned char> exv_ZERO = from_base_blob(uint256::ZERO);[m
[32m+[m[32m        BOOST_TEST(HexStr(exv_ZERO) == "0000000000000000000000000000000000000000000000000000000000000000");[m
[32m+[m[32m        ex_vector<unsigned char> exv_ONE = from_base_blob(uint256::ONE);[m
[32m+[m[32m        BOOST_TEST(HexStr(exv_ONE) == "0100000000000000000000000000000000000000000000000000000000000000");[m
[32m+[m[32m        ex_vector<unsigned char> exv_other = from_base_blob(uint256S([m
[32m+[m[32m            "0123456789abcdef00000000000000000000000000000000fedcba9876543210"));[m
[32m+[m[32m        BOOST_TEST(HexStr(exv_other) == "1032547698badcfe00000000000000000000000000000000efcdab8967452301");[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        // Concatenating vectors via `operator||` (producing ex_vectors)[m
[32m+[m[32m        valtype c0{};[m
[32m+[m[32m        valtype c1{"ABCDEFGH"_bv};[m
[32m+[m[32m        valtype c2{"1234"_bv};[m
[32m+[m
[32m+[m[32m        BOOST_TEST(((c0 || c0) == c0));[m
[32m+[m[32m        BOOST_TEST(((c0 || c1) == c1));[m
[32m+[m[32m        BOOST_TEST(((c2 || c0) == c2));[m
[32m+[m[32m        BOOST_TEST(((c1 || c2) == "ABCDEFGH1234"_bv));[m
[32m+[m[32m        BOOST_TEST(((c2 || c1) == "1234ABCDEFGH"_bv));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(pretty_flags)[m
[32m+[m[32m{[m
[32m+[m[32m    // A small assortment[m
[32m+[m[32m    BOOST_TEST(SCRIPT_VERIFY_P2SH == ParseScriptFlags("P2SH"sv).value_or(0));[m
[32m+[m[32m    BOOST_TEST(SCRIPT_VERIFY_SIGPUSHONLY == ParseScriptFlags("SIGPUSHONLY"sv).value_or(0));[m
[32m+[m[32m    BOOST_TEST(SCRIPT_VERIFY_TAPROOT == ParseScriptFlags("TAPROOT"sv).value_or(0));[m
[32m+[m[32m    BOOST_TEST((SCRIPT_VERIFY_MINIMALIF | SCRIPT_VERIFY_WITNESS) == ParseScriptFlags("MINIMALIF,WITNESS"sv).value_or(0));[m
[32m+[m[32m    BOOST_TEST((SCRIPT_VERIFY_TAPROOT | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_DERSIG) == ParseScriptFlags("TAPROOT,LOW_S,DERSIG"sv).value_or(0));[m
[32m+[m[32m    BOOST_TEST(0 == ParseScriptFlags("F00BAR"sv).value_or(0));[m
[32m+[m[32m    BOOST_TEST(0 == ParseScriptFlags("witness"sv).value_or(0));        // case-sensitive[m
[32m+[m[32m    BOOST_TEST(0 == ParseScriptFlags("P2SH , WITNESS"sv).value_or(0)); // Underlying function "split" doesn't tri.m[m
[32m+[m
[32m+[m[32m    BOOST_TEST("STRICTENC"sv == FormatScriptFlags(SCRIPT_VERIFY_STRICTENC));[m
[32m+[m[32m    BOOST_TEST("WITNESS_PUBKEYTYPE"sv == FormatScriptFlags(SCRIPT_VERIFY_WITNESS_PUBKEYTYPE));[m
[32m+[m[32m    BOOST_TEST("CONST_SCRIPTCODE,TAPROOT"sv == FormatScriptFlags(SCRIPT_VERIFY_TAPROOT | SCRIPT_VERIFY_CONST_SCRIPTCODE));[m
[32m+[m[32m    BOOST_TEST("CLEANSTACK,NULLDUMMY,NULLFAIL"sv == FormatScriptFlags(SCRIPT_VERIFY_NULLDUMMY | SCRIPT_VERIFY_CLEANSTACK | SCRIPT_VERIFY_NULLFAIL));[m
[32m+[m[32m    BOOST_TEST(""sv == FormatScriptFlags(0));[m
[32m+[m[32m    BOOST_TEST(""sv == FormatScriptFlags(1U << 30)); // invalid flags just ignored[m
[32m+[m[32m    BOOST_TEST("WITNESS"sv == FormatScriptFlags((1U << 30) | SCRIPT_VERIFY_WITNESS));[m
[32m+[m
[32m+[m[32m    // Systematic[m
[32m+[m[32m    auto flag_map = MapFlagNames();[m
[32m+[m[32m    for (auto [name1, value1] : flag_map) {[m
[32m+[m[32m        BOOST_TEST(value1 == ParseScriptFlags(name1).value_or(0));[m
[32m+[m[32m        BOOST_TEST(name1 == FormatScriptFlags(value1));[m
[32m+[m
[32m+[m[32m        for (auto [name2, value2] : flag_map) {[m
[32m+[m[32m            if (value1 == value2) continue;[m
[32m+[m[32m            BOOST_TEST((value1 | value2) == ParseScriptFlags(std::string(name1) + "," + std::string(name2)).value_or(0));[m
[32m+[m[32m            BOOST_TEST(std::string(name1 < name2 ? name1 : name2) + "," + std::string(name1 < name2 ? name2 : name1) == FormatScriptFlags(value1 | value2));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(pretty_script_errors)[m
[32m+[m[32m{[m
[32m+[m[32m    // A small assortment[m
[32m+[m[32m    BOOST_TEST("OK"sv == FormatScriptError(SCRIPT_ERR_OK).value_or(""s));[m
[32m+[m[32m    BOOST_TEST("UNKNOWN_ERROR"sv == FormatScriptError(SCRIPT_ERR_UNKNOWN_ERROR).value_or(""s));[m
[32m+[m[32m    BOOST_TEST(""sv == FormatScriptError(SCRIPT_ERR_ERROR_COUNT).value_or(""s));[m
[32m+[m
[32m+[m[32m    BOOST_TEST(SCRIPT_ERR_OK == ParseScriptError("OK"sv).value_or(SCRIPT_ERR_UNKNOWN_ERROR));[m
[32m+[m[32m    BOOST_TEST(SCRIPT_ERR_SCHNORR_SIG_SIZE == ParseScriptError("SCHNORR_SIG_SIZE"sv).value_or(SCRIPT_ERR_UNKNOWN_ERROR));[m
[32m+[m[32m    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError("F00Bar"sv).value_or(SCRIPT_ERR_UNKNOWN_ERROR));[m
[32m+[m[32m    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError("Schnorr_Sig"sv).value_or(SCRIPT_ERR_UNKNOWN_ERROR)); // case-sensitive[m
[32m+[m[32m    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError("MINIMALIF "sv).value_or(SCRIPT_ERR_UNKNOWN_ERROR));  // doesn't tri.m arg[m
[32m+[m
[32m+[m[32m    // Systematic[m
[32m+[m[32m    for (size_t i = 0; i < SCRIPT_ERR_ERROR_COUNT; ++i) {[m
[32m+[m[32m        const auto name = FormatScriptError(static_cast<ScriptError_t>(i)).value_or(""s);[m
[32m+[m[32m        BOOST_TEST(!name.empty());[m
[32m+[m[32m        BOOST_TEST(i == ParseScriptError(name).value_or(i ? SCRIPT_ERR_UNKNOWN_ERROR : SCRIPT_ERR_OK));[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#define EVAL(...) []() -> bool { return __VA_ARGS__; }()[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(is_base_of_trait)[m
[32m+[m[32m{[m
[32m+[m[32m    class A[m
[32m+[m[32m    {[m
[32m+[m[32m    };[m
[32m+[m[32m    class B : A[m
[32m+[m[32m    {[m
[32m+[m[32m    };[m
[32m+[m[32m    class C : B[m
[32m+[m[32m    {[m
[32m+[m[32m    };[m
[32m+[m[32m    class D[m
[32m+[m[32m    {[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    BOOST_TEST(EVAL((std::is_base_of_v<A, A>)));[m
[32m+[m[32m    BOOST_TEST(EVAL((std::is_base_of_v<A, B>)));[m
[32m+[m[32m    BOOST_TEST(EVAL((std::is_base_of_v<A, C>)));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(std::is_base_of_v<A, D>)));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(std::is_base_of_v<B, A>)));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(std::is_base_of_v<int, int>)));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate <unsigned int UI>[m
[32m+[m[32mstruct base_template {[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(is_base_template_of_template_trait)[m
[32m+[m[32m{[m
[32m+[m[32m    struct d_1010 : public base_template<1010> {[m
[32m+[m[32m    };[m
[32m+[m[32m    struct d_2022 : public base_template<2022> {[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    BOOST_TEST(EVAL((traits::is_base_of_template_of_uint_v<base_template, d_1010>)));[m
[32m+[m[32m    BOOST_TEST(EVAL((traits::is_base_of_template_of_uint_v<base_template, d_2022>)));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(traits::is_base_of_template_of_uint_v<base_template, std::ostringstream>)));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(traits::is_base_of_template_of_uint_v<base_template, int>)));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate <typename T>[m
[32m+[m[32musing copy_assign_t = decltype(std::declval<T&>() = std::declval<const T&>());[m
[32m+[m
[32m+[m[32mtemplate <typename C>[m
[32m+[m[32mbool fun(...)[m
[32m+[m[32m{[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate <typename C, typename = traits::ok_for_range_based_for<C>>[m
[32m+[m[32mbool fun(int)[m
[32m+[m[32m{[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(is_detected)[m
[32m+[m[32m{[m
[32m+[m[32m    struct Meow {[m
[32m+[m[32m    };[m
[32m+[m[32m    struct Purr {[m
[32m+[m[32m        void operator=(const Purr&) = delete;[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    BOOST_TEST(EVAL((traits::is_detected_v<copy_assign_t, Meow>)));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(traits::is_detected_v<copy_assign_t, Purr>)));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(ok_for_range_based_for)[m
[32m+[m[32m{[m
[32m+[m[32m    BOOST_TEST(EVAL((fun<std::vector<int>>(5))));[m
[32m+[m[32m    BOOST_TEST(EVAL(!(fun<std::allocator<int>>(5))));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_SUITE_END()[m
[33mdiff --git a/src/test/transaction_tests.cpp b/src/test/transaction_tests.cpp[m
[33mindex 4e6c223ccc..95922c82a0 100644[m
[33m--- a/src/test/transaction_tests.cpp[m
[33m+++ b/src/test/transaction_tests.cpp[m
[36m@@ -21,6 +21,7 @@[m
 #include <script/signingprovider.h>[m
 #include <script/standard.h>[m
 #include <streams.h>[m
[32m+[m[32m#include <test/util/pretty_data.h>[m
 #include <test/util/script.h>[m
 #include <test/util/transaction_utils.h>[m
 #include <util/strencodings.h>[m
[36m@@ -29,6 +30,7 @@[m
 [m
 #include <functional>[m
 #include <map>[m
[32m+[m[32m#include <optional>[m
 #include <string>[m
 [m
 #include <boost/test/unit_test.hpp>[m
[36m@@ -40,72 +42,16 @@[m [mtypedef std::vector<unsigned char> valtype;[m
 // In script_tests.cpp[m
 UniValue read_json(const std::string& jsondata);[m
 [m
[31m-static std::map<std::string, unsigned int> mapFlagNames = {[m
[31m-    {std::string("P2SH"), (unsigned int)SCRIPT_VERIFY_P2SH},[m
[31m-    {std::string("STRICTENC"), (unsigned int)SCRIPT_VERIFY_STRICTENC},[m
[31m-    {std::string("DERSIG"), (unsigned int)SCRIPT_VERIFY_DERSIG},[m
[31m-    {std::string("LOW_S"), (unsigned int)SCRIPT_VERIFY_LOW_S},[m
[31m-    {std::string("SIGPUSHONLY"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY},[m
[31m-    {std::string("MINIMALDATA"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA},[m
[31m-    {std::string("NULLDUMMY"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},[m
[31m-    {std::string("DISCOURAGE_UPGRADABLE_NOPS"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS},[m
[31m-    {std::string("CLEANSTACK"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK},[m
[31m-    {std::string("MINIMALIF"), (unsigned int)SCRIPT_VERIFY_MINIMALIF},[m
[31m-    {std::string("NULLFAIL"), (unsigned int)SCRIPT_VERIFY_NULLFAIL},[m
[31m-    {std::string("CHECKLOCKTIMEVERIFY"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},[m
[31m-    {std::string("CHECKSEQUENCEVERIFY"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},[m
[31m-    {std::string("WITNESS"), (unsigned int)SCRIPT_VERIFY_WITNESS},[m
[31m-    {std::string("DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},[m
[31m-    {std::string("WITNESS_PUBKEYTYPE"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},[m
[31m-    {std::string("CONST_SCRIPTCODE"), (unsigned int)SCRIPT_VERIFY_CONST_SCRIPTCODE},[m
[31m-    {std::string("TAPROOT"), (unsigned int)SCRIPT_VERIFY_TAPROOT},[m
[31m-    {std::string("DISCOURAGE_UPGRADABLE_PUBKEYTYPE"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE},[m
[31m-    {std::string("DISCOURAGE_OP_SUCCESS"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS},[m
[31m-    {std::string("DISCOURAGE_UPGRADABLE_TAPROOT_VERSION"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION},[m
[31m-};[m
[31m-[m
[31m-unsigned int ParseScriptFlags(std::string strFlags)[m
[2m-{[m
[2m-    if (strFlags.empty() || strFlags == "NONE") return 0;[m
[2m-    unsigned int flags = 0;[m
[2m-    std::vector<std::string> words = SplitString(strFlags, ',');[m
[2m-[m
[31m-    for (const std::string& word : words)[m
[31m-    {[m
[31m-        if (!mapFlagNames.count(word))[m
[31m-            BOOST_ERROR("Bad test: unknown verification flag '" << word << "'");[m
[31m-        flags |= mapFlagNames[word];[m
[31m-    }[m
[31m-[m
[31m-    return flags;[m
[31m-}[m
[31m-[m
 // Check that all flags in STANDARD_SCRIPT_VERIFY_FLAGS are present in mapFlagNames.[m
 bool CheckMapFlagNames()[m
 {[m
     unsigned int standard_flags_missing{STANDARD_SCRIPT_VERIFY_FLAGS};[m
[2m-    for (const auto& pair : mapFlagNames) {[m
[32m+[m[32m    for (const auto& pair : MapFlagNames()) {[m
         standard_flags_missing &= ~(pair.second);[m
     }[m
     return standard_flags_missing == 0;[m
 }[m
 [m
[2m-std::string FormatScriptFlags(unsigned int flags)[m
[2m-{[m
[2m-    if (flags == 0) {[m
[2m-        return "";[m
[2m-    }[m
[2m-    std::string ret;[m
[31m-    std::map<std::string, unsigned int>::const_iterator it = mapFlagNames.begin();[m
[2m-    while (it != mapFlagNames.end()) {[m
[2m-        if (flags & it->second) {[m
[31m-            ret += it->first + ",";[m
[31m-        }[m
[31m-        it++;[m
[31m-    }[m
[2m-    return ret.substr(0, ret.size() - 1);[m
[2m-}[m
[2m-[m
 /*[m
 * Check that the input scripts of a transaction are valid/invalid as expected.[m
 */[m
[36m@@ -173,7 +119,7 @@[m [munsigned int FillFlags(unsigned int flags)[m
 std::set<unsigned int> ExcludeIndividualFlags(unsigned int flags)[m
 {[m
     std::set<unsigned int> flags_combos;[m
[2m-    for (const auto& pair : mapFlagNames) {[m
[32m+[m[32m    for (const auto& pair : MapFlagNames()) {[m
         const unsigned int flags_excluding_one = TrimFlags(flags & ~(pair.second));[m
         if (flags != flags_excluding_one) {[m
             flags_combos.insert(flags_excluding_one);[m
[36m@@ -239,32 +185,35 @@[m [mBOOST_AUTO_TEST_CASE(tx_valid)[m
             BOOST_CHECK(state.IsValid());[m
 [m
             PrecomputedTransactionData txdata(tx);[m
[31m-            unsigned int verify_flags = ParseScriptFlags(test[2].get_str());[m
[32m+[m[32m            auto flag_word = test[2].get_str();[m
[32m+[m[32m            auto verify_flags = ParseScriptFlags(flag_word);[m
[32m+[m[32m            if (!verify_flags) BOOST_ERROR("Bad test: unknown verification flag '" << flag_word << "'");[m
[32m+[m
 [m
             // Check that the test gives a valid combination of flags (otherwise VerifyScript will throw). Don't edit the flags.[m
[31m-            if (~verify_flags != FillFlags(~verify_flags)) {[m
[32m+[m[32m            if (~verify_flags.value() != FillFlags(~verify_flags.value())) {[m
                 BOOST_ERROR("Bad test flags: " << strTest);[m
             }[m
 [m
[31m-            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~verify_flags, txdata, strTest, /*expect_valid=*/true),[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~verify_flags.value(), txdata, strTest, /*expect_valid=*/true),[m
                                 "Tx unexpectedly failed: " << strTest);[m
 [m
             // Backwards compatibility of script verification flags: Removing any flag(s) should not invalidate a valid transaction[m
[31m-            for (const auto& [name, flag] : mapFlagNames) {[m
[32m+[m[32m            for (const auto& [name, flag] : MapFlagNames()) {[m
                 // Removing individual flags[m
[31m-                unsigned int flags = TrimFlags(~(verify_flags | flag));[m
[32m+[m[32m                unsigned int flags = TrimFlags(~(verify_flags.value() | flag));[m
                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/true)) {[m
                     BOOST_ERROR("Tx unexpectedly failed with flag " << name << " unset: " << strTest);[m
                 }[m
                 // Removing random combinations of flags[m
[31m-                flags = TrimFlags(~(verify_flags | (unsigned int)InsecureRandBits(mapFlagNames.size())));[m
[32m+[m[32m                flags = TrimFlags(~(verify_flags.value() | (unsigned int)InsecureRandBits(MapFlagNames().size())));[m
                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/true)) {[m
                     BOOST_ERROR("Tx unexpectedly failed with random flags " << ToString(flags) << ": " << strTest);[m
                 }[m
             }[m
 [m
             // Check that flags are maximal: transaction should fail if any unset flags are set.[m
[31m-            for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags)) {[m
[32m+[m[32m            for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags.value())) {[m
                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, ~flags_excluding_one, txdata, strTest, /*expect_valid=*/false)) {[m
                     BOOST_ERROR("Too many flags unset: " << strTest);[m
                 }[m
[36m@@ -329,33 +278,35 @@[m [mBOOST_AUTO_TEST_CASE(tx_invalid)[m
             }[m
 [m
             PrecomputedTransactionData txdata(tx);[m
[31m-            unsigned int verify_flags = ParseScriptFlags(test[2].get_str());[m
[32m+[m[32m            auto flag_word = test[2].get_str();[m
[32m+[m[32m            auto verify_flags = ParseScriptFlags(flag_word);[m
[32m+[m[32m            if (!verify_flags) BOOST_ERROR("Bad test: unknown verification flag '" << flag_word << "'");[m
 [m
             // Check that the test gives a valid combination of flags (otherwise VerifyScript will throw). Don't edit the flags.[m
[31m-            if (verify_flags != FillFlags(verify_flags)) {[m
[32m+[m[32m            if (verify_flags != FillFlags(verify_flags.value())) {[m
                 BOOST_ERROR("Bad test flags: " << strTest);[m
             }[m
 [m
             // Not using FillFlags() in the main test, in order to detect invalid verifyFlags combination[m
[31m-            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, verify_flags, txdata, strTest, /*expect_valid=*/false),[m
[32m+[m[32m            BOOST_CHECK_MESSAGE(CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, verify_flags.value(), txdata, strTest, /*expect_valid=*/false),[m
                                 "Tx unexpectedly passed: " << strTest);[m
 [m
             // Backwards compatibility of script verification flags: Adding any flag(s) should not validate an invalid transaction[m
[31m-            for (const auto& [name, flag] : mapFlagNames) {[m
[31m-                unsigned int flags = FillFlags(verify_flags | flag);[m
[32m+[m[32m            for (const auto& [name, flag] : MapFlagNames()) {[m
[32m+[m[32m                unsigned int flags = FillFlags(verify_flags.value() | flag);[m
                 // Adding individual flags[m
                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/false)) {[m
                     BOOST_ERROR("Tx unexpectedly passed with flag " << name << " set: " << strTest);[m
                 }[m
                 // Adding random combinations of flags[m
[31m-                flags = FillFlags(verify_flags | (unsigned int)InsecureRandBits(mapFlagNames.size()));[m
[32m+[m[32m                flags = FillFlags(verify_flags.value() | (unsigned int)InsecureRandBits(MapFlagNames().size()));[m
                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags, txdata, strTest, /*expect_valid=*/false)) {[m
                     BOOST_ERROR("Tx unexpectedly passed with random flags " << name << ": " << strTest);[m
                 }[m
             }[m
 [m
             // Check that flags are minimal: transaction should succeed if any set flags are unset.[m
[31m-            for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags)) {[m
[32m+[m[32m            for (auto flags_excluding_one : ExcludeIndividualFlags(verify_flags.value())) {[m
                 if (!CheckTxScripts(tx, mapprevOutScriptPubKeys, mapprevOutValues, flags_excluding_one, txdata, strTest, /*expect_valid=*/true)) {[m
                     BOOST_ERROR("Too many flags set: " << strTest);[m
                 }[m
[33mdiff --git a/src/test/util/boost_test_boosts.h b/src/test/util/boost_test_boosts.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..cba9a7a842[m
[33m--- /dev/null[m
[33m+++ b/src/test/util/boost_test_boosts.h[m
[36m@@ -0,0 +1,93 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_TEST_UTIL_BOOST_TEST_BOOSTS_H[m
[32m+[m[32m#define BITCOIN_TEST_UTIL_BOOST_TEST_BOOSTS_H[m
[32m+[m
[32m+[m[32m// This file contain macros and other constructs that "boost" the Boost Test[m
[32m+[m[32m// Framework - additional capabilities, or existing capabilities made more[m
[32m+[m[32m// usable with wrappers[m
[32m+[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m// Test that an `assert` was triggered[m
[32m+[m[32m////////////////////////////////////////////////////////////////////////////////[m
[32m+[m[32m//[m
[32m+[m[32m// The following macro provides "death" tests: The test succeeds iff it causes[m
[32m+[m[32m// a crash.  (The name comes from the popular Googletest unit test framework.)[m
[32m+[m[32m//[m
[32m+[m[32m// These tests use the Boost Test `execution_monitor` facility to trap signals,[m
[32m+[m[32m// specifically: SIGABRT (which is raised by the `assert` statement - iff Linux!).[m
[32m+[m[32m// The execution monitor will trap signals and reflect them as exceptions.  (So[m
[32m+[m[32m// these aren't really "full" death tests à la Googletest as it is not trapping[m
[32m+[m[32m// hard faults like calling through a null pointer.  But we don't actually need[m
[32m+[m[32m// that so it's fine.)[m
[32m+[m[32m//[m
[32m+[m[32m// `assert` statement signals SIGABRT - the macro `BOOST_CHECK_SIGABRT` succeeds[m
[32m+[m[32m// iff that SIGABRT is raised. (Could be a false positive if code signals SIGABRT[m
[32m+[m[32m// for _some other reason than calling `assert`; also if some _other_[m
[32m+[m[32m// `system_error` is caused ...)) (There doesn't appear to be any way to check[m
[32m+[m[32m// the actual `assert` message to distinguish between different asserts, and the[m
[32m+[m[32m// line number field of the exception is not set either.)[m
[32m+[m[32m//[m
[32m+[m[32m// Each successful call of the macro will cause a message to be logged, along the[m
[32m+[m[32m// lines of "... Assertion ... failed."  This is _expected_ - the message is[m
[32m+[m[32m// emitted by `assertion_fail()` (`src/util/check.{h,cpp}`). The test _succeeds_[m
[32m+[m[32m// iff the assert is triggered (and thus prints that message, in failing).[m
[32m+[m[32m//[m
[32m+[m[32m// N.B.: These tests are _only_ run if the OS is _not_ Windows _and_ the Thread[m
[32m+[m[32m// Sanitizer is _not_ being used.  So protect all such death tests by checking[m
[32m+[m[32m// that `OK_TO_TEST_ASSERT_FUNCTION` is defined:[m
[32m+[m[32m//[m
[32m+[m[32m//     ```[m
[32m+[m[32m//     #if defined(OK_TO_TEST_ASSERT_FUNCITON)[m
[32m+[m[32m//     BOOST_AUTO_TEST_CASE(ensure_method_foo_triggers_assert)[m
[32m+[m[32m//     { ... }[m
[32m+[m[32m//     #endif[m
[32m+[m[32m//     ```[m
[32m+[m[32m//[m
[32m+[m[32m//     N.B.: Apparently doesn't work with MSVC or MINGW.  Looking at Boost's[m
[32m+[m[32m//     `execution_monitor.ipp` it seems like it _should_ work: the code there[m
[32m+[m[32m//     seems to take the structured exception from the `assert` and change it to[m
[32m+[m[32m//     a `boost::execution_exception`.  But, no, apparently it doesn't: the[m
[32m+[m[32m//     Bitcoin repository CI pipeline for `win64 [unit tests, no gui tests,[m
[32m+[m[32m//     no boost::process, no functional tests]` prints the assert and then[m
[32m+[m[32m//     aborts.  Also `win64 [native]`.[m
[32m+[m[32m//[m
[32m+[m[32m//     N.B.: Doesn't work with the ThreadSanitizer, which doesn't like an unsafe[m
[32m+[m[32m//     call inside of the Boost Test signal handler.[m
[32m+[m
[32m+[m[32m#define BOOST_CHECK_SIGABRT(expr)                                                  \[m
[32m+[m[32m    {                                                                              \[m
[32m+[m[32m        ::boost::execution_monitor exmon;                                          \[m
[32m+[m[32m        BOOST_TEST_MESSAGE("!!! This is a 'death test': It is expected that "      \[m
[32m+[m[32m                           "'Assertion ... failed' message will follow .. and if " \[m
[32m+[m[32m                           "it does the test will _succeed_");                     \[m
[32m+[m[32m        BOOST_CHECK_EXCEPTION(                                                     \[m
[32m+[m[32m            exmon.vexecute([&]() { (void)(expr); }),                               \[m
[32m+[m[32m            boost::execution_exception,                                            \[m
[32m+[m[32m            [](boost::execution_exception const& ex) {                             \[m
[32m+[m[32m                return ex.code() == boost::execution_exception::system_error;      \[m
[32m+[m[32m            });                                                                    \[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m// Tests that check whether an `assert` function is hit can only run when _not_[m
[32m+[m[32m// under Windows _and not_ under the Thread Sanitizer.[m
[32m+[m[32m#if defined(__has_feature)[m
[32m+[m[32m#if __has_feature(thread_sanitizer)[m
[32m+[m[32m#define THREAD_SANITIZER_IN_PLAY 1[m
[32m+[m[32m#endif[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined(_MSC_VER) || defined(__MINGW32__)[m
[32m+[m[32m#define OS_IS_WINDOWS 1[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if !defined(THREAD_SANITIZER_IN_PLAY) && !defined(OS_IS_WINDOWS)[m
[32m+[m[32m#define OK_TO_TEST_ASSERT_FUNCTION 1[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#undef THREAD_SANITIZER_IN_PLAY[m
[32m+[m[32m#undef OS_IS_WINDOWS[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_TEST_UTIL_BOOST_TEST_BOOSTS_H[m
[33mdiff --git a/src/test/util/pretty_data.cpp b/src/test/util/pretty_data.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..a220b8fd4a[m
[33m--- /dev/null[m
[33m+++ b/src/test/util/pretty_data.cpp[m
[36m@@ -0,0 +1,174 @@[m
[32m+[m[32m// Copyright (c) 2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <policy/policy.h>[m
[32m+[m[32m#include <script/interpreter.h>[m
[32m+[m[32m#include <test/util/pretty_data.h>[m
[32m+[m[32m#include <util/string.h>[m
[32m+[m
[32m+[m[32m#include <map>[m
[32m+[m[32m#include <optional>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <string_view>[m
[32m+[m
[32m+[m[32musing namespace std::string_view_literals;[m
[32m+[m
[32m+[m[32mnamespace {[m
[32m+[m
[32m+[m[32mconst std::map<std::string_view, unsigned int> mapFlagNames = {[m
[32m+[m[32m    {"P2SH"sv, (unsigned int)SCRIPT_VERIFY_P2SH},[m
[32m+[m[32m    {"STRICTENC"sv, (unsigned int)SCRIPT_VERIFY_STRICTENC},[m
[32m+[m[32m    {"DERSIG"sv, (unsigned int)SCRIPT_VERIFY_DERSIG},[m
[32m+[m[32m    {"LOW_S"sv, (unsigned int)SCRIPT_VERIFY_LOW_S},[m
[32m+[m[32m    {"SIGPUSHONLY"sv, (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY},[m
[32m+[m[32m    {"MINIMALDATA"sv, (unsigned int)SCRIPT_VERIFY_MINIMALDATA},[m
[32m+[m[32m    {"NULLDUMMY"sv, (unsigned int)SCRIPT_VERIFY_NULLDUMMY},[m
[32m+[m[32m    {"DISCOURAGE_UPGRADABLE_NOPS"sv, (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS},[m
[32m+[m[32m    {"CLEANSTACK"sv, (unsigned int)SCRIPT_VERIFY_CLEANSTACK},[m
[32m+[m[32m    {"MINIMALIF"sv, (unsigned int)SCRIPT_VERIFY_MINIMALIF},[m
[32m+[m[32m    {"NULLFAIL"sv, (unsigned int)SCRIPT_VERIFY_NULLFAIL},[m
[32m+[m[32m    {"CHECKLOCKTIMEVERIFY"sv, (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},[m
[32m+[m[32m    {"CHECKSEQUENCEVERIFY"sv, (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},[m
[32m+[m[32m    {"WITNESS"sv, (unsigned int)SCRIPT_VERIFY_WITNESS},[m
[32m+[m[32m    {"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"sv, (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},[m
[32m+[m[32m    {"WITNESS_PUBKEYTYPE"sv, (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},[m
[32m+[m[32m    {"CONST_SCRIPTCODE"sv, (unsigned int)SCRIPT_VERIFY_CONST_SCRIPTCODE},[m
[32m+[m[32m    {"TAPROOT"sv, (unsigned int)SCRIPT_VERIFY_TAPROOT},[m
[32m+[m[32m    {"DISCOURAGE_UPGRADABLE_PUBKEYTYPE"sv, (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE},[m
[32m+[m[32m    {"DISCOURAGE_OP_SUCCESS"sv, (unsigned int)SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS},[m
[32m+[m[32m    {"DISCOURAGE_UPGRADABLE_TAPROOT_VERSION"sv, (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION},[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Check that all flags in STANDARD_SCRIPT_VERIFY_FLAGS are present in mapFlagNames[m
[32m+[m[32m[[maybe_unused]] auto DoValidateMapFlagNames = []() {[m
[32m+[m[32m    unsigned int standard_flags_missing{STANDARD_SCRIPT_VERIFY_FLAGS};[m
[2m+[m[2m    for (const auto& pair : mapFlagNames) {[m
[32m+[m[32m        standard_flags_missing &= ~(pair.second);[m
[32m+[m[32m    }[m
[32m+[m[32m    assert(!standard_flags_missing && "array `mapFlagNames` is missing a script verification flag");[m
[32m+[m[32m    return true;[m
[32m+[m[32m}();[m
[32m+[m
[32m+[m[32mstruct ScriptErrorDesc {[m
[32m+[m[32m    ScriptError_t err;[m
[32m+[m[32m    const std::string_view name;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mconst ScriptErrorDesc script_errors[] = {[m
[32m+[m[32m    {SCRIPT_ERR_OK, "OK"sv},[m
[32m+[m[32m    {SCRIPT_ERR_UNKNOWN_ERROR, "UNKNOWN_ERROR"sv},[m
[32m+[m[32m    {SCRIPT_ERR_EVAL_FALSE, "EVAL_FALSE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_OP_RETURN, "OP_RETURN"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SCRIPT_SIZE, "SCRIPT_SIZE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_PUSH_SIZE, "PUSH_SIZE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_OP_COUNT, "OP_COUNT"sv},[m
[32m+[m[32m    {SCRIPT_ERR_STACK_SIZE, "STACK_SIZE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_COUNT, "SIG_COUNT"sv},[m
[32m+[m[32m    {SCRIPT_ERR_PUBKEY_COUNT, "PUBKEY_COUNT"sv},[m
[32m+[m[32m    {SCRIPT_ERR_VERIFY, "VERIFY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_EQUALVERIFY, "EQUALVERIFY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_CHECKSIGVERIFY, "CHECKSIGVERIFY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_NUMEQUALVERIFY, "NUMEQUALVERIFY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_BAD_OPCODE, "BAD_OPCODE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_DISABLED_OPCODE, "DISABLED_OPCODE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_INVALID_STACK_OPERATION, "INVALID_STACK_OPERATION"sv},[m
[32m+[m[32m    {SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "INVALID_ALTSTACK_OPERATION"sv},[m
[32m+[m[32m    {SCRIPT_ERR_UNBALANCED_CONDITIONAL, "UNBALANCED_CONDITIONAL"sv},[m
[32m+[m[32m    {SCRIPT_ERR_NEGATIVE_LOCKTIME, "NEGATIVE_LOCKTIME"sv},[m
[32m+[m[32m    {SCRIPT_ERR_UNSATISFIED_LOCKTIME, "UNSATISFIED_LOCKTIME"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_HASHTYPE, "SIG_HASHTYPE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_DER, "SIG_DER"sv},[m
[32m+[m[32m    {SCRIPT_ERR_MINIMALDATA, "MINIMALDATA"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_PUSHONLY, "SIG_PUSHONLY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_HIGH_S, "SIG_HIGH_S"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_NULLDUMMY, "SIG_NULLDUMMY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_PUBKEYTYPE, "PUBKEYTYPE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_CLEANSTACK, "CLEANSTACK"sv},[m
[32m+[m[32m    {SCRIPT_ERR_MINIMALIF, "MINIMALIF"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_NULLFAIL, "NULLFAIL"sv},[m
[32m+[m[32m    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "DISCOURAGE_UPGRADABLE_NOPS"sv},[m
[32m+[m[32m    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, "DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH, "WITNESS_PROGRAM_WRONG_LENGTH"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY, "WITNESS_PROGRAM_WITNESS_EMPTY"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH, "WITNESS_PROGRAM_MISMATCH"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_MALLEATED, "WITNESS_MALLEATED"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_MALLEATED_P2SH, "WITNESS_MALLEATED_P2SH"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_UNEXPECTED, "WITNESS_UNEXPECTED"sv},[m
[32m+[m[32m    {SCRIPT_ERR_WITNESS_PUBKEYTYPE, "WITNESS_PUBKEYTYPE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_OP_CODESEPARATOR, "OP_CODESEPARATOR"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SIG_FINDANDDELETE, "SIG_FINDANDDELETE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_DISCOURAGE_OP_SUCCESS, "DISCOURAGE_OP_SUCCESS"sv},[m
[32m+[m[32m    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE, "DISCOURAGE_UPGRADABLE_PUBKEYTYPE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION, "DISCOURAGE_UPGRADABLE_TAPROOT_VERSION"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SCHNORR_SIG, "SCHNORR_SIG"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SCHNORR_SIG_HASHTYPE, "SCHNORR_SIG_HASHTYPE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_SCHNORR_SIG_SIZE, "SCHNORR_SIG_SIZE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE, "TAPROOT_WRONG_CONTROL_SIZE"sv},[m
[32m+[m[32m    {SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG, "TAPSCRIPT_CHECKMULTISIG"sv},[m
[32m+[m[32m    {SCRIPT_ERR_TAPSCRIPT_MINIMALIF, "TAPSCRIPT_MINIMALIF"sv},[m
[32m+[m[32m    {SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT, "TAPSCRIPT_VALIDATION_WEIGHT"sv},[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m// Check that all ERROR CODES in ScriptError_t are present in script_errors array[m
[32m+[m[32m[[maybe_unused]] auto DoValidateScriptErrorCount = []() {[m
[32m+[m[32m    assert(SCRIPT_ERR_ERROR_COUNT == std::size(script_errors));[m
[32m+[m[32m    return true;[m
[32m+[m[32m}();[m
[32m+[m
[32m+[m[32m} // namespace[m
[32m+[m
[32m+[m[32mconst std::map<std::string_view, unsigned int>& MapFlagNames()[m
[32m+[m[32m{[m
[32m+[m[32m    return mapFlagNames;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstd::optional<unsigned int> ParseScriptFlags(std::string_view strFlags)[m
[2m+[m[2m{[m
[2m+[m[2m    if (strFlags.empty() || strFlags == "NONE") return 0;[m
[2m+[m[2m    unsigned int flags = 0;[m
[2m+[m[2m    std::vector<std::string> words = SplitString(strFlags, ',');[m
[1;36m+[m
[1;33m+[m[1;33m    for (const std::string& word : words) {[m
[32m+[m[32m        if (auto r = mapFlagNames.find(word); r != mapFlagNames.end()) {[m
[32m+[m[32m            flags |= r->second;[m
[32m+[m[32m        } else return {};[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return flags;[m
[32m+[m[32m}[m
[32m+[m
[2m+[m[2mstd::string FormatScriptFlags(unsigned int flags)[m
[2m+[m[2m{[m
[2m+[m[2m    if (flags == 0) {[m
[2m+[m[2m        return "";[m
[2m+[m[2m    }[m
[2m+[m[2m    std::string ret;[m
[32m+[m[32m    decltype(mapFlagNames)::const_iterator it = mapFlagNames.begin();[m
[2m+[m[2m    while (it != mapFlagNames.end()) {[m
[2m+[m[2m        if (flags & it->second) {[m
[32m+[m[32m            ret += it->first;[m
[32m+[m[32m            ret += ",";[m
[32m+[m[32m        }[m
[32m+[m[32m        it++;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (ret.empty()) return "";[m
[2m+[m[2m    return ret.substr(0, ret.size() - 1);[m
[2m+[m[2m}[m
[2m+[m
[32m+[m[32mstd::optional<std::string> FormatScriptError(ScriptError_t err)[m
[2m+[m[2m{[m
[2m+[m[2m    for (const auto& se : script_errors)[m
[2m+[m[2m        if (se.err == err)[m
[32m+[m[32m            return std::string(se.name);[m
[32m+[m[32m    return {};[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstd::optional<ScriptError_t> ParseScriptError(std::string_view name)[m
[2m+[m[2m{[m
[2m+[m[2m    for (const auto& se : script_errors)[m
[2m+[m[2m        if (se.name == name)[m
[2m+[m[2m            return se.err;[m
[32m+[m[32m    return {};[m
[32m+[m[32m}[m
[33mdiff --git a/src/test/util/pretty_data.h b/src/test/util/pretty_data.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..06d3dcd008[m
[33m--- /dev/null[m
[33m+++ b/src/test/util/pretty_data.h[m
[36m@@ -0,0 +1,204 @@[m
[32m+[m[32m// Copyright (c) 2011-2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_TEST_UTIL_PRETTY_DATA_H[m
[32m+[m[32m#define BITCOIN_TEST_UTIL_PRETTY_DATA_H[m
[32m+[m
[32m+[m[32m#include <script/script_error.h>[m
[32m+[m[32m#include <span.h>[m
[32m+[m[32m#include <test/util/traits.h>[m
[32m+[m[32m#include <uint256.h>[m
[32m+[m[32m#include <util/strencodings.h>[m
[32m+[m
[32m+[m[32m#include <array>[m
[32m+[m[32m#include <charconv>[m
[32m+[m[32m#include <iomanip>[m
[32m+[m[32m#include <map>[m
[32m+[m[32m#include <optional>[m
[32m+[m[32m#include <ostream>[m
[32m+[m[32m#include <set>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <string_view>[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Integer type to string (without locale issues)[m
[32m+[m[32m *[m
[32m+[m[32m * (This seems rather elaborate to avoid locale issues with `std::to_string`.[m
[32m+[m[32m * One can't help but think the C++ committee could have provided a nicer[m
[32m+[m[32m * wrapper for it.)[m
[32m+[m[32m *[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename I>[m
[32m+[m[32mstd::string as_string(I i, int base = 10)[m
[32m+[m[32m{[m
[32m+[m[32m    std::array<char, 24> a{0};[m
[32m+[m[32m    if (const auto [ptr, ec] = std::to_chars(a.data(), a.data() + a.size(), i);[m
[32m+[m[32m        ec == std::errc()) {[m
[32m+[m[32m        return {a.data(), static_cast<std::string::size_type>(ptr - a.data())};[m
[32m+[m[32m    }[m
[32m+[m[32m    return {}; // EOVERFLOW - should never happen as buffer `a` is large enough[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Outputs to a stream as hex - this unspecialized primary template doesn't[m
[32m+[m[32m * implement `operator<<` - it must be specialized for suitable types.[m
[32m+[m[32m *[m
[32m+[m[32m * Convert something to a hex string in a context suitable for output to a stream[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename US, typename Enable = void>[m
[32m+[m[32mstruct Hex {[m
[32m+[m[32m    explicit Hex(US v) {}[m
[32m+[m[32m}; // primary template - but invalid[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Outputs to stream as hex - suitable for any integral type[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename US>[m
[32m+[m[32mstruct Hex<US, typename std::enable_if_t<std::is_integral_v<US>>> {[m
[32m+[m[32m    explicit Hex(US v) : m_value(v) {}[m
[32m+[m
[32m+[m[32m    // Unfortunately, `<<` operators for streams have overloads for `char`,[m
[32m+[m[32m    // `signed char`, and `unsigned char` that output as _characters_ not integers.[m
[32m+[m[32m    // Must force a widening for those types.[m
[32m+[m[32m    using USBase = std::conditional_t<std::is_same_v<char, US>, int,[m
[32m+[m[32m                                      std::conditional_t<std::is_same_v<signed char, US>, int,[m
[32m+[m[32m                                                         std::conditional_t<std::is_same_v<unsigned char, US>, unsigned int, US>>>;[m
[32m+[m
[32m+[m[32m    const USBase m_value;[m
[32m+[m
[32m+[m[32m    friend std::ostream& operator<<(std::ostream& os, Hex hex)[m
[32m+[m[32m    {[m
[32m+[m[32m        auto flags = os.flags();[m
[32m+[m[32m        os << std::setw(2 + 2 * sizeof(US)) << std::setfill('0')[m
[32m+[m[32m           << std::hex << std::showbase << std::nouppercase << std::internal[m
[32m+[m[32m           << hex.m_value;[m
[32m+[m[32m        os.flags(flags);[m
[32m+[m[32m        return os;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Outputs to stream as hex - suitable for any `base_blob<>` type, e.g., `uint256`[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename BLOB>[m
[32m+[m[32mstruct Hex<BLOB, typename std::enable_if_t<traits::is_base_of_template_of_uint_v<base_blob, BLOB>>> {[m
[32m+[m[32m    explicit Hex(const BLOB v) : m_value(v) {}[m
[32m+[m[32m    const BLOB m_value;[m
[32m+[m
[32m+[m[32m    friend std::ostream& operator<<(std::ostream& os, Hex hex)[m
[32m+[m[32m    {[m
[32m+[m[32m        os << "0x" << hex.m_value.GetHex();[m
[32m+[m[32m        return os;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Outputs to stream as hex - suitable for any `Span` with an overload of `HexStr`[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <>[m
[32m+[m[32mstruct Hex<Span<unsigned char>, void> {[m
[32m+[m[32m    explicit Hex(const Span<unsigned char> v) : m_value(v) {}[m
[32m+[m[32m    const Span<const unsigned char> m_value;[m
[32m+[m
[32m+[m[32m    friend std::ostream& operator<<(std::ostream& os, Hex hex)[m
[32m+[m[32m    {[m
[32m+[m[32m        os << "0x" << HexStr(hex.m_value);[m
[32m+[m[32m        return os;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Conversion to hex string for any "container" supporting `begin()` and `end()`[m
[32m+[m[32m *[m
[32m+[m[32m * (Another overload for functions defined in `src/util/strencodings.h`)[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename C, typename = traits::ok_for_range_based_for<C>>[m
[32m+[m[32mstd::string HexStr(C container)[m
[32m+[m[32m{[m
[32m+[m[32m    constexpr auto to_hexit = [](unsigned char c) -> char {[m
[32m+[m[32m        return "0123456789abcdef"[c];[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    std::string r;[m
[32m+[m[32m    r.reserve(container.size() * 2);[m
[32m+[m[32m    for (unsigned char c : container) {[m
[32m+[m[32m        r.push_back(to_hexit(c >> 4 & 0x0F));[m
[32m+[m[32m        r.push_back(to_hexit(c & 0x0F));[m
[32m+[m[32m    }[m
[32m+[m[32m    return r;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Return a map from script verification flag name to its binary value (word with[m
[32m+[m[32m * single bit set).[m
[32m+[m[32m *[m
[32m+[m[32m * The names are the enum name with the prefix `SCRIPT_VERIFY_` removed.[m
[32m+[m[32m */[m
[32m+[m[32mconst std::map<std::string_view, unsigned int>& MapFlagNames();[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Given a comma-separated string of script verification flags (from[m
[32m+[m[32m * `script/interpreter.h`) return the flag word (word with the flag bits set)[m
[32m+[m[32m */[m
[32m+[m[32mstd::optional<unsigned int> ParseScriptFlags(std::string_view strFlags);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Given a flag word (word with script verification flag bits set) return[m
[32m+[m[32m * a comma-separated string of the flags by name.[m
[32m+[m[32m */[m
[2m+[m[2mstd::string FormatScriptFlags(unsigned int flags);[m
[2m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Given the name of script err return the error value.[m
[32m+[m[32m *[m
[32m+[m[32m * The name is the enum name with the prefix `SCRIPT_ERR_` removed.[m
[32m+[m[32m */[m
[32m+[m[32mstd::optional<ScriptError_t> ParseScriptError(std::string_view err);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Given a script error value return its string name.[m
[32m+[m[32m *[m
[32m+[m[32m * The name is the enum name with the prefix `SCRIPT_ERR_` removed.  Note[m
[32m+[m[32m * that this is different from `ScriptErrorString` (`script_error.h`) which[m
[32m+[m[32m * returns an English phrase describing the error.[m
[32m+[m[32m */[m
[32m+[m[32mstd::optional<std::string> FormatScriptError(ScriptError_t err);[m
[32m+[m
[32m+[m[32mnamespace test::util::literals {[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * User-defined literal for converting script verify flag name to flag word.[m
[32m+[m[32m */[m
[32m+[m[32minline unsigned int operator"" _svf(const char* s, size_t len)[m
[32m+[m[32m{[m
[32m+[m[32m    std::string_view sv{s, len};[m
[32m+[m[32m    if (auto r = MapFlagNames().find(sv); r != MapFlagNames().end()) return r->second;[m
[32m+[m[32m    throw std::invalid_argument("invalid script verify flag name");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * User-defined literal for converting hex strings to byte vectors.[m
[32m+[m[32m */[m
[32m+[m[32minline std::vector<unsigned char> operator"" _hex(const char* s, size_t len)[m
[32m+[m[32m{[m
[32m+[m[32m    std::string_view sv{s, len};[m
[32m+[m[32m    if (IsHex(sv)) return ParseHex(sv);[m
[32m+[m[32m    throw std::invalid_argument("invalid hex literal");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Literal format for a `vector<unsigned char>` initialized from a string literal.[m
[32m+[m[32m *[m
[32m+[m[32m * Characters in the string are used _directly_, not interpreted as hex.[m
[32m+[m[32m */[m
[32m+[m[32minline std::vector<unsigned char> operator"" _bv(const char* s, size_t len)[m
[32m+[m[32m{[m
[32m+[m[32m    std::string_view sv{s, len};[m
[32m+[m[32m    std::vector<unsigned char> r(sv.begin(), sv.end());[m
[32m+[m[32m    return r;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m} // namespace test::util::literals[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_TEST_UTIL_PRETTY_DATA_H[m
[33mdiff --git a/src/test/util/traits.h b/src/test/util/traits.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..b5c44a6f88[m
[33m--- /dev/null[m
[33m+++ b/src/test/util/traits.h[m
[36m@@ -0,0 +1,95 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_TEST_UTIL_TRAITS_H[m
[32m+[m[32m#define BITCOIN_TEST_UTIL_TRAITS_H[m
[32m+[m
[32m+[m[32m#include <type_traits>[m
[32m+[m
[32m+[m[32mnamespace traits {[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Determine if a class is a derived class of a template.  This is a specific[m
[32m+[m[32m * trait where the base template class has one type parameter: an unsigned int.[m
[32m+[m[32m * (This fits the case of `base_blob<>`, used for `uint256`);[m
[32m+[m[32m *[m
[32m+[m[32m * This metaprogramming magic adapted from excellent answer here:[m
[32m+[m[32m * https://stackoverflow.com/a/34672753/751579[m
[32m+[m[32m * Adapted by making it applicable to a base template class with one non-type[m
[32m+[m[32m * parameter.[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <template <unsigned int> typename base, typename derived>[m
[32m+[m[32mstruct is_base_of_template_of_uint {[m
[32m+[m[32m    template <unsigned int UI>[m
[32m+[m[32m    static constexpr std::true_type test(const base<UI>*);[m
[32m+[m[32m    static constexpr std::false_type test(...);[m
[32m+[m[32m    using type = decltype(test(std::declval<derived*>()));[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mtemplate <template <unsigned int> typename base, typename derived>[m
[32m+[m[32musing is_base_of_template_of_uint_t = typename is_base_of_template_of_uint<base, derived>::type;[m
[32m+[m
[32m+[m[32mtemplate <template <unsigned int> typename base, typename derived>[m
[32m+[m[32minline constexpr bool is_base_of_template_of_uint_v = is_base_of_template_of_uint<base, derived>::type::value;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Trait `is_detected` from `std::experimental` for "library fundamentals TS v2"[m
[32m+[m[32m * See https://en.cppreference.com/w/cpp/experimental/is_detected for specification[m
[32m+[m[32m * and sample implementation, also https://stackoverflow.com/a/41936999/751579[m
[32m+[m[32m *[m
[32m+[m[32m * Namespace `detail_detected` consists of helpers for `is_detected`.[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mnamespace detail_detected {[m
[32m+[m
[32m+[m[32mtemplate <class Default, class AlwaysVoid,[m
[32m+[m[32m          template <class...> class Op, class... Args>[m
[32m+[m[32mstruct detector {[m
[32m+[m[32m    using value_t = std::false_type;[m
[32m+[m[32m    using type = Default;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mtemplate <class Default, template <class...> class Op, class... Args>[m
[32m+[m[32mstruct detector<Default, std::void_t<Op<Args...>>, Op, Args...> {[m
[32m+[m[32m    using value_t = std::true_type;[m
[32m+[m[32m    using type = Op<Args...>;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct nonesuch {[m
[32m+[m[32m    nonesuch() = delete;[m
[32m+[m[32m    ~nonesuch() = delete;[m
[32m+[m[32m    nonesuch(nonesuch const&) = delete;[m
[32m+[m[32m    void operator=(nonesuch const&) = delete;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m} // namespace detail_detected[m
[32m+[m
[32m+[m[32mtemplate <template <class...> class Op, class... Args>[m
[32m+[m[32musing is_detected = typename detail_detected::detector<detail_detected::nonesuch, void, Op, Args...>::value_t;[m
[32m+[m
[32m+[m[32mtemplate <template <class...> class Op, class... Args>[m
[32m+[m[32mconstexpr bool is_detected_v = is_detected<Op, Args...>::value;[m
[32m+[m
[32m+[m[32m// And here we have trait predicates that look for `begin()` and `end()`[m
[32m+[m[32mtemplate <class T>[m
[32m+[m[32musing requires_has_begin = decltype(std::declval<T&>().begin());[m
[32m+[m[32mtemplate <class T>[m
[32m+[m[32musing requires_has_end = decltype(std::declval<T&>().end());[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Trait (approximate) for a type that supports `begin()` and `end()[m
[32m+[m[32m *[m
[32m+[m[32m * (Approximate because it doesn't check return types are valid among other[m
[32m+[m[32m * flaws, e.g., not checking that theres a `begin(C)` or `end(C)` that can be[m
[32m+[m[32m * found via ADL.  But it's sufficient for our purposes here.  Anyway, will be[m
[32m+[m[32m * obsolete with C++20 and ranges.)[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <class C>[m
[32m+[m[32musing ok_for_range_based_for =[m
[32m+[m[32m    std::enable_if_t<std::conjunction_v<is_detected<requires_has_begin, C>,[m
[32m+[m[32m                                        is_detected<requires_has_end, C>>>;[m
[32m+[m
[32m+[m[32m} // namespace traits[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_TEST_UTIL_TRAITS_H[m
[33mdiff --git a/src/test/util/vector.h b/src/test/util/vector.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..f97d9a173a[m
[33m--- /dev/null[m
[33m+++ b/src/test/util/vector.h[m
[36m@@ -0,0 +1,87 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_TEST_UTIL_VECTOR_H[m
[32m+[m[32m#define BITCOIN_TEST_UTIL_VECTOR_H[m
[32m+[m
[32m+[m[32m#include <test/util/traits.h>[m
[32m+[m[32m#include <uint256.h>[m
[32m+[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32m#include <string_view>[m
[32m+[m[32m#include <tuple>[m
[32m+[m[32m#include <type_traits>[m
[32m+[m[32m#include <utility>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * A `std::vector` with a few extra operations to make it nice for unit tests,[m
[32m+[m[32m * especially of byte vectors (`vector<unsigned char>`).[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename E>[m
[32m+[m[32mstruct ex_vector : public std::vector<E> {[m
[32m+[m[32m    using std::vector<E>::vector;[m
[32m+[m[32m    using std::vector<E>::operator[];[m
[32m+[m
[32m+[m[32m    explicit ex_vector(const std::vector<E>& other) : std::vector<E>(other)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    explicit ex_vector(std::vector<E>&& other) : std::vector<E>(std::move(other))[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Return half-open subrange from byte vector, use notation `v[{i,j}]` for[m
[32m+[m[32m     * the subrange `[i,j)`.  N.B.: `first`, `one-past-last`, _NOT_ `first` + `length`.[m
[32m+[m[32m     *[m
[32m+[m[32m     * (Not sure why `operator[]` overloads must be a member function, but that's[m
[32m+[m[32m     * the way it is.))[m
[32m+[m[32m     */[m
[32m+[m[32m    ex_vector operator[](std::tuple<size_t, size_t> range) const[m
[32m+[m[32m    {[m
[32m+[m[32m        auto [i, j] = range;[m
[32m+[m[32m        assert(i <= j && j <= this->size());[m
[32m+[m[32m        ex_vector r(j - i, 0);[m
[32m+[m[32m        std::copy(this->begin() + i, this->begin() + j, r.begin());[m
[32m+[m[32m        return r;[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Make an `ex_vector` from a `uint160` or `uint256`[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <unsigned int BITS>[m
[32m+[m[32mex_vector<unsigned char> from_base_blob(const base_blob<BITS>& bb)[m
[32m+[m[32m{[m
[32m+[m[32m    return ex_vector<unsigned char>(bb.begin(), bb.end());[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mnamespace test::util::vector_ops {[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Convert a `std::vector` into an `ex_vector` via unary `+`[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename E>[m
[32m+[m[32mex_vector<E> operator+(const std::vector<E>& v)[m
[32m+[m[32m{[m
[32m+[m[32m    return ex_vector<E>(v);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Concatenate two vectors (producing an `ex_vector` for further operations)[m
[32m+[m[32m */[m
[32m+[m[32mtemplate <typename E>[m
[32m+[m[32mex_vector<E> operator||(const std::vector<E>& lhs, const std::vector<E>& rhs)[m
[32m+[m[32m{[m
[32m+[m[32m    ex_vector<E> r;[m
[32m+[m[32m    r.resize(lhs.size() + rhs.size());[m
[32m+[m[32m    std::copy(lhs.begin(), lhs.end(), r.begin());[m
[32m+[m[32m    std::copy(rhs.begin(), rhs.end(), r.begin() + lhs.size());[m
[32m+[m[32m    return r;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m} // namespace test::util::vector_ops[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_TEST_UTIL_VECTOR_H[m
[33mdiff --git a/test/lint/lint-includes.py b/test/lint/lint-includes.py[m
[33mindex ae62994642..e3f78f3512 100755[m
[33m--- a/test/lint/lint-includes.py[m
[33m+++ b/test/lint/lint-includes.py[m
[36m@@ -31,6 +31,7 @@[m [mEXPECTED_BOOST_INCLUDES = ["boost/algorithm/string/replace.hpp",[m
                            "boost/signals2/connection.hpp",[m
                            "boost/signals2/optional_last_value.hpp",[m
                            "boost/signals2/signal.hpp",[m
[32m+[m[32m                           "boost/test/execution_monitor.hpp",[m
                            "boost/test/included/unit_test.hpp",[m
                            "boost/test/unit_test.hpp"][m
 [m