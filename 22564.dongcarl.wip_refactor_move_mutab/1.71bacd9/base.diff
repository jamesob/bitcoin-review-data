[33mdiff --git a/src/bench/rpc_blockchain.cpp b/src/bench/rpc_blockchain.cpp[m
[33mindex c8886a4c23..49abdeee73 100644[m
[33m--- a/src/bench/rpc_blockchain.cpp[m
[33m+++ b/src/bench/rpc_blockchain.cpp[m
[36m@@ -40,7 +40,7 @@[m [mstatic void BlockToJsonVerbose(benchmark::Bench& bench)[m
 {[m
     TestBlockAndIndex data;[m
     bench.run([&] {[m
[31m-        auto univalue = blockToJSON(data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);[m
[32m+[m[32m        auto univalue = blockToJSON(WITH_LOCK(::cs_main, return std::ref(data.testing_setup->m_node.chainman->m_blockman)), data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);[m
         ankerl::nanobench::doNotOptimizeAway(univalue);[m
     });[m
 }[m
[36m@@ -50,7 +50,7 @@[m [mBENCHMARK(BlockToJsonVerbose);[m
 static void BlockToJsonVerboseWrite(benchmark::Bench& bench)[m
 {[m
     TestBlockAndIndex data;[m
[31m-    auto univalue = blockToJSON(data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);[m
[32m+[m[32m    auto univalue = blockToJSON(WITH_LOCK(::cs_main, return std::ref(data.testing_setup->m_node.chainman->m_blockman)), data.block, &data.blockindex, &data.blockindex, /*verbose*/ true);[m
     bench.run([&] {[m
         auto str = univalue.write();[m
         ankerl::nanobench::doNotOptimizeAway(str);[m
[33mdiff --git a/src/deploymentstatus.cpp b/src/deploymentstatus.cpp[m
[33mindex bba86639a3..a1cc37c64f 100644[m
[33m--- a/src/deploymentstatus.cpp[m
[33m+++ b/src/deploymentstatus.cpp[m
[36m@@ -9,8 +9,6 @@[m
 [m
 #include <type_traits>[m
 [m
[31m-VersionBitsCache g_versionbitscache;[m
[31m-[m
 /* Basic sanity checking for BuriedDeployment/DeploymentPos enums and[m
  * ValidDeployment check */[m
 [m
[33mdiff --git a/src/deploymentstatus.h b/src/deploymentstatus.h[m
[33mindex f95c5996f5..5b4a5ccdb9 100644[m
[33m--- a/src/deploymentstatus.h[m
[33m+++ b/src/deploymentstatus.h[m
[36m@@ -10,9 +10,6 @@[m
 [m
 #include <limits>[m
 [m
[31m-/** Global cache for versionbits deployment status */[m
[31m-extern VersionBitsCache g_versionbitscache;[m
[31m-[m
 /** Determine if a deployment is active for the next block */[m
 inline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::BuriedDeployment dep)[m
 {[m
[36m@@ -20,10 +17,10 @@[m [minline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus[m
     return (pindexPrev == nullptr ? 0 : pindexPrev->nHeight + 1) >= params.DeploymentHeight(dep);[m
 }[m
 [m
[31m-inline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos dep)[m
[32m+[m[32minline bool DeploymentActiveAfter(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos dep, VersionBitsCache& versionbitscache)[m
 {[m
     assert(Consensus::ValidDeployment(dep));[m
[31m-    return ThresholdState::ACTIVE == g_versionbitscache.State(pindexPrev, params, dep);[m
[32m+[m[32m    return ThresholdState::ACTIVE == versionbitscache.State(pindexPrev, params, dep);[m
 }[m
 [m
 /** Determine if a deployment is active for this block */[m
[36m@@ -33,10 +30,10 @@[m [minline bool DeploymentActiveAt(const CBlockIndex& index, const Consensus::Params[m
     return index.nHeight >= params.DeploymentHeight(dep);[m
 }[m
 [m
[31m-inline bool DeploymentActiveAt(const CBlockIndex& index, const Consensus::Params& params, Consensus::DeploymentPos dep)[m
[32m+[m[32minline bool DeploymentActiveAt(const CBlockIndex& index, const Consensus::Params& params, Consensus::DeploymentPos dep, VersionBitsCache& versionbitscache)[m
 {[m
     assert(Consensus::ValidDeployment(dep));[m
[31m-    return DeploymentActiveAfter(index.pprev, params, dep);[m
[32m+[m[32m    return DeploymentActiveAfter(index.pprev, params, dep, versionbitscache);[m
 }[m
 [m
 /** Determine if a deployment is enabled (can ever be active) */[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex d4ba441b0c..b72d7ac4f3 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -1211,114 +1211,14 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
     assert(!node.connman);[m
     node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), *node.addrman, args.GetBoolArg("-networkactive", true));[m
 [m
[32m+[m[32m    // ********************************************************* Step 7: load block chain[m
[32m+[m
     assert(!node.fee_estimator);[m
     // Don't initialize fee estimation with old data if we don't relay transactions,[m
     // as they would never get updated.[m
     if (!ignores_incoming_txs) node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();[m
 [m
[31m-    assert(!node.mempool);[m
     int check_ratio = std::min<int>(std::max<int>(args.GetArg("-checkmempool", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);[m
[31m-    node.mempool = std::make_unique<CTxMemPool>(node.fee_estimator.get(), check_ratio);[m
[31m-[m
[31m-    assert(!node.chainman);[m
[31m-    node.chainman = std::make_unique<ChainstateManager>();[m
[31m-    ChainstateManager& chainman = *node.chainman;[m
[2m-[m
[2m-    assert(!node.peerman);[m
[2m-    node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),[m
[2m-                                     chainman, *node.mempool, ignores_incoming_txs);[m
[2m-    RegisterValidationInterface(node.peerman.get());[m
[2m-[m
[2m-    // sanitize comments per BIP-0014, format user agent and check total size[m
[2m-    std::vector<std::string> uacomments;[m
[2m-    for (const std::string& cmt : args.GetArgs("-uacomment")) {[m
[2m-        if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))[m
[2m-            return InitError(strprintf(_("User Agent comment (%s) contains unsafe characters."), cmt));[m
[2m-        uacomments.push_back(cmt);[m
[2m-    }[m
[2m-    strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);[m
[2m-    if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {[m
[2m-        return InitError(strprintf(_("Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments."),[m
[2m-            strSubVersion.size(), MAX_SUBVERSION_LENGTH));[m
[2m-    }[m
[2m-[m
[2m-    if (args.IsArgSet("-onlynet")) {[m
[2m-        std::set<enum Network> nets;[m
[2m-        for (const std::string& snet : args.GetArgs("-onlynet")) {[m
[2m-            enum Network net = ParseNetwork(snet);[m
[2m-            if (net == NET_UNROUTABLE)[m
[2m-                return InitError(strprintf(_("Unknown network specified in -onlynet: '%s'"), snet));[m
[2m-            nets.insert(net);[m
[2m-        }[m
[2m-        for (int n = 0; n < NET_MAX; n++) {[m
[2m-            enum Network net = (enum Network)n;[m
[2m-            if (!nets.count(net))[m
[2m-                SetReachable(net, false);[m
[2m-        }[m
[2m-    }[m
[2m-[m
[2m-    // Check for host lookup allowed before parsing any network related parameters[m
[2m-    fNameLookup = args.GetBoolArg("-dns", DEFAULT_NAME_LOOKUP);[m
[2m-[m
[2m-    bool proxyRandomize = args.GetBoolArg("-proxyrandomize", DEFAULT_PROXYRANDOMIZE);[m
[2m-    // -proxy sets a proxy for all outgoing network traffic[m
[2m-    // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default[m
[2m-    std::string proxyArg = args.GetArg("-proxy", "");[m
[2m-    SetReachable(NET_ONION, false);[m
[2m-    if (proxyArg != "" && proxyArg != "0") {[m
[2m-        CService proxyAddr;[m
[2m-        if (!Lookup(proxyArg, proxyAddr, 9050, fNameLookup)) {[m
[2m-            return InitError(strprintf(_("Invalid -proxy address or hostname: '%s'"), proxyArg));[m
[2m-        }[m
[2m-[m
[2m-        proxyType addrProxy = proxyType(proxyAddr, proxyRandomize);[m
[2m-        if (!addrProxy.IsValid())[m
[2m-            return InitError(strprintf(_("Invalid -proxy address or hostname: '%s'"), proxyArg));[m
[2m-[m
[2m-        SetProxy(NET_IPV4, addrProxy);[m
[2m-        SetProxy(NET_IPV6, addrProxy);[m
[2m-        SetProxy(NET_ONION, addrProxy);[m
[2m-        SetNameProxy(addrProxy);[m
[2m-        SetReachable(NET_ONION, true); // by default, -proxy sets onion as reachable, unless -noonion later[m
[2m-    }[m
[2m-[m
[2m-    // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses[m
[2m-    // -noonion (or -onion=0) disables connecting to .onion entirely[m
[2m-    // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none)[m
[2m-    std::string onionArg = args.GetArg("-onion", "");[m
[2m-    if (onionArg != "") {[m
[2m-        if (onionArg == "0") { // Handle -noonion/-onion=0[m
[2m-            SetReachable(NET_ONION, false);[m
[2m-        } else {[m
[2m-            CService onionProxy;[m
[2m-            if (!Lookup(onionArg, onionProxy, 9050, fNameLookup)) {[m
[2m-                return InitError(strprintf(_("Invalid -onion address or hostname: '%s'"), onionArg));[m
[2m-            }[m
[2m-            proxyType addrOnion = proxyType(onionProxy, proxyRandomize);[m
[2m-            if (!addrOnion.IsValid())[m
[2m-                return InitError(strprintf(_("Invalid -onion address or hostname: '%s'"), onionArg));[m
[2m-            SetProxy(NET_ONION, addrOnion);[m
[2m-            SetReachable(NET_ONION, true);[m
[2m-        }[m
[2m-    }[m
[2m-[m
[2m-    for (const std::string& strAddr : args.GetArgs("-externalip")) {[m
[2m-        CService addrLocal;[m
[2m-        if (Lookup(strAddr, addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())[m
[2m-            AddLocal(addrLocal, LOCAL_MANUAL);[m
[2m-        else[m
[2m-            return InitError(ResolveErrMsg("externalip", strAddr));[m
[2m-    }[m
[2m-[m
[2m-#if ENABLE_ZMQ[m
[2m-    g_zmq_notification_interface = CZMQNotificationInterface::Create();[m
[2m-[m
[2m-    if (g_zmq_notification_interface) {[m
[2m-        RegisterValidationInterface(g_zmq_notification_interface);[m
[2m-    }[m
[2m-#endif[m
[2m-[m
[31m-    // ********************************************************* Step 7: load block chain[m
 [m
     fReindex = args.GetBoolArg("-reindex", false);[m
     bool fReindexChainState = args.GetBoolArg("-reindex-chainstate", false);[m
[36m@@ -1355,8 +1255,18 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
     LogPrintf("* Using %.1f MiB for chain state database\n", nCoinDBCache * (1.0 / 1024 / 1024));[m
     LogPrintf("* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\n", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));[m
 [m
[32m+[m[32m    assert(!node.mempool);[m
[32m+[m[32m    assert(!node.chainman);[m
     bool fLoaded = false;[m
     while (!fLoaded && !ShutdownRequested()) {[m
[32m+[m[32m        node.mempool = std::make_unique<CTxMemPool>(node.fee_estimator.get(), check_ratio);[m
[32m+[m[32m        CTxMemPool& mempool = *Assert(node.mempool);[m
[32m+[m
[32m+[m[32m        node.chainman = std::make_unique<ChainstateManager>();[m
[32m+[m[32m        ChainstateManager& chainman = *Assert(node.chainman);[m
[32m+[m[32m        chainman.m_total_coinstip_cache = nCoinCacheUsage;[m
[32m+[m[32m        chainman.m_total_coinsdb_cache = nCoinDBCache;[m
[32m+[m
         const bool fReset = fReindex;[m
         auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {[m
             return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();[m
[36m@@ -1369,11 +1279,8 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
             const int64_t load_block_index_start_time = GetTimeMillis();[m
             try {[m
                 LOCK(cs_main);[m
[31m-                chainman.InitializeChainstate(Assert(node.mempool.get()));[m
[31m-                chainman.m_total_coinstip_cache = nCoinCacheUsage;[m
[31m-                chainman.m_total_coinsdb_cache = nCoinDBCache;[m
 [m
[31m-                UnloadBlockIndex(node.mempool.get(), chainman);[m
[32m+[m[32m                chainman.InitializeChainstate(&mempool);[m
 [m
                 auto& pblocktree{chainman.m_blockman.m_block_tree_db};[m
                 // new CBlockTreeDB tries to delete the existing file, which[m
[36m@@ -1409,7 +1316,7 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
 [m
                 // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks[m
                 // in the past, but is now trying to run unpruned.[m
[31m-                if (fHavePruned && !fPruneMode) {[m
[32m+[m[32m                if (chainman.m_blockman.fHavePruned && !fPruneMode) {[m
                     strLoadError = _("You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain");[m
                     break;[m
                 }[m
[36m@@ -1498,7 +1405,7 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
                 for (CChainState* chainstate : chainman.GetAll()) {[m
                     if (!is_coinsview_empty(chainstate)) {[m
                         uiInterface.InitMessage(_("Verifying blocks…").translated);[m
[31m-                        if (fHavePruned && args.GetArg("-checkblocks", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {[m
[32m+[m[32m                        if (chainman.m_blockman.fHavePruned && args.GetArg("-checkblocks", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {[m
                             LogPrintf("Prune: pruned datadir may not have more than %d blocks; only checking available blocks\n",[m
                                 MIN_BLOCKS_TO_KEEP);[m
                         }[m
[36m@@ -1564,6 +1471,105 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
         return false;[m
     }[m
 [m
[32m+[m[32m    ChainstateManager& chainman = *Assert(node.chainman);[m
[32m+[m
[32m+[m[32m    // ********************************************************* Step 7: network init pt. 2[m
[2;3m+[m
[2;3m+[m[2;3m    assert(!node.peerman);[m
[2;3m+[m[2;3m    node.peerman = PeerManager::make(chainparams, *node.connman, *node.addrman, node.banman.get(),[m
[2;3m+[m[2;3m                                     chainman, *node.mempool, ignores_incoming_txs);[m
[2;3m+[m[2;3m    RegisterValidationInterface(node.peerman.get());[m
[2;3m+[m
[2;3m+[m[2;3m    // sanitize comments per BIP-0014, format user agent and check total size[m
[2;3m+[m[2;3m    std::vector<std::string> uacomments;[m
[2;3m+[m[2;3m    for (const std::string& cmt : args.GetArgs("-uacomment")) {[m
[2;3m+[m[2;3m        if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))[m
[2;3m+[m[2;3m            return InitError(strprintf(_("User Agent comment (%s) contains unsafe characters."), cmt));[m
[2;3m+[m[2;3m        uacomments.push_back(cmt);[m
[2;3m+[m[2;3m    }[m
[2;3m+[m[2;3m    strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);[m
[2;3m+[m[2;3m    if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {[m
[2;3m+[m[2;3m        return InitError(strprintf(_("Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments."),[m
[2;3m+[m[2;3m            strSubVersion.size(), MAX_SUBVERSION_LENGTH));[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m    if (args.IsArgSet("-onlynet")) {[m
[2;3m+[m[2;3m        std::set<enum Network> nets;[m
[2;3m+[m[2;3m        for (const std::string& snet : args.GetArgs("-onlynet")) {[m
[2;3m+[m[2;3m            enum Network net = ParseNetwork(snet);[m
[2;3m+[m[2;3m            if (net == NET_UNROUTABLE)[m
[2;3m+[m[2;3m                return InitError(strprintf(_("Unknown network specified in -onlynet: '%s'"), snet));[m
[2;3m+[m[2;3m            nets.insert(net);[m
[2;3m+[m[2;3m        }[m
[2;3m+[m[2;3m        for (int n = 0; n < NET_MAX; n++) {[m
[2;3m+[m[2;3m            enum Network net = (enum Network)n;[m
[2;3m+[m[2;3m            if (!nets.count(net))[m
[2;3m+[m[2;3m                SetReachable(net, false);[m
[2;3m+[m[2;3m        }[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m    // Check for host lookup allowed before parsing any network related parameters[m
[2;3m+[m[2;3m    fNameLookup = args.GetBoolArg("-dns", DEFAULT_NAME_LOOKUP);[m
[2;3m+[m
[2;3m+[m[2;3m    bool proxyRandomize = args.GetBoolArg("-proxyrandomize", DEFAULT_PROXYRANDOMIZE);[m
[2;3m+[m[2;3m    // -proxy sets a proxy for all outgoing network traffic[m
[2;3m+[m[2;3m    // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default[m
[2;3m+[m[2;3m    std::string proxyArg = args.GetArg("-proxy", "");[m
[2;3m+[m[2;3m    SetReachable(NET_ONION, false);[m
[2;3m+[m[2;3m    if (proxyArg != "" && proxyArg != "0") {[m
[2;3m+[m[2;3m        CService proxyAddr;[m
[2;3m+[m[2;3m        if (!Lookup(proxyArg, proxyAddr, 9050, fNameLookup)) {[m
[2;3m+[m[2;3m            return InitError(strprintf(_("Invalid -proxy address or hostname: '%s'"), proxyArg));[m
[2;3m+[m[2;3m        }[m
[2;3m+[m
[2;3m+[m[2;3m        proxyType addrProxy = proxyType(proxyAddr, proxyRandomize);[m
[2;3m+[m[2;3m        if (!addrProxy.IsValid())[m
[2;3m+[m[2;3m            return InitError(strprintf(_("Invalid -proxy address or hostname: '%s'"), proxyArg));[m
[2;3m+[m
[2;3m+[m[2;3m        SetProxy(NET_IPV4, addrProxy);[m
[2;3m+[m[2;3m        SetProxy(NET_IPV6, addrProxy);[m
[2;3m+[m[2;3m        SetProxy(NET_ONION, addrProxy);[m
[2;3m+[m[2;3m        SetNameProxy(addrProxy);[m
[2;3m+[m[2;3m        SetReachable(NET_ONION, true); // by default, -proxy sets onion as reachable, unless -noonion later[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m    // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses[m
[2;3m+[m[2;3m    // -noonion (or -onion=0) disables connecting to .onion entirely[m
[2;3m+[m[2;3m    // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none)[m
[2;3m+[m[2;3m    std::string onionArg = args.GetArg("-onion", "");[m
[2;3m+[m[2;3m    if (onionArg != "") {[m
[2;3m+[m[2;3m        if (onionArg == "0") { // Handle -noonion/-onion=0[m
[2;3m+[m[2;3m            SetReachable(NET_ONION, false);[m
[2;3m+[m[2;3m        } else {[m
[2;3m+[m[2;3m            CService onionProxy;[m
[2;3m+[m[2;3m            if (!Lookup(onionArg, onionProxy, 9050, fNameLookup)) {[m
[2;3m+[m[2;3m                return InitError(strprintf(_("Invalid -onion address or hostname: '%s'"), onionArg));[m
[2;3m+[m[2;3m            }[m
[2;3m+[m[2;3m            proxyType addrOnion = proxyType(onionProxy, proxyRandomize);[m
[2;3m+[m[2;3m            if (!addrOnion.IsValid())[m
[2;3m+[m[2;3m                return InitError(strprintf(_("Invalid -onion address or hostname: '%s'"), onionArg));[m
[2;3m+[m[2;3m            SetProxy(NET_ONION, addrOnion);[m
[2;3m+[m[2;3m            SetReachable(NET_ONION, true);[m
[2;3m+[m[2;3m        }[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m    for (const std::string& strAddr : args.GetArgs("-externalip")) {[m
[2;3m+[m[2;3m        CService addrLocal;[m
[2;3m+[m[2;3m        if (Lookup(strAddr, addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())[m
[2;3m+[m[2;3m            AddLocal(addrLocal, LOCAL_MANUAL);[m
[2;3m+[m[2;3m        else[m
[2;3m+[m[2;3m            return InitError(ResolveErrMsg("externalip", strAddr));[m
[2;3m+[m[2;3m    }[m
[2;3m+[m
[2;3m+[m[2;3m#if ENABLE_ZMQ[m
[2;3m+[m[2;3m    g_zmq_notification_interface = CZMQNotificationInterface::Create();[m
[2;3m+[m
[2;3m+[m[2;3m    if (g_zmq_notification_interface) {[m
[2;3m+[m[2;3m        RegisterValidationInterface(g_zmq_notification_interface);[m
[2;3m+[m[2;3m    }[m
[2;3m+[m[2;3m#endif[m
[2;3m+[m
[32m+[m
     // ********************************************************* Step 8: start indexers[m
     if (args.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {[m
         g_txindex = std::make_unique<TxIndex>(nTxIndexCache, false, fReindex);[m
[36m@@ -1681,9 +1687,9 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
             tip_info->block_time = chainman.ActiveChain().Tip() ? chainman.ActiveChain().Tip()->GetBlockTime() : Params().GenesisBlock().GetBlockTime();[m
             tip_info->verification_progress = GuessVerificationProgress(Params().TxData(), chainman.ActiveChain().Tip());[m
         }[m
[31m-        if (tip_info && ::pindexBestHeader) {[m
[31m-            tip_info->header_height = ::pindexBestHeader->nHeight;[m
[31m-            tip_info->header_time = ::pindexBestHeader->GetBlockTime();[m
[32m+[m[32m        if (tip_info && chainman.m_blockman.pindexBestHeader) {[m
[32m+[m[32m            tip_info->header_height = chainman.m_blockman.pindexBestHeader->nHeight;[m
[32m+[m[32m            tip_info->header_time = chainman.m_blockman.pindexBestHeader->GetBlockTime();[m
         }[m
     }[m
     LogPrintf("nBestHeight = %d\n", chain_active_height);[m
[33mdiff --git a/src/miner.cpp b/src/miner.cpp[m
[33mindex 168ade5507..998e54891a 100644[m
[33m--- a/src/miner.cpp[m
[33m+++ b/src/miner.cpp[m
[36m@@ -121,7 +121,7 @@[m [mstd::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc[m
     assert(pindexPrev != nullptr);[m
     nHeight = pindexPrev->nHeight + 1;[m
 [m
[31m-    pblock->nVersion = g_versionbitscache.ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());[m
[32m+[m[32m    pblock->nVersion = m_chainstate.m_blockman.versionbitscache.ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());[m
     // -regtest only: allow overriding block.nVersion with[m
     // -blockversion=N to test forking scenarios[m
     if (chainparams.MineBlocksOnDemand())[m
[33mdiff --git a/src/net_processing.cpp b/src/net_processing.cpp[m
[33mindex 3ad34e83ba..edfbc37c1b 100644[m
[33m--- a/src/net_processing.cpp[m
[33m+++ b/src/net_processing.cpp[m
[36m@@ -1414,9 +1414,9 @@[m [mbool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)[m
 {[m
     AssertLockHeld(cs_main);[m
     if (m_chainman.ActiveChain().Contains(pindex)) return true;[m
[31m-    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&[m
[31m-           (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&[m
[31m-           (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);[m
[32m+[m[32m    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (m_chainman.m_blockman.pindexBestHeader != nullptr) &&[m
[32m+[m[32m           (m_chainman.m_blockman.pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&[m
[32m+[m[32m           (GetBlockProofEquivalentTime(*m_chainman.m_blockman.pindexBestHeader, *pindex, *m_chainman.m_blockman.pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);[m
 }[m
 [m
 std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,[m
[36m@@ -1776,7 +1776,7 @@[m [mvoid PeerManagerImpl::ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv&[m
     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());[m
     // disconnect node in case we have reached the outbound limit for serving historical blocks[m
     if (m_connman.OutboundTargetReached(true) &&[m
[31m-        (((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&[m
[32m+[m[32m        (((m_chainman.m_blockman.pindexBestHeader != nullptr) && (m_chainman.m_blockman.pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.IsMsgFilteredBlk()) &&[m
         !pfrom.HasPermission(NetPermissionFlags::Download) // nodes with the download permission may exceed target[m
     ) {[m
         LogPrint(BCLog::NET, "historical block serving limit reached, disconnect peer=%d\n", pfrom.GetId());[m
[36m@@ -2054,11 +2054,11 @@[m [mvoid PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,[m
         //   nUnconnectingHeaders gets reset back to 0.[m
         if (!m_chainman.m_blockman.LookupBlockIndex(headers[0].hashPrevBlock) && nCount < MAX_BLOCKS_TO_ANNOUNCE) {[m
             nodestate->nUnconnectingHeaders++;[m
[31m-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));[m
[32m+[m[32m            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(m_chainman.m_blockman.pindexBestHeader), uint256()));[m
             LogPrint(BCLog::NET, "received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\n",[m
                     headers[0].GetHash().ToString(),[m
                     headers[0].hashPrevBlock.ToString(),[m
[31m-                    pindexBestHeader->nHeight,[m
[32m+[m[32m                    m_chainman.m_blockman.pindexBestHeader->nHeight,[m
                     pfrom.GetId(), nodestate->nUnconnectingHeaders);[m
             // Set hashLastUnknownBlock for this peer, so that if we[m
             // eventually get the headers - even from a different peer -[m
[36m@@ -2967,8 +2967,8 @@[m [mvoid PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,[m
         }[m
 [m
         if (best_block != nullptr) {[m
[31m-            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), *best_block));[m
[31m-            LogPrint(BCLog::NET, "getheaders (%d) %s to peer=%d\n", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());[m
[32m+[m[32m            m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(m_chainman.m_blockman.pindexBestHeader), *best_block));[m
[32m+[m[32m            LogPrint(BCLog::NET, "getheaders (%d) %s to peer=%d\n", m_chainman.m_blockman.pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());[m
         }[m
 [m
         return;[m
[36m@@ -3413,7 +3413,7 @@[m [mvoid PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,[m
         if (!m_chainman.m_blockman.LookupBlockIndex(cmpctblock.header.hashPrevBlock)) {[m
             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers[m
             if (!m_chainman.ActiveChainstate().IsInitialBlockDownload())[m
[31m-                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(pindexBestHeader), uint256()));[m
[32m+[m[32m                m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, m_chainman.ActiveChain().GetLocator(m_chainman.m_blockman.pindexBestHeader), uint256()));[m
             return;[m
         }[m
 [m
[36m@@ -4524,28 +4524,28 @@[m [mbool PeerManagerImpl::SendMessages(CNode* pto)[m
         CNodeState &state = *State(pto->GetId());[m
 [m
         // Start block sync[m
[31m-        if (pindexBestHeader == nullptr)[m
[31m-            pindexBestHeader = m_chainman.ActiveChain().Tip();[m
[32m+[m[32m        if (m_chainman.m_blockman.pindexBestHeader == nullptr)[m
[32m+[m[32m            m_chainman.m_blockman.pindexBestHeader = m_chainman.ActiveChain().Tip();[m
         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->IsAddrFetchConn()); // Download if this is a nice peer, or we have no nice peers and this one might do.[m
         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {[m
             // Only actively request headers from a single peer, unless we're close to today.[m
[31m-            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {[m
[32m+[m[32m            if ((nSyncStarted == 0 && fFetch) || m_chainman.m_blockman.pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {[m
                 state.fSyncStarted = true;[m
                 state.m_headers_sync_timeout = current_time + HEADERS_DOWNLOAD_TIMEOUT_BASE +[m
                     ([m
                         // Convert HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER to microseconds before scaling[m
                         // to maintain precision[m
                         std::chrono::microseconds{HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER} *[m
[31m-                        (GetAdjustedTime() - pindexBestHeader->GetBlockTime()) / consensusParams.nPowTargetSpacing[m
[32m+[m[32m                        (GetAdjustedTime() - m_chainman.m_blockman.pindexBestHeader->GetBlockTime()) / consensusParams.nPowTargetSpacing[m
                     );[m
                 nSyncStarted++;[m
[31m-                const CBlockIndex *pindexStart = pindexBestHeader;[m
[32m+[m[32m                const CBlockIndex *pindexStart = m_chainman.m_blockman.pindexBestHeader;[m
                 /* If possible, start at the block preceding the currently[m
                    best known header.  This ensures that we always get a[m
                    non-empty list of headers back as long as the peer[m
                    is up-to-date.  With a non-empty response, we can initialise[m
                    the peer's known best block.  This wouldn't be possible[m
[31m-                   if we requested starting at pindexBestHeader and[m
[32m+[m[32m                   if we requested starting at m_chainman.m_blockman.pindexBestHeader and[m
                    got back an empty response.  */[m
                 if (pindexStart->pprev)[m
                     pindexStart = pindexStart->pprev;[m
[36m@@ -4870,7 +4870,7 @@[m [mbool PeerManagerImpl::SendMessages(CNode* pto)[m
         // Check for headers sync timeouts[m
         if (state.fSyncStarted && state.m_headers_sync_timeout < std::chrono::microseconds::max()) {[m
             // Detect whether this is a stalling initial-headers-sync peer[m
[31m-            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24 * 60 * 60) {[m
[32m+[m[32m            if (m_chainman.m_blockman.pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24 * 60 * 60) {[m
                 if (current_time > state.m_headers_sync_timeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {[m
                     // Disconnect a peer (without NetPermissionFlags::NoBan permission) if it is our only sync peer,[m
                     // and we have others we could be using instead.[m
[33mdiff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp[m
[33mindex 90f7ba191d..97bde22f02 100644[m
[33m--- a/src/node/blockstorage.cpp[m
[33m+++ b/src/node/blockstorage.cpp[m
[36m@@ -21,32 +21,14 @@[m
 [m
 std::atomic_bool fImporting(false);[m
 std::atomic_bool fReindex(false);[m
[31m-bool fHavePruned = false;[m
 bool fPruneMode = false;[m
 uint64_t nPruneTarget = 0;[m
 [m
[31m-// TODO make namespace {[m
[31m-RecursiveMutex cs_LastBlockFile;[m
[31m-std::vector<CBlockFileInfo> vinfoBlockFile;[m
[31m-int nLastBlockFile = 0;[m
[31m-/** Global flag to indicate we should check to see if there are[m
[31m-*  block/undo files that should be deleted.  Set on startup[m
[31m-*  or if we allocate more file space when we're in prune mode[m
[31m-*/[m
[31m-bool fCheckForPruning = false;[m
[31m-[m
[31m-/** Dirty block index entries. */[m
[31m-std::set<CBlockIndex*> setDirtyBlockIndex;[m
[31m-[m
[31m-/** Dirty block file entries. */[m
[31m-std::set<int> setDirtyFileInfo;[m
[31m-// } // namespace[m
[31m-[m
 static FILE* OpenUndoFile(const FlatFilePos& pos, bool fReadOnly = false);[m
 static FlatFileSeq BlockFileSeq();[m
 static FlatFileSeq UndoFileSeq();[m
 [m
[31m-bool IsBlockPruned(const CBlockIndex* pblockindex)[m
[32m+[m[32mbool BlockManager::IsBlockPruned(const CBlockIndex* pblockindex)[m
 {[m
     return (fHavePruned && !(pblockindex->nStatus & BLOCK_HAVE_DATA) && pblockindex->nTx > 0);[m
 }[m
[36m@@ -98,9 +80,9 @@[m [mstd::string CBlockFileInfo::ToString() const[m
     return strprintf("CBlockFileInfo(blocks=%u, size=%u, heights=%u...%u, time=%s...%s)", nBlocks, nSize, nHeightFirst, nHeightLast, FormatISO8601Date(nTimeFirst), FormatISO8601Date(nTimeLast));[m
 }[m
 [m
[31m-CBlockFileInfo* GetBlockFileInfo(size_t n)[m
[32m+[m[32mCBlockFileInfo* BlockManager::GetBlockFileInfo(size_t n)[m
 {[m
[31m-    LOCK(cs_LastBlockFile);[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
 [m
     return &vinfoBlockFile.at(n);[m
 }[m
[36m@@ -166,17 +148,18 @@[m [mbool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex)[m
     return true;[m
 }[m
 [m
[31m-static void FlushUndoFile(int block_file, bool finalize = false)[m
[32m+[m[32mvoid BlockManager::FlushUndoFile(int block_file, bool finalize)[m
 {[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
     FlatFilePos undo_pos_old(block_file, vinfoBlockFile[block_file].nUndoSize);[m
     if (!UndoFileSeq().Flush(undo_pos_old, finalize)) {[m
         AbortNode("Flushing undo file to disk failed. This is likely the result of an I/O error.");[m
     }[m
 }[m
 [m
[31m-void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)[m
[32m+[m[32mvoid BlockManager::FlushBlockFile(bool fFinalize, bool finalize_undo)[m
 {[m
[31m-    LOCK(cs_LastBlockFile);[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
     FlatFilePos block_pos_old(nLastBlockFile, vinfoBlockFile[nLastBlockFile].nSize);[m
     if (!BlockFileSeq().Flush(block_pos_old, fFinalize)) {[m
         AbortNode("Flushing block file to disk failed. This is likely the result of an I/O error.");[m
[36m@@ -186,9 +169,9 @@[m [mvoid FlushBlockFile(bool fFinalize = false, bool finalize_undo = false)[m
     if (!fFinalize || finalize_undo) FlushUndoFile(nLastBlockFile, finalize_undo);[m
 }[m
 [m
[31m-uint64_t CalculateCurrentUsage()[m
[32m+[m[32muint64_t BlockManager::CalculateCurrentUsage()[m
 {[m
[31m-    LOCK(cs_LastBlockFile);[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
 [m
     uint64_t retval = 0;[m
     for (const CBlockFileInfo& file : vinfoBlockFile) {[m
[36m@@ -233,9 +216,9 @@[m [mfs::path GetBlockPosFilename(const FlatFilePos& pos)[m
     return BlockFileSeq().FileName(pos);[m
 }[m
 [m
[31m-bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)[m
[32m+[m[32mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown = false)[m
 {[m
[31m-    LOCK(cs_LastBlockFile);[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
 [m
     unsigned int nFile = fKnown ? pos.nFile : nLastBlockFile;[m
     if (vinfoBlockFile.size() <= nFile) {[m
[36m@@ -288,11 +271,11 @@[m [mbool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight,[m
     return true;[m
 }[m
 [m
[31m-static bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize)[m
[32m+[m[32mbool BlockManager::FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize)[m
 {[m
     pos.nFile = nFile;[m
 [m
[31m-    LOCK(cs_LastBlockFile);[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
 [m
     pos.nPos = vinfoBlockFile[nFile].nUndoSize;[m
     vinfoBlockFile[nFile].nUndoSize += nAddSize;[m
[36m@@ -333,7 +316,7 @@[m [mstatic bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessa[m
     return true;[m
 }[m
 [m
[31m-bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)[m
[32m+[m[32mbool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams)[m
 {[m
     // Write undo information to disk[m
     if (pindex->GetUndoPos().IsNull()) {[m
[36m@@ -349,8 +332,11 @@[m [mbool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& st[m
         // in the block file info as below; note that this does not catch the case where the undo writes are keeping up[m
         // with the block writes (usually when a synced up node is getting newly mined blocks) -- this case is caught in[m
         // the FindBlockPos function[m
[31m-        if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {[m
[31m-            FlushUndoFile(_pos.nFile, true);[m
[32m+[m[32m        {[m
[32m+[m[32m            LOCK(cs_blockfiles);[m
[32m+[m[32m            if (_pos.nFile < nLastBlockFile && static_cast<uint32_t>(pindex->nHeight) == vinfoBlockFile[_pos.nFile].nHeightLast) {[m
[32m+[m[32m                FlushUndoFile(_pos.nFile, true);[m
[32m+[m[32m            }[m
         }[m
 [m
         // update nUndoPos in block index[m
[36m@@ -457,7 +443,7 @@[m [mbool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex[m
 }[m
 [m
 /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */[m
[31m-FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp)[m
[32m+[m[32mFlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp)[m
 {[m
     unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);[m
     FlatFilePos blockPos;[m
[33mdiff --git a/src/node/blockstorage.h b/src/node/blockstorage.h[m
[33mindex 7c7bf68178..ceada91589 100644[m
[33m--- a/src/node/blockstorage.h[m
[33m+++ b/src/node/blockstorage.h[m
[36m@@ -38,16 +38,11 @@[m [mstatic const unsigned int MAX_BLOCKFILE_SIZE = 0x8000000; // 128 MiB[m
 extern std::atomic_bool fImporting;[m
 extern std::atomic_bool fReindex;[m
 /** Pruning-related variables and constants */[m
[31m-/** True if any block files have ever been pruned. */[m
[31m-extern bool fHavePruned;[m
 /** True if we're running in -prune mode. */[m
 extern bool fPruneMode;[m
 /** Number of MiB of block files that we're trying to stay below. */[m
 extern uint64_t nPruneTarget;[m
 [m
[31m-//! Check whether the block associated with this index entry is pruned or not.[m
[31m-bool IsBlockPruned(const CBlockIndex* pblockindex);[m
[31m-[m
 void CleanupBlockRevFiles();[m
 [m
 /** Open a block file (blk?????.dat) */[m
[36m@@ -55,12 +50,6 @@[m [mFILE* OpenBlockFile(const FlatFilePos& pos, bool fReadOnly = false);[m
 /** Translation to a filesystem path */[m
 fs::path GetBlockPosFilename(const FlatFilePos& pos);[m
 [m
[31m-/** Get block file info entry for one block file */[m
[31m-CBlockFileInfo* GetBlockFileInfo(size_t n);[m
[31m-[m
[31m-/** Calculate the amount of disk space the block & undo files currently use */[m
[31m-uint64_t CalculateCurrentUsage();[m
[31m-[m
 /**[m
  *  Actually unlink the specified files[m
  */[m
[36m@@ -73,9 +62,6 @@[m [mbool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatFilePos& pos, c[m
 bool ReadRawBlockFromDisk(std::vector<uint8_t>& block, const CBlockIndex* pindex, const CMessageHeader::MessageStartChars& message_start);[m
 [m
 bool UndoReadFromDisk(CBlockUndo& blockundo, const CBlockIndex* pindex);[m
[31m-bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams);[m
[31m-[m
[31m-FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);[m
 [m
 void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args);[m
 [m
[33mdiff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp[m
[33mindex b46ad0333e..19b875276f 100644[m
[33m--- a/src/node/interfaces.cpp[m
[33m+++ b/src/node/interfaces.cpp[m
[36m@@ -197,9 +197,9 @@[m [mpublic:[m
     bool getHeaderTip(int& height, int64_t& block_time) override[m
     {[m
         LOCK(::cs_main);[m
[31m-        if (::pindexBestHeader) {[m
[31m-            height = ::pindexBestHeader->nHeight;[m
[31m-            block_time = ::pindexBestHeader->GetBlockTime();[m
[32m+[m[32m        if (m_context->chainman->m_blockman.pindexBestHeader) {[m
[32m+[m[32m            height = m_context->chainman->m_blockman.pindexBestHeader->nHeight;[m
[32m+[m[32m            block_time = m_context->chainman->m_blockman.pindexBestHeader->GetBlockTime();[m
             return true;[m
         }[m
         return false;[m
[36m@@ -623,7 +623,7 @@[m [mpublic:[m
     bool havePruned() override[m
     {[m
         LOCK(cs_main);[m
[31m-        return ::fHavePruned;[m
[32m+[m[32m        return m_node.chainman->m_blockman.fHavePruned;[m
     }[m
     bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }[m
     bool isInitialBlockDownload() override {[m
[36m@@ -702,7 +702,7 @@[m [mpublic:[m
     {[m
         LOCK(::cs_main);[m
         const CBlockIndex* tip = Assert(m_node.chainman)->ActiveChain().Tip();[m
[31m-        return DeploymentActiveAfter(tip, Params().GetConsensus(), Consensus::DEPLOYMENT_TAPROOT);[m
[32m+[m[32m        return DeploymentActiveAfter(tip, Params().GetConsensus(), Consensus::DEPLOYMENT_TAPROOT, m_node.chainman->m_blockman.versionbitscache);[m
     }[m
     NodeContext& m_node;[m
 };[m
[33mdiff --git a/src/rest.cpp b/src/rest.cpp[m
[33mindex e50ab33e54..9d292c15fc 100644[m
[33m--- a/src/rest.cpp[m
[33m+++ b/src/rest.cpp[m
[36m@@ -274,10 +274,10 @@[m [mstatic bool rest_block(const std::any& context,[m
     CBlock block;[m
     CBlockIndex* pblockindex = nullptr;[m
     CBlockIndex* tip = nullptr;[m
[32m+[m[32m    ChainstateManager* maybe_chainman = GetChainman(context, req);[m
[32m+[m[32m    if (!maybe_chainman) return false;[m
[32m+[m[32m    ChainstateManager& chainman = *maybe_chainman;[m
     {[m
[31m-        ChainstateManager* maybe_chainman = GetChainman(context, req);[m
[31m-        if (!maybe_chainman) return false;[m
[31m-        ChainstateManager& chainman = *maybe_chainman;[m
         LOCK(cs_main);[m
         tip = chainman.ActiveChain().Tip();[m
         pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
[36m@@ -285,7 +285,7 @@[m [mstatic bool rest_block(const std::any& context,[m
             return RESTERR(req, HTTP_NOT_FOUND, hashStr + " not found");[m
         }[m
 [m
[31m-        if (IsBlockPruned(pblockindex))[m
[32m+[m[32m        if (chainman.m_blockman.IsBlockPruned(pblockindex))[m
             return RESTERR(req, HTTP_NOT_FOUND, hashStr + " not available (pruned data)");[m
 [m
         if (!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))[m
[36m@@ -312,7 +312,7 @@[m [mstatic bool rest_block(const std::any& context,[m
     }[m
 [m
     case RetFormat::JSON: {[m
[31m-        UniValue objBlock = blockToJSON(block, tip, pblockindex, showTxDetails);[m
[32m+[m[32m        UniValue objBlock = blockToJSON(WITH_LOCK(::cs_main, return std::ref(chainman.m_blockman)), block, tip, pblockindex, showTxDetails);[m
         std::string strJSON = objBlock.write() + "\n";[m
         req->WriteHeader("Content-Type", "application/json");[m
         req->WriteReply(HTTP_OK, strJSON);[m
[33mdiff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp[m
[33mindex 909019d796..988bb909e0 100644[m
[33m--- a/src/rpc/blockchain.cpp[m
[33m+++ b/src/rpc/blockchain.cpp[m
[36m@@ -200,7 +200,7 @@[m [mUniValue blockheaderToJSON(const CBlockIndex* tip, const CBlockIndex* blockindex[m
     return result;[m
 }[m
 [m
[31m-UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails)[m
[32m+[m[32mUniValue blockToJSON(BlockManager& blockman, const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails)[m
 {[m
     UniValue result = blockheaderToJSON(tip, blockindex);[m
 [m
[36m@@ -210,7 +210,7 @@[m [mUniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIn[m
     UniValue txs(UniValue::VARR);[m
     if (txDetails) {[m
         CBlockUndo blockUndo;[m
[31m-        const bool have_undo = !IsBlockPruned(blockindex) && UndoReadFromDisk(blockUndo, blockindex);[m
[32m+[m[32m        const bool have_undo = !blockman.IsBlockPruned(blockindex) && UndoReadFromDisk(blockUndo, blockindex);[m
         for (size_t i = 0; i < block.vtx.size(); ++i) {[m
             const CTransactionRef& tx = block.vtx.at(i);[m
             // coinbase transaction (i == 0) doesn't have undo data[m
[36m@@ -895,10 +895,10 @@[m [mstatic RPCHelpMan getblockheader()[m
     };[m
 }[m
 [m
[31m-static CBlock GetBlockChecked(const CBlockIndex* pblockindex)[m
[32m+[m[32mstatic CBlock GetBlockChecked(BlockManager& blockman, const CBlockIndex* pblockindex)[m
 {[m
     CBlock block;[m
[31m-    if (IsBlockPruned(pblockindex)) {[m
[32m+[m[32m    if (blockman.IsBlockPruned(pblockindex)) {[m
         throw JSONRPCError(RPC_MISC_ERROR, "Block not available (pruned data)");[m
     }[m
 [m
[36m@@ -912,10 +912,10 @@[m [mstatic CBlock GetBlockChecked(const CBlockIndex* pblockindex)[m
     return block;[m
 }[m
 [m
[31m-static CBlockUndo GetUndoChecked(const CBlockIndex* pblockindex)[m
[32m+[m[32mstatic CBlockUndo GetUndoChecked(BlockManager& blockman, const CBlockIndex* pblockindex)[m
 {[m
     CBlockUndo blockUndo;[m
[31m-    if (IsBlockPruned(pblockindex)) {[m
[32m+[m[32m    if (blockman.IsBlockPruned(pblockindex)) {[m
         throw JSONRPCError(RPC_MISC_ERROR, "Undo data not available (pruned data)");[m
     }[m
 [m
[36m@@ -997,8 +997,8 @@[m [mstatic RPCHelpMan getblock()[m
     CBlock block;[m
     const CBlockIndex* pblockindex;[m
     const CBlockIndex* tip;[m
[32m+[m[32m    ChainstateManager& chainman = EnsureAnyChainman(request.context);[m
     {[m
[31m-        ChainstateManager& chainman = EnsureAnyChainman(request.context);[m
         LOCK(cs_main);[m
         pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         tip = chainman.ActiveChain().Tip();[m
[36m@@ -1007,7 +1007,7 @@[m [mstatic RPCHelpMan getblock()[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
 [m
[31m-        block = GetBlockChecked(pblockindex);[m
[32m+[m[32m        block = GetBlockChecked(chainman.m_blockman, pblockindex);[m
     }[m
 [m
     if (verbosity <= 0)[m
[36m@@ -1018,7 +1018,7 @@[m [mstatic RPCHelpMan getblock()[m
         return strHex;[m
     }[m
 [m
[31m-    return blockToJSON(block, tip, pblockindex, verbosity >= 2);[m
[32m+[m[32m    return blockToJSON(WITH_LOCK(::cs_main, return std::ref(chainman.m_blockman)), block, tip, pblockindex, verbosity >= 2);[m
 },[m
     };[m
 }[m
[36m@@ -1368,14 +1368,14 @@[m [mstatic void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue&[m
     softforks.pushKV(DeploymentName(dep), rv);[m
 }[m
 [m
[31m-static void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue& softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id)[m
[32m+[m[32mstatic void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue& softforks, const Consensus::Params& consensusParams, Consensus::DeploymentPos id, VersionBitsCache& versionbitscache)[m
 {[m
     // For BIP9 deployments.[m
 [m
     if (!DeploymentEnabled(consensusParams, id)) return;[m
 [m
     UniValue bip9(UniValue::VOBJ);[m
[31m-    const ThresholdState thresholdState = g_versionbitscache.State(active_chain_tip, consensusParams, id);[m
[32m+[m[32m    const ThresholdState thresholdState = versionbitscache.State(active_chain_tip, consensusParams, id);[m
     switch (thresholdState) {[m
     case ThresholdState::DEFINED: bip9.pushKV("status", "defined"); break;[m
     case ThresholdState::STARTED: bip9.pushKV("status", "started"); break;[m
[36m@@ -1389,11 +1389,11 @@[m [mstatic void SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue&[m
     }[m
     bip9.pushKV("start_time", consensusParams.vDeployments[id].nStartTime);[m
     bip9.pushKV("timeout", consensusParams.vDeployments[id].nTimeout);[m
[31m-    int64_t since_height = g_versionbitscache.StateSinceHeight(active_chain_tip, consensusParams, id);[m
[32m+[m[32m    int64_t since_height = versionbitscache.StateSinceHeight(active_chain_tip, consensusParams, id);[m
     bip9.pushKV("since", since_height);[m
     if (has_signal) {[m
         UniValue statsUV(UniValue::VOBJ);[m
[31m-        BIP9Stats statsStruct = g_versionbitscache.Statistics(active_chain_tip, consensusParams, id);[m
[32m+[m[32m        BIP9Stats statsStruct = versionbitscache.Statistics(active_chain_tip, consensusParams, id);[m
         statsUV.pushKV("period", statsStruct.period);[m
         statsUV.pushKV("elapsed", statsStruct.elapsed);[m
         statsUV.pushKV("count", statsStruct.count);[m
[36m@@ -1483,7 +1483,7 @@[m [mRPCHelpMan getblockchaininfo()[m
     UniValue obj(UniValue::VOBJ);[m
     obj.pushKV("chain",                 Params().NetworkIDString());[m
     obj.pushKV("blocks",                height);[m
[31m-    obj.pushKV("headers",               pindexBestHeader ? pindexBestHeader->nHeight : -1);[m
[32m+[m[32m    obj.pushKV("headers",               chainman.m_blockman.pindexBestHeader ? chainman.m_blockman.pindexBestHeader->nHeight : -1);[m
     obj.pushKV("bestblockhash",         tip->GetBlockHash().GetHex());[m
     obj.pushKV("difficulty",            (double)GetDifficulty(tip));[m
     obj.pushKV("time",                  (int64_t)tip->nTime);[m
[36m@@ -1491,7 +1491,7 @@[m [mRPCHelpMan getblockchaininfo()[m
     obj.pushKV("verificationprogress",  GuessVerificationProgress(Params().TxData(), tip));[m
     obj.pushKV("initialblockdownload",  active_chainstate.IsInitialBlockDownload());[m
     obj.pushKV("chainwork",             tip->nChainWork.GetHex());[m
[31m-    obj.pushKV("size_on_disk",          CalculateCurrentUsage());[m
[32m+[m[32m    obj.pushKV("size_on_disk",          chainman.m_blockman.CalculateCurrentUsage());[m
     obj.pushKV("pruned",                fPruneMode);[m
     if (fPruneMode) {[m
         const CBlockIndex* block = tip;[m
[36m@@ -1512,13 +1512,14 @@[m [mRPCHelpMan getblockchaininfo()[m
 [m
     const Consensus::Params& consensusParams = Params().GetConsensus();[m
     UniValue softforks(UniValue::VOBJ);[m
[32m+[m[32m    VersionBitsCache& versionbitscache = chainman.m_blockman.versionbitscache;[m
     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_HEIGHTINCB);[m
     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_DERSIG);[m
     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_CLTV);[m
     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_CSV);[m
     SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_SEGWIT);[m
[31m-    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);[m
[31m-    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TAPROOT);[m
[32m+[m[32m    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TESTDUMMY, versionbitscache);[m
[32m+[m[32m    SoftForkDescPushBack(tip, softforks, consensusParams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache);[m
     obj.pushKV("softforks", softforks);[m
 [m
     obj.pushKV("warnings", GetWarnings(false).original);[m
[36m@@ -1584,10 +1585,10 @@[m [mstatic RPCHelpMan getchaintips()[m
     std::set<const CBlockIndex*> setOrphans;[m
     std::set<const CBlockIndex*> setPrevs;[m
 [m
[31m-    for (const std::pair<const uint256, CBlockIndex*>& item : chainman.BlockIndex()) {[m
[31m-        if (!active_chain.Contains(item.second)) {[m
[31m-            setOrphans.insert(item.second);[m
[31m-            setPrevs.insert(item.second->pprev);[m
[32m+[m[32m    for (const std::pair<const uint256, CBlockIndex>& item : chainman.BlockIndex()) {[m
[32m+[m[32m        if (!active_chain.Contains(&item.second)) {[m
[32m+[m[32m            setOrphans.insert(&item.second);[m
[32m+[m[32m            setPrevs.insert(item.second.pprev);[m
         }[m
     }[m
 [m
[36m@@ -2030,8 +2031,8 @@[m [mstatic RPCHelpMan getblockstats()[m
         }[m
     }[m
 [m
[31m-    const CBlock block = GetBlockChecked(pindex);[m
[31m-    const CBlockUndo blockUndo = GetUndoChecked(pindex);[m
[32m+[m[32m    const CBlock block = GetBlockChecked(chainman.m_blockman, pindex);[m
[32m+[m[32m    const CBlockUndo blockUndo = GetUndoChecked(chainman.m_blockman, pindex);[m
 [m
     const bool do_all = stats.size() == 0; // Calculate everything if nothing selected (default)[m
     const bool do_mediantxsize = do_all || stats.count("mediantxsize") != 0;[m
[33mdiff --git a/src/rpc/blockchain.h b/src/rpc/blockchain.h[m
[33mindex ffb6f03b47..fd47557a0b 100644[m
[33m--- a/src/rpc/blockchain.h[m
[33m+++ b/src/rpc/blockchain.h[m
[36m@@ -9,6 +9,7 @@[m
 #include <core_io.h>[m
 #include <streams.h>[m
 #include <sync.h>[m
[32m+[m[32m#include <validation.h>[m
 [m
 #include <any>[m
 #include <stdint.h>[m
[36m@@ -39,7 +40,7 @@[m [mdouble GetDifficulty(const CBlockIndex* blockindex);[m
 void RPCNotifyBlockChange(const CBlockIndex*);[m
 [m
 /** Block description to JSON */[m
[31m-UniValue blockToJSON(const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails = false) LOCKS_EXCLUDED(cs_main);[m
[32m+[m[32mUniValue blockToJSON(BlockManager& blockman, const CBlock& block, const CBlockIndex* tip, const CBlockIndex* blockindex, bool txDetails = false) LOCKS_EXCLUDED(cs_main);[m
 [m
 /** Mempool information to JSON */[m
 UniValue MempoolInfoToJSON(const CTxMemPool& pool);[m
[33mdiff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp[m
[33mindex 27cbb3a702..21bcab84ef 100644[m
[33m--- a/src/rpc/mining.cpp[m
[33m+++ b/src/rpc/mining.cpp[m
[36m@@ -839,9 +839,10 @@[m [mstatic RPCHelpMan getblocktemplate()[m
     }[m
 [m
     UniValue vbavailable(UniValue::VOBJ);[m
[32m+[m[32m    VersionBitsCache& versionbitscache = chainman.m_blockman.versionbitscache;[m
     for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {[m
         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);[m
[31m-        ThresholdState state = g_versionbitscache.State(pindexPrev, consensusParams, pos);[m
[32m+[m[32m        ThresholdState state = versionbitscache.State(pindexPrev, consensusParams, pos);[m
         switch (state) {[m
             case ThresholdState::DEFINED:[m
             case ThresholdState::FAILED:[m
[36m@@ -849,7 +850,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
                 break;[m
             case ThresholdState::LOCKED_IN:[m
                 // Ensure bit is set in block version[m
[31m-                pblock->nVersion |= g_versionbitscache.Mask(consensusParams, pos);[m
[32m+[m[32m                pblock->nVersion |= versionbitscache.Mask(consensusParams, pos);[m
                 [[fallthrough]];[m
             case ThresholdState::STARTED:[m
             {[m
[36m@@ -858,7 +859,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
                 if (setClientRules.find(vbinfo.name) == setClientRules.end()) {[m
                     if (!vbinfo.gbt_force) {[m
                         // If the client doesn't support this, don't indicate it in the [default] version[m
[31m-                        pblock->nVersion &= ~g_versionbitscache.Mask(consensusParams, pos);[m
[32m+[m[32m                        pblock->nVersion &= ~versionbitscache.Mask(consensusParams, pos);[m
                     }[m
                 }[m
                 break;[m
[33mdiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp[m
[33mindex ba6b3e32ea..4e9212a548 100644[m
[33m--- a/src/test/util/setup_common.cpp[m
[33m+++ b/src/test/util/setup_common.cpp[m
[36m@@ -163,10 +163,8 @@[m [mChainTestingSetup::~ChainTestingSetup()[m
     m_node.banman.reset();[m
     m_node.addrman.reset();[m
     m_node.args = nullptr;[m
[31m-    UnloadBlockIndex(m_node.mempool.get(), *m_node.chainman);[m
     m_node.mempool.reset();[m
     m_node.scheduler.reset();[m
[31m-    m_node.chainman->Reset();[m
     m_node.chainman.reset();[m
 }[m
 [m
[33mdiff --git a/src/test/validation_chainstate_tests.cpp b/src/test/validation_chainstate_tests.cpp[m
[33mindex 315ef22599..659d5e623d 100644[m
[33m--- a/src/test/validation_chainstate_tests.cpp[m
[33m+++ b/src/test/validation_chainstate_tests.cpp[m
[36m@@ -13,15 +13,14 @@[m
 [m
 #include <boost/test/unit_test.hpp>[m
 [m
[31m-BOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, TestingSetup)[m
[32m+[m[32mBOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, ChainTestingSetup)[m
 [m
 //! Test resizing coins-related CChainState caches during runtime.[m
 //![m
 BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)[m
 {[m
[31m-    ChainstateManager manager;[m
[31m-    WITH_LOCK(::cs_main, manager.m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(1 << 20, true));[m
[31m-    CTxMemPool mempool;[m
[32m+[m[32m    ChainstateManager& manager = *m_node.chainman;[m
[32m+[m[32m    CTxMemPool& mempool = *m_node.mempool;[m
 [m
     //! Create and add a Coin with DynamicMemoryUsage of 80 bytes to the given view.[m
     auto add_coin = [](CCoinsViewCache& coins_view) -> COutPoint {[m
[36m@@ -39,11 +38,14 @@[m [mBOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)[m
     CChainState& c1 = WITH_LOCK(cs_main, return manager.InitializeChainstate(&mempool));[m
     c1.InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
[31m-    WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));[m
 [m
     // Add a coin to the in-memory cache, upsize once, then downsize.[m
     {[m
         LOCK(::cs_main);[m
[32m+[m
[32m+[m[32m        c1.InitCoinsCache(1 << 23);[m
[32m+[m[32m        BOOST_REQUIRE(c1.LoadGenesisBlock());[m
[32m+[m
         auto outpoint = add_coin(c1.CoinsTip());[m
 [m
         // Set a meaningless bestblock value in the coinsview cache - otherwise we won't[m
[36m@@ -68,9 +70,6 @@[m [mBOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)[m
         // The view cache should be empty since we had to destruct to downsize.[m
         BOOST_CHECK(!c1.CoinsTip().HaveCoinInCache(outpoint));[m
     }[m
[31m-[m
[31m-    // Avoid triggering the address sanitizer.[m
[31m-    WITH_LOCK(::cs_main, manager.Unload());[m
 }[m
 [m
 BOOST_AUTO_TEST_SUITE_END()[m
[33mdiff --git a/src/test/validation_chainstatemanager_tests.cpp b/src/test/validation_chainstatemanager_tests.cpp[m
[33mindex 0bd378631b..0e8a116caa 100644[m
[33m--- a/src/test/validation_chainstatemanager_tests.cpp[m
[33m+++ b/src/test/validation_chainstatemanager_tests.cpp[m
[36m@@ -111,8 +111,6 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
 [m
     // Let scheduler events finish running to avoid accessing memory that is going to be unloaded[m
     SyncWithValidationInterfaceQueue();[m
[31m-[m
[31m-    WITH_LOCK(::cs_main, manager.Unload());[m
 }[m
 [m
 //! Test rebalancing the caches associated with each chainstate.[m
[33mdiff --git a/src/test/versionbits_tests.cpp b/src/test/versionbits_tests.cpp[m
[33mindex 690031cdc1..94a277fac6 100644[m
[33m--- a/src/test/versionbits_tests.cpp[m
[33m+++ b/src/test/versionbits_tests.cpp[m
[36m@@ -257,10 +257,10 @@[m [mBOOST_AUTO_TEST_CASE(versionbits_test)[m
 }[m
 [m
 /** Check that ComputeBlockVersion will set the appropriate bit correctly */[m
[31m-static void check_computeblockversion(const Consensus::Params& params, Consensus::DeploymentPos dep)[m
[32m+[m[32mstatic void check_computeblockversion(const Consensus::Params& params, Consensus::DeploymentPos dep, VersionBitsCache& versionbitscache)[m
 {[m
[31m-    // This implicitly uses g_versionbitscache, so clear it every time[m
[31m-    g_versionbitscache.Clear();[m
[32m+[m[32m    // This implicitly uses versionbitscache, so clear it every time[m
[32m+[m[32m    versionbitscache.Clear();[m
 [m
     int64_t bit = params.vDeployments[dep].bit;[m
     int64_t nStartTime = params.vDeployments[dep].nStartTime;[m
[36m@@ -268,7 +268,7 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
     int min_activation_height = params.vDeployments[dep].min_activation_height;[m
 [m
     // should not be any signalling for first block[m
[31m-    BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(nullptr, params), VERSIONBITS_TOP_BITS);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(nullptr, params), VERSIONBITS_TOP_BITS);[m
 [m
     // always/never active deployments shouldn't need to be tested further[m
     if (nStartTime == Consensus::BIP9Deployment::ALWAYS_ACTIVE ||[m
[36m@@ -288,7 +288,7 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
     // Check min_activation_height is on a retarget boundary[m
     BOOST_REQUIRE_EQUAL(min_activation_height % params.nMinerConfirmationWindow, 0U);[m
 [m
[31m-    const uint32_t bitmask{g_versionbitscache.Mask(params, dep)};[m
[32m+[m[32m    const uint32_t bitmask{versionbitscache.Mask(params, dep)};[m
     BOOST_CHECK_EQUAL(bitmask, uint32_t{1} << bit);[m
 [m
     // In the first chain, test that the bit is set by CBV until it has failed.[m
[36m@@ -307,9 +307,9 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
         // earlier time, so will transition from DEFINED to STARTED at the[m
         // end of the first period by mining blocks at nTime == 0[m
         lastBlock = firstChain.Mine(params.nMinerConfirmationWindow - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
[32m+[m[32m        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
         lastBlock = firstChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-        BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m        BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
         // then we'll keep mining at nStartTime...[m
     } else {[m
         // use a time 1s earlier than start time to check we stay DEFINED[m
[36m@@ -317,28 +317,28 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
 [m
         // Start generating blocks before nStartTime[m
         lastBlock = firstChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
[32m+[m[32m        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
 [m
         // Mine more blocks (4 less than the adjustment period) at the old time, and check that CBV isn't setting the bit yet.[m
         for (uint32_t i = 1; i < params.nMinerConfirmationWindow - 4; i++) {[m
             lastBlock = firstChain.Mine(params.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-            BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
[32m+[m[32m            BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
         }[m
         // Now mine 5 more blocks at the start time -- MTP should not have passed yet, so[m
         // CBV should still not yet set the bit.[m
         nTime = nStartTime;[m
         for (uint32_t i = params.nMinerConfirmationWindow - 4; i <= params.nMinerConfirmationWindow; i++) {[m
             lastBlock = firstChain.Mine(params.nMinerConfirmationWindow + i, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-            BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
[32m+[m[32m            BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
         }[m
         // Next we will advance to the next period and transition to STARTED,[m
     }[m
 [m
     lastBlock = firstChain.Mine(params.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
     // so ComputeBlockVersion should now set the bit,[m
[31m-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
     // and should also be using the VERSIONBITS_TOP_BITS.[m
[31m-    BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);[m
 [m
     // Check that ComputeBlockVersion will set the bit until nTimeout[m
     nTime += 600;[m
[36m@@ -347,8 +347,8 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
     // These blocks are all before nTimeout is reached.[m
     while (nTime < nTimeout && blocksToMine > 0) {[m
         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-        BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[31m-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);[m
[32m+[m[32m        BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & VERSIONBITS_TOP_MASK, VERSIONBITS_TOP_BITS);[m
         blocksToMine--;[m
         nTime += 600;[m
         nHeight += 1;[m
[36m@@ -362,7 +362,7 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
         // finish the last period before we start timing out[m
         while (nHeight % params.nMinerConfirmationWindow != 0) {[m
             lastBlock = firstChain.Mine(nHeight+1, nTime - 1, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-            BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m            BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
             nHeight += 1;[m
         }[m
 [m
[36m@@ -370,12 +370,12 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
         // the bit until the period transition.[m
         for (uint32_t i = 0; i < params.nMinerConfirmationWindow - 1; i++) {[m
             lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-            BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m            BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
             nHeight += 1;[m
         }[m
         // The next block should trigger no longer setting the bit.[m
         lastBlock = firstChain.Mine(nHeight+1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-        BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
[32m+[m[32m        BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
     }[m
 [m
     // On a new chain:[m
[36m@@ -386,34 +386,36 @@[m [mstatic void check_computeblockversion(const Consensus::Params& params, Consensus[m
     // Mine one period worth of blocks, and check that the bit will be on for the[m
     // next period.[m
     lastBlock = secondChain.Mine(params.nMinerConfirmationWindow, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
 [m
     // Mine another period worth of blocks, signaling the new bit.[m
     lastBlock = secondChain.Mine(params.nMinerConfirmationWindow * 2, nTime, VERSIONBITS_TOP_BITS | (1<<bit)).Tip();[m
     // After one period of setting the bit on each block, it should have locked in.[m
     // We keep setting the bit for one more period though, until activation.[m
[31m-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
 [m
     // Now check that we keep mining the block until the end of this period, and[m
     // then stop at the beginning of the next period.[m
     lastBlock = secondChain.Mine((params.nMinerConfirmationWindow * 3) - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-    BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m    BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
     lastBlock = secondChain.Mine(params.nMinerConfirmationWindow * 3, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
 [m
     if (lastBlock->nHeight + 1 < min_activation_height) {[m
         // check signalling continues while min_activation_height is not reached[m
         lastBlock = secondChain.Mine(min_activation_height - 1, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
[31m-        BOOST_CHECK((g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
[32m+[m[32m        BOOST_CHECK((versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit)) != 0);[m
         // then reach min_activation_height, which was already REQUIRE'd to start a new period[m
         lastBlock = secondChain.Mine(min_activation_height, nTime, VERSIONBITS_LAST_OLD_BLOCK_VERSION).Tip();[m
     }[m
 [m
     // Check that we don't signal after activation[m
[31m-    BOOST_CHECK_EQUAL(g_versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(versionbitscache.ComputeBlockVersion(lastBlock, params) & (1 << bit), 0);[m
 }[m
 [m
 BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)[m
 {[m
[32m+[m[32m    VersionBitsCache& versionbitscache = WITH_LOCK(::cs_main, return std::ref(m_node.chainman->m_blockman.versionbitscache));[m
[32m+[m
     // check that any deployment on any chain can conceivably reach both[m
     // ACTIVE and FAILED states in roughly the way we expect[m
     for (const auto& chain_name : {CBaseChainParams::MAIN, CBaseChainParams::TESTNET, CBaseChainParams::SIGNET, CBaseChainParams::REGTEST}) {[m
[36m@@ -426,10 +428,10 @@[m [mBOOST_AUTO_TEST_CASE(versionbits_computeblockversion)[m
             // not take precedence over STARTED/LOCKED_IN. So all softforks on[m
             // the same bit might overlap, even when non-overlapping start-end[m
             // times are picked.[m
[31m-            const uint32_t dep_mask{g_versionbitscache.Mask(chainParams->GetConsensus(), dep)};[m
[32m+[m[32m            const uint32_t dep_mask{versionbitscache.Mask(chainParams->GetConsensus(), dep)};[m
             BOOST_CHECK(!(chain_all_vbits & dep_mask));[m
             chain_all_vbits |= dep_mask;[m
[31m-            check_computeblockversion(chainParams->GetConsensus(), dep);[m
[32m+[m[32m            check_computeblockversion(chainParams->GetConsensus(), dep, versionbitscache);[m
         }[m
     }[m
 [m
[36m@@ -439,7 +441,7 @@[m [mBOOST_AUTO_TEST_CASE(versionbits_computeblockversion)[m
         ArgsManager args;[m
         args.ForceSetArg("-vbparams", "testdummy:1199145601:1230767999"); // January 1, 2008 - December 31, 2008[m
         const auto chainParams = CreateChainParams(args, CBaseChainParams::REGTEST);[m
[31m-        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY);[m
[32m+[m[32m        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY, versionbitscache);[m
     }[m
 [m
     {[m
[36m@@ -449,7 +451,7 @@[m [mBOOST_AUTO_TEST_CASE(versionbits_computeblockversion)[m
         ArgsManager args;[m
         args.ForceSetArg("-vbparams", "testdummy:1199145601:1230767999:403200"); // January 1, 2008 - December 31, 2008, min act height 403200[m
         const auto chainParams = CreateChainParams(args, CBaseChainParams::REGTEST);[m
[31m-        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY);[m
[32m+[m[32m        check_computeblockversion(chainParams->GetConsensus(), Consensus::DEPLOYMENT_TESTDUMMY, versionbitscache);[m
     }[m
 }[m
 [m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex 8696f1af85..cb6043f1f9 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -115,7 +115,6 @@[m [mbool CBlockIndexWorkComparator::operator()(const CBlockIndex *pa, const CBlockIn[m
  */[m
 RecursiveMutex cs_main;[m
 [m
[31m-CBlockIndex *pindexBestHeader = nullptr;[m
 Mutex g_best_block_mutex;[m
 std::condition_variable g_best_block_cv;[m
 uint256 g_best_block;[m
[36m@@ -130,26 +129,11 @@[m [marith_uint256 nMinimumChainWork;[m
 [m
 CFeeRate minRelayTxFee = CFeeRate(DEFAULT_MIN_RELAY_TX_FEE);[m
 [m
[31m-// Internal stuff[m
[31m-namespace {[m
[2m-    CBlockIndex* pindexBestInvalid = nullptr;[m
[31m-} // namespace[m
[31m-[m
[31m-// Internal stuff from blockstorage ...[m
[31m-extern RecursiveMutex cs_LastBlockFile;[m
[31m-extern std::vector<CBlockFileInfo> vinfoBlockFile;[m
[31m-extern int nLastBlockFile;[m
[31m-extern bool fCheckForPruning;[m
[31m-extern std::set<CBlockIndex*> setDirtyBlockIndex;[m
[31m-extern std::set<int> setDirtyFileInfo;[m
[31m-void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);[m
[31m-// ... TODO move fully to blockstorage[m
[31m-[m
[31m-CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const[m
[32m+[m[32mCBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash)[m
 {[m
     AssertLockHeld(cs_main);[m
[31m-    BlockMap::const_iterator it = m_block_index.find(hash);[m
[31m-    return it == m_block_index.end() ? nullptr : it->second;[m
[32m+[m[32m    BlockMap::iterator it = m_block_index.find(hash);[m
[32m+[m[32m    return it == m_block_index.end() ? nullptr : &it->second;[m
 }[m
 [m
 CBlockIndex* BlockManager::FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)[m
[36m@@ -300,7 +284,7 @@[m [mbool CheckSequenceLocks(CBlockIndex* tip,[m
 }[m
 [m
 // Returns the script flags which should be checked for a given block[m
[31m-static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);[m
[32m+[m[32mstatic unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams, VersionBitsCache& versionbitscache);[m
 [m
 static void LimitMempoolSize(CTxMemPool& pool, CCoinsViewCache& coins_cache, size_t limit, std::chrono::seconds age)[m
     EXCLUSIVE_LOCKS_REQUIRED(pool.cs, ::cs_main)[m
[36m@@ -323,7 +307,7 @@[m [mstatic bool IsCurrentForFeeEstimation(CChainState& active_chainstate) EXCLUSIVE_[m
         return false;[m
     if (active_chainstate.m_chain.Tip()->GetBlockTime() < count_seconds(GetTime<std::chrono::seconds>() - MAX_FEE_ESTIMATION_TIP_AGE))[m
         return false;[m
[31m-    if (active_chainstate.m_chain.Height() < pindexBestHeader->nHeight - 1)[m
[32m+[m[32m    if (active_chainstate.m_chain.Height() < active_chainstate.m_blockman.pindexBestHeader->nHeight - 1)[m
         return false;[m
     return true;[m
 }[m
[36m@@ -669,7 +653,7 @@[m [mbool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)[m
     }[m
 [m
     // Check for non-standard pay-to-script-hash in inputs[m
[31m-    const bool taproot_active = DeploymentActiveAfter(m_active_chainstate.m_chain.Tip(), args.m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_TAPROOT);[m
[32m+[m[32m    const bool taproot_active = DeploymentActiveAfter(m_active_chainstate.m_chain.Tip(), args.m_chainparams.GetConsensus(), Consensus::DEPLOYMENT_TAPROOT, m_active_chainstate.m_blockman.versionbitscache);[m
     if (fRequireStandard && !AreInputsStandard(tx, m_view, taproot_active)) {[m
         return state.Invalid(TxValidationResult::TX_INPUTS_NOT_STANDARD, "bad-txns-nonstandard-inputs");[m
     }[m
[36m@@ -858,7 +842,7 @@[m [mbool MemPoolAccept::ConsensusScriptChecks(const ATMPArgs& args, Workspace& ws, P[m
     // There is a similar check in CreateNewBlock() to prevent creating[m
     // invalid blocks (using TestBlockValidity), however allowing such[m
     // transactions into the mempool can be exploited as a DoS attack.[m
[31m-    unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(m_active_chainstate.m_chain.Tip(), chainparams.GetConsensus());[m
[32m+[m[32m    unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(m_active_chainstate.m_chain.Tip(), chainparams.GetConsensus(), m_active_chainstate.m_blockman.versionbitscache);[m
     if (!CheckInputsFromMempoolAndCache(tx, state, m_view, m_pool, currentBlockScriptVerifyFlags, txdata, m_active_chainstate.CoinsTip())) {[m
         return error("%s: BUG! PLEASE REPORT THIS! CheckInputScripts failed against latest-block but not STANDARD flags %s, %s",[m
                 __func__, hash.ToString(), state.ToString());[m
[36m@@ -1174,7 +1158,7 @@[m [mvoid CChainState::CheckForkWarningConditions()[m
         return;[m
     }[m
 [m
[31m-    if (pindexBestInvalid && pindexBestInvalid->nChainWork > m_chain.Tip()->nChainWork + (GetBlockProof(*m_chain.Tip()) * 6)) {[m
[32m+[m[32m    if (m_blockman.pindexBestInvalid && m_blockman.pindexBestInvalid->nChainWork > m_chain.Tip()->nChainWork + (GetBlockProof(*m_chain.Tip()) * 6)) {[m
         LogPrintf("%s: Warning: Found invalid chain at least ~6 blocks longer than our best chain.\nChain state database corruption likely.\n", __func__);[m
         SetfLargeWorkInvalidChainFound(true);[m
     } else {[m
[36m@@ -1185,10 +1169,10 @@[m [mvoid CChainState::CheckForkWarningConditions()[m
 // Called both upon regular invalid block discovery *and* InvalidateBlock[m
 void CChainState::InvalidChainFound(CBlockIndex* pindexNew)[m
 {[m
[31m-    if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)[m
[31m-        pindexBestInvalid = pindexNew;[m
[31m-    if (pindexBestHeader != nullptr && pindexBestHeader->GetAncestor(pindexNew->nHeight) == pindexNew) {[m
[31m-        pindexBestHeader = m_chain.Tip();[m
[32m+[m[32m    if (!m_blockman.pindexBestInvalid || pindexNew->nChainWork > m_blockman.pindexBestInvalid->nChainWork)[m
[32m+[m[32m        m_blockman.pindexBestInvalid = pindexNew;[m
[32m+[m[32m    if (m_blockman.pindexBestHeader != nullptr && m_blockman.pindexBestHeader->GetAncestor(pindexNew->nHeight) == pindexNew) {[m
[32m+[m[32m        m_blockman.pindexBestHeader = m_chain.Tip();[m
     }[m
 [m
     LogPrintf("%s: invalid block=%s  height=%d  log2_work=%f  date=%s\n", __func__,[m
[36m@@ -1209,7 +1193,7 @@[m [mvoid CChainState::InvalidBlockFound(CBlockIndex* pindex, const BlockValidationSt[m
     if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {[m
         pindex->nStatus |= BLOCK_FAILED_VALID;[m
         m_blockman.m_failed_blocks.insert(pindex);[m
[31m-        setDirtyBlockIndex.insert(pindex);[m
[32m+[m[32m        m_blockman.setDirtyBlockIndex.insert(pindex);[m
         setBlockIndexCandidates.erase(pindex);[m
         InvalidChainFound(pindex);[m
     }[m
[36m@@ -1495,9 +1479,10 @@[m [mclass WarningBitsConditionChecker : public AbstractThresholdConditionChecker[m
 {[m
 private:[m
     int bit;[m
[32m+[m[32m    VersionBitsCache& m_versionbitscache;[m
 [m
 public:[m
[31m-    explicit WarningBitsConditionChecker(int bitIn) : bit(bitIn) {}[m
[32m+[m[32m    explicit WarningBitsConditionChecker(int bitIn, VersionBitsCache& versionbitscache) : bit(bitIn), m_versionbitscache(versionbitscache) {}[m
 [m
     int64_t BeginTime(const Consensus::Params& params) const override { return 0; }[m
     int64_t EndTime(const Consensus::Params& params) const override { return std::numeric_limits<int64_t>::max(); }[m
[36m@@ -1509,13 +1494,11 @@[m [mpublic:[m
         return pindex->nHeight >= params.MinBIP9WarningHeight &&[m
                ((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) &&[m
                ((pindex->nVersion >> bit) & 1) != 0 &&[m
[31m-               ((g_versionbitscache.ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;[m
[32m+[m[32m               ((m_versionbitscache.ComputeBlockVersion(pindex->pprev, params) >> bit) & 1) == 0;[m
     }[m
 };[m
 [m
[31m-static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS] GUARDED_BY(cs_main);[m
[31m-[m
[31m-static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams)[m
[32m+[m[32mstatic unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams, VersionBitsCache& versionbitscache)[m
 {[m
     unsigned int flags = SCRIPT_VERIFY_NONE;[m
 [m
[36m@@ -1548,7 +1531,7 @@[m [mstatic unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens[m
     }[m
 [m
     // Enforce Taproot (BIP340-BIP342)[m
[31m-    if (DeploymentActiveAt(*pindex, consensusparams, Consensus::DEPLOYMENT_TAPROOT)) {[m
[32m+[m[32m    if (DeploymentActiveAt(*pindex, consensusparams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache)) {[m
         flags |= SCRIPT_VERIFY_TAPROOT;[m
     }[m
 [m
[36m@@ -1628,9 +1611,9 @@[m [mbool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,[m
         //  effectively caching the result of part of the verification.[m
         BlockMap::const_iterator  it = m_blockman.m_block_index.find(hashAssumeValid);[m
         if (it != m_blockman.m_block_index.end()) {[m
[31m-            if (it->second->GetAncestor(pindex->nHeight) == pindex &&[m
[31m-                pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&[m
[31m-                pindexBestHeader->nChainWork >= nMinimumChainWork) {[m
[32m+[m[32m            if (it->second.GetAncestor(pindex->nHeight) == pindex &&[m
[32m+[m[32m                m_blockman.pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&[m
[32m+[m[32m                m_blockman.pindexBestHeader->nChainWork >= nMinimumChainWork) {[m
                 // This block is a member of the assumed verified chain and an ancestor of the best header.[m
                 // Script verification is skipped when connecting blocks under the[m
                 // assumevalid block. Assuming the assumevalid block is valid this[m
[36m@@ -1645,7 +1628,7 @@[m [mbool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,[m
                 //  artificially set the default assumed verified block further back.[m
                 // The test against nMinimumChainWork prevents the skipping when denied access to any chain at[m
                 //  least as good as the expected chain.[m
[31m-                fScriptChecks = (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_params.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);[m
[32m+[m[32m                fScriptChecks = (GetBlockProofEquivalentTime(*m_blockman.pindexBestHeader, *pindex, *m_blockman.pindexBestHeader, m_params.GetConsensus()) <= 60 * 60 * 24 * 7 * 2);[m
             }[m
         }[m
     }[m
[36m@@ -1750,7 +1733,7 @@[m [mbool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,[m
     }[m
 [m
     // Get the script flags for this block[m
[31m-    unsigned int flags = GetBlockScriptFlags(pindex, m_params.GetConsensus());[m
[32m+[m[32m    unsigned int flags = GetBlockScriptFlags(pindex, m_params.GetConsensus(), m_blockman.versionbitscache);[m
 [m
     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;[m
     LogPrint(BCLog::BENCH, "    - Fork checks: %.2fms [%.2fs (%.2fms/blk)]\n", MILLI * (nTime2 - nTime1), nTimeForks * MICRO, nTimeForks * MILLI / nBlocksTotal);[m
[36m@@ -1856,13 +1839,13 @@[m [mbool CChainState::ConnectBlock(const CBlock& block, BlockValidationState& state,[m
     if (fJustCheck)[m
         return true;[m
 [m
[31m-    if (!WriteUndoDataForBlock(blockundo, state, pindex, m_params)) {[m
[32m+[m[32m    if (!m_blockman.WriteUndoDataForBlock(blockundo, state, pindex, m_params)) {[m
         return false;[m
     }[m
 [m
     if (!pindex->IsValid(BLOCK_VALID_SCRIPTS)) {[m
         pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);[m
[31m-        setDirtyBlockIndex.insert(pindex);[m
[32m+[m[32m        m_blockman.setDirtyBlockIndex.insert(pindex);[m
     }[m
 [m
     assert(pindex->phashBlock);[m
[36m@@ -1939,8 +1922,8 @@[m [mbool CChainState::FlushStateToDisk([m
         bool fDoFullFlush = false;[m
 [m
         CoinsCacheSizeState cache_state = GetCoinsCacheSizeState();[m
[31m-        LOCK(cs_LastBlockFile);[m
[31m-        if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {[m
[32m+[m[32m        LOCK(m_blockman.cs_blockfiles);[m
[32m+[m[32m        if (fPruneMode && (m_blockman.fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {[m
             // make sure we don't prune above the blockfilterindexes bestblocks[m
             // pruning is height-based[m
             int last_prune = m_chain.Height(); // last height we can prune[m
[36m@@ -1956,13 +1939,13 @@[m [mbool CChainState::FlushStateToDisk([m
                 LOG_TIME_MILLIS_WITH_CATEGORY("find files to prune", BCLog::BENCH);[m
 [m
                 m_blockman.FindFilesToPrune(setFilesToPrune, m_params.PruneAfterHeight(), m_chain.Height(), last_prune, IsInitialBlockDownload());[m
[31m-                fCheckForPruning = false;[m
[32m+[m[32m                m_blockman.fCheckForPruning = false;[m
             }[m
             if (!setFilesToPrune.empty()) {[m
                 fFlushForPrune = true;[m
[31m-                if (!fHavePruned) {[m
[32m+[m[32m                if (!m_blockman.fHavePruned) {[m
                     m_blockman.m_block_tree_db->WriteFlag("prunedblockfiles", true);[m
[31m-                    fHavePruned = true;[m
[32m+[m[32m                    m_blockman.fHavePruned = true;[m
                 }[m
             }[m
         }[m
[36m@@ -1994,7 +1977,7 @@[m [mbool CChainState::FlushStateToDisk([m
                 LOG_TIME_MILLIS_WITH_CATEGORY("write block and undo data to disk", BCLog::BENCH);[m
 [m
                 // First make sure all block and undo data is flushed to disk.[m
[31m-                FlushBlockFile();[m
[32m+[m[32m                m_blockman.FlushBlockFile();[m
             }[m
 [m
             // Then update all block file information (which may refer to block and undo files).[m
[36m@@ -2002,18 +1985,18 @@[m [mbool CChainState::FlushStateToDisk([m
                 LOG_TIME_MILLIS_WITH_CATEGORY("write block index to disk", BCLog::BENCH);[m
 [m
                 std::vector<std::pair<int, const CBlockFileInfo*> > vFiles;[m
[31m-                vFiles.reserve(setDirtyFileInfo.size());[m
[31m-                for (std::set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {[m
[31m-                    vFiles.push_back(std::make_pair(*it, &vinfoBlockFile[*it]));[m
[31m-                    setDirtyFileInfo.erase(it++);[m
[32m+[m[32m                vFiles.reserve(m_blockman.setDirtyFileInfo.size());[m
[32m+[m[32m                for (std::set<int>::iterator it = m_blockman.setDirtyFileInfo.begin(); it != m_blockman.setDirtyFileInfo.end(); ) {[m
[32m+[m[32m                    vFiles.push_back(std::make_pair(*it, &m_blockman.vinfoBlockFile[*it]));[m
[32m+[m[32m                    m_blockman.setDirtyFileInfo.erase(it++);[m
                 }[m
                 std::vector<const CBlockIndex*> vBlocks;[m
[31m-                vBlocks.reserve(setDirtyBlockIndex.size());[m
[31m-                for (std::set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {[m
[32m+[m[32m                vBlocks.reserve(m_blockman.setDirtyBlockIndex.size());[m
[32m+[m[32m                for (std::set<CBlockIndex*>::iterator it = m_blockman.setDirtyBlockIndex.begin(); it != m_blockman.setDirtyBlockIndex.end(); ) {[m
                     vBlocks.push_back(*it);[m
[31m-                    setDirtyBlockIndex.erase(it++);[m
[32m+[m[32m                    m_blockman.setDirtyBlockIndex.erase(it++);[m
                 }[m
[31m-                if (!m_blockman.m_block_tree_db->WriteBatchSync(vFiles, nLastBlockFile, vBlocks)) {[m
[32m+[m[32m                if (!m_blockman.m_block_tree_db->WriteBatchSync(vFiles, m_blockman.nLastBlockFile, vBlocks)) {[m
                     return AbortNode(state, "Failed to write to block index database");[m
                 }[m
             }[m
[36m@@ -2066,7 +2049,10 @@[m [mvoid CChainState::ForceFlushStateToDisk()[m
 void CChainState::PruneAndFlush()[m
 {[m
     BlockValidationState state;[m
[31m-    fCheckForPruning = true;[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(m_blockman.cs_blockfiles);[m
[32m+[m[32m        m_blockman.fCheckForPruning = true;[m
[32m+[m[32m    }[m
     if (!this->FlushStateToDisk(state, FlushStateMode::NONE)) {[m
         LogPrintf("%s: failed to flush state (%s)\n", __func__, state.ToString());[m
     }[m
[36m@@ -2106,8 +2092,8 @@[m [mvoid CChainState::UpdateTip(const CBlockIndex* pindexNew)[m
     if (!this->IsInitialBlockDownload()) {[m
         const CBlockIndex* pindex = pindexNew;[m
         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {[m
[31m-            WarningBitsConditionChecker checker(bit);[m
[31m-            ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), warningcache[bit]);[m
[32m+[m[32m            WarningBitsConditionChecker checker(bit, m_blockman.versionbitscache);[m
[32m+[m[32m            ThresholdState state = checker.GetStateFor(pindex, m_params.GetConsensus(), m_blockman.warningcache.at(bit));[m
             if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {[m
                 const bilingual_str warning = strprintf(_("Unknown new rules activated (versionbit %i)"), bit);[m
                 if (state == ThresholdState::ACTIVE) {[m
[36m@@ -2333,8 +2319,8 @@[m [mCBlockIndex* CChainState::FindMostWorkChain() {[m
             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);[m
             if (fFailedChain || fMissingData) {[m
                 // Candidate chain is not usable (either invalid or missing data)[m
[31m-                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))[m
[31m-                    pindexBestInvalid = pindexNew;[m
[32m+[m[32m                if (fFailedChain && (m_blockman.pindexBestInvalid == nullptr || pindexNew->nChainWork > m_blockman.pindexBestInvalid->nChainWork))[m
[32m+[m[32m                    m_blockman.pindexBestInvalid = pindexNew;[m
                 CBlockIndex *pindexFailed = pindexNew;[m
                 // Remove the entire chain from the set.[m
                 while (pindexTest != pindexFailed) {[m
[36m@@ -2478,7 +2464,7 @@[m [mstatic bool NotifyHeaderTip(CChainState& chainstate) LOCKS_EXCLUDED(cs_main) {[m
     CBlockIndex* pindexHeader = nullptr;[m
     {[m
         LOCK(cs_main);[m
[31m-        pindexHeader = pindexBestHeader;[m
[32m+[m[32m        pindexHeader = chainstate.m_blockman.pindexBestHeader;[m
 [m
         if (pindexHeader != pindexHeaderOld) {[m
             fNotify = true;[m
[36m@@ -2656,8 +2642,8 @@[m [mbool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind[m
 [m
     {[m
         LOCK(cs_main);[m
[31m-        for (const auto& entry : m_blockman.m_block_index) {[m
[31m-            CBlockIndex *candidate = entry.second;[m
[32m+[m[32m        for (auto& entry : m_blockman.m_block_index) {[m
[32m+[m[32m            CBlockIndex *candidate = &entry.second;[m
             // We don't need to put anything in our active chain into the[m
             // multimap, because those candidates will be found and considered[m
             // as we disconnect.[m
[36m@@ -2706,14 +2692,14 @@[m [mbool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind[m
         // are no blocks that meet the "have data and are not invalid per[m
         // nStatus" criteria for inclusion in setBlockIndexCandidates).[m
         invalid_walk_tip->nStatus |= BLOCK_FAILED_VALID;[m
[31m-        setDirtyBlockIndex.insert(invalid_walk_tip);[m
[32m+[m[32m        m_blockman.setDirtyBlockIndex.insert(invalid_walk_tip);[m
         setBlockIndexCandidates.erase(invalid_walk_tip);[m
         setBlockIndexCandidates.insert(invalid_walk_tip->pprev);[m
         if (invalid_walk_tip->pprev == to_mark_failed && (to_mark_failed->nStatus & BLOCK_FAILED_VALID)) {[m
             // We only want to mark the last disconnected block as BLOCK_FAILED_VALID; its children[m
             // need to be BLOCK_FAILED_CHILD instead.[m
             to_mark_failed->nStatus = (to_mark_failed->nStatus ^ BLOCK_FAILED_VALID) | BLOCK_FAILED_CHILD;[m
[31m-            setDirtyBlockIndex.insert(to_mark_failed);[m
[32m+[m[32m            m_blockman.setDirtyBlockIndex.insert(to_mark_failed);[m
         }[m
 [m
         // Add any equal or more work headers to setBlockIndexCandidates[m
[36m@@ -2743,7 +2729,7 @@[m [mbool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind[m
 [m
         // Mark pindex (or the last disconnected block) as invalid, even when it never was in the main chain[m
         to_mark_failed->nStatus |= BLOCK_FAILED_VALID;[m
[31m-        setDirtyBlockIndex.insert(to_mark_failed);[m
[32m+[m[32m        m_blockman.setDirtyBlockIndex.insert(to_mark_failed);[m
         setBlockIndexCandidates.erase(to_mark_failed);[m
         m_blockman.m_failed_blocks.insert(to_mark_failed);[m
 [m
[36m@@ -2756,8 +2742,8 @@[m [mbool CChainState::InvalidateBlock(BlockValidationState& state, CBlockIndex* pind[m
         // to setBlockIndexCandidates.[m
         BlockMap::iterator it = m_blockman.m_block_index.begin();[m
         while (it != m_blockman.m_block_index.end()) {[m
[31m-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {[m
[31m-                setBlockIndexCandidates.insert(it->second);[m
[32m+[m[32m            if (it->second.IsValid(BLOCK_VALID_TRANSACTIONS) && it->second.HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(&it->second, m_chain.Tip())) {[m
[32m+[m[32m                setBlockIndexCandidates.insert(&it->second);[m
             }[m
             it++;[m
         }[m
[36m@@ -2780,17 +2766,17 @@[m [mvoid CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {[m
     // Remove the invalidity flag from this block and all its descendants.[m
     BlockMap::iterator it = m_blockman.m_block_index.begin();[m
     while (it != m_blockman.m_block_index.end()) {[m
[31m-        if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {[m
[31m-            it->second->nStatus &= ~BLOCK_FAILED_MASK;[m
[31m-            setDirtyBlockIndex.insert(it->second);[m
[31m-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {[m
[31m-                setBlockIndexCandidates.insert(it->second);[m
[32m+[m[32m        if (!it->second.IsValid() && it->second.GetAncestor(nHeight) == pindex) {[m
[32m+[m[32m            it->second.nStatus &= ~BLOCK_FAILED_MASK;[m
[32m+[m[32m            m_blockman.setDirtyBlockIndex.insert(&it->second);[m
[32m+[m[32m            if (it->second.IsValid(BLOCK_VALID_TRANSACTIONS) && it->second.HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), &it->second)) {[m
[32m+[m[32m                setBlockIndexCandidates.insert(&it->second);[m
             }[m
[31m-            if (it->second == pindexBestInvalid) {[m
[32m+[m[32m            if (&it->second == m_blockman.pindexBestInvalid) {[m
                 // Reset invalid block marker if it was pointing to one of those.[m
[31m-                pindexBestInvalid = nullptr;[m
[32m+[m[32m                m_blockman.pindexBestInvalid = nullptr;[m
             }[m
[31m-            m_blockman.m_failed_blocks.erase(it->second);[m
[32m+[m[32m            m_blockman.m_failed_blocks.erase(&it->second);[m
         }[m
         it++;[m
     }[m
[36m@@ -2799,7 +2785,7 @@[m [mvoid CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {[m
     while (pindex != nullptr) {[m
         if (pindex->nStatus & BLOCK_FAILED_MASK) {[m
             pindex->nStatus &= ~BLOCK_FAILED_MASK;[m
[31m-            setDirtyBlockIndex.insert(pindex);[m
[32m+[m[32m            m_blockman.setDirtyBlockIndex.insert(pindex);[m
             m_blockman.m_failed_blocks.erase(pindex);[m
         }[m
         pindex = pindex->pprev;[m
[36m@@ -2814,20 +2800,21 @@[m [mCBlockIndex* BlockManager::AddToBlockIndex(const CBlockHeader& block)[m
     uint256 hash = block.GetHash();[m
     BlockMap::iterator it = m_block_index.find(hash);[m
     if (it != m_block_index.end())[m
[31m-        return it->second;[m
[32m+[m[32m        return &it->second;[m
 [m
     // Construct new block index object[m
[31m-    CBlockIndex* pindexNew = new CBlockIndex(block);[m
[32m+[m[32m    CBlockIndex neue(block);[m
     // We assign the sequence id to blocks only when the full data is available,[m
     // to avoid miners withholding blocks but broadcasting headers, to get a[m
     // competitive advantage.[m
[31m-    pindexNew->nSequenceId = 0;[m
[31m-    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;[m
[32m+[m[32m    neue.nSequenceId = 0;[m
[32m+[m[32m    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, std::move(neue))).first;[m
[32m+[m[32m    CBlockIndex* pindexNew = &(*mi).second;[m
     pindexNew->phashBlock = &((*mi).first);[m
     BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);[m
     if (miPrev != m_block_index.end())[m
     {[m
[31m-        pindexNew->pprev = (*miPrev).second;[m
[32m+[m[32m        pindexNew->pprev = &(*miPrev).second;[m
         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;[m
         pindexNew->BuildSkip();[m
     }[m
[36m@@ -2855,7 +2842,7 @@[m [mvoid CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi[m
         pindexNew->nStatus |= BLOCK_OPT_WITNESS;[m
     }[m
     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);[m
[31m-    setDirtyBlockIndex.insert(pindexNew);[m
[32m+[m[32m    m_blockman.setDirtyBlockIndex.insert(pindexNew);[m
 [m
     if (pindexNew->pprev == nullptr || pindexNew->pprev->HaveTxsDownloaded()) {[m
         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.[m
[36m@@ -3170,7 +3157,7 @@[m [mbool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS[m
     if (hash != chainparams.GetConsensus().hashGenesisBlock) {[m
         if (miSelf != m_block_index.end()) {[m
             // Block header is already known.[m
[31m-            CBlockIndex* pindex = miSelf->second;[m
[32m+[m[32m            CBlockIndex* pindex = &(miSelf->second);[m
             if (ppindex)[m
                 *ppindex = pindex;[m
             if (pindex->nStatus & BLOCK_FAILED_MASK) {[m
[36m@@ -3192,7 +3179,7 @@[m [mbool BlockManager::AcceptBlockHeader(const CBlockHeader& block, BlockValidationS[m
             LogPrintf("ERROR: %s: prev block not found\n", __func__);[m
             return state.Invalid(BlockValidationResult::BLOCK_MISSING_PREV, "prev-blk-not-found");[m
         }[m
[31m-        pindexPrev = (*mi).second;[m
[32m+[m[32m        pindexPrev = &((*mi).second);[m
         if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {[m
             LogPrintf("ERROR: %s: prev block invalid\n", __func__);[m
             return state.Invalid(BlockValidationResult::BLOCK_INVALID_PREV, "bad-prevblk");[m
[36m@@ -3328,7 +3315,7 @@[m [mbool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block[m
         !ContextualCheckBlock(block, state, m_params.GetConsensus(), pindex->pprev)) {[m
         if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {[m
             pindex->nStatus |= BLOCK_FAILED_VALID;[m
[31m-            setDirtyBlockIndex.insert(pindex);[m
[32m+[m[32m            m_blockman.setDirtyBlockIndex.insert(pindex);[m
         }[m
         return error("%s: %s", __func__, state.ToString());[m
     }[m
[36m@@ -3341,7 +3328,7 @@[m [mbool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, Block[m
     // Write block to history file[m
     if (fNewBlock) *fNewBlock = true;[m
     try {[m
[31m-        FlatFilePos blockPos = SaveBlockToDisk(block, pindex->nHeight, m_chain, m_params, dbp);[m
[32m+[m[32m        FlatFilePos blockPos = m_blockman.SaveBlockToDisk(block, pindex->nHeight, m_chain, m_params, dbp);[m
         if (blockPos.IsNull()) {[m
             state.Error(strprintf("%s: Failed to find position to write new block to disk", __func__));[m
             return false;[m
[36m@@ -3436,10 +3423,10 @@[m [mbool TestBlockValidity(BlockValidationState& state,[m
 void BlockManager::PruneOneBlockFile(const int fileNumber)[m
 {[m
     AssertLockHeld(cs_main);[m
[31m-    LOCK(cs_LastBlockFile);[m
[32m+[m[32m    LOCK(cs_blockfiles);[m
 [m
[31m-    for (const auto& entry : m_block_index) {[m
[31m-        CBlockIndex* pindex = entry.second;[m
[32m+[m[32m    for (auto& entry : m_block_index) {[m
[32m+[m[32m        CBlockIndex* pindex = &entry.second;[m
         if (pindex->nFile == fileNumber) {[m
             pindex->nStatus &= ~BLOCK_HAVE_DATA;[m
             pindex->nStatus &= ~BLOCK_HAVE_UNDO;[m
[36m@@ -3471,7 +3458,7 @@[m [mvoid BlockManager::FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nM[m
 {[m
     assert(fPruneMode && nManualPruneHeight > 0);[m
 [m
[31m-    LOCK2(cs_main, cs_LastBlockFile);[m
[32m+[m[32m    LOCK2(cs_main, cs_blockfiles);[m
     if (chain_tip_height < 0) {[m
         return;[m
     }[m
[36m@@ -3502,7 +3489,7 @@[m [mvoid PruneBlockFilesManual(CChainState& active_chainstate, int nManualPruneHeigh[m
 [m
 void BlockManager::FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight, int chain_tip_height, int prune_height, bool is_ibd)[m
 {[m
[31m-    LOCK2(cs_main, cs_LastBlockFile);[m
[32m+[m[32m    LOCK2(cs_main, cs_blockfiles);[m
     if (chain_tip_height < 0 || nPruneTarget == 0) {[m
         return;[m
     }[m
[36m@@ -3569,11 +3556,12 @@[m [mCBlockIndex * BlockManager::InsertBlockIndex(const uint256& hash)[m
     // Return existing[m
     BlockMap::iterator mi = m_block_index.find(hash);[m
     if (mi != m_block_index.end())[m
[31m-        return (*mi).second;[m
[32m+[m[32m        return &(*mi).second;[m
 [m
     // Create new[m
[31m-    CBlockIndex* pindexNew = new CBlockIndex();[m
[31m-    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;[m
[32m+[m[32m    CBlockIndex neue;[m
[32m+[m[32m    mi = m_block_index.insert(std::make_pair(hash, std::move(neue))).first;[m
[32m+[m[32m    CBlockIndex* pindexNew = &(*mi).second;[m
     pindexNew->phashBlock = &((*mi).first);[m
 [m
     return pindexNew;[m
[36m@@ -3590,9 +3578,9 @@[m [mbool BlockManager::LoadBlockIndex([m
     // Calculate nChainWork[m
     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;[m
     vSortedByHeight.reserve(m_block_index.size());[m
[31m-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)[m
[32m+[m[32m    for (std::pair<const uint256, CBlockIndex>& item : m_block_index)[m
     {[m
[31m-        CBlockIndex* pindex = item.second;[m
[32m+[m[32m        CBlockIndex* pindex = &item.second;[m
         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));[m
     }[m
     sort(vSortedByHeight.begin(), vSortedByHeight.end());[m
[36m@@ -3634,17 +3622,6 @@[m [mbool BlockManager::LoadBlockIndex([m
     return true;[m
 }[m
 [m
[31m-void BlockManager::Unload() {[m
[31m-    m_failed_blocks.clear();[m
[31m-    m_blocks_unlinked.clear();[m
[31m-[m
[31m-    for (const BlockMap::value_type& entry : m_block_index) {[m
[31m-        delete entry.second;[m
[31m-    }[m
[31m-[m
[31m-    m_block_index.clear();[m
[31m-}[m
[31m-[m
 bool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates)[m
 {[m
     if (!LoadBlockIndex([m
[36m@@ -3653,6 +3630,7 @@[m [mbool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar[m
         return false;[m
     }[m
 [m
[32m+[m[32m    LOCK(cs_blockfiles);[m
     // Load block file info[m
     m_block_tree_db->ReadLastBlockFile(nLastBlockFile);[m
     vinfoBlockFile.resize(nLastBlockFile + 1);[m
[36m@@ -3673,8 +3651,8 @@[m [mbool BlockManager::LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkCompar[m
     // Check presence of blk files[m
     LogPrintf("Checking all blk files are present...\n");[m
     std::set<int> setBlkDataFiles;[m
[31m-    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index) {[m
[31m-        CBlockIndex* pindex = item.second;[m
[32m+[m[32m    for (const std::pair<const uint256, CBlockIndex>& item : m_block_index) {[m
[32m+[m[32m        const CBlockIndex* pindex = &item.second;[m
         if (pindex->nStatus & BLOCK_HAVE_DATA) {[m
             setBlkDataFiles.insert(pindex->nFile);[m
         }[m
[36m@@ -3899,13 +3877,13 @@[m [mbool CChainState::ReplayBlocks()[m
     if (m_blockman.m_block_index.count(hashHeads[0]) == 0) {[m
         return error("ReplayBlocks(): reorganization to unknown block requested");[m
     }[m
[31m-    pindexNew = m_blockman.m_block_index[hashHeads[0]];[m
[32m+[m[32m    pindexNew = &(m_blockman.m_block_index[hashHeads[0]]);[m
 [m
     if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.[m
         if (m_blockman.m_block_index.count(hashHeads[1]) == 0) {[m
             return error("ReplayBlocks(): reorganization from unknown block requested");[m
         }[m
[31m-        pindexOld = m_blockman.m_block_index[hashHeads[1]];[m
[32m+[m[32m        pindexOld = &(m_blockman.m_block_index[hashHeads[1]]);[m
         pindexFork = LastCommonAncestor(pindexOld, pindexNew);[m
         assert(pindexFork != nullptr);[m
     }[m
[36m@@ -3963,32 +3941,6 @@[m [mbool CChainState::NeedsRedownload() const[m
     return false;[m
 }[m
 [m
[31m-void CChainState::UnloadBlockIndex() {[m
[31m-    nBlockSequenceId = 1;[m
[31m-    setBlockIndexCandidates.clear();[m
[31m-}[m
[31m-[m
[31m-// May NOT be used after any connections are up as much[m
[31m-// of the peer-processing logic assumes a consistent[m
[31m-// block index state[m
[31m-void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman)[m
[31m-{[m
[31m-    LOCK(cs_main);[m
[31m-    chainman.Unload();[m
[31m-    pindexBestInvalid = nullptr;[m
[31m-    pindexBestHeader = nullptr;[m
[31m-    if (mempool) mempool->clear();[m
[31m-    vinfoBlockFile.clear();[m
[31m-    nLastBlockFile = 0;[m
[31m-    setDirtyBlockIndex.clear();[m
[31m-    setDirtyFileInfo.clear();[m
[31m-    g_versionbitscache.Clear();[m
[31m-    for (int b = 0; b < VERSIONBITS_NUM_BITS; b++) {[m
[31m-        warningcache[b].clear();[m
[31m-    }[m
[31m-    fHavePruned = false;[m
[31m-}[m
[31m-[m
 bool ChainstateManager::LoadBlockIndex()[m
 {[m
     AssertLockHeld(cs_main);[m
[36m@@ -4025,7 +3977,7 @@[m [mbool CChainState::LoadGenesisBlock()[m
 [m
     try {[m
         const CBlock& block = m_params.GenesisBlock();[m
[31m-        FlatFilePos blockPos = SaveBlockToDisk(block, 0, m_chain, m_params, nullptr);[m
[32m+[m[32m        FlatFilePos blockPos = m_blockman.SaveBlockToDisk(block, 0, m_chain, m_params, nullptr);[m
         if (blockPos.IsNull())[m
             return error("%s: writing genesis block to disk failed", __func__);[m
         CBlockIndex *pindex = m_blockman.AddToBlockIndex(block);[m
[36m@@ -4173,8 +4125,8 @@[m [mvoid CChainState::CheckBlockIndex()[m
 [m
     // Build forward-pointing map of the entire block tree.[m
     std::multimap<CBlockIndex*,CBlockIndex*> forward;[m
[31m-    for (const std::pair<const uint256, CBlockIndex*>& entry : m_blockman.m_block_index) {[m
[31m-        forward.insert(std::make_pair(entry.second->pprev, entry.second));[m
[32m+[m[32m    for (std::pair<const uint256, CBlockIndex>& entry : m_blockman.m_block_index) {[m
[32m+[m[32m        forward.insert(std::make_pair(entry.second.pprev, &entry.second));[m
     }[m
 [m
     assert(forward.size() == m_blockman.m_block_index.size());[m
[36m@@ -4215,7 +4167,7 @@[m [mvoid CChainState::CheckBlockIndex()[m
         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)[m
         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).[m
         // HAVE_DATA is only equivalent to nTx > 0 (or VALID_TRANSACTIONS) if no pruning has occurred.[m
[31m-        if (!fHavePruned) {[m
[32m+[m[32m        if (!m_blockman.fHavePruned) {[m
             // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0[m
             assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));[m
             assert(pindexFirstMissing == pindexFirstNeverProcessed);[m
[36m@@ -4274,7 +4226,7 @@[m [mvoid CChainState::CheckBlockIndex()[m
         if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.[m
         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {[m
             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.[m
[31m-            assert(fHavePruned); // We must have pruned.[m
[32m+[m[32m            assert(m_blockman.fHavePruned); // We must have pruned.[m
             // This block may have entered m_blocks_unlinked if:[m
             //  - it has a descendant that at some point had more work than the[m
             //    tip, and[m
[36m@@ -4898,16 +4850,6 @@[m [mbool ChainstateManager::IsBackgroundIBD(CChainState* chainstate) const[m
     return (m_snapshot_chainstate && chainstate == m_ibd_chainstate.get());[m
 }[m
 [m
[31m-void ChainstateManager::Unload()[m
[31m-{[m
[31m-    for (CChainState* chainstate : this->GetAll()) {[m
[31m-        chainstate->m_chain.SetTip(nullptr);[m
[31m-        chainstate->UnloadBlockIndex();[m
[31m-    }[m
[31m-[m
[31m-    m_blockman.Unload();[m
[31m-}[m
[31m-[m
 void ChainstateManager::Reset()[m
 {[m
     LOCK(::cs_main);[m
[33mdiff --git a/src/validation.h b/src/validation.h[m
[33mindex d4fcac1d48..45fcb39c8d 100644[m
[33m--- a/src/validation.h[m
[33m+++ b/src/validation.h[m
[36m@@ -28,6 +28,7 @@[m
 #include <util/check.h>[m
 #include <util/hasher.h>[m
 #include <util/translation.h>[m
[32m+[m[32m#include <versionbits.h>[m
 [m
 #include <atomic>[m
 #include <map>[m
[36m@@ -106,7 +107,13 @@[m [menum class SynchronizationState {[m
 };[m
 [m
 extern RecursiveMutex cs_main;[m
[31m-typedef std::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;[m
[32m+[m
[32m+[m[32m// Because validation code takes pointers to the map's CBlockIndex objects, if[m
[32m+[m[32m// we ever switch to another associative container, we need to either use a[m
[32m+[m[32m// container that has stable addressing (true of all std associative[m
[32m+[m[32m// containers), or make the key a `std::unique_ptr<CBlockIndex>`[m
[32m+[m[32mtypedef std::unordered_map<uint256, CBlockIndex, BlockHasher> BlockMap;[m
[32m+[m
 extern Mutex g_best_block_mutex;[m
 extern std::condition_variable g_best_block_cv;[m
 extern uint256 g_best_block;[m
[36m@@ -128,14 +135,9 @@[m [mextern uint256 hashAssumeValid;[m
 /** Minimum work we will assume exists on some valid chain. */[m
 extern arith_uint256 nMinimumChainWork;[m
 [m
[31m-/** Best header we've seen so far (used for getheaders queries' starting points). */[m
[31m-extern CBlockIndex *pindexBestHeader;[m
[31m-[m
 /** Documentation for argument 'checklevel'. */[m
 extern const std::vector<std::string> CHECKLEVEL_DOC;[m
 [m
[31m-/** Unload database information */[m
[31m-void UnloadBlockIndex(CTxMemPool* mempool, ChainstateManager& chainman);[m
 /** Run instances of script checking worker threads */[m
 void StartScriptCheckWorkerThreads(int threads_num);[m
 /** Stop all of the script checking worker threads */[m
[36m@@ -430,6 +432,26 @@[m [mpublic:[m
       */[m
     std::set<CBlockIndex*> m_failed_blocks;[m
 [m
[2m+[m[2m    CBlockIndex* pindexBestInvalid = nullptr;[m
[32m+[m
[32m+[m[32m    /** Best header we've seen so far (used for getheaders queries' starting points). */[m
[32m+[m[32m    CBlockIndex *pindexBestHeader = nullptr;[m
[32m+[m
[32m+[m[32m    /** Dirty block index entries. */[m
[32m+[m[32m    std::set<CBlockIndex*> setDirtyBlockIndex;[m
[32m+[m
[32m+[m[32m    /** Dirty block file entries. */[m
[32m+[m[32m    std::set<int> setDirtyFileInfo;[m
[32m+[m
[32m+[m[32m    RecursiveMutex cs_blockfiles;[m
[32m+[m[32m    std::vector<CBlockFileInfo> vinfoBlockFile GUARDED_BY(cs_blockfiles);[m
[32m+[m[32m    int nLastBlockFile GUARDED_BY(cs_blockfiles) = 0;[m
[32m+[m[32m    /** Global flag to indicate we should check to see if there are[m
[32m+[m[32m     *  block/undo files that should be deleted.  Set on startup[m
[32m+[m[32m     *  or if we allocate more file space when we're in prune mode[m
[32m+[m[32m     */[m
[32m+[m[32m    bool fCheckForPruning GUARDED_BY(cs_blockfiles) = false;[m
[32m+[m
     /**[m
      * All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.[m
      * Pruned nodes may have entries where B is missing data.[m
[36m@@ -440,6 +462,9 @@[m [mpublic:[m
 [m
     bool LoadBlockIndexDB(std::set<CBlockIndex*, CBlockIndexWorkComparator>& setBlockIndexCandidates) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
 [m
[32m+[m[32m    /** True if any block files have ever been pruned. */[m
[32m+[m[32m    bool fHavePruned = false;[m
[32m+[m
     /**[m
      * Load the blocktree off disk and into memory. Populate certain metadata[m
      * per index entry (nStatus, nChainWork, nTimeMax, etc.) as well as peripheral[m
[36m@@ -453,9 +478,6 @@[m [mpublic:[m
         std::set<CBlockIndex*, CBlockIndexWorkComparator>& block_index_candidates)[m
         EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[31m-    /** Clear all data members. */[m
[31m-    void Unload() EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[31m-[m
     CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     /** Create a new block index entry for a given block hash */[m
     CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[36m@@ -473,7 +495,7 @@[m [mpublic:[m
         const CChainParams& chainparams,[m
         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[31m-    CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m[32m    CBlockIndex* LookupBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
     /** Find the last common block between the parameter chain and a locator. */[m
     CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[36m@@ -488,9 +510,28 @@[m [mpublic:[m
      */[m
     int GetSpendHeight(const CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[31m-    ~BlockManager() {[m
[31m-        Unload();[m
[31m-    }[m
[32m+[m[32m    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown);[m
[32m+[m[32m    bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize);[m
[32m+[m[32m    bool WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValidationState& state, CBlockIndex* pindex, const CChainParams& chainparams);[m
[32m+[m[32m    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const CChainParams& chainparams, const FlatFilePos* dbp);[m
[32m+[m
[32m+[m[32m    void FlushUndoFile(int block_file, bool finalize = false);[m
[32m+[m
[32m+[m[32m    void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);[m
[32m+[m
[32m+[m[32m    /** Calculate the amount of disk space the block & undo files currently use */[m
[32m+[m[32m    uint64_t CalculateCurrentUsage();[m
[32m+[m
[32m+[m[32m    /** Get block file info entry for one block file */[m
[32m+[m[32m    CBlockFileInfo* GetBlockFileInfo(size_t n);[m
[32m+[m
[32m+[m[32m    //! Check whether the block associated with this index entry is pruned or not.[m
[32m+[m[32m    bool IsBlockPruned(const CBlockIndex* pblockindex);[m
[32m+[m
[32m+[m[32m    /** Global cache for versionbits deployment status */[m
[32m+[m[32m    VersionBitsCache versionbitscache;[m
[32m+[m
[32m+[m[32m    std::array<ThresholdConditionCache, VERSIONBITS_NUM_BITS> warningcache GUARDED_BY(cs_main);[m
 };[m
 [m
 /**[m
[36m@@ -561,7 +602,7 @@[m [mprotected:[m
     /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */[m
     int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;[m
     /** Decreasing counter (used by subsequent preciousblock calls). */[m
[31m-    int32_t nBlockReverseSequenceId = -1;[m
[32m+[m[32m    int32_t nBlockReverseSequenceId GUARDED_BY(::cs_main) = -1;[m
     /** chainwork for the last block that preciousblock has been applied to. */[m
     arith_uint256 nLastPreciousChainwork = 0;[m
 [m
[36m@@ -748,8 +789,6 @@[m [mpublic:[m
 [m
     void PruneBlockIndexCandidates();[m
 [m
[31m-    void UnloadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[31m-[m
     /** Check whether we are doing an initial block download (synchronizing from disk or network) */[m
     bool IsInitialBlockDownload() const;[m
 [m
[36m@@ -1020,21 +1059,12 @@[m [mpublic:[m
     //! Load the block tree and coins database from disk, initializing state if we're running with -reindex[m
     bool LoadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[31m-    //! Unload block index and chain data before shutdown.[m
[31m-    void Unload() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[31m-[m
     //! Clear (deconstruct) chainstate data.[m
     void Reset();[m
 [m
     //! Check to see if caches are out of balance and if so, call[m
     //! ResizeCoinsCaches() as needed.[m
     void MaybeRebalanceCaches() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[31m-[m
[31m-    ~ChainstateManager() {[m
[31m-        LOCK(::cs_main);[m
[31m-        UnloadBlockIndex(/* mempool */ nullptr, *this);[m
[31m-        Reset();[m
[31m-    }[m
 };[m
 [m
 using FopenFn = std::function<FILE*(const fs::path&, const char*)>;[m
[33mdiff --git a/src/versionbits.h b/src/versionbits.h[m
[33mindex 0b2f4a0258..094ce17b71 100644[m
[33m--- a/src/versionbits.h[m
[33m+++ b/src/versionbits.h[m
[36m@@ -51,6 +51,8 @@[m [mstruct BIP9Stats {[m
     bool possible;[m
 };[m
 [m
[32m+[m[32mclass VersionBitsCache;[m
[32m+[m
 /**[m
  * Abstract class that implements BIP9-style threshold logic, and caches results.[m
  */[m
[33mdiff --git a/src/wallet/test/wallet_tests.cpp b/src/wallet/test/wallet_tests.cpp[m
[33mindex 5431a38bee..8b840a69ea 100644[m
[33m--- a/src/wallet/test/wallet_tests.cpp[m
[33m+++ b/src/wallet/test/wallet_tests.cpp[m
[36m@@ -86,7 +86,7 @@[m [mBOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)[m
 {[m
     // Cap last block file size, and mine new block in a new block file.[m
     CBlockIndex* oldTip = m_node.chainman->ActiveChain().Tip();[m
[31m-    GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;[m
[32m+[m[32m    (*WITH_LOCK(::cs_main, return &m_node.chainman->m_blockman)).GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;[m
     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));[m
     CBlockIndex* newTip = m_node.chainman->ActiveChain().Tip();[m
 [m
[36m@@ -183,7 +183,7 @@[m [mBOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)[m
 {[m
     // Cap last block file size, and mine new block in a new block file.[m
     CBlockIndex* oldTip = m_node.chainman->ActiveChain().Tip();[m
[31m-    GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;[m
[32m+[m[32m    (*WITH_LOCK(::cs_main, return &m_node.chainman->m_blockman)).GetBlockFileInfo(oldTip->GetBlockPos().nFile)->nSize = MAX_BLOCKFILE_SIZE;[m
     CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));[m
     CBlockIndex* newTip = m_node.chainman->ActiveChain().Tip();[m
 [m
[36m@@ -349,10 +349,10 @@[m [mstatic int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lock[m
     CBlockIndex* block = nullptr;[m
     if (blockTime > 0) {[m
         LOCK(cs_main);[m
[31m-        auto inserted = chainman.BlockIndex().emplace(GetRandHash(), new CBlockIndex);[m
[32m+[m[32m        auto inserted = chainman.BlockIndex().emplace(std::piecewise_construct, std::make_tuple(GetRandHash()), std::make_tuple());[m
         assert(inserted.second);[m
         const uint256& hash = inserted.first->first;[m
[31m-        block = inserted.first->second;[m
[32m+[m[32m        block = &inserted.first->second;[m
         block->nTime = blockTime;[m
         block->phashBlock = &hash;[m
         confirm = {CWalletTx::Status::CONFIRMED, block->nHeight, hash, 0};[m