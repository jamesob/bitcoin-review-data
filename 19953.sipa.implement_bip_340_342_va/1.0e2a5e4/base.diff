[33mdiff --git a/build_msvc/libsecp256k1/libsecp256k1.vcxproj b/build_msvc/libsecp256k1/libsecp256k1.vcxproj[m
[33mindex 99fb63fb02..c42918d6e1 100644[m
[33m--- a/build_msvc/libsecp256k1/libsecp256k1.vcxproj[m
[33m+++ b/build_msvc/libsecp256k1/libsecp256k1.vcxproj[m
[36m@@ -12,7 +12,7 @@[m
   </ItemGroup>[m
     <ItemDefinitionGroup>[m
     <ClCompile>[m
[31m-      <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <PreprocessorDefinitions>ENABLE_MODULE_ECDH;ENABLE_MODULE_RECOVERY;ENABLE_MODULE_EXTRAKEYS;ENABLE_MODULE_SCHNORRSIG;%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
        <AdditionalIncludeDirectories>..\..\src\secp256k1;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
      </ClCompile>[m
   </ItemDefinitionGroup>[m
[33mdiff --git a/ci/test/04_install.sh b/ci/test/04_install.sh[m
[33mindex d3566914ac..632bccf574 100755[m
[33m--- a/ci/test/04_install.sh[m
[33m+++ b/ci/test/04_install.sh[m
[36m@@ -81,11 +81,10 @@[m [melse[m
 fi[m
 [m
 if [ ! -d ${DIR_QA_ASSETS} ]; then[m
[31m- if [ "$RUN_FUZZ_TESTS" = "true" ]; then[m
[31m-  DOCKER_EXEC git clone https://github.com/bitcoin-core/qa-assets ${DIR_QA_ASSETS}[m
[31m- fi[m
[32m+[m[32m  DOCKER_EXEC git clone --depth=1 https://github.com/bitcoin-core/qa-assets ${DIR_QA_ASSETS}[m
 fi[m
 export DIR_FUZZ_IN=${DIR_QA_ASSETS}/fuzz_seed_corpus/[m
[32m+[m[32mexport DIR_UNIT_TEST_DATA=${DIR_QA_ASSETS}/unit_test_data/[m
 [m
 DOCKER_EXEC mkdir -p "${BASE_SCRATCH_DIR}/sanitizer-output/"[m
 [m
[33mdiff --git a/ci/test/06_script_b.sh b/ci/test/06_script_b.sh[m
[33mindex 6c14a3dfbe..607a2820dd 100755[m
[33m--- a/ci/test/06_script_b.sh[m
[33m+++ b/ci/test/06_script_b.sh[m
[36m@@ -23,13 +23,13 @@[m [mfi[m
 [m
 if [ "$RUN_UNIT_TESTS" = "true" ]; then[m
   BEGIN_FOLD unit-tests[m
[31m-  DOCKER_EXEC LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib make $MAKEJOBS check VERBOSE=1[m
[32m+[m[32m  DOCKER_EXEC DIR_UNIT_TEST_DATA=${DIR_UNIT_TEST_DATA} LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib make $MAKEJOBS check VERBOSE=1[m
   END_FOLD[m
 fi[m
 [m
 if [ "$RUN_UNIT_TESTS_SEQUENTIAL" = "true" ]; then[m
   BEGIN_FOLD unit-tests-seq[m
[31m-  DOCKER_EXEC LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib "${BASE_BUILD_DIR}/bitcoin-*/src/test/test_bitcoin*" --catch_system_errors=no -l test_suite[m
[32m+[m[32m  DOCKER_EXEC DIR_UNIT_TEST_DATA=${DIR_UNIT_TEST_DATA} LD_LIBRARY_PATH=$DEPENDS_DIR/$HOST/lib "${BASE_BUILD_DIR}/bitcoin-*/src/test/test_bitcoin*" --catch_system_errors=no -l test_suite[m
   END_FOLD[m
 fi[m
 [m
[33mdiff --git a/configure.ac b/configure.ac[m
[33mindex fbf56443f1..3df59e0b7b 100644[m
[33m--- a/configure.ac[m
[33m+++ b/configure.ac[m
[36m@@ -1645,7 +1645,7 @@[m [mif test x$need_bundled_univalue = xyes; then[m
   AC_CONFIG_SUBDIRS([src/univalue])[m
 fi[m
 [m
[31m-ac_configure_args="${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery"[m
[32m+[m[32mac_configure_args="${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --enable-module-schnorrsig --enable-experimental"[m
 AC_CONFIG_SUBDIRS([src/secp256k1])[m
 [m
 AC_OUTPUT[m
[33mdiff --git a/src/Makefile.test.include b/src/Makefile.test.include[m
[33mindex 06dde87ddd..28608715b4 100644[m
[33m--- a/src/Makefile.test.include[m
[33m+++ b/src/Makefile.test.include[m
[36m@@ -129,6 +129,7 @@[m [mFUZZ_TARGETS = \[m
   test/fuzz/script_deserialize \[m
   test/fuzz/script_flags \[m
   test/fuzz/script_interpreter \[m
[32m+[m[32m  test/fuzz/script_assets_test_minimizer \[m
   test/fuzz/script_ops \[m
   test/fuzz/script_sigcache \[m
   test/fuzz/script_sign \[m
[36m@@ -1082,6 +1083,12 @@[m [mtest_fuzz_script_interpreter_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
 test_fuzz_script_interpreter_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON)[m
 test_fuzz_script_interpreter_SOURCES = test/fuzz/script_interpreter.cpp[m
 [m
[32m+[m[32mtest_fuzz_script_assets_test_minimizer_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)[m
[32m+[m[32mtest_fuzz_script_assets_test_minimizer_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
[32m+[m[32mtest_fuzz_script_assets_test_minimizer_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[32m+[m[32mtest_fuzz_script_assets_test_minimizer_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)[m
[32m+[m[32mtest_fuzz_script_assets_test_minimizer_SOURCES = test/fuzz/script_assets_test_minimizer.cpp[m
[32m+[m
 test_fuzz_script_ops_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)[m
 test_fuzz_script_ops_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
 test_fuzz_script_ops_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[33mdiff --git a/src/chainparams.cpp b/src/chainparams.cpp[m
[33mindex ef501e9de2..a34bf350fc 100644[m
[33m--- a/src/chainparams.cpp[m
[33m+++ b/src/chainparams.cpp[m
[36m@@ -86,6 +86,11 @@[m [mpublic:[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008[m
 [m
[32m+[m[32m        // Deployment of Taproot (BIPs 340-342)[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008[m
[32m+[m
         // The best chain should have at least this much work.[m
         consensus.nMinimumChainWork = uint256S("0x00000000000000000000000000000000000000000e1ab5ec9348e9f4b8eb8154");[m
 [m
[36m@@ -197,6 +202,11 @@[m [mpublic:[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008[m
 [m
[32m+[m[32m        // Deployment of Taproot (BIPs 340-342)[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = 1199145601; // January 1, 2008[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = 1230767999; // December 31, 2008[m
[32m+[m
         // The best chain should have at least this much work.[m
         consensus.nMinimumChainWork = uint256S("0x0000000000000000000000000000000000000000000001495c1d5a01e2af8a23");[m
 [m
[36m@@ -380,6 +390,9 @@[m [mpublic:[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;[m
         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].bit = 2;[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;[m
[32m+[m[32m        consensus.vDeployments[Consensus::DEPLOYMENT_TAPROOT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;[m
 [m
         // The best chain should have at least this much work.[m
         consensus.nMinimumChainWork = uint256S("0x00");[m
[33mdiff --git a/src/consensus/params.h b/src/consensus/params.h[m
[33mindex 85ab3f61ef..932f0d2c60 100644[m
[33m--- a/src/consensus/params.h[m
[33m+++ b/src/consensus/params.h[m
[36m@@ -14,6 +14,7 @@[m [mnamespace Consensus {[m
 enum DeploymentPos[m
 {[m
     DEPLOYMENT_TESTDUMMY,[m
[32m+[m[32m    DEPLOYMENT_TAPROOT, // Deployment of Schnorr/Taproot (BIPs 340-342)[m
     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp[m
     MAX_VERSION_BITS_DEPLOYMENTS[m
 };[m
[33mdiff --git a/src/hash.cpp b/src/hash.cpp[m
[33mindex 83b90ae063..3657b38639 100644[m
[33m--- a/src/hash.cpp[m
[33m+++ b/src/hash.cpp[m
[36m@@ -6,6 +6,7 @@[m
 #include <crypto/common.h>[m
 #include <crypto/hmac_sha512.h>[m
 [m
[32m+[m[32m#include <string>[m
 [m
 inline uint32_t ROTL32(uint32_t x, int8_t r)[m
 {[m
[36m@@ -84,3 +85,12 @@[m [muint256 SHA256Uint256(const uint256& input)[m
     CSHA256().Write(input.begin(), 32).Finalize(result.begin());[m
     return result;[m
 }[m
[32m+[m
[32m+[m[32mCHashWriter TaggedHash(const std::string& tag)[m
[32m+[m[32m{[m
[32m+[m[32m    CHashWriter writer(SER_GETHASH, 0);[m
[32m+[m[32m    uint256 taghash;[m
[32m+[m[32m    CSHA256().Write((const unsigned char*)tag.data(), tag.size()).Finalize(taghash.begin());[m
[32m+[m[32m    writer << taghash << taghash;[m
[32m+[m[32m    return writer;[m
[32m+[m[32m}[m
[33mdiff --git a/src/hash.h b/src/hash.h[m
[33mindex c16bbb48ce..6d876076ee 100644[m
[33m--- a/src/hash.h[m
[33m+++ b/src/hash.h[m
[36m@@ -15,6 +15,7 @@[m
 #include <uint256.h>[m
 #include <version.h>[m
 [m
[32m+[m[32m#include <string>[m
 #include <vector>[m
 [m
 typedef uint256 ChainCode;[m
[36m@@ -202,4 +203,12 @@[m [munsigned int MurmurHash3(unsigned int nHashSeed, Span<const unsigned char> vData[m
 [m
 void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);[m
 [m
[32m+[m[32m/** Return a CHashWriter primed for tagged hashes (as specified in BIP 340).[m
[32m+[m[32m *[m
[32m+[m[32m * The returned object will have SHA256(tag) written to it twice (= 64 bytes).[m
[32m+[m[32m * A tagged hash can be computed by feeding the message into this object, and[m
[32m+[m[32m * then calling CHashWriter::GetSHA256().[m
[32m+[m[32m */[m
[32m+[m[32mCHashWriter TaggedHash(const std::string& tag);[m
[32m+[m
 #endif // BITCOIN_HASH_H[m
[33mdiff --git a/src/policy/policy.cpp b/src/policy/policy.cpp[m
[33mindex 0e9820da1e..69f2b456f1 100644[m
[33m--- a/src/policy/policy.cpp[m
[33m+++ b/src/policy/policy.cpp[m
[36m@@ -9,7 +9,7 @@[m
 [m
 #include <consensus/validation.h>[m
 #include <coins.h>[m
[31m-[m
[32m+[m[32m#include <span.h>[m
 [m
 CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)[m
 {[m
[36m@@ -206,6 +206,7 @@[m [mbool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)[m
         // get the scriptPubKey corresponding to this input:[m
         CScript prevScript = prev.scriptPubKey;[m
 [m
[32m+[m[32m        bool p2sh = false;[m
         if (prevScript.IsPayToScriptHash()) {[m
             std::vector <std::vector<unsigned char> > stack;[m
             // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig[m
[36m@@ -216,6 +217,7 @@[m [mbool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)[m
             if (stack.empty())[m
                 return false;[m
             prevScript = CScript(stack.back().begin(), stack.back().end());[m
[32m+[m[32m            p2sh = true;[m
         }[m
 [m
         int witnessversion = 0;[m
[36m@@ -237,6 +239,36 @@[m [mbool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)[m
                     return false;[m
             }[m
         }[m
[32m+[m
[32m+[m[32m        // Check policy limits for Taproot spends:[m
[32m+[m[32m        // - MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE limit for stack item size[m
[32m+[m[32m        // - No annexes[m
[32m+[m[32m        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE && !p2sh) {[m
[32m+[m[32m            // Taproot spend (non-P2SH-wrapped, version 1, witness program size 32; see BIP 341)[m
[32m+[m[32m            auto stack = MakeSpan(tx.vin[i].scriptWitness.stack);[m
[32m+[m[32m            if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {[m
[32m+[m[32m                // Annexes are nonstandard as long as no semantics are defined for them.[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m            if (stack.size() >= 2) {[m
[32m+[m[32m                // Script path spend (2 or more stack elements after removing optional annex)[m
[32m+[m[32m                const auto& control_block = SpanPopBack(stack);[m
[32m+[m[32m                SpanPopBack(stack); // Ignore script[m
[32m+[m[32m                if (control_block.empty()) return false; // Empty control block is invalid[m
[32m+[m[32m                if ((control_block[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {[m
[32m+[m[32m                    // Leaf version 0xc0 (aka Tapscript, see BIP 342)[m
[32m+[m[32m                    for (const auto& item : stack) {[m
[32m+[m[32m                        if (item.size() > MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE) return false;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            } else if (stack.size() == 1) {[m
[32m+[m[32m                // Key path spend (1 stack element after removing optional annex)[m
[32m+[m[32m                // (no policy rules apply)[m
[32m+[m[32m            } else {[m
[32m+[m[32m                // 0 stack elements; this is already invalid by consensus rules[m
[32m+[m[32m                return false;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
     }[m
     return true;[m
 }[m
[33mdiff --git a/src/policy/policy.h b/src/policy/policy.h[m
[33mindex 7f168ee20f..51d67b9390 100644[m
[33m--- a/src/policy/policy.h[m
[33m+++ b/src/policy/policy.h[m
[36m@@ -40,6 +40,8 @@[m [mstatic const bool DEFAULT_PERMIT_BAREMULTISIG = true;[m
 static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;[m
 /** The maximum size of each witness stack item in a standard P2WSH script */[m
 static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;[m
[32m+[m[32m/** The maximum size of each witness stack item in a standard BIP 342 script (Taproot, leaf version 0xc0) */[m
[32m+[m[32mstatic const unsigned int MAX_STANDARD_TAPSCRIPT_STACK_ITEM_SIZE = 80;[m
 /** The maximum size of a standard witnessScript */[m
 static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;[m
 /** Min feerate for defining dust. Historically this has been based on the[m
[36m@@ -68,7 +70,11 @@[m [mstatic constexpr unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VE[m
                                                              SCRIPT_VERIFY_WITNESS |[m
                                                              SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |[m
                                                              SCRIPT_VERIFY_WITNESS_PUBKEYTYPE |[m
[31m-                                                             SCRIPT_VERIFY_CONST_SCRIPTCODE;[m
[32m+[m[32m                                                             SCRIPT_VERIFY_CONST_SCRIPTCODE |[m
[32m+[m[32m                                                             SCRIPT_VERIFY_TAPROOT |[m
[32m+[m[32m                                                             SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION |[m
[32m+[m[32m                                                             SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS |[m
[32m+[m[32m                                                             SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE;[m
 [m
 /** For convenience, standard but not mandatory verify flags. */[m
 static constexpr unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;[m
[33mdiff --git a/src/pubkey.cpp b/src/pubkey.cpp[m
[33mindex fc14f41a0c..4d734fc891 100644[m
[33m--- a/src/pubkey.cpp[m
[33m+++ b/src/pubkey.cpp[m
[36m@@ -7,6 +7,7 @@[m
 [m
 #include <secp256k1.h>[m
 #include <secp256k1_recovery.h>[m
[32m+[m[32m#include <secp256k1_schnorrsig.h>[m
 [m
 namespace[m
 {[m
[36m@@ -166,6 +167,27 @@[m [mint ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_[m
     return 1;[m
 }[m
 [m
[32m+[m[32mXOnlyPubKey::XOnlyPubKey(Span<const unsigned char> bytes)[m
[32m+[m[32m{[m
[32m+[m[32m    assert(bytes.size() == 32);[m
[32m+[m[32m    std::copy(bytes.begin(), bytes.end(), m_keydata.begin());[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool XOnlyPubKey::VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const[m
[32m+[m[32m{[m
[32m+[m[32m    assert(sigbytes.size() == 64);[m
[32m+[m[32m    secp256k1_xonly_pubkey pubkey;[m
[32m+[m[32m    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &pubkey, m_keydata.data())) return false;[m
[32m+[m[32m    return secp256k1_schnorrsig_verify(secp256k1_context_verify, sigbytes.data(), msg.begin(), &pubkey);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool XOnlyPubKey::CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool parity) const[m
[32m+[m[32m{[m
[32m+[m[32m    secp256k1_xonly_pubkey base_point;[m
[32m+[m[32m    if (!secp256k1_xonly_pubkey_parse(secp256k1_context_verify, &base_point, base.data())) return false;[m
[32m+[m[32m    return secp256k1_xonly_pubkey_tweak_add_check(secp256k1_context_verify, m_keydata.begin(), parity, &base_point, hash.begin());[m
[32m+[m[32m}[m
[32m+[m
 bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {[m
     if (!IsValid())[m
         return false;[m
[33mdiff --git a/src/pubkey.h b/src/pubkey.h[m
[33mindex fcbc7e8416..0f784b86e4 100644[m
[33m--- a/src/pubkey.h[m
[33m+++ b/src/pubkey.h[m
[36m@@ -9,6 +9,7 @@[m
 [m
 #include <hash.h>[m
 #include <serialize.h>[m
[32m+[m[32m#include <span.h>[m
 #include <uint256.h>[m
 [m
 #include <stdexcept>[m
[36m@@ -169,7 +170,7 @@[m [mpublic:[m
     /*[m
      * Check syntactic correctness.[m
      *[m
[31m-     * Note that this is consensus critical as CheckSig() calls it![m
[32m+[m[32m     * Note that this is consensus critical as CheckECDSASignature() calls it![m
      */[m
     bool IsValid() const[m
     {[m
[36m@@ -206,6 +207,27 @@[m [mpublic:[m
     bool Derive(CPubKey& pubkeyChild, ChainCode &ccChild, unsigned int nChild, const ChainCode& cc) const;[m
 };[m
 [m
[32m+[m[32mclass XOnlyPubKey[m
[32m+[m[32m{[m
[32m+[m[32mprivate:[m
[32m+[m[32m    uint256 m_keydata;[m
[32m+[m
[32m+[m[32mpublic:[m
[32m+[m[32m    /** Construct an x-only pubkey from exactly 32 bytes. */[m
[32m+[m[32m    XOnlyPubKey(Span<const unsigned char> bytes);[m
[32m+[m
[32m+[m[32m    /** Verify a Schnorr signature against this public key.[m
[32m+[m[32m     *[m
[32m+[m[32m     * sigbytes must be exactly 64 bytes.[m
[32m+[m[32m     */[m
[32m+[m[32m    bool VerifySchnorr(const uint256& msg, Span<const unsigned char> sigbytes) const;[m
[32m+[m[32m    bool CheckPayToContract(const XOnlyPubKey& base, const uint256& hash, bool parity) const;[m
[32m+[m
[32m+[m[32m    const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }[m
[32m+[m[32m    const unsigned char* data() const { return m_keydata.begin(); }[m
[32m+[m[32m    size_t size() const { return m_keydata.size(); }[m
[32m+[m[32m};[m
[32m+[m
 struct CExtPubKey {[m
     unsigned char nDepth;[m
     unsigned char vchFingerprint[4];[m
[33mdiff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp[m
[33mindex 0bb7342db0..ef8d59266d 100644[m
[33m--- a/src/rpc/blockchain.cpp[m
[33m+++ b/src/rpc/blockchain.cpp[m
[36m@@ -1355,6 +1355,7 @@[m [mRPCHelpMan getblockchaininfo()[m
     BuriedForkDescPushBack(softforks, "csv", consensusParams.CSVHeight);[m
     BuriedForkDescPushBack(softforks, "segwit", consensusParams.SegwitHeight);[m
     BIP9SoftForkDescPushBack(softforks, "testdummy", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);[m
[32m+[m[32m    BIP9SoftForkDescPushBack(softforks, "taproot", consensusParams, Consensus::DEPLOYMENT_TAPROOT);[m
     obj.pushKV("softforks",             softforks);[m
 [m
     obj.pushKV("warnings", GetWarnings(false).original);[m
[33mdiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp[m
[33mindex 50a6192476..5735e7df66 100644[m
[33m--- a/src/script/interpreter.cpp[m
[33m+++ b/src/script/interpreter.cpp[m
[36m@@ -342,13 +342,10 @@[m [mpublic:[m
 };[m
 }[m
 [m
[31m-/** Helper for OP_CHECKSIG and OP_CHECKSIGVERIFY[m
[2m- *[m
[2m- * A return value of false means the script fails entirely. When true is returned, the[m
[31m- * fSuccess variable indicates whether the signature check itself succeeded.[m
[31m- */[m
[31m-static bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& fSuccess)[m
[32m+[m[32mstatic bool EvalChecksigPreTapscript(const valtype& vchSig, const valtype& vchPubKey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& fSuccess)[m
 {[m
[32m+[m[32m    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0);[m
[32m+[m
     // Subset of script starting at the most recent codeseparator[m
     CScript scriptCode(pbegincodehash, pend);[m
 [m
[36m@@ -363,7 +360,7 @@[m [mstatic bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip[m
         //serror is set[m
         return false;[m
     }[m
[31m-    fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);[m
[32m+[m[32m    fSuccess = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);[m
 [m
     if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())[m
         return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);[m
[36m@@ -371,7 +368,67 @@[m [mstatic bool EvalChecksig(const valtype& vchSig, const valtype& vchPubKey, CScrip[m
     return true;[m
 }[m
 [m
[2m-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)[m
[32m+[m[32mstatic bool EvalChecksigTapscript(const valtype& sig, const valtype& pubkey, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)[m
[32m+[m[32m{[m
[32m+[m[32m    assert(sigversion == SigVersion::TAPSCRIPT);[m
[32m+[m
[32m+[m[32m    /*[m
[32m+[m[32m     *  The following validation sequence is consensus critical. Please note how --[m
[32m+[m[32m     *    upgradable public key versions precede other rules;[m
[32m+[m[32m     *    the script execution fails when using empty signature with invalid public key;[m
[32m+[m[32m     *    the script execution fails when using non-empty invalid signature.[m
[32m+[m[32m     */[m
[32m+[m[32m    success = !sig.empty();[m
[32m+[m[32m    if (success) {[m
[32m+[m[32m        // Implement the sigops/witnesssize ratio test.[m
[32m+[m[32m        // Passing with an upgradable public key version is also counted.[m
[32m+[m[32m        assert(execdata.m_validation_weight_left_init);[m
[32m+[m[32m        execdata.m_validation_weight_left -= VALIDATION_WEIGHT_PER_SIGOP_PASSED;[m
[32m+[m[32m        if (execdata.m_validation_weight_left < 0) {[m
[32m+[m[32m            return set_error(serror, SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (pubkey.size() == 0) {[m
[32m+[m[32m        return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);[m
[32m+[m[32m    } else if (pubkey.size() == 32) {[m
[32m+[m[32m        if (success && !checker.CheckSchnorrSignature(sig, pubkey, sigversion, execdata, serror)) {[m
[32m+[m[32m            return false; // serror is set[m
[32m+[m[32m        }[m
[32m+[m[32m    } else {[m
[32m+[m[32m        /*[m
[32m+[m[32m         *  New public key version softforks should be defined before this `else` block.[m
[32m+[m[32m         *  Generally, the new code should not do anything but failing the script execution. To avoid[m
[32m+[m[32m         *  consensus bugs, it should not modify any existing values (including `success`).[m
[32m+[m[32m         */[m
[32m+[m[32m        if ((flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE) != 0) {[m
[32m+[m[32m            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/** Helper for OP_CHECKSIG, OP_CHECKSIGVERIFY, and (in Tapscript) OP_CHECKSIGADD.[m
[2m+[m[2m *[m
[2m+[m[2m * A return value of false means the script fails entirely. When true is returned, the[m
[32m+[m[32m * success variable indicates whether the signature check itself succeeded.[m
[32m+[m[32m */[m
[32m+[m[32mstatic bool EvalChecksig(const valtype& sig, const valtype& pubkey, CScript::const_iterator pbegincodehash, CScript::const_iterator pend, ScriptExecutionData& execdata, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror, bool& success)[m
[32m+[m[32m{[m
[32m+[m[32m    switch (sigversion) {[m
[32m+[m[32m    case SigVersion::BASE:[m
[32m+[m[32m    case SigVersion::WITNESS_V0:[m
[32m+[m[32m        return EvalChecksigPreTapscript(sig, pubkey, pbegincodehash, pend, flags, checker, sigversion, serror, success);[m
[32m+[m[32m    case SigVersion::TAPSCRIPT:[m
[32m+[m[32m        return EvalChecksigTapscript(sig, pubkey, execdata, flags, checker, sigversion, serror, success);[m
[32m+[m[32m    case SigVersion::TAPROOT:[m
[32m+[m[32m        // Key path spending in Taproot has no script, so this is unreachable.[m
[32m+[m[32m        break;[m
[32m+[m[32m    }[m
[32m+[m[32m    assert(false);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* serror)[m
 {[m
     static const CScriptNum bnZero(0);[m
     static const CScriptNum bnOne(1);[m
[36m@@ -381,6 +438,9 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
     // static const valtype vchZero(0);[m
     static const valtype vchTrue(1, 1);[m
 [m
[32m+[m[32m    // sigversion cannot be TAPROOT here, as it admits no script execution.[m
[32m+[m[32m    assert(sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0 || sigversion == SigVersion::TAPSCRIPT);[m
[32m+[m
     CScript::const_iterator pc = script.begin();[m
     CScript::const_iterator pend = script.end();[m
     CScript::const_iterator pbegincodehash = script.begin();[m
[36m@@ -389,15 +449,18 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
     ConditionStack vfExec;[m
     std::vector<valtype> altstack;[m
     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);[m
[31m-    if (script.size() > MAX_SCRIPT_SIZE)[m
[32m+[m[32m    if ((sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) && script.size() > MAX_SCRIPT_SIZE) {[m
         return set_error(serror, SCRIPT_ERR_SCRIPT_SIZE);[m
[32m+[m[32m    }[m
     int nOpCount = 0;[m
     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;[m
[32m+[m[32m    uint32_t opcode_pos = 0;[m
[32m+[m[32m    execdata.m_codeseparator_pos = 0xFFFFFFFFUL;[m
[32m+[m[32m    execdata.m_codeseparator_pos_init = true;[m
 [m
     try[m
     {[m
[31m-        while (pc < pend)[m
[31m-        {[m
[32m+[m[32m        for (; pc < pend; ++opcode_pos) {[m
             bool fExec = vfExec.all_true();[m
 [m
             //[m
[36m@@ -408,9 +471,12 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
             if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)[m
                 return set_error(serror, SCRIPT_ERR_PUSH_SIZE);[m
 [m
[31m-            // Note how OP_RESERVED does not count towards the opcode limit.[m
[31m-            if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT)[m
[31m-                return set_error(serror, SCRIPT_ERR_OP_COUNT);[m
[32m+[m[32m            if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) {[m
[32m+[m[32m                // Note how OP_RESERVED does not count towards the opcode limit.[m
[32m+[m[32m                if (opcode > OP_16 && ++nOpCount > MAX_OPS_PER_SCRIPT) {[m
[32m+[m[32m                    return set_error(serror, SCRIPT_ERR_OP_COUNT);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
 [m
             if (opcode == OP_CAT ||[m
                 opcode == OP_SUBSTR ||[m
[36m@@ -568,6 +634,15 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
                         if (stack.size() < 1)[m
                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);[m
                         valtype& vch = stacktop(-1);[m
[32m+[m[32m                        // Tapscript requires minimal IF/NOTIF inputs as a consensus rule.[m
[32m+[m[32m                        if (sigversion == SigVersion::TAPSCRIPT) {[m
[32m+[m[32m                            // The input argument to the OP_IF and OP_NOTIF opcodes must be either[m
[32m+[m[32m                            // exactly 0 (the empty vector) or exactly 1 (the one-byte vector with value 1).[m
[32m+[m[32m                            if (vch.size() > 1 || (vch.size() == 1 && vch[0] != 1)) {[m
[32m+[m[32m                                return set_error(serror, SCRIPT_ERR_TAPSCRIPT_MINIMALIF);[m
[32m+[m[32m                            }[m
[32m+[m[32m                        }[m
[32m+[m[32m                        // Under witness v0 rules it is only a policy rule, enabled through SCRIPT_VERIFY_MINIMALIF.[m
                         if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {[m
                             if (vch.size() > 1)[m
                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);[m
[36m@@ -1001,6 +1076,7 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
 [m
                     // Hash starts after the code separator[m
                     pbegincodehash = pc;[m
[32m+[m[32m                    execdata.m_codeseparator_pos = opcode_pos;[m
                 }[m
                 break;[m
 [m
[36m@@ -1015,7 +1091,7 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
                     valtype& vchPubKey = stacktop(-1);[m
 [m
                     bool fSuccess = true;[m
[31m-                    if (!EvalChecksig(vchSig, vchPubKey, pbegincodehash, pend, flags, checker, sigversion, serror, fSuccess)) return false;[m
[32m+[m[32m                    if (!EvalChecksig(vchSig, vchPubKey, pbegincodehash, pend, execdata, flags, checker, sigversion, serror, fSuccess)) return false;[m
                     popstack(stack);[m
                     popstack(stack);[m
                     stack.push_back(fSuccess ? vchTrue : vchFalse);[m
[36m@@ -1029,9 +1105,32 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
                 }[m
                 break;[m
 [m
[32m+[m[32m                case OP_CHECKSIGADD:[m
[32m+[m[32m                {[m
[32m+[m[32m                    // OP_CHECKSIGADD is only available in Tapscript[m
[32m+[m[32m                    if (sigversion == SigVersion::BASE || sigversion == SigVersion::WITNESS_V0) return set_error(serror, SCRIPT_ERR_BAD_OPCODE);[m
[32m+[m
[32m+[m[32m                    // (sig num pubkey -- num)[m
[32m+[m[32m                    if (stack.size() < 3) return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);[m
[32m+[m
[32m+[m[32m                    const valtype& sig = stacktop(-3);[m
[32m+[m[32m                    const CScriptNum num(stacktop(-2), fRequireMinimal);[m
[32m+[m[32m                    const valtype& pubkey = stacktop(-1);[m
[32m+[m
[32m+[m[32m                    bool success = true;[m
[32m+[m[32m                    if (!EvalChecksig(sig, pubkey, pbegincodehash, pend, execdata, flags, checker, sigversion, serror, success)) return false;[m
[32m+[m[32m                    popstack(stack);[m
[32m+[m[32m                    popstack(stack);[m
[32m+[m[32m                    popstack(stack);[m
[32m+[m[32m                    stack.push_back((num + (success ? 1 : 0)).getvch());[m
[32m+[m[32m                }[m
[32m+[m[32m                break;[m
[32m+[m
                 case OP_CHECKMULTISIG:[m
                 case OP_CHECKMULTISIGVERIFY:[m
                 {[m
[32m+[m[32m                    if (sigversion == SigVersion::TAPSCRIPT) return set_error(serror, SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG);[m
[32m+[m
                     // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)[m
 [m
                     int i = 1;[m
[36m@@ -1089,7 +1188,7 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
                         }[m
 [m
                         // Check signature[m
[31m-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);[m
[32m+[m[32m                        bool fOk = checker.CheckECDSASignature(vchSig, vchPubKey, scriptCode, sigversion);[m
 [m
                         if (fOk) {[m
                             isig++;[m
[36m@@ -1159,6 +1258,12 @@[m [mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&[m
     return set_success(serror);[m
 }[m
 [m
[2m+[m[2mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)[m
[32m+[m[32m{[m
[32m+[m[32m    ScriptExecutionData execdata;[m
[32m+[m[32m    return EvalScript(stack, script, flags, checker, sigversion, execdata, serror);[m
[32m+[m[32m}[m
[32m+[m
 namespace {[m
 [m
 /**[m
[36m@@ -1291,35 +1396,183 @@[m [muint256 GetOutputsSHA256(const T& txTo)[m
     return ss.GetSHA256();[m
 }[m
 [m
[32m+[m[32m/** Compute the (single) SHA256 of the concatenation of all amounts spent by a tx. */[m
[32m+[m[32muint256 GetSpentAmountsSHA256(const std::vector<CTxOut>& outputs_spent)[m
[32m+[m[32m{[m
[32m+[m[32m    CHashWriter ss(SER_GETHASH, 0);[m
[32m+[m[32m    for (const auto& txout : outputs_spent) {[m
[32m+[m[32m        ss << txout.nValue;[m
[32m+[m[32m    }[m
[32m+[m[32m    return ss.GetSHA256();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/** Compute the (single) SHA256 of the concatenation of all scriptPubKeys spent by a tx. */[m
[32m+[m[32muint256 GetSpentScriptsSHA256(const std::vector<CTxOut>& outputs_spent)[m
[32m+[m[32m{[m
[32m+[m[32m    CHashWriter ss(SER_GETHASH, 0);[m
[32m+[m[32m    for (const auto& txout : outputs_spent) {[m
[32m+[m[32m        ss << txout.scriptPubKey;[m
[32m+[m[32m    }[m
[32m+[m[32m    return ss.GetSHA256();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
 } // namespace[m
 [m
 template <class T>[m
[31m-void PrecomputedTransactionData::Init(const T& txTo)[m
[32m+[m[32mvoid PrecomputedTransactionData::Init(const T& txTo, std::vector<CTxOut>&& spent_outputs)[m
 {[m
[31m-    assert(!m_ready);[m
[32m+[m[32m    assert(!m_spent_outputs_ready);[m
 [m
[31m-    // Cache is calculated only for transactions with witness[m
[31m-    if (txTo.HasWitness()) {[m
[31m-        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));[m
[31m-        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));[m
[31m-        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));[m
[32m+[m[32m    m_spent_outputs = std::move(spent_outputs);[m
[32m+[m[32m    if (!m_spent_outputs.empty()) {[m
[32m+[m[32m        assert(m_spent_outputs.size() == txTo.vin.size());[m
[32m+[m[32m        m_spent_outputs_ready = true;[m
     }[m
 [m
[31m-    m_ready = true;[m
[32m+[m[32m    // Determine which precomputation-impacting features this transaction uses.[m
[32m+[m[32m    bool uses_bip143_segwit = false;[m
[32m+[m[32m    bool uses_bip341_taproot = false;[m
[32m+[m[32m    for (size_t inpos = 0; inpos < txTo.vin.size(); ++inpos) {[m
[32m+[m[32m        if (!txTo.vin[inpos].scriptWitness.IsNull()) {[m
[32m+[m[32m            if (m_spent_outputs_ready && m_spent_outputs[inpos].scriptPubKey.size() == 2 + WITNESS_V1_TAPROOT_SIZE &&[m
[32m+[m[32m                m_spent_outputs[inpos].scriptPubKey[0] == OP_1) {[m
[32m+[m[32m                // Treat every witness-bearing spend with 34-byte scriptPubKey that starts with OP_1 as a Taproot[m
[32m+[m[32m                // spend. This only works if spent_outputs was provided as well, but if it wasn't, actual validation[m
[32m+[m[32m                // will fail anyway. Note that this branch may trigger for scriptPubKeys that aren't actually segwit[m
[32m+[m[32m                // but in that case validation will fail as SCRIPT_ERR_WITNESS_UNEXPECTED anyway.[m
[32m+[m[32m                uses_bip341_taproot = true;[m
[32m+[m[32m            } else {[m
[32m+[m[32m                // Treat every spend that's not known to native witness v1 as a Witness v0 spend. This branch may[m
[32m+[m[32m                // also be taken for unknown witness versions, but it is harmless, and being precise would require[m
[32m+[m[32m                // P2SH evaluation to find the redeemScript.[m
[32m+[m[32m                uses_bip143_segwit = true;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if (uses_bip341_taproot && uses_bip143_segwit) break; // No need to scan further if we already need all.[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (uses_bip143_segwit || uses_bip341_taproot) {[m
[32m+[m[32m        // Computations shared between both sighash schemes.[m
[32m+[m[32m        m_prevouts_single_hash = GetPrevoutsSHA256(txTo);[m
[32m+[m[32m        m_sequences_single_hash = GetSequencesSHA256(txTo);[m
[32m+[m[32m        m_outputs_single_hash = GetOutputsSHA256(txTo);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (uses_bip143_segwit) {[m
[32m+[m[32m        hashPrevouts = SHA256Uint256(m_prevouts_single_hash);[m
[32m+[m[32m        hashSequence = SHA256Uint256(m_sequences_single_hash);[m
[32m+[m[32m        hashOutputs = SHA256Uint256(m_outputs_single_hash);[m
[32m+[m[32m        m_bip143_segwit_ready = true;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (uses_bip341_taproot) {[m
[32m+[m[32m        m_spent_amounts_single_hash = GetSpentAmountsSHA256(m_spent_outputs);[m
[32m+[m[32m        m_spent_scripts_single_hash = GetSpentScriptsSHA256(m_spent_outputs);[m
[32m+[m[32m        m_bip341_taproot_ready = true;[m
[32m+[m[32m    }[m
 }[m
 [m
 template <class T>[m
 PrecomputedTransactionData::PrecomputedTransactionData(const T& txTo)[m
 {[m
[31m-    Init(txTo);[m
[32m+[m[32m    Init(txTo, {});[m
 }[m
 [m
 // explicit instantiation[m
[31m-template void PrecomputedTransactionData::Init(const CTransaction& txTo);[m
[31m-template void PrecomputedTransactionData::Init(const CMutableTransaction& txTo);[m
[32m+[m[32mtemplate void PrecomputedTransactionData::Init(const CTransaction& txTo, std::vector<CTxOut>&& spent_outputs);[m
[32m+[m[32mtemplate void PrecomputedTransactionData::Init(const CMutableTransaction& txTo, std::vector<CTxOut>&& spent_outputs);[m
 template PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo);[m
 template PrecomputedTransactionData::PrecomputedTransactionData(const CMutableTransaction& txTo);[m
 [m
[32m+[m[32mstatic const CHashWriter HASHER_TAPSIGHASH = TaggedHash("TapSighash");[m
[32m+[m[32mstatic const CHashWriter HASHER_TAPLEAF = TaggedHash("TapLeaf");[m
[32m+[m[32mstatic const CHashWriter HASHER_TAPBRANCH = TaggedHash("TapBranch");[m
[32m+[m[32mstatic const CHashWriter HASHER_TAPTWEAK = TaggedHash("TapTweak");[m
[32m+[m
[32m+[m[32mtemplate<typename T>[m
[32m+[m[32mbool SignatureHashSchnorr(uint256& hash_out, const ScriptExecutionData& execdata, const T& tx_to, uint32_t in_pos, uint8_t hash_type, SigVersion sigversion, const PrecomputedTransactionData& cache)[m
[32m+[m[32m{[m
[32m+[m[32m    uint8_t ext_flag, key_version;[m
[32m+[m[32m    switch (sigversion) {[m
[32m+[m[32m    case SigVersion::TAPROOT:[m
[32m+[m[32m        ext_flag = 0;[m
[32m+[m[32m        // key_version is not used and left uninitialized.[m
[32m+[m[32m        break;[m
[32m+[m[32m    case SigVersion::TAPSCRIPT:[m
[32m+[m[32m        ext_flag = 1;[m
[32m+[m[32m        // key_version must be 0 for now, representing the current version of[m
[32m+[m[32m        // 32-byte public keys in the tapscript signature opcode execution.[m
[32m+[m[32m        // An upgradable public key version (with a size not 32-byte) may[m
[32m+[m[32m        // request a different key_version with a new sigversion.[m
[32m+[m[32m        key_version = 0;[m
[32m+[m[32m        break;[m
[32m+[m[32m    default:[m
[32m+[m[32m        assert(false);[m
[32m+[m[32m    }[m
[32m+[m[32m    assert(in_pos < tx_to.vin.size());[m
[32m+[m[32m    assert(cache.m_bip341_taproot_ready && cache.m_spent_outputs_ready);[m
[32m+[m
[32m+[m[32m    CHashWriter ss = HASHER_TAPSIGHASH;[m
[32m+[m
[32m+[m[32m    // Epoch[m
[32m+[m[32m    static constexpr uint8_t EPOCH = 0;[m
[32m+[m[32m    ss << EPOCH;[m
[32m+[m
[32m+[m[32m    // Hash type[m
[32m+[m[32m    const uint8_t output_type = (hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK); // Default (no sighash byte) is equivalent to SIGHASH_ALL[m
[32m+[m[32m    const uint8_t input_type = hash_type & SIGHASH_INPUT_MASK;[m
[32m+[m[32m    if (!(hash_type <= 0x03 || (hash_type >= 0x81 && hash_type <= 0x83))) return false;[m
[32m+[m[32m    ss << hash_type;[m
[32m+[m
[32m+[m[32m    // Transaction level data[m
[32m+[m[32m    ss << tx_to.nVersion;[m
[32m+[m[32m    ss << tx_to.nLockTime;[m
[32m+[m[32m    if (input_type != SIGHASH_ANYONECANPAY) {[m
[32m+[m[32m        ss << cache.m_prevouts_single_hash;[m
[32m+[m[32m        ss << cache.m_spent_amounts_single_hash;[m
[32m+[m[32m        ss << cache.m_spent_scripts_single_hash;[m
[32m+[m[32m        ss << cache.m_sequences_single_hash;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (output_type == SIGHASH_ALL) {[m
[32m+[m[32m        ss << cache.m_outputs_single_hash;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Data about the input/prevout being spent[m
[32m+[m[32m    assert(execdata.m_annex_init);[m
[32m+[m[32m    const bool have_annex = execdata.m_annex_present;[m
[32m+[m[32m    const uint8_t spend_type = (ext_flag << 1) + (have_annex ? 1 : 0); // The low bit indicates whether an annex is present.[m
[32m+[m[32m    ss << spend_type;[m
[32m+[m[32m    if (input_type == SIGHASH_ANYONECANPAY) {[m
[32m+[m[32m        ss << tx_to.vin[in_pos].prevout;[m
[32m+[m[32m        ss << cache.m_spent_outputs[in_pos];[m
[32m+[m[32m        ss << tx_to.vin[in_pos].nSequence;[m
[32m+[m[32m    } else {[m
[32m+[m[32m        ss << in_pos;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (have_annex) {[m
[32m+[m[32m        ss << execdata.m_annex_hash;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Data about the output (if only one).[m
[32m+[m[32m    if (output_type == SIGHASH_SINGLE) {[m
[32m+[m[32m        if (in_pos >= tx_to.vout.size()) return false;[m
[32m+[m[32m        CHashWriter sha_single_output(SER_GETHASH, 0);[m
[32m+[m[32m        sha_single_output << tx_to.vout[in_pos];[m
[32m+[m[32m        ss << sha_single_output.GetSHA256();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    // Additional data for BIP 342 signatures[m
[32m+[m[32m    if (sigversion == SigVersion::TAPSCRIPT) {[m
[32m+[m[32m        assert(execdata.m_tapleaf_hash_init);[m
[32m+[m[32m        ss << execdata.m_tapleaf_hash;[m
[32m+[m[32m        ss << key_version;[m
[32m+[m[32m        assert(execdata.m_codeseparator_pos_init);[m
[32m+[m[32m        ss << execdata.m_codeseparator_pos;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    hash_out = ss.GetSHA256();[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
 template <class T>[m
 uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache)[m
 {[m
[36m@@ -1329,7 +1582,7 @@[m [muint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn[m
         uint256 hashPrevouts;[m
         uint256 hashSequence;[m
         uint256 hashOutputs;[m
[31m-        const bool cacheready = cache && cache->m_ready;[m
[32m+[m[32m        const bool cacheready = cache && cache->m_bip143_segwit_ready;[m
 [m
         if (!(nHashType & SIGHASH_ANYONECANPAY)) {[m
             hashPrevouts = cacheready ? cache->hashPrevouts : SHA256Uint256(GetPrevoutsSHA256(txTo));[m
[36m@@ -1389,13 +1642,19 @@[m [muint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn[m
 }[m
 [m
 template <class T>[m
[31m-bool GenericTransactionSignatureChecker<T>::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const[m
[32m+[m[32mbool GenericTransactionSignatureChecker<T>::VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const[m
 {[m
     return pubkey.Verify(sighash, vchSig);[m
 }[m
 [m
 template <class T>[m
[31m-bool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const[m
[32m+[m[32mbool GenericTransactionSignatureChecker<T>::VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const[m
[32m+[m[32m{[m
[32m+[m[32m    return pubkey.VerifySchnorr(sighash, sig);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate <class T>[m
[32m+[m[32mbool GenericTransactionSignatureChecker<T>::CheckECDSASignature(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const[m
 {[m
     CPubKey pubkey(vchPubKey);[m
     if (!pubkey.IsValid())[m
[36m@@ -1410,12 +1669,40 @@[m [mbool GenericTransactionSignatureChecker<T>::CheckSig(const std::vector<unsigned[m
 [m
     uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion, this->txdata);[m
 [m
[31m-    if (!VerifySignature(vchSig, pubkey, sighash))[m
[32m+[m[32m    if (!VerifyECDSASignature(vchSig, pubkey, sighash))[m
         return false;[m
 [m
     return true;[m
 }[m
 [m
[32m+[m[32mtemplate <class T>[m
[32m+[m[32mbool GenericTransactionSignatureChecker<T>::CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey_in, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror) const[m
[32m+[m[32m{[m
[32m+[m[32m    assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);[m
[32m+[m[32m    // Schnorr signatures have 32-byte public keys. The caller is responsible for enforcing this.[m
[32m+[m[32m    assert(pubkey_in.size() == 32);[m
[32m+[m[32m    // Note that in Tapscript evaluation, empty signatures are treated specially (invalid signature that does not[m
[32m+[m[32m    // abort script execution). This is implemented in EvalChecksigTapscript, which won't invoke[m
[32m+[m[32m    // CheckSchnorrSignature in that case. In other contexts, they are invalid like every other signature with[m
[32m+[m[32m    // size different from 64 or 65.[m
[32m+[m[32m    if (sig.size() != 64 && sig.size() != 65) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_SIZE);[m
[32m+[m
[32m+[m[32m    XOnlyPubKey pubkey{pubkey_in};[m
[32m+[m
[32m+[m[32m    uint8_t hashtype = SIGHASH_DEFAULT;[m
[32m+[m[32m    if (sig.size() == 65) {[m
[32m+[m[32m        hashtype = SpanPopBack(sig);[m
[32m+[m[32m        if (hashtype == SIGHASH_DEFAULT) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);[m
[32m+[m[32m    }[m
[32m+[m[32m    uint256 sighash;[m
[32m+[m[32m    assert(this->txdata);[m
[32m+[m[32m    if (!SignatureHashSchnorr(sighash, execdata, *txTo, nIn, hashtype, sigversion, *this->txdata)) {[m
[32m+[m[32m        return set_error(serror, SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!VerifySchnorrSignature(sig, pubkey, sighash)) return set_error(serror, SCRIPT_ERR_SCHNORR_SIG);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
 template <class T>[m
 bool GenericTransactionSignatureChecker<T>::CheckLockTime(const CScriptNum& nLockTime) const[m
 {[m
[36m@@ -1504,17 +1791,39 @@[m [mbool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq[m
 template class GenericTransactionSignatureChecker<CTransaction>;[m
 template class GenericTransactionSignatureChecker<CMutableTransaction>;[m
 [m
[31m-static bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptError* serror)[m
[32m+[m[32mstatic bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CScript& scriptPubKey, unsigned int flags, SigVersion sigversion, const BaseSignatureChecker& checker, ScriptExecutionData& execdata, ScriptError* serror)[m
 {[m
     std::vector<valtype> stack{stack_span.begin(), stack_span.end()};[m
 [m
[32m+[m[32m    if (sigversion == SigVersion::TAPSCRIPT) {[m
[32m+[m[32m        // OP_SUCCESSx processing overrides everything, including stack element size limits[m
[32m+[m[32m        CScript::const_iterator pc = scriptPubKey.begin();[m
[32m+[m[32m        while (pc < scriptPubKey.end()) {[m
[32m+[m[32m            opcodetype opcode;[m
[32m+[m[32m            if (!scriptPubKey.GetOp(pc, opcode)) {[m
[32m+[m[32m                // Note how this condition would not be reached if an unknown OP_SUCCESSx was found[m
[32m+[m[32m                return set_error(serror, SCRIPT_ERR_BAD_OPCODE);[m
[32m+[m[32m            }[m
[32m+[m[32m            // New opcodes will be listed here. May use a different sigversion to modify existing opcodes.[m
[32m+[m[32m            if (IsOpSuccess(opcode)) {[m
[32m+[m[32m                if (flags & SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS) {[m
[32m+[m[32m                    return set_error(serror, SCRIPT_ERR_DISCOURAGE_OP_SUCCESS);[m
[32m+[m[32m                }[m
[32m+[m[32m                return set_success(serror);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Tapscript enforces initial stack size limits (altstack is empty here)[m
[32m+[m[32m        if (stack.size() > MAX_STACK_SIZE) return set_error(serror, SCRIPT_ERR_STACK_SIZE);[m
[32m+[m[32m    }[m
[32m+[m
     // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack[m
     for (const valtype& elem : stack) {[m
         if (elem.size() > MAX_SCRIPT_ELEMENT_SIZE) return set_error(serror, SCRIPT_ERR_PUSH_SIZE);[m
     }[m
 [m
     // Run the script interpreter.[m
[31m-    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, serror)) return false;[m
[32m+[m[32m    if (!EvalScript(stack, scriptPubKey, flags, checker, sigversion, execdata, serror)) return false;[m
 [m
     // Scripts inside witness implicitly require cleanstack behaviour[m
     if (stack.size() != 1) return set_error(serror, SCRIPT_ERR_CLEANSTACK);[m
[36m@@ -1522,40 +1831,104 @@[m [mstatic bool ExecuteWitnessScript(const Span<const valtype>& stack_span, const CS[m
     return true;[m
 }[m
 [m
[31m-static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)[m
[32m+[m[32mstatic bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, const std::vector<unsigned char>& program, const CScript& script, uint256& tapleaf_hash)[m
 {[m
[31m-    CScript scriptPubKey;[m
[32m+[m[32m    const int path_len = (control.size() - TAPROOT_CONTROL_BASE_SIZE) / TAPROOT_CONTROL_NODE_SIZE;[m
[32m+[m[32m    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};[m
[32m+[m[32m    const XOnlyPubKey q{uint256(program)};[m
[32m+[m[32m    tapleaf_hash = (CHashWriter(HASHER_TAPLEAF) << uint8_t(control[0] & TAPROOT_LEAF_MASK) << script).GetSHA256();[m
[32m+[m[32m    uint256 k = tapleaf_hash;[m
[32m+[m[32m    for (int i = 0; i < path_len; ++i) {[m
[32m+[m[32m        CHashWriter ss_branch{HASHER_TAPBRANCH};[m
[32m+[m[32m        Span<const unsigned char> node(control.data() + TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * i, TAPROOT_CONTROL_NODE_SIZE);[m
[32m+[m[32m        if (std::lexicographical_compare(k.begin(), k.end(), node.begin(), node.end())) {[m
[32m+[m[32m            ss_branch << k << node;[m
[32m+[m[32m        } else {[m
[32m+[m[32m            ss_branch << node << k;[m
[32m+[m[32m        }[m
[32m+[m[32m        k = ss_branch.GetSHA256();[m
[32m+[m[32m    }[m
[32m+[m[32m    k = (CHashWriter(HASHER_TAPTWEAK) << MakeSpan(p) << k).GetSHA256();[m
[32m+[m[32m    return q.CheckPayToContract(p, k, control[0] & 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror, bool is_p2sh)[m
[32m+[m[32m{[m
[32m+[m[32m    CScript exec_script; //!< Actually executed script (last stack item in P2WSH; implied P2PKH script in P2WPKH; leaf script in P2TR)[m
     Span<const valtype> stack{witness.stack};[m
[32m+[m[32m    ScriptExecutionData execdata;[m
 [m
     if (witversion == 0) {[m
         if (program.size() == WITNESS_V0_SCRIPTHASH_SIZE) {[m
[31m-            // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness[m
[32m+[m[32m            // BIP141 P2WSH: 32-byte witness v0 program (which encodes SHA256(script))[m
             if (stack.size() == 0) {[m
                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);[m
             }[m
             const valtype& script_bytes = SpanPopBack(stack);[m
[31m-            scriptPubKey = CScript(script_bytes.begin(), script_bytes.end());[m
[31m-            uint256 hashScriptPubKey;[m
[31m-            CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());[m
[31m-            if (memcmp(hashScriptPubKey.begin(), program.data(), 32)) {[m
[32m+[m[32m            exec_script = CScript(script_bytes.begin(), script_bytes.end());[m
[32m+[m[32m            uint256 hash_exec_script;[m
[32m+[m[32m            CSHA256().Write(&exec_script[0], exec_script.size()).Finalize(hash_exec_script.begin());[m
[32m+[m[32m            if (memcmp(hash_exec_script.begin(), program.data(), 32)) {[m
                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);[m
             }[m
[31m-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);[m
[32m+[m[32m            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, execdata, serror);[m
         } else if (program.size() == WITNESS_V0_KEYHASH_SIZE) {[m
[31m-            // Special case for pay-to-pubkeyhash; signature + pubkey in witness[m
[32m+[m[32m            // BIP141 P2WPKH: 20-byte witness v0 program (which encodes Hash160(pubkey))[m
             if (stack.size() != 2) {[m
                 return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness[m
             }[m
[31m-            scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;[m
[31m-            return ExecuteWitnessScript(stack, scriptPubKey, flags, SigVersion::WITNESS_V0, checker, serror);[m
[32m+[m[32m            exec_script << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;[m
[32m+[m[32m            return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::WITNESS_V0, checker, execdata, serror);[m
         } else {[m
             return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);[m
         }[m
[32m+[m[32m    } else if (witversion == 1 && program.size() == WITNESS_V1_TAPROOT_SIZE && !is_p2sh) {[m
[32m+[m[32m        // BIP341 Taproot: 32-byte non-P2SH witness v1 program (which encodes a P2C-tweaked pubkey)[m
[32m+[m[32m        if (!(flags & SCRIPT_VERIFY_TAPROOT)) return set_success(serror);[m
[32m+[m[32m        if (stack.size() == 0) return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);[m
[32m+[m[32m        if (stack.size() >= 2 && !stack.back().empty() && stack.back()[0] == ANNEX_TAG) {[m
[32m+[m[32m            // Drop annex (this is non-standard; see IsWitnessStandard)[m
[32m+[m[32m            const valtype& annex = SpanPopBack(stack);[m
[32m+[m[32m            execdata.m_annex_hash = (CHashWriter(SER_GETHASH, 0) << annex).GetSHA256();[m
[32m+[m[32m            execdata.m_annex_present = true;[m
[32m+[m[32m        } else {[m
[32m+[m[32m            execdata.m_annex_present = false;[m
[32m+[m[32m        }[m
[32m+[m[32m        execdata.m_annex_init = true;[m
[32m+[m[32m        if (stack.size() == 1) {[m
[32m+[m[32m            // Key path spending (stack size is 1 after removing optional annex)[m
[32m+[m[32m            if (!checker.CheckSchnorrSignature(stack.front(), program, SigVersion::TAPROOT, execdata, serror)) {[m
[32m+[m[32m                return false; // serror is set[m
[32m+[m[32m            }[m
[32m+[m[32m            return set_success(serror);[m
[32m+[m[32m        } else {[m
[32m+[m[32m            // Script path spending (stack size is >1 after removing optional annex)[m
[32m+[m[32m            const valtype& control = SpanPopBack(stack);[m
[32m+[m[32m            const valtype& script_bytes = SpanPopBack(stack);[m
[32m+[m[32m            exec_script = CScript(script_bytes.begin(), script_bytes.end());[m
[32m+[m[32m            if (control.size() < TAPROOT_CONTROL_BASE_SIZE || control.size() > TAPROOT_CONTROL_MAX_SIZE || ((control.size() - TAPROOT_CONTROL_BASE_SIZE) % TAPROOT_CONTROL_NODE_SIZE) != 0) {[m
[32m+[m[32m                return set_error(serror, SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (!VerifyTaprootCommitment(control, program, exec_script, execdata.m_tapleaf_hash)) {[m
[32m+[m[32m                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);[m
[32m+[m[32m            }[m
[32m+[m[32m            execdata.m_tapleaf_hash_init = true;[m
[32m+[m[32m            if ((control[0] & TAPROOT_LEAF_MASK) == TAPROOT_LEAF_TAPSCRIPT) {[m
[32m+[m[32m                // Tapscript (leaf version 0xc0)[m
[32m+[m[32m                execdata.m_validation_weight_left = ::GetSerializeSize(witness.stack, PROTOCOL_VERSION) + VALIDATION_WEIGHT_OFFSET;[m
[32m+[m[32m                execdata.m_validation_weight_left_init = true;[m
[32m+[m[32m                return ExecuteWitnessScript(stack, exec_script, flags, SigVersion::TAPSCRIPT, checker, execdata, serror);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION) {[m
[32m+[m[32m                return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION);[m
[32m+[m[32m            }[m
[32m+[m[32m            return set_success(serror);[m
[32m+[m[32m        }[m
     } else {[m
         if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {[m
             return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);[m
         }[m
[31m-        // Higher version witness scripts return true for future softfork compatibility[m
[32m+[m[32m        // Other version/size/p2sh combinations return true for future softfork compatibility[m
         return true;[m
     }[m
     // There is intentionally no return statement here, to be able to use "control reaches end of non-void function" warnings to detect gaps in the logic above.[m
[36m@@ -1601,7 +1974,7 @@[m [mbool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C[m
                 // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.[m
                 return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);[m
             }[m
[31m-            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {[m
[32m+[m[32m            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /* is_p2sh */ false)) {[m
                 return false;[m
             }[m
             // Bypass the cleanstack check at the end. The actual stack is obviously not clean[m
[36m@@ -1646,7 +2019,7 @@[m [mbool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C[m
                     // reintroduce malleability.[m
                     return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);[m
                 }[m
[31m-                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {[m
[32m+[m[32m                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror, /* is_p2sh */ true)) {[m
                     return false;[m
                 }[m
                 // Bypass the cleanstack check at the end. The actual stack is obviously not clean[m
[33mdiff --git a/src/script/interpreter.h b/src/script/interpreter.h[m
[33mindex 71f2436369..c0c2b012c6 100644[m
[33m--- a/src/script/interpreter.h[m
[33m+++ b/src/script/interpreter.h[m
[36m@@ -7,14 +7,17 @@[m
 #define BITCOIN_SCRIPT_INTERPRETER_H[m
 [m
 #include <script/script_error.h>[m
[32m+[m[32m#include <span.h>[m
 #include <primitives/transaction.h>[m
 [m
 #include <vector>[m
 #include <stdint.h>[m
 [m
 class CPubKey;[m
[32m+[m[32mclass XOnlyPubKey;[m
 class CScript;[m
 class CTransaction;[m
[32m+[m[32mclass CTxOut;[m
 class uint256;[m
 [m
 /** Signature hash types/flags */[m
[36m@@ -24,6 +27,10 @@[m [menum[m
     SIGHASH_NONE = 2,[m
     SIGHASH_SINGLE = 3,[m
     SIGHASH_ANYONECANPAY = 0x80,[m
[32m+[m
[32m+[m[32m    SIGHASH_DEFAULT = 0, //!< Taproot only; implied when sighash byte is missing, and equivalent to SIGHASH_ALL[m
[32m+[m[32m    SIGHASH_OUTPUT_MASK = 3,[m
[32m+[m[32m    SIGHASH_INPUT_MASK = 0x80,[m
 };[m
 [m
 /** Script verification flags.[m
[36m@@ -79,6 +86,8 @@[m [menum[m
     // "Exactly one stack element must remain, and when interpreted as a boolean, it must be true".[m
     // (BIP62 rule 6)[m
     // Note: CLEANSTACK should never be used without P2SH or WITNESS.[m
[32m+[m[32m    // Note: WITNESS_V0 and TAPSCRIPT script execution have behavior similar to CLEANSTACK as part of their[m
[32m+[m[32m    //       consensus rules. It is automatic there and does not need this flag.[m
     SCRIPT_VERIFY_CLEANSTACK = (1U << 8),[m
 [m
     // Verify CHECKLOCKTIMEVERIFY[m
[36m@@ -101,6 +110,8 @@[m [menum[m
 [m
     // Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector[m
     //[m
[32m+[m[32m    // Note: TAPSCRIPT script execution has behavior similar to MINIMALIF as part of its consensus[m
[32m+[m[32m    //       rules. It is automatic there and does not depend on this flag.[m
     SCRIPT_VERIFY_MINIMALIF = (1U << 13),[m
 [m
     // Signature(s) must be empty vector if a CHECK(MULTI)SIG operation failed[m
[36m@@ -114,19 +125,49 @@[m [menum[m
     // Making OP_CODESEPARATOR and FindAndDelete fail any non-segwit scripts[m
     //[m
     SCRIPT_VERIFY_CONST_SCRIPTCODE = (1U << 16),[m
[32m+[m
[32m+[m[32m    // Taproot/Tapscript validation (BIPs 341 & 342)[m
[32m+[m[32m    //[m
[32m+[m[32m    SCRIPT_VERIFY_TAPROOT = (1U << 17),[m
[32m+[m
[32m+[m[32m    // Making unknown Taproot leaf versions non-standard[m
[32m+[m[32m    //[m
[32m+[m[32m    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION = (1U << 18),[m
[32m+[m
[32m+[m[32m    // Making unknown OP_SUCCESS non-standard[m
[32m+[m[32m    SCRIPT_VERIFY_DISCOURAGE_OP_SUCCESS = (1U << 19),[m
[32m+[m
[32m+[m[32m    // Making unknown public key versions (in BIP 342 scripts) non-standard[m
[32m+[m[32m    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE = (1U << 20),[m
 };[m
 [m
 bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);[m
 [m
 struct PrecomputedTransactionData[m
 {[m
[32m+[m[32m    // BIP341 precomputed data.[m
[32m+[m[32m    // These are single-SHA256, see https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-15.[m
[32m+[m[32m    uint256 m_prevouts_single_hash;[m
[32m+[m[32m    uint256 m_sequences_single_hash;[m
[32m+[m[32m    uint256 m_outputs_single_hash;[m
[32m+[m[32m    uint256 m_spent_amounts_single_hash;[m
[32m+[m[32m    uint256 m_spent_scripts_single_hash;[m
[32m+[m[32m    //! Whether the 5 fields above are initialized.[m
[32m+[m[32m    bool m_bip341_taproot_ready = false;[m
[32m+[m
[32m+[m[32m    // BIP143 precomputed data (double-SHA256).[m
     uint256 hashPrevouts, hashSequence, hashOutputs;[m
[31m-    bool m_ready = false;[m
[32m+[m[32m    //! Whether the 3 fields above are initialized.[m
[32m+[m[32m    bool m_bip143_segwit_ready = false;[m
[32m+[m
[32m+[m[32m    std::vector<CTxOut> m_spent_outputs;[m
[32m+[m[32m    //! Whether m_spent_outputs is initialized.[m
[32m+[m[32m    bool m_spent_outputs_ready = false;[m
 [m
     PrecomputedTransactionData() = default;[m
 [m
     template <class T>[m
[31m-    void Init(const T& tx);[m
[32m+[m[32m    void Init(const T& tx, std::vector<CTxOut>&& spent_outputs);[m
 [m
     template <class T>[m
     explicit PrecomputedTransactionData(const T& tx);[m
[36m@@ -134,13 +175,48 @@[m [mstruct PrecomputedTransactionData[m
 [m
 enum class SigVersion[m
 {[m
[31m-    BASE = 0,[m
[31m-    WITNESS_V0 = 1,[m
[32m+[m[32m    BASE = 0,        //!< Bare scripts and BIP16 P2SH-wrapped redeemscripts[m
[32m+[m[32m    WITNESS_V0 = 1,  //!< Witness v0 (P2WPKH and P2WSH); see BIP 141[m
[32m+[m[32m    TAPROOT = 2,     //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, key path spending; see BIP 341[m
[32m+[m[32m    TAPSCRIPT = 3,   //!< Witness v1 with 32-byte program, not BIP16 P2SH-wrapped, script path spending, leaf version 0xc0; see BIP 342[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstruct ScriptExecutionData[m
[32m+[m[32m{[m
[32m+[m[32m    //! Whether m_tapleaf_hash is initialized.[m
[32m+[m[32m    bool m_tapleaf_hash_init = false;[m
[32m+[m[32m    //! The tapleaf hash.[m
[32m+[m[32m    uint256 m_tapleaf_hash;[m
[32m+[m
[32m+[m[32m    //! Whether m_codeseparator_pos is initialized.[m
[32m+[m[32m    bool m_codeseparator_pos_init = false;[m
[32m+[m[32m    //! Opcode position of the last executed OP_CODESEPARATOR (or 0xFFFFFFFF if none executed).[m
[32m+[m[32m    uint32_t m_codeseparator_pos;[m
[32m+[m
[32m+[m[32m    //! Whether m_annex_present and (when needed) m_annex_hash are initialized.[m
[32m+[m[32m    bool m_annex_init = false;[m
[32m+[m[32m    //! Whether an annex is present.[m
[32m+[m[32m    bool m_annex_present;[m
[32m+[m[32m    //! Hash of the annex data.[m
[32m+[m[32m    uint256 m_annex_hash;[m
[32m+[m
[32m+[m[32m    //! Whether m_validation_weight_left is initialized.[m
[32m+[m[32m    bool m_validation_weight_left_init = false;[m
[32m+[m[32m    //! How much validation weight is left (decremented for every successful non-empty signature check).[m
[32m+[m[32m    int64_t m_validation_weight_left;[m
 };[m
 [m
 /** Signature hash sizes */[m
 static constexpr size_t WITNESS_V0_SCRIPTHASH_SIZE = 32;[m
 static constexpr size_t WITNESS_V0_KEYHASH_SIZE = 20;[m
[32m+[m[32mstatic constexpr size_t WITNESS_V1_TAPROOT_SIZE = 32;[m
[32m+[m
[32m+[m[32mstatic constexpr uint8_t TAPROOT_LEAF_MASK = 0xfe;[m
[32m+[m[32mstatic constexpr uint8_t TAPROOT_LEAF_TAPSCRIPT = 0xc0;[m
[32m+[m[32mstatic constexpr size_t TAPROOT_CONTROL_BASE_SIZE = 33;[m
[32m+[m[32mstatic constexpr size_t TAPROOT_CONTROL_NODE_SIZE = 32;[m
[32m+[m[32mstatic constexpr size_t TAPROOT_CONTROL_MAX_NODE_COUNT = 128;[m
[32m+[m[32mstatic constexpr size_t TAPROOT_CONTROL_MAX_SIZE = TAPROOT_CONTROL_BASE_SIZE + TAPROOT_CONTROL_NODE_SIZE * TAPROOT_CONTROL_MAX_NODE_COUNT;[m
 [m
 template <class T>[m
 uint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);[m
[36m@@ -148,7 +224,12 @@[m [muint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn[m
 class BaseSignatureChecker[m
 {[m
 public:[m
[31m-    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const[m
[32m+[m[32m    virtual bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const[m
[32m+[m[32m    {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    virtual bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const[m
     {[m
         return false;[m
     }[m
[36m@@ -176,12 +257,14 @@[m [mprivate:[m
     const PrecomputedTransactionData* txdata;[m
 [m
 protected:[m
[31m-    virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;[m
[32m+[m[32m    virtual bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;[m
[32m+[m[32m    virtual bool VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const;[m
 [m
 public:[m
     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(nullptr) {}[m
     GenericTransactionSignatureChecker(const T* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}[m
[31m-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;[m
[32m+[m[32m    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;[m
[32m+[m[32m    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override;[m
     bool CheckLockTime(const CScriptNum& nLockTime) const override;[m
     bool CheckSequence(const CScriptNum& nSequence) const override;[m
 };[m
[36m@@ -189,6 +272,7 @@[m [mpublic:[m
 using TransactionSignatureChecker = GenericTransactionSignatureChecker<CTransaction>;[m
 using MutableTransactionSignatureChecker = GenericTransactionSignatureChecker<CMutableTransaction>;[m
 [m
[32m+[m[32mbool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptExecutionData& execdata, ScriptError* error = nullptr);[m
 bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = nullptr);[m
 bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = nullptr);[m
 [m
[33mdiff --git a/src/script/script.cpp b/src/script/script.cpp[m
[33mindex 92c6fe7785..f31472e42d 100644[m
[33m--- a/src/script/script.cpp[m
[33m+++ b/src/script/script.cpp[m
[36m@@ -140,6 +140,9 @@[m [mstd::string GetOpName(opcodetype opcode)[m
     case OP_NOP9                   : return "OP_NOP9";[m
     case OP_NOP10                  : return "OP_NOP10";[m
 [m
[32m+[m[32m    // Opcode added by BIP 342 (Tapscript)[m
[32m+[m[32m    case OP_CHECKSIGADD            : return "OP_CHECKSIGADD";[m
[32m+[m
     case OP_INVALIDOPCODE          : return "OP_INVALIDOPCODE";[m
 [m
     default:[m
[36m@@ -328,3 +331,11 @@[m [mbool GetScriptOp(CScriptBase::const_iterator& pc, CScriptBase::const_iterator en[m
     opcodeRet = static_cast<opcodetype>(opcode);[m
     return true;[m
 }[m
[32m+[m
[32m+[m[32mbool IsOpSuccess(const opcodetype& opcode)[m
[32m+[m[32m{[m
[32m+[m[32m    return opcode == 80 || opcode == 98 || (opcode >= 126 && opcode <= 129) ||[m
[32m+[m[32m           (opcode >= 131 && opcode <= 134) || (opcode >= 137 && opcode <= 138) ||[m
[32m+[m[32m           (opcode >= 141 && opcode <= 142) || (opcode >= 149 && opcode <= 153) ||[m
[32m+[m[32m           (opcode >= 187 && opcode <= 254);[m
[32m+[m[32m}[m
[33mdiff --git a/src/script/script.h b/src/script/script.h[m
[33mindex c1f2b66921..974cde4984 100644[m
[33m--- a/src/script/script.h[m
[33m+++ b/src/script/script.h[m
[36m@@ -44,6 +44,17 @@[m [mstatic const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20[m
 // SEQUENCE_FINAL).[m
 static const uint32_t LOCKTIME_MAX = 0xFFFFFFFFU;[m
 [m
[32m+[m[32m// Tag for input annex. If there are at least two witness elements for a transaction input,[m
[32m+[m[32m// and the first byte of the last element is 0x50, this last element is called annex, and[m
[32m+[m[32m// has meanings independent of the script[m
[32m+[m[32mstatic constexpr unsigned int ANNEX_TAG = 0x50;[m
[32m+[m
[32m+[m[32m// Validation weight per passing signature (Tapscript only, see BIP 342).[m
[32m+[m[32mstatic constexpr uint64_t VALIDATION_WEIGHT_PER_SIGOP_PASSED = 50;[m
[32m+[m
[32m+[m[32m// How much weight budget is added to the witness size (Tapscript only, see BIP 342).[m
[32m+[m[32mstatic constexpr uint64_t VALIDATION_WEIGHT_OFFSET = 50;[m
[32m+[m
 template <typename T>[m
 std::vector<unsigned char> ToByteVector(const T& in)[m
 {[m
[36m@@ -187,6 +198,9 @@[m [menum opcodetype[m
     OP_NOP9 = 0xb8,[m
     OP_NOP10 = 0xb9,[m
 [m
[32m+[m[32m    // Opcode added by BIP 342 (Tapscript)[m
[32m+[m[32m    OP_CHECKSIGADD = 0xba,[m
[32m+[m
     OP_INVALIDOPCODE = 0xff,[m
 };[m
 [m
[36m@@ -555,4 +569,7 @@[m [mstruct CScriptWitness[m
     std::string ToString() const;[m
 };[m
 [m
[32m+[m[32m/** Test for OP_SUCCESSx opcodes as defined by BIP342. */[m
[32m+[m[32mbool IsOpSuccess(const opcodetype& opcode);[m
[32m+[m
 #endif // BITCOIN_SCRIPT_SCRIPT_H[m
[33mdiff --git a/src/script/script_error.cpp b/src/script/script_error.cpp[m
[33mindex 3b383393f9..fadc04262c 100644[m
[33m--- a/src/script/script_error.cpp[m
[33m+++ b/src/script/script_error.cpp[m
[36m@@ -73,6 +73,12 @@[m [mstd::string ScriptErrorString(const ScriptError serror)[m
             return "NOPx reserved for soft-fork upgrades";[m
         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM:[m
             return "Witness version reserved for soft-fork upgrades";[m
[32m+[m[32m        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION:[m
[32m+[m[32m            return "Taproot version reserved for soft-fork upgrades";[m
[32m+[m[32m        case SCRIPT_ERR_DISCOURAGE_OP_SUCCESS:[m
[32m+[m[32m            return "OP_SUCCESSx reserved for soft-fork upgrades";[m
[32m+[m[32m        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE:[m
[32m+[m[32m            return "Public key version reserved for soft-fork upgrades";[m
         case SCRIPT_ERR_PUBKEYTYPE:[m
             return "Public key is neither compressed or uncompressed";[m
         case SCRIPT_ERR_CLEANSTACK:[m
[36m@@ -91,6 +97,20 @@[m [mstd::string ScriptErrorString(const ScriptError serror)[m
             return "Witness provided for non-witness script";[m
         case SCRIPT_ERR_WITNESS_PUBKEYTYPE:[m
             return "Using non-compressed keys in segwit";[m
[32m+[m[32m        case SCRIPT_ERR_SCHNORR_SIG_SIZE:[m
[32m+[m[32m            return "Invalid Schnorr signature size";[m
[32m+[m[32m        case SCRIPT_ERR_SCHNORR_SIG_HASHTYPE:[m
[32m+[m[32m            return "Invalid Schnorr signature hash type";[m
[32m+[m[32m        case SCRIPT_ERR_SCHNORR_SIG:[m
[32m+[m[32m            return "Invalid Schnorr signature";[m
[32m+[m[32m        case SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE:[m
[32m+[m[32m            return "Invalid Taproot control block size";[m
[32m+[m[32m        case SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT:[m
[32m+[m[32m            return "Too much signature validation relative to witness weight";[m
[32m+[m[32m        case SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG:[m
[32m+[m[32m            return "OP_CHECKMULTISIG(VERIFY) is not available in tapscript";[m
[32m+[m[32m        case SCRIPT_ERR_TAPSCRIPT_MINIMALIF:[m
[32m+[m[32m            return "OP_IF/NOTIF argument must be minimal in tapscript";[m
         case SCRIPT_ERR_OP_CODESEPARATOR:[m
             return "Using OP_CODESEPARATOR in non-witness script";[m
         case SCRIPT_ERR_SIG_FINDANDDELETE:[m
[33mdiff --git a/src/script/script_error.h b/src/script/script_error.h[m
[33mindex 2978c147e1..b071681613 100644[m
[33m--- a/src/script/script_error.h[m
[33m+++ b/src/script/script_error.h[m
[36m@@ -56,6 +56,9 @@[m [mtypedef enum ScriptError_t[m
     /* softfork safeness */[m
     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,[m
     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,[m
[32m+[m[32m    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_TAPROOT_VERSION,[m
[32m+[m[32m    SCRIPT_ERR_DISCOURAGE_OP_SUCCESS,[m
[32m+[m[32m    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE,[m
 [m
     /* segregated witness */[m
     SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH,[m
[36m@@ -66,6 +69,15 @@[m [mtypedef enum ScriptError_t[m
     SCRIPT_ERR_WITNESS_UNEXPECTED,[m
     SCRIPT_ERR_WITNESS_PUBKEYTYPE,[m
 [m
[32m+[m[32m    /* Taproot */[m
[32m+[m[32m    SCRIPT_ERR_SCHNORR_SIG_SIZE,[m
[32m+[m[32m    SCRIPT_ERR_SCHNORR_SIG_HASHTYPE,[m
[32m+[m[32m    SCRIPT_ERR_SCHNORR_SIG,[m
[32m+[m[32m    SCRIPT_ERR_TAPROOT_WRONG_CONTROL_SIZE,[m
[32m+[m[32m    SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT,[m
[32m+[m[32m    SCRIPT_ERR_TAPSCRIPT_CHECKMULTISIG,[m
[32m+[m[32m    SCRIPT_ERR_TAPSCRIPT_MINIMALIF,[m
[32m+[m
     /* Constant scriptCode */[m
     SCRIPT_ERR_OP_CODESEPARATOR,[m
     SCRIPT_ERR_SIG_FINDANDDELETE,[m
[33mdiff --git a/src/script/sigcache.cpp b/src/script/sigcache.cpp[m
[33mindex aaecab1ef2..4a6e04f2eb 100644[m
[33m--- a/src/script/sigcache.cpp[m
[33m+++ b/src/script/sigcache.cpp[m
[36m@@ -22,8 +22,9 @@[m [mnamespace {[m
 class CSignatureCache[m
 {[m
 private:[m
[31m-     //! Entries are SHA256(nonce || signature hash || public key || signature):[m
[31m-    CSHA256 m_salted_hasher;[m
[32m+[m[32m     //! Entries are SHA256(nonce || 'E' or 'S' || 31 zero bytes || signature hash || public key || signature):[m
[32m+[m[32m    CSHA256 m_salted_hasher_ecdsa;[m
[32m+[m[32m    CSHA256 m_salted_hasher_schnorr;[m
     typedef CuckooCache::cache<uint256, SignatureCacheHasher> map_type;[m
     map_type setValid;[m
     boost::shared_mutex cs_sigcache;[m
[36m@@ -34,18 +35,30 @@[m [mpublic:[m
         uint256 nonce = GetRandHash();[m
         // We want the nonce to be 64 bytes long to force the hasher to process[m
         // this chunk, which makes later hash computations more efficient. We[m
[31m-        // just write our 32-byte entropy twice to fill the 64 bytes.[m
[31m-        m_salted_hasher.Write(nonce.begin(), 32);[m
[31m-        m_salted_hasher.Write(nonce.begin(), 32);[m
[32m+[m[32m        // just write our 32-byte entropy, and then pad with 'E' for ECDSA and[m
[32m+[m[32m        // 'S' for Schnorr (followed by 0 bytes).[m
[32m+[m[32m        static constexpr unsigned char PADDING_ECDSA[32] = {'E'};[m
[32m+[m[32m        static constexpr unsigned char PADDING_SCHNORR[32] = {'S'};[m
[32m+[m[32m        m_salted_hasher_ecdsa.Write(nonce.begin(), 32);[m
[32m+[m[32m        m_salted_hasher_ecdsa.Write(PADDING_ECDSA, 32);[m
[32m+[m[32m        m_salted_hasher_schnorr.Write(nonce.begin(), 32);[m
[32m+[m[32m        m_salted_hasher_schnorr.Write(PADDING_SCHNORR, 32);[m
     }[m
 [m
     void[m
[31m-    ComputeEntry(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey)[m
[32m+[m[32m    ComputeEntryECDSA(uint256& entry, const uint256 &hash, const std::vector<unsigned char>& vchSig, const CPubKey& pubkey)[m
     {[m
[31m-        CSHA256 hasher = m_salted_hasher;[m
[32m+[m[32m        CSHA256 hasher = m_salted_hasher_ecdsa;[m
         hasher.Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(&vchSig[0], vchSig.size()).Finalize(entry.begin());[m
     }[m
 [m
[32m+[m[32m    void[m
[32m+[m[32m    ComputeEntrySchnorr(uint256& entry, const uint256 &hash, Span<const unsigned char> sig, const XOnlyPubKey& pubkey)[m
[32m+[m[32m    {[m
[32m+[m[32m        CSHA256 hasher = m_salted_hasher_schnorr;[m
[32m+[m[32m        hasher.Write(hash.begin(), 32).Write(&pubkey[0], pubkey.size()).Write(sig.data(), sig.size()).Finalize(entry.begin());[m
[32m+[m[32m    }[m
[32m+[m
     bool[m
     Get(const uint256& entry, const bool erase)[m
     {[m
[36m@@ -85,15 +98,25 @@[m [mvoid InitSignatureCache()[m
             (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);[m
 }[m
 [m
[31m-bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const[m
[32m+[m[32mbool CachingTransactionSignatureChecker::VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const[m
 {[m
     uint256 entry;[m
[31m-    signatureCache.ComputeEntry(entry, sighash, vchSig, pubkey);[m
[32m+[m[32m    signatureCache.ComputeEntryECDSA(entry, sighash, vchSig, pubkey);[m
     if (signatureCache.Get(entry, !store))[m
         return true;[m
[31m-    if (!TransactionSignatureChecker::VerifySignature(vchSig, pubkey, sighash))[m
[32m+[m[32m    if (!TransactionSignatureChecker::VerifyECDSASignature(vchSig, pubkey, sighash))[m
         return false;[m
     if (store)[m
         signatureCache.Set(entry);[m
     return true;[m
 }[m
[32m+[m
[32m+[m[32mbool CachingTransactionSignatureChecker::VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const[m
[32m+[m[32m{[m
[32m+[m[32m    uint256 entry;[m
[32m+[m[32m    signatureCache.ComputeEntrySchnorr(entry, sighash, sig, pubkey);[m
[32m+[m[32m    if (signatureCache.Get(entry, !store)) return true;[m
[32m+[m[32m    if (!TransactionSignatureChecker::VerifySchnorrSignature(sig, pubkey, sighash)) return false;[m
[32m+[m[32m    if (store) signatureCache.Set(entry);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[33mdiff --git a/src/script/sigcache.h b/src/script/sigcache.h[m
[33mindex 807b61b542..00534f9758 100644[m
[33m--- a/src/script/sigcache.h[m
[33m+++ b/src/script/sigcache.h[m
[36m@@ -7,6 +7,7 @@[m
 #define BITCOIN_SCRIPT_SIGCACHE_H[m
 [m
 #include <script/interpreter.h>[m
[32m+[m[32m#include <span.h>[m
 [m
 #include <vector>[m
 [m
[36m@@ -48,7 +49,8 @@[m [mprivate:[m
 public:[m
     CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}[m
 [m
[31m-    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;[m
[32m+[m[32m    bool VerifyECDSASignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;[m
[32m+[m[32m    bool VerifySchnorrSignature(Span<const unsigned char> sig, const XOnlyPubKey& pubkey, const uint256& sighash) const override;[m
 };[m
 [m
 void InitSignatureCache();[m
[33mdiff --git a/src/script/sign.cpp b/src/script/sign.cpp[m
[33mindex 9b3f94f14d..0e6864d547 100644[m
[33m--- a/src/script/sign.cpp[m
[33m+++ b/src/script/sign.cpp[m
[36m@@ -111,6 +111,7 @@[m [mstatic bool SignStep(const SigningProvider& provider, const BaseSignatureCreator[m
     case TxoutType::NONSTANDARD:[m
     case TxoutType::NULL_DATA:[m
     case TxoutType::WITNESS_UNKNOWN:[m
[32m+[m[32m    case TxoutType::WITNESS_V1_TAPROOT:[m
         return false;[m
     case TxoutType::PUBKEY:[m
         if (!CreateSig(creator, sigdata, provider, sig, CPubKey(vSolutions[0]), scriptPubKey, sigversion)) return false;[m
[36m@@ -260,9 +261,9 @@[m [mprivate:[m
 [m
 public:[m
     SignatureExtractorChecker(SignatureData& sigdata, BaseSignatureChecker& checker) : sigdata(sigdata), checker(checker) {}[m
[31m-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override[m
[32m+[m[32m    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override[m
     {[m
[31m-        if (checker.CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {[m
[32m+[m[32m        if (checker.CheckECDSASignature(scriptSig, vchPubKey, scriptCode, sigversion)) {[m
             CPubKey pubkey(vchPubKey);[m
             sigdata.signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));[m
             return true;[m
[36m@@ -339,7 +340,7 @@[m [mSignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nI[m
             for (unsigned int i = last_success_key; i < num_pubkeys; ++i) {[m
                 const valtype& pubkey = solutions[i+1];[m
                 // We either have a signature for this pubkey, or we have found a signature and it is valid[m
[31m-                if (data.signatures.count(CPubKey(pubkey).GetID()) || extractor_checker.CheckSig(sig, pubkey, next_script, sigversion)) {[m
[32m+[m[32m                if (data.signatures.count(CPubKey(pubkey).GetID()) || extractor_checker.CheckECDSASignature(sig, pubkey, next_script, sigversion)) {[m
                     last_success_key = i + 1;[m
                     break;[m
                 }[m
[36m@@ -400,7 +401,7 @@[m [mclass DummySignatureChecker final : public BaseSignatureChecker[m
 {[m
 public:[m
     DummySignatureChecker() {}[m
[31m-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override { return true; }[m
[32m+[m[32m    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override { return true; }[m
 };[m
 const DummySignatureChecker DUMMY_CHECKER;[m
 [m
[33mdiff --git a/src/script/sign.h b/src/script/sign.h[m
[33mindex b77d26c0d7..a1cfe1574d 100644[m
[33m--- a/src/script/sign.h[m
[33m+++ b/src/script/sign.h[m
[36m@@ -11,6 +11,7 @@[m
 #include <pubkey.h>[m
 #include <script/interpreter.h>[m
 #include <script/keyorigin.h>[m
[32m+[m[32m#include <span.h>[m
 #include <streams.h>[m
 [m
 class CKey;[m
[33mdiff --git a/src/script/standard.cpp b/src/script/standard.cpp[m
[33mindex 96a3d311a6..f2f81664f6 100644[m
[33m--- a/src/script/standard.cpp[m
[33m+++ b/src/script/standard.cpp[m
[36m@@ -55,6 +55,7 @@[m [mstd::string GetTxnOutputType(TxoutType t)[m
     case TxoutType::NULL_DATA: return "nulldata";[m
     case TxoutType::WITNESS_V0_KEYHASH: return "witness_v0_keyhash";[m
     case TxoutType::WITNESS_V0_SCRIPTHASH: return "witness_v0_scripthash";[m
[32m+[m[32m    case TxoutType::WITNESS_V1_TAPROOT: return "witness_v1_taproot";[m
     case TxoutType::WITNESS_UNKNOWN: return "witness_unknown";[m
     } // no default case, so the compiler can warn about missing cases[m
     assert(false);[m
[36m@@ -130,6 +131,11 @@[m [mTxoutType Solver(const CScript& scriptPubKey, std::vector<std::vector<unsigned c[m
             vSolutionsRet.push_back(witnessprogram);[m
             return TxoutType::WITNESS_V0_SCRIPTHASH;[m
         }[m
[32m+[m[32m        if (witnessversion == 1 && witnessprogram.size() == WITNESS_V1_TAPROOT_SIZE) {[m
[32m+[m[32m            vSolutionsRet.push_back(std::vector<unsigned char>{(unsigned char)witnessversion});[m
[32m+[m[32m            vSolutionsRet.push_back(std::move(witnessprogram));[m
[32m+[m[32m            return TxoutType::WITNESS_V1_TAPROOT;[m
[32m+[m[32m        }[m
         if (witnessversion != 0) {[m
             vSolutionsRet.push_back(std::vector<unsigned char>{(unsigned char)witnessversion});[m
             vSolutionsRet.push_back(std::move(witnessprogram));[m
[36m@@ -203,7 +209,7 @@[m [mbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)[m
         std::copy(vSolutions[0].begin(), vSolutions[0].end(), hash.begin());[m
         addressRet = hash;[m
         return true;[m
[31m-    } else if (whichType == TxoutType::WITNESS_UNKNOWN) {[m
[32m+[m[32m    } else if (whichType == TxoutType::WITNESS_UNKNOWN || whichType == TxoutType::WITNESS_V1_TAPROOT) {[m
         WitnessUnknown unk;[m
         unk.version = vSolutions[0][0];[m
         std::copy(vSolutions[1].begin(), vSolutions[1].end(), unk.program);[m
[33mdiff --git a/src/script/standard.h b/src/script/standard.h[m
[33mindex 6dbcd04968..721203385e 100644[m
[33m--- a/src/script/standard.h[m
[33m+++ b/src/script/standard.h[m
[36m@@ -129,6 +129,7 @@[m [menum class TxoutType {[m
     NULL_DATA, //!< unspendable OP_RETURN script that carries data[m
     WITNESS_V0_SCRIPTHASH,[m
     WITNESS_V0_KEYHASH,[m
[32m+[m[32m    WITNESS_V1_TAPROOT,[m
     WITNESS_UNKNOWN, //!< Only for Witness versions not already defined above[m
 };[m
 [m
[36m@@ -206,7 +207,8 @@[m [mstruct WitnessUnknown[m
  *  * ScriptHash: TxoutType::SCRIPTHASH destination (P2SH)[m
  *  * WitnessV0ScriptHash: TxoutType::WITNESS_V0_SCRIPTHASH destination (P2WSH)[m
  *  * WitnessV0KeyHash: TxoutType::WITNESS_V0_KEYHASH destination (P2WPKH)[m
[31m- *  * WitnessUnknown: TxoutType::WITNESS_UNKNOWN destination (P2W???)[m
[32m+[m[32m *  * WitnessUnknown: TxoutType::WITNESS_UNKNOWN/WITNESS_V1_TAPROOT destination (P2W???)[m
[32m+[m[32m *    (taproot outputs do not require their own type as long as no wallet support exists)[m
  *  A CTxDestination is the internal data type encoded in a bitcoin address[m
  */[m
 typedef boost::variant<CNoDestination, PKHash, ScriptHash, WitnessV0ScriptHash, WitnessV0KeyHash, WitnessUnknown> CTxDestination;[m
[33mdiff --git a/src/test/fuzz/script_assets_test_minimizer.cpp b/src/test/fuzz/script_assets_test_minimizer.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..d20fa43d68[m
[33m--- /dev/null[m
[33m+++ b/src/test/fuzz/script_assets_test_minimizer.cpp[m
[36m@@ -0,0 +1,200 @@[m
[32m+[m[32m// Copyright (c) 2020 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <test/fuzz/fuzz.h>[m
[32m+[m
[32m+[m[32m#include <primitives/transaction.h>[m
[32m+[m[32m#include <pubkey.h>[m
[32m+[m[32m#include <script/interpreter.h>[m
[32m+[m[32m#include <serialize.h>[m
[32m+[m[32m#include <streams.h>[m
[32m+[m[32m#include <univalue.h>[m
[32m+[m[32m#include <util/strencodings.h>[m
[32m+[m
[32m+[m[32m#include <boost/algorithm/string.hpp>[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32m// This fuzz "test" can be used to minimize test cases for script_assets_test in[m
[32m+[m[32m// src/test/script_tests.cpp. While it written as a fuzz test, and can be used as such,[m
[32m+[m[32m// fuzzing the inputs is unlikely to construct useful test cases.[m
[32m+[m[32m//[m
[32m+[m[32m// Instead, it is primarily intended to be run on a test set that was generated[m
[32m+[m[32m// externally, for example using test/functional/feature_taproot.py's --dumptests mode.[m
[32m+[m[32m// The minimized set can then be concatenated together, surrounded by '[' and ']',[m
[32m+[m[32m// and used as the script_assets_test.json input to the script_assets_test unit test:[m
[32m+[m[32m//[m
[32m+[m[32m// (normal build)[m
[32m+[m[32m// $ mkdir dump[m
[32m+[m[32m// $ for N in $(seq 1 10); do TEST_DUMP_DIR=dump test/functional/feature_taproot --dumptests; done[m
[32m+[m[32m// $ ...[m
[32m+[m[32m//[m
[32m+[m[32m// (fuzz test build)[m
[32m+[m[32m// $ mkdir dump-min[m
[32m+[m[32m// $ ./src/test/fuzz/script_assets_test_minimizer -merge=1 dump-min/ dump/[m
[32m+[m[32m// $ (echo -en '[\n'; cat dump-min/* | head -c -2; echo -en '\n]') >script_assets_test.json[m
[32m+[m
[32m+[m[32mnamespace {[m
[32m+[m
[32m+[m[32mstd::vector<unsigned char> CheckedParseHex(const std::string& str)[m
[32m+[m[32m{[m
[32m+[m[32m    if (str.size() && !IsHex(str)) throw std::runtime_error("Non-hex input '" + str + "'");[m
[32m+[m[32m    return ParseHex(str);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mCScript ScriptFromHex(const std::string& str)[m
[32m+[m[32m{[m
[32m+[m[32m    std::vector<unsigned char> data = CheckedParseHex(str);[m
[32m+[m[32m    return CScript(data.begin(), data.end());[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mCMutableTransaction TxFromHex(const std::string& str)[m
[32m+[m[32m{[m
[32m+[m[32m    CMutableTransaction tx;[m
[32m+[m[32m    try {[m
[32m+[m[32m        VectorReader(SER_DISK, SERIALIZE_TRANSACTION_NO_WITNESS, CheckedParseHex(str), 0) >> tx;[m
[32m+[m[32m    } catch (const std::ios_base::failure&) {[m
[32m+[m[32m        throw std::runtime_error("Tx deserialization failure");[m
[32m+[m[32m    }[m
[32m+[m[32m    return tx;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstd::vector<CTxOut> TxOutsFromJSON(const UniValue& univalue)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!univalue.isArray()) throw std::runtime_error("Prevouts must be array");[m
[32m+[m[32m    std::vector<CTxOut> prevouts;[m
[32m+[m[32m    for (size_t i = 0; i < univalue.size(); ++i) {[m
[32m+[m[32m        CTxOut txout;[m
[32m+[m[32m        try {[m
[32m+[m[32m            VectorReader(SER_DISK, 0, CheckedParseHex(univalue[i].get_str()), 0) >> txout;[m
[32m+[m[32m        } catch (const std::ios_base::failure&) {[m
[32m+[m[32m            throw std::runtime_error("Prevout invalid format");[m
[32m+[m[32m        }[m
[32m+[m[32m        prevouts.push_back(std::move(txout));[m
[32m+[m[32m    }[m
[32m+[m[32m    return prevouts;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mCScriptWitness ScriptWitnessFromJSON(const UniValue& univalue)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!univalue.isArray()) throw std::runtime_error("Script witness is not array");[m
[32m+[m[32m    CScriptWitness scriptwitness;[m
[32m+[m[32m    for (size_t i = 0; i < univalue.size(); ++i) {[m
[32m+[m[32m        auto bytes = CheckedParseHex(univalue[i].get_str());[m
[32m+[m[32m        scriptwitness.stack.push_back(std::move(bytes));[m
[32m+[m[32m    }[m
[32m+[m[32m    return scriptwitness;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst std::map<std::string, unsigned int> FLAG_NAMES = {[m
[32m+[m[32m    {std::string("P2SH"), (unsigned int)SCRIPT_VERIFY_P2SH},[m
[32m+[m[32m    {std::string("DERSIG"), (unsigned int)SCRIPT_VERIFY_DERSIG},[m
[32m+[m[32m    {std::string("NULLDUMMY"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},[m
[32m+[m[32m    {std::string("CHECKLOCKTIMEVERIFY"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},[m
[32m+[m[32m    {std::string("CHECKSEQUENCEVERIFY"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},[m
[32m+[m[32m    {std::string("WITNESS"), (unsigned int)SCRIPT_VERIFY_WITNESS},[m
[32m+[m[32m    {std::string("TAPROOT"), (unsigned int)SCRIPT_VERIFY_TAPROOT},[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstd::vector<unsigned int> AllFlags()[m
[32m+[m[32m{[m
[32m+[m[32m    std::vector<unsigned int> ret;[m
[32m+[m
[32m+[m[32m    for (unsigned int i = 0; i < 128; ++i) {[m
[32m+[m[32m        unsigned int flag = 0;[m
[32m+[m[32m        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;[m
[32m+[m[32m        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;[m
[32m+[m[32m        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;[m
[32m+[m[32m        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;[m
[32m+[m[32m        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;[m
[32m+[m[32m        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;[m
[32m+[m[32m        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;[m
[32m+[m
[32m+[m[32m        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH[m
[32m+[m[32m        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;[m
[32m+[m[32m        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS[m
[32m+[m[32m        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;[m
[32m+[m
[32m+[m[32m        ret.push_back(flag);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return ret;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mconst std::vector<unsigned int> ALL_FLAGS = AllFlags();[m
[32m+[m
[32m+[m[32munsigned int ParseScriptFlags(const std::string& str)[m
[32m+[m[32m{[m
[32m+[m[32m    if (str.empty()) return 0;[m
[32m+[m
[32m+[m[32m    unsigned int flags = 0;[m
[32m+[m[32m    std::vector<std::string> words;[m
[32m+[m[32m    boost::algorithm::split(words, str, boost::algorithm::is_any_of(","));[m
[32m+[m
[32m+[m[32m    for (const std::string& word : words)[m
[32m+[m[32m    {[m
[32m+[m[32m        auto it = FLAG_NAMES.find(word);[m
[32m+[m[32m        if (it == FLAG_NAMES.end()) throw std::runtime_error("Unknown verification flag " + word);[m
[32m+[m[32m        flags |= it->second;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return flags;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid Test(const std::string& str)[m
[32m+[m[32m{[m
[32m+[m[32m    UniValue test;[m
[32m+[m[32m    if (!test.read(str) || !test.isObject()) throw std::runtime_error("Non-object test input");[m
[32m+[m
[32m+[m[32m    CMutableTransaction tx = TxFromHex(test["tx"].get_str());[m
[32m+[m[32m    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test["prevouts"]);[m
[32m+[m[32m    if (prevouts.size() != tx.vin.size()) throw std::runtime_error("Incorrect number of prevouts");[m
[32m+[m[32m    size_t idx = test["index"].get_int64();[m
[32m+[m[32m    if (idx >= tx.vin.size()) throw std::runtime_error("Invalid index");[m
[32m+[m[32m    unsigned int test_flags = ParseScriptFlags(test["flags"].get_str());[m
[32m+[m[32m    bool final = test.exists("final") && test["final"].get_bool();[m
[32m+[m
[32m+[m[32m    if (test.exists("success")) {[m
[32m+[m[32m        tx.vin[idx].scriptSig = ScriptFromHex(test["success"]["scriptSig"].get_str());[m
[32m+[m[32m        tx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test["success"]["witness"]);[m
[32m+[m[32m        PrecomputedTransactionData txdata;[m
[32m+[m[32m        txdata.Init(tx, std::vector<CTxOut>(prevouts));[m
[32m+[m[32m        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata);[m
[32m+[m[32m        for (const auto flags : ALL_FLAGS) {[m
[32m+[m[32m            // "final": true tests are valid for all flags. Others are only valid with flags that are[m
[32m+[m[32m            // a subset of test_flags.[m
[32m+[m[32m            if (final || ((flags & test_flags) == flags)) {[m
[32m+[m[32m                (void)VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (test.exists("failure")) {[m
[32m+[m[32m        tx.vin[idx].scriptSig = ScriptFromHex(test["failure"]["scriptSig"].get_str());[m
[32m+[m[32m        tx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test["failure"]["witness"]);[m
[32m+[m[32m        PrecomputedTransactionData txdata;[m
[32m+[m[32m        txdata.Init(tx, std::vector<CTxOut>(prevouts));[m
[32m+[m[32m        MutableTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, txdata);[m
[32m+[m[32m        for (const auto flags : ALL_FLAGS) {[m
[32m+[m[32m            // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.[m
[32m+[m[32m            if ((flags & test_flags) == test_flags) {[m
[32m+[m[32m                (void)VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mECCVerifyHandle handle;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
[32m+[m[32m{[m
[32m+[m[32m    if (buffer.size() < 2 || buffer.back() != '\n' || buffer[buffer.size() - 2] != ',') return;[m
[32m+[m[32m    const std::string str((const char*)buffer.data(), buffer.size() - 2);[m
[32m+[m[32m    try {[m
[32m+[m[32m        Test(str);[m
[32m+[m[32m    } catch (const std::runtime_error&) {}[m
[32m+[m[32m}[m
[33mdiff --git a/src/test/fuzz/script_sigcache.cpp b/src/test/fuzz/script_sigcache.cpp[m
[33mindex 434a47b702..87af71897b 100644[m
[33m--- a/src/test/fuzz/script_sigcache.cpp[m
[33m+++ b/src/test/fuzz/script_sigcache.cpp[m
[36m@@ -35,11 +35,19 @@[m [mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
     const bool store = fuzzed_data_provider.ConsumeBool();[m
     PrecomputedTransactionData tx_data;[m
     CachingTransactionSignatureChecker caching_transaction_signature_checker{mutable_transaction ? &tx : nullptr, n_in, amount, store, tx_data};[m
[31m-    const std::optional<CPubKey> pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);[m
[31m-    if (pub_key) {[m
[31m-        const std::vector<uint8_t> random_bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);[m
[31m-        if (!random_bytes.empty()) {[m
[31m-            (void)caching_transaction_signature_checker.VerifySignature(random_bytes, *pub_key, ConsumeUInt256(fuzzed_data_provider));[m
[32m+[m[32m    if (fuzzed_data_provider.ConsumeBool()) {[m
[32m+[m[32m        const auto random_bytes = fuzzed_data_provider.ConsumeBytes<unsigned char>(64);[m
[32m+[m[32m        const XOnlyPubKey pub_key(ConsumeUInt256(fuzzed_data_provider));[m
[32m+[m[32m        if (random_bytes.size() == 64) {[m
[32m+[m[32m            (void)caching_transaction_signature_checker.VerifySchnorrSignature(random_bytes, pub_key, ConsumeUInt256(fuzzed_data_provider));[m
[32m+[m[32m        }[m
[32m+[m[32m    } else {[m
[32m+[m[32m        const auto random_bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);[m
[32m+[m[32m        const auto pub_key = ConsumeDeserializable<CPubKey>(fuzzed_data_provider);[m
[32m+[m[32m        if (pub_key) {[m
[32m+[m[32m            if (!random_bytes.empty()) {[m
[32m+[m[32m                (void)caching_transaction_signature_checker.VerifyECDSASignature(random_bytes, *pub_key, ConsumeUInt256(fuzzed_data_provider));[m
[32m+[m[32m            }[m
         }[m
     }[m
 }[m
[33mdiff --git a/src/test/fuzz/signature_checker.cpp b/src/test/fuzz/signature_checker.cpp[m
[33mindex 3aaeb66649..e121c89665 100644[m
[33m--- a/src/test/fuzz/signature_checker.cpp[m
[33m+++ b/src/test/fuzz/signature_checker.cpp[m
[36m@@ -28,7 +28,12 @@[m [mpublic:[m
     {[m
     }[m
 [m
[31m-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override[m
[32m+[m[32m    bool CheckECDSASignature(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override[m
[32m+[m[32m    {[m
[32m+[m[32m        return m_fuzzed_data_provider.ConsumeBool();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    bool CheckSchnorrSignature(Span<const unsigned char> sig, Span<const unsigned char> pubkey, SigVersion sigversion, const ScriptExecutionData& execdata, ScriptError* serror = nullptr) const override[m
     {[m
         return m_fuzzed_data_provider.ConsumeBool();[m
     }[m
[33mdiff --git a/src/test/key_tests.cpp b/src/test/key_tests.cpp[m
[33mindex 4e4c44266a..3362b8d17c 100644[m
[33m--- a/src/test/key_tests.cpp[m
[33m+++ b/src/test/key_tests.cpp[m
[36m@@ -264,4 +264,32 @@[m [mBOOST_AUTO_TEST_CASE(pubkey_unserialize)[m
     }[m
 }[m
 [m
[32m+[m[32mBOOST_AUTO_TEST_CASE(bip340_test_vectors)[m
[32m+[m[32m{[m
[32m+[m[32m    static const std::vector<std::pair<std::array<std::string, 3>, bool>> VECTORS = {[m
[32m+[m[32m        {{"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9", "0000000000000000000000000000000000000000000000000000000000000000", "E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0"}, true},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A"}, true},[m
[32m+[m[32m        {{"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8", "7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C", "5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7"}, true},[m
[32m+[m[32m        {{"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", "7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3"}, true},[m
[32m+[m[32m        {{"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9", "4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703", "00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4"}, true},[m
[32m+[m[32m        {{"EEFDEA4CDB677750A420FEE807EACF21EB9898AE79B9768766E4FAA04A2D4A34", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "FFF97BD5755EEEA420453A14355235D382F6472F8568A18B2F057A14602975563CC27944640AC607CD107AE10923D9EF7A73C643E166BE5EBEAFA34B1AC553E2"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "1FA62E331EDBC21C394792D2AB1100A7B432B013DF3F6FF4F99FCB33E0E1515F28890B3EDB6E7189B630448B515CE4F8622A954CFE545735AAEA5134FCCDB2BD"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769961764B3AA9B2FFCB6EF947B6887A226E8D7C93E00C5ED0C1834FF0D0C2E6DA6"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "0000000000000000000000000000000000000000000000000000000000000000123DDA8328AF9C23A94C1FEECFD123BA4FB73476F0D594DCB65C6425BD186051"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "00000000000000000000000000000000000000000000000000000000000000017615FBAF5AE28864013C099742DEADB4DBA87F11AC6754F93780D5A1837CF197"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "4A298DACAE57395A15D0795DDBFD1DCB564DA82B0F269BC70A74F8220429BA1D69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B"}, false},[m
[32m+[m[32m        {{"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"}, false},[m
[32m+[m[32m        {{"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30", "243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89", "6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B"}, false}[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    for (const auto& test : VECTORS) {[m
[32m+[m[32m        auto pubkey = ParseHex(test.first[0]);[m
[32m+[m[32m        auto msg = ParseHex(test.first[1]);[m
[32m+[m[32m        auto sig = ParseHex(test.first[2]);[m
[32m+[m[32m        BOOST_CHECK_EQUAL(XOnlyPubKey(pubkey).VerifySchnorr(uint256(msg), sig), test.second);[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
 BOOST_AUTO_TEST_SUITE_END()[m
[33mdiff --git a/src/test/script_tests.cpp b/src/test/script_tests.cpp[m
[33mindex 0830743d61..a2efd8ac07 100644[m
[33m--- a/src/test/script_tests.cpp[m
[33m+++ b/src/test/script_tests.cpp[m
[36m@@ -5,10 +5,12 @@[m
 #include <test/data/script_tests.json.h>[m
 [m
 #include <core_io.h>[m
[32m+[m[32m#include <fs.h>[m
 #include <key.h>[m
 #include <rpc/util.h>[m
 #include <script/script.h>[m
 #include <script/script_error.h>[m
[32m+[m[32m#include <script/sigcache.h>[m
 #include <script/sign.h>[m
 #include <script/signingprovider.h>[m
 #include <streams.h>[m
[36m@@ -1339,13 +1341,41 @@[m [mBOOST_AUTO_TEST_CASE(script_GetScriptAsm)[m
     BOOST_CHECK_EQUAL(derSig + "83 " + pubKey, ScriptToAsmStr(CScript() << ToByteVector(ParseHex(derSig + "83")) << vchPubKey));[m
 }[m
 [m
[31m-static CScript[m
[31m-ScriptFromHex(const char* hex)[m
[32m+[m[32mstatic CScript ScriptFromHex(const std::string& str)[m
 {[m
[31m-    std::vector<unsigned char> data = ParseHex(hex);[m
[32m+[m[32m    std::vector<unsigned char> data = ParseHex(str);[m
     return CScript(data.begin(), data.end());[m
 }[m
 [m
[32m+[m[32mstatic CMutableTransaction TxFromHex(const std::string& str)[m
[32m+[m[32m{[m
[32m+[m[32m    CMutableTransaction tx;[m
[32m+[m[32m    VectorReader(SER_DISK, SERIALIZE_TRANSACTION_NO_WITNESS, ParseHex(str), 0) >> tx;[m
[32m+[m[32m    return tx;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic std::vector<CTxOut> TxOutsFromJSON(const UniValue& univalue)[m
[32m+[m[32m{[m
[32m+[m[32m    assert(univalue.isArray());[m
[32m+[m[32m    std::vector<CTxOut> prevouts;[m
[32m+[m[32m    for (size_t i = 0; i < univalue.size(); ++i) {[m
[32m+[m[32m        CTxOut txout;[m
[32m+[m[32m        VectorReader(SER_DISK, 0, ParseHex(univalue[i].get_str()), 0) >> txout;[m
[32m+[m[32m        prevouts.push_back(std::move(txout));[m
[32m+[m[32m    }[m
[32m+[m[32m    return prevouts;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic CScriptWitness ScriptWitnessFromJSON(const UniValue& univalue)[m
[32m+[m[32m{[m
[32m+[m[32m    assert(univalue.isArray());[m
[32m+[m[32m    CScriptWitness scriptwitness;[m
[32m+[m[32m    for (size_t i = 0; i < univalue.size(); ++i) {[m
[32m+[m[32m        auto bytes = ParseHex(univalue[i].get_str());[m
[32m+[m[32m        scriptwitness.stack.push_back(std::move(bytes));[m
[32m+[m[32m    }[m
[32m+[m[32m    return scriptwitness;[m
[32m+[m[32m}[m
 [m
 BOOST_AUTO_TEST_CASE(script_FindAndDelete)[m
 {[m
[36m@@ -1610,5 +1640,107 @@[m [mBOOST_AUTO_TEST_CASE(bitcoinconsensus_verify_script_invalid_flags)[m
     BOOST_CHECK_EQUAL(err, bitcoinconsensus_ERR_INVALID_FLAGS);[m
 }[m
 [m
[32m+[m[32mstatic std::vector<unsigned int> AllConsensusFlags()[m
[32m+[m[32m{[m
[32m+[m[32m    std::vector<unsigned int> ret;[m
[32m+[m
[32m+[m[32m    for (unsigned int i = 0; i < 128; ++i) {[m
[32m+[m[32m        unsigned int flag = 0;[m
[32m+[m[32m        if (i & 1) flag |= SCRIPT_VERIFY_P2SH;[m
[32m+[m[32m        if (i & 2) flag |= SCRIPT_VERIFY_DERSIG;[m
[32m+[m[32m        if (i & 4) flag |= SCRIPT_VERIFY_NULLDUMMY;[m
[32m+[m[32m        if (i & 8) flag |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;[m
[32m+[m[32m        if (i & 16) flag |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;[m
[32m+[m[32m        if (i & 32) flag |= SCRIPT_VERIFY_WITNESS;[m
[32m+[m[32m        if (i & 64) flag |= SCRIPT_VERIFY_TAPROOT;[m
[32m+[m
[32m+[m[32m        // SCRIPT_VERIFY_WITNESS requires SCRIPT_VERIFY_P2SH[m
[32m+[m[32m        if (flag & SCRIPT_VERIFY_WITNESS && !(flag & SCRIPT_VERIFY_P2SH)) continue;[m
[32m+[m[32m        // SCRIPT_VERIFY_TAPROOT requires SCRIPT_VERIFY_WITNESS[m
[32m+[m[32m        if (flag & SCRIPT_VERIFY_TAPROOT && !(flag & SCRIPT_VERIFY_WITNESS)) continue;[m
[32m+[m
[32m+[m[32m        ret.push_back(flag);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return ret;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/** Precomputed list of all valid combinations of consensus-relevant script validation flags. */[m
[32m+[m[32mstatic const std::vector<unsigned int> ALL_CONSENSUS_FLAGS = AllConsensusFlags();[m
[32m+[m
[32m+[m[32mstatic void AssetTest(const UniValue& test)[m
[32m+[m[32m{[m
[32m+[m[32m    BOOST_CHECK(test.isObject());[m
[32m+[m
[32m+[m[32m    CMutableTransaction mtx = TxFromHex(test["tx"].get_str());[m
[32m+[m[32m    const std::vector<CTxOut> prevouts = TxOutsFromJSON(test["prevouts"]);[m
[32m+[m[32m    BOOST_CHECK(prevouts.size() == mtx.vin.size());[m
[32m+[m[32m    size_t idx = test["index"].get_int64();[m
[32m+[m[32m    unsigned int test_flags = ParseScriptFlags(test["flags"].get_str());[m
[32m+[m[32m    bool fin = test.exists("final") && test["final"].get_bool();[m
[32m+[m
[32m+[m[32m    if (test.exists("success")) {[m
[32m+[m[32m        mtx.vin[idx].scriptSig = ScriptFromHex(test["success"]["scriptSig"].get_str());[m
[32m+[m[32m        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test["success"]["witness"]);[m
[32m+[m[32m        CTransaction tx(mtx);[m
[32m+[m[32m        PrecomputedTransactionData txdata;[m
[32m+[m[32m        txdata.Init(tx, std::vector<CTxOut>(prevouts));[m
[32m+[m[32m        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);[m
[32m+[m[32m        for (const auto flags : ALL_CONSENSUS_FLAGS) {[m
[32m+[m[32m            // "final": true tests are valid for all flags. Others are only valid with flags that are[m
[32m+[m[32m            // a subset of test_flags.[m
[32m+[m[32m            if (fin || ((flags & test_flags) == flags)) {[m
[32m+[m[32m                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
[32m+[m[32m                BOOST_CHECK(ret);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (test.exists("failure")) {[m
[32m+[m[32m        mtx.vin[idx].scriptSig = ScriptFromHex(test["failure"]["scriptSig"].get_str());[m
[32m+[m[32m        mtx.vin[idx].scriptWitness = ScriptWitnessFromJSON(test["failure"]["witness"]);[m
[32m+[m[32m        CTransaction tx(mtx);[m
[32m+[m[32m        PrecomputedTransactionData txdata;[m
[32m+[m[32m        txdata.Init(tx, std::vector<CTxOut>(prevouts));[m
[32m+[m[32m        CachingTransactionSignatureChecker txcheck(&tx, idx, prevouts[idx].nValue, true, txdata);[m
[32m+[m[32m        for (const auto flags : ALL_CONSENSUS_FLAGS) {[m
[32m+[m[32m            // If a test is supposed to fail with test_flags, it should also fail with any superset thereof.[m
[32m+[m[32m            if ((flags & test_flags) == test_flags) {[m
[32m+[m[32m                bool ret = VerifyScript(tx.vin[idx].scriptSig, prevouts[idx].scriptPubKey, &tx.vin[idx].scriptWitness, flags, txcheck, nullptr);[m
[32m+[m[32m                BOOST_CHECK(!ret);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(script_assets_test)[m
[32m+[m[32m{[m
[32m+[m[32m    // See src/test/fuzz/script_assets_test_minimizer.cpp for information on how to generate[m
[32m+[m[32m    // the script_assets_test.json file used by this test.[m
[32m+[m
[32m+[m[32m    const char* dir = std::getenv("DIR_UNIT_TEST_DATA");[m
[32m+[m[32m    BOOST_WARN_MESSAGE(dir != nullptr, "Variable DIR_UNIT_TEST_DATA unset, skipping script_assets_test");[m
[32m+[m[32m    if (dir == nullptr) return;[m
[32m+[m[32m    auto path = fs::path(dir) / "script_assets_test.json";[m
[32m+[m[32m    bool exists = fs::exists(path);[m
[32m+[m[32m    BOOST_WARN_MESSAGE(exists, "File $DIR_UNIT_TEST_DATA/script_assets_test.json not found, skipping script_assets_test");[m
[32m+[m[32m    if (!exists) return;[m
[32m+[m[32m    fs::ifstream file(path);[m
[32m+[m[32m    BOOST_CHECK(file.is_open());[m
[32m+[m[32m    file.seekg(0, std::ios::end);[m
[32m+[m[32m    size_t length = file.tellg();[m
[32m+[m[32m    file.seekg(0, std::ios::beg);[m
[32m+[m[32m    std::string data(length, '\0');[m
[32m+[m[32m    file.read(&data[0], data.size());[m
[32m+[m[32m    UniValue tests = read_json(data);[m
[32m+[m[32m    BOOST_CHECK(tests.isArray());[m
[32m+[m[32m    BOOST_CHECK(tests.size() > 0);[m
[32m+[m
[32m+[m[32m    for (size_t i = 0; i < tests.size(); i++) {[m
[32m+[m[32m        AssetTest(tests[i]);[m
[32m+[m[32m    }[m
[32m+[m[32m    file.close();[m
[32m+[m[32m}[m
[32m+[m
 #endif[m
 BOOST_AUTO_TEST_SUITE_END()[m
[33mdiff --git a/src/test/transaction_tests.cpp b/src/test/transaction_tests.cpp[m
[33mindex 94b5dba913..b7ee280336 100644[m
[33m--- a/src/test/transaction_tests.cpp[m
[33m+++ b/src/test/transaction_tests.cpp[m
[36m@@ -57,6 +57,7 @@[m [mstatic std::map<std::string, unsigned int> mapFlagNames = {[m
     {std::string("DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},[m
     {std::string("WITNESS_PUBKEYTYPE"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},[m
     {std::string("CONST_SCRIPTCODE"), (unsigned int)SCRIPT_VERIFY_CONST_SCRIPTCODE},[m
[32m+[m[32m    {std::string("TAPROOT"), (unsigned int)SCRIPT_VERIFY_TAPROOT},[m
 };[m
 [m
 unsigned int ParseScriptFlags(std::string strFlags)[m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex e9c0607ced..0b78ba677e 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -1538,14 +1538,21 @@[m [mbool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C[m
         return true;[m
     }[m
 [m
[31m-    if (!txdata.m_ready) {[m
[31m-        txdata.Init(tx);[m
[32m+[m[32m    if (!txdata.m_spent_outputs_ready) {[m
[32m+[m[32m        std::vector<CTxOut> spent_outputs;[m
[32m+[m[32m        spent_outputs.reserve(tx.vin.size());[m
[32m+[m
[32m+[m[32m        for (const auto& txin : tx.vin) {[m
[32m+[m[32m            const COutPoint& prevout = txin.prevout;[m
[32m+[m[32m            const Coin& coin = inputs.AccessCoin(prevout);[m
[32m+[m[32m            assert(!coin.IsSpent());[m
[32m+[m[32m            spent_outputs.emplace_back(coin.out);[m
[32m+[m[32m        }[m
[32m+[m[32m        txdata.Init(tx, std::move(spent_outputs));[m
     }[m
[32m+[m[32m    assert(txdata.m_spent_outputs.size() == tx.vin.size());[m
 [m
     for (unsigned int i = 0; i < tx.vin.size(); i++) {[m
[31m-        const COutPoint &prevout = tx.vin[i].prevout;[m
[31m-        const Coin& coin = inputs.AccessCoin(prevout);[m
[31m-        assert(!coin.IsSpent());[m
 [m
         // We very carefully only pass in things to CScriptCheck which[m
         // are clearly committed to by tx' witness hash. This provides[m
[36m@@ -1554,7 +1561,7 @@[m [mbool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C[m
         // spent being checked as a part of CScriptCheck.[m
 [m
         // Verify signature[m
[31m-        CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);[m
[32m+[m[32m        CScriptCheck check(txdata.m_spent_outputs[i], tx, i, flags, cacheSigStore, &txdata);[m
         if (pvChecks) {[m
             pvChecks->push_back(CScriptCheck());[m
             check.swap(pvChecks->back());[m
[36m@@ -1568,7 +1575,7 @@[m [mbool CheckInputScripts(const CTransaction& tx, TxValidationState &state, const C[m
                 // splitting the network between upgraded and[m
                 // non-upgraded nodes by banning CONSENSUS-failing[m
                 // data providers.[m
[31m-                CScriptCheck check2(coin.out, tx, i,[m
[32m+[m[32m                CScriptCheck check2(txdata.m_spent_outputs[i], tx, i,[m
                         flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);[m
                 if (check2())[m
                     return state.Invalid(TxValidationResult::TX_NOT_STANDARD, strprintf("non-mandatory-script-verify-flag (%s)", ScriptErrorString(check.GetScriptError())));[m
[36m@@ -1913,6 +1920,11 @@[m [mstatic unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens[m
         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;[m
     }[m
 [m
[32m+[m[32m    // Start enforcing Taproot using versionbits logic.[m
[32m+[m[32m    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_TAPROOT, versionbitscache) == ThresholdState::ACTIVE) {[m
[32m+[m[32m        flags |= SCRIPT_VERIFY_TAPROOT;[m
[32m+[m[32m    }[m
[32m+[m
     // Start enforcing BIP147 NULLDUMMY (activated simultaneously with segwit)[m
     if (IsWitnessEnabled(pindex->pprev, consensusparams)) {[m
         flags |= SCRIPT_VERIFY_NULLDUMMY;[m
[33mdiff --git a/src/versionbitsinfo.cpp b/src/versionbitsinfo.cpp[m
[33mindex 20297b9f9d..20dfc044ca 100644[m
[33m--- a/src/versionbitsinfo.cpp[m
[33m+++ b/src/versionbitsinfo.cpp[m
[36m@@ -11,4 +11,8 @@[m [mconst struct VBDeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION_B[m
         /*.name =*/ "testdummy",[m
         /*.gbt_force =*/ true,[m
     },[m
[32m+[m[32m    {[m
[32m+[m[32m        /*.name =*/ "taproot",[m
[32m+[m[32m        /*.gbt_force =*/ true,[m
[32m+[m[32m    },[m
 };[m
[33mdiff --git a/src/wallet/rpcdump.cpp b/src/wallet/rpcdump.cpp[m
[33mindex 9e36a09780..7dcab46ad3 100644[m
[33m--- a/src/wallet/rpcdump.cpp[m
[33m+++ b/src/wallet/rpcdump.cpp[m
[36m@@ -932,6 +932,7 @@[m [mstatic std::string RecurseImportData(const CScript& script, ImportData& import_d[m
         return "unspendable script";[m
     case TxoutType::NONSTANDARD:[m
     case TxoutType::WITNESS_UNKNOWN:[m
[32m+[m[32m    case TxoutType::WITNESS_V1_TAPROOT:[m
     default:[m
         return "unrecognized script";[m
     }[m
[33mdiff --git a/src/wallet/scriptpubkeyman.cpp b/src/wallet/scriptpubkeyman.cpp[m
[33mindex 435716e56a..b7c70dac3a 100644[m
[33m--- a/src/wallet/scriptpubkeyman.cpp[m
[33m+++ b/src/wallet/scriptpubkeyman.cpp[m
[36m@@ -96,6 +96,7 @@[m [mIsMineResult IsMineInner(const LegacyScriptPubKeyMan& keystore, const CScript& s[m
     case TxoutType::NONSTANDARD:[m
     case TxoutType::NULL_DATA:[m
     case TxoutType::WITNESS_UNKNOWN:[m
[32m+[m[32m    case TxoutType::WITNESS_V1_TAPROOT:[m
         break;[m
     case TxoutType::PUBKEY:[m
         keyID = CPubKey(vSolutions[0]).GetID();[m
[33mdiff --git a/test/functional/feature_taproot.py b/test/functional/feature_taproot.py[m
[33mnew file mode 100755[m
[33mindex 0000000000..7b534c1c2f[m
[33m--- /dev/null[m
[33m+++ b/test/functional/feature_taproot.py[m
[36m@@ -0,0 +1,1458 @@[m
[32m+[m[32m#!/usr/bin/env python3[m
[32m+[m[32m# Copyright (c) 2019-2020 The Bitcoin Core developers[m
[32m+[m[32m# Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m# file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m[32m# Test Taproot softfork (BIPs 340-342)[m
[32m+[m
[32m+[m[32mfrom test_framework.blocktools import ([m
[32m+[m[32m    create_coinbase,[m
[32m+[m[32m    create_block,[m
[32m+[m[32m    add_witness_commitment,[m
[32m+[m[32m    MAX_BLOCK_SIGOPS_WEIGHT,[m
[32m+[m[32m    WITNESS_SCALE_FACTOR,[m
[32m+[m[32m)[m
[32m+[m[32mfrom test_framework.messages import ([m
[32m+[m[32m    COutPoint,[m
[32m+[m[32m    CTransaction,[m
[32m+[m[32m    CTxIn,[m
[32m+[m[32m    CTxInWitness,[m
[32m+[m[32m    CTxOut,[m
[32m+[m[32m    ToHex,[m
[32m+[m[32m)[m
[32m+[m[32mfrom test_framework.script import ([m
[32m+[m[32m    ANNEX_TAG,[m
[32m+[m[32m    CScript,[m
[32m+[m[32m    CScriptNum,[m
[32m+[m[32m    CScriptOp,[m
[32m+[m[32m    LEAF_VERSION_TAPSCRIPT,[m
[32m+[m[32m    LegacySignatureHash,[m
[32m+[m[32m    LOCKTIME_THRESHOLD,[m
[32m+[m[32m    MAX_SCRIPT_ELEMENT_SIZE,[m
[32m+[m[32m    OP_0,[m
[32m+[m[32m    OP_1,[m
[32m+[m[32m    OP_2,[m
[32m+[m[32m    OP_3,[m
[32m+[m[32m    OP_4,[m
[32m+[m[32m    OP_5,[m
[32m+[m[32m    OP_6,[m
[32m+[m[32m    OP_7,[m
[32m+[m[32m    OP_8,[m
[32m+[m[32m    OP_9,[m
[32m+[m[32m    OP_10,[m
[32m+[m[32m    OP_11,[m
[32m+[m[32m    OP_12,[m
[32m+[m[32m    OP_16,[m
[32m+[m[32m    OP_2DROP,[m
[32m+[m[32m    OP_2DUP,[m
[32m+[m[32m    OP_CHECKMULTISIG,[m
[32m+[m[32m    OP_CHECKMULTISIGVERIFY,[m
[32m+[m[32m    OP_CHECKSIG,[m
[32m+[m[32m    OP_CHECKSIGADD,[m
[32m+[m[32m    OP_CHECKSIGVERIFY,[m
[32m+[m[32m    OP_CODESEPARATOR,[m
[32m+[m[32m    OP_DROP,[m
[32m+[m[32m    OP_DUP,[m
[32m+[m[32m    OP_ELSE,[m
[32m+[m[32m    OP_ENDIF,[m
[32m+[m[32m    OP_EQUAL,[m
[32m+[m[32m    OP_EQUALVERIFY,[m
[32m+[m[32m    OP_HASH160,[m
[32m+[m[32m    OP_IF,[m
[32m+[m[32m    OP_NOP,[m
[32m+[m[32m    OP_NOT,[m
[32m+[m[32m    OP_NOTIF,[m
[32m+[m[32m    OP_PUSHDATA1,[m
[32m+[m[32m    OP_RETURN,[m
[32m+[m[32m    OP_SWAP,[m
[32m+[m[32m    OP_VERIFY,[m
[32m+[m[32m    SIGHASH_DEFAULT,[m
[32m+[m[32m    SIGHASH_ALL,[m
[32m+[m[32m    SIGHASH_NONE,[m
[32m+[m[32m    SIGHASH_SINGLE,[m
[32m+[m[32m    SIGHASH_ANYONECANPAY,[m
[32m+[m[32m    SegwitV0SignatureHash,[m
[32m+[m[32m    TaprootSignatureHash,[m
[32m+[m[32m    is_op_success,[m
[32m+[m[32m    taproot_construct,[m
[32m+[m[32m)[m
[32m+[m[32mfrom test_framework.test_framework import BitcoinTestFramework[m
[32m+[m[32mfrom test_framework.util import assert_raises_rpc_error, assert_equal[m
[32m+[m[32mfrom test_framework.key import generate_privkey, compute_xonly_pubkey, sign_schnorr, tweak_add_privkey, ECKey[m
[32m+[m[32mfrom test_framework.address import ([m
[32m+[m[32m    hash160,[m
[32m+[m[32m    sha256,[m
[32m+[m[32m)[m
[32m+[m[32mfrom collections import OrderedDict, namedtuple[m
[32m+[m[32mfrom io import BytesIO[m
[32m+[m[32mimport json[m
[32m+[m[32mimport hashlib[m
[32m+[m[32mimport os[m
[32m+[m[32mimport random[m
[32m+[m
[32m+[m[32m# === Framework for building spending transactions. ===[m
[32m+[m[32m#[m
[32m+[m[32m# The computation is represented as a "context" dict, whose entries store potentially-unevaluated expressions that[m
[32m+[m[32m# refer to lower-level ones. By overwriting these expression, many aspects - both high and low level - of the signing[m
[32m+[m[32m# process can be overridden.[m
[32m+[m[32m#[m
[32m+[m[32m# Specifically, a context object is a dict that maps names to compositions of:[m
[32m+[m[32m# - values[m
[32m+[m[32m# - lists of values[m
[32m+[m[32m# - callables which, when fed the context object as argument, produce any of these[m
[32m+[m[32m#[m
[32m+[m[32m# The DEFAULT_CONTEXT object specifies a standard signing process, with many overridable knobs.[m
[32m+[m[32m#[m
[32m+[m[32m# The get(ctx, name) function can evaluate a name, and cache its result in the context.[m
[32m+[m[32m# getter(name) can be used to construct a callable that evaluates name. For example:[m
[32m+[m[32m#[m
[32m+[m[32m#   ctx1 = {**DEFAULT_CONTEXT, inputs=[getter("sign"), b'\x01']}[m
[32m+[m[32m#[m
[32m+[m[32m# creates a context where the script inputs are a signature plus the bytes 0x01.[m
[32m+[m[32m#[m
[32m+[m[32m# override(expr, name1=expr1, name2=expr2, ...) can be used to cause an expression to be evaluated in a selectively[m
[32m+[m[32m# modified context. For example:[m
[32m+[m[32m#[m
[32m+[m[32m#   ctx2 = {**DEFAULT_CONTEXT, sighash=override(default_sighash, hashtype=SIGHASH_DEFAULT)}[m
[32m+[m[32m#[m
[32m+[m[32m# creates a context ctx2 where the sighash is modified to use hashtype=SIGHASH_DEFAULT. This differs from[m
[32m+[m[32m#[m
[32m+[m[32m#   ctx3 = {**DEFAULT_CONTEXT, hashtype=SIGHASH_DEFAULT}[m
[32m+[m[32m#[m
[32m+[m[32m# in that ctx3 will globally use hashtype=SIGHASH_DEFAULT (including in the hashtype byte appended to the signature)[m
[32m+[m[32m# while ctx2 only uses the modified hashtype inside the sighash calculation.[m
[32m+[m
[32m+[m[32mdef deep_eval(ctx, expr):[m
[32m+[m[32m    """Recursively replace any callables c in expr (including inside lists) with c(ctx)."""[m
[32m+[m[32m    while callable(expr):[m
[32m+[m[32m        expr = expr(ctx)[m
[32m+[m[32m    if isinstance(expr, list):[m
[32m+[m[32m        expr = [deep_eval(ctx, x) for x in expr][m
[32m+[m[32m    return expr[m
[32m+[m
[32m+[m[32m# Data type to represent fully-evaluated expressions in a context dict (so we can avoid reevaluating them).[m
[32m+[m[32mFinal = namedtuple("Final", "value")[m
[32m+[m
[32m+[m[32mdef get(ctx, name):[m
[32m+[m[32m    """Evaluate name in context ctx."""[m
[32m+[m[32m    assert name in ctx, "Missing '%s' in context" % name[m
[32m+[m[32m    expr = ctx[name][m
[32m+[m[32m    if not isinstance(expr, Final):[m
[32m+[m[32m        # Evaluate and cache the result.[m
[32m+[m[32m        expr = Final(deep_eval(ctx, expr))[m
[32m+[m[32m        ctx[name] = expr[m
[32m+[m[32m    return expr.value[m
[32m+[m
[32m+[m[32mdef getter(name):[m
[32m+[m[32m    """Return a callable that evaluates name in its passed context."""[m
[32m+[m[32m    return lambda ctx: get(ctx, name)[m
[32m+[m
[32m+[m[32mdef override(expr, **kwargs):[m
[32m+[m[32m    """Return a callable that evaluates expr in a modified context."""[m
[32m+[m[32m    return lambda ctx: deep_eval({**ctx, **kwargs}, expr)[m
[32m+[m
[32m+[m[32m# === Implementations for the various default expressions in DEFAULT_CONTEXT ===[m
[32m+[m
[32m+[m[32mdef default_hashtype(ctx):[m
[32m+[m[32m    """Default expression for "hashtype": SIGHASH_DEFAULT for taproot, SIGHASH_ALL otherwise."""[m
[32m+[m[32m    mode = get(ctx, "mode")[m
[32m+[m[32m    if mode == "taproot":[m
[32m+[m[32m        return SIGHASH_DEFAULT[m
[32m+[m[32m    else:[m
[32m+[m[32m        return SIGHASH_ALL[m
[32m+[m
[32m+[m[32mdef default_tapleaf(ctx):[m
[32m+[m[32m    """Default expression for "tapleaf": looking up leaf in tap[2]."""[m
[32m+[m[32m    return get(ctx, "tap").leaves[get(ctx, "leaf")][m
[32m+[m
[32m+[m[32mdef default_script_taproot(ctx):[m
[32m+[m[32m    """Default expression for "script_taproot": tapleaf.script."""[m
[32m+[m[32m    return get(ctx, "tapleaf").script[m
[32m+[m
[32m+[m[32mdef default_leafversion(ctx):[m
[32m+[m[32m    """Default expression for "leafversion": tapleaf.version"""[m
[32m+[m[32m    return get(ctx, "tapleaf").version[m
[32m+[m
[32m+[m[32mdef default_negflag(ctx):[m
[32m+[m[32m    """Default expression for "negflag": tap.negflag."""[m
[32m+[m[32m    return get(ctx, "tap").negflag[m
[32m+[m
[32m+[m[32mdef default_pubkey_inner(ctx):[m
[32m+[m[32m    """Default expression for "pubkey_inner": tap.inner_pubkey."""[m
[32m+[m[32m    return get(ctx, "tap").inner_pubkey[m
[32m+[m
[32m+[m[32mdef default_merklebranch(ctx):[m
[32m+[m[32m    """Default expression for "merklebranch": tapleaf.merklebranch."""[m
[32m+[m[32m    return get(ctx, "tapleaf").merklebranch[m
[32m+[m
[32m+[m[32mdef default_controlblock(ctx):[m
[32m+[m[32m    """Default expression for "controlblock": combine leafversion, negflag, pubkey_inner, merklebranch."""[m
[32m+[m[32m    return bytes([get(ctx, "leafversion") + get(ctx, "negflag")]) + get(ctx, "pubkey_inner") + get(ctx, "merklebranch")[m
[32m+[m
[32m+[m[32mdef default_sighash(ctx):[m
[32m+[m[32m    """Default expression for "sighash": depending on mode, compute BIP341, BIP143, or legacy sighash."""[m
[32m+[m[32m    tx = get(ctx, "tx")[m
[32m+[m[32m    idx = get(ctx, "idx")[m
[32m+[m[32m    hashtype = get(ctx, "hashtype_actual")[m
[32m+[m[32m    mode = get(ctx, "mode")[m
[32m+[m[32m    if mode == "taproot":[m
[32m+[m[32m        # BIP341 signature hash[m
[32m+[m[32m        utxos = get(ctx, "utxos")[m
[32m+[m[32m        annex = get(ctx, "annex")[m
[32m+[m[32m        if get(ctx, "leaf") is not None:[m
[32m+[m[32m            codeseppos = get(ctx, "codeseppos")[m
[32m+[m[32m            leaf_ver = get(ctx, "leafversion")[m
[32m+[m[32m            script = get(ctx, "script_taproot")[m
[32m+[m[32m            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=True, script=script, leaf_ver=leaf_ver, codeseparator_pos=codeseppos, annex=annex)[m
[32m+[m[32m        else:[m
[32m+[m[32m            return TaprootSignatureHash(tx, utxos, hashtype, idx, scriptpath=False, annex=annex)[m
[32m+[m[32m    elif mode == "witv0":[m
[32m+[m[32m        # BIP143 signature hash[m
[32m+[m[32m        scriptcode = get(ctx, "scriptcode")[m
[32m+[m[32m        utxos = get(ctx, "utxos")[m
[32m+[m[32m        return SegwitV0SignatureHash(scriptcode, tx, idx, hashtype, utxos[idx].nValue)[m
[32m+[m[32m    else:[m
[32m+[m[32m        # Pre-segwit signature hash[m
[32m+[m[32m        scriptcode = get(ctx, "scriptcode")[m
[32m+[m[32m        return LegacySignatureHash(scriptcode, tx, idx, hashtype)[0][m
[32m+[m
[32m+[m[32mdef default_tweak(ctx):[m
[32m+[m[32m    """Default expression for "tweak": None if a leaf is specified, tap[0] otherwise."""[m
[32m+[m[32m    if get(ctx, "leaf") is None:[m
[32m+[m[32m        return get(ctx, "tap").tweak[m
[32m+[m[32m    return None[m
[32m+[m
[32m+[m[32mdef default_key_tweaked(ctx):[m
[32m+[m[32m    """Default expression for "key_tweaked": key if tweak is None, tweaked with it otherwise."""[m
[32m+[m[32m    key = get(ctx, "key")[m
[32m+[m[32m    tweak = get(ctx, "tweak")[m
[32m+[m[32m    if tweak is None:[m
[32m+[m[32m        return key[m
[32m+[m[32m    else:[m
[32m+[m[32m        return tweak_add_privkey(key, tweak)[m
[32m+[m
[32m+[m[32mdef default_signature(ctx):[m
[32m+[m[32m    """Default expression for "signature": BIP340 signature or ECDSA signature depending on mode."""[m
[32m+[m[32m    sighash = get(ctx, "sighash")[m
[32m+[m[32m    if get(ctx, "mode") == "taproot":[m
[32m+[m[32m        key = get(ctx, "key_tweaked")[m
[32m+[m[32m        flip_r = get(ctx, "flag_flip_r")[m
[32m+[m[32m        flip_p = get(ctx, "flag_flip_p")[m
[32m+[m[32m        return sign_schnorr(key, sighash, flip_r=flip_r, flip_p=flip_p)[m
[32m+[m[32m    else:[m
[32m+[m[32m        key = get(ctx, "key")[m
[32m+[m[32m        return key.sign_ecdsa(sighash)[m
[32m+[m
[32m+[m[32mdef default_hashtype_actual(ctx):[m
[32m+[m[32m    """Default expression for "hashtype_actual": hashtype, unless mismatching SIGHASH_SINGLE in taproot."""[m
[32m+[m[32m    hashtype = get(ctx, "hashtype")[m
[32m+[m[32m    mode = get(ctx, "mode")[m
[32m+[m[32m    if mode != "taproot":[m
[32m+[m[32m        return hashtype[m
[32m+[m[32m    idx = get(ctx, "idx")[m
[32m+[m[32m    tx = get(ctx, "tx")[m
[32m+[m[32m    if hashtype & 3 == SIGHASH_SINGLE and idx >= len(tx.vout):[m
[32m+[m[32m        return (hashtype & ~3) | SIGHASH_NONE[m
[32m+[m[32m    return hashtype[m
[32m+[m
[32m+[m[32mdef default_bytes_hashtype(ctx):[m
[32m+[m[32m    """Default expression for "bytes_hashtype": bytes([hashtype_actual]) if not 0, b"" otherwise."""[m
[32m+[m[32m    return bytes([x for x in [get(ctx, "hashtype_actual")] if x != 0])[m
[32m+[m
[32m+[m[32mdef default_sign(ctx):[m
[32m+[m[32m    """Default expression for "sign": concatenation of signature and bytes_hashtype."""[m
[32m+[m[32m    return get(ctx, "signature") + get(ctx, "bytes_hashtype")[m
[32m+[m
[32m+[m[32mdef default_inputs_keypath(ctx):[m
[32m+[m[32m    """Default expression for "inputs_keypath": a signature."""[m
[32m+[m[32m    return [get(ctx, "sign")][m
[32m+[m
[32m+[m[32mdef default_witness_taproot(ctx):[m
[32m+[m[32m    """Default expression for "witness_taproot", consisting of inputs, script, control block, and annex as needed."""[m
[32m+[m[32m    annex = get(ctx, "annex")[m
[32m+[m[32m    suffix_annex = [][m
[32m+[m[32m    if annex is not None:[m
[32m+[m[32m        suffix_annex = [annex][m
[32m+[m[32m    if get(ctx, "leaf") is None:[m
[32m+[m[32m        return get(ctx, "inputs_keypath") + suffix_annex[m
[32m+[m[32m    else:[m
[32m+[m[32m        return get(ctx, "inputs") + [bytes(get(ctx, "script_taproot")), get(ctx, "controlblock")] + suffix_annex[m
[32m+[m
[32m+[m[32mdef default_witness_witv0(ctx):[m
[32m+[m[32m    """Default expression for "witness_witv0", consisting of inputs and witness script, as needed."""[m
[32m+[m[32m    script = get(ctx, "script_witv0")[m
[32m+[m[32m    inputs = get(ctx, "inputs")[m
[32m+[m[32m    if script is None:[m
[32m+[m[32m        return inputs[m
[32m+[m[32m    else:[m
[32m+[m[32m        return inputs + [script][m
[32m+[m
[32m+[m[32mdef default_witness(ctx):[m
[32m+[m[32m    """Default expression for "witness", delegating to "witness_taproot" or "witness_witv0" as needed."""[m
[32m+[m[32m    mode = get(ctx, "mode")[m
[32m+[m[32m    if mode == "taproot":[m
[32m+[m[32m        return get(ctx, "witness_taproot")[m
[32m+[m[32m    elif mode == "witv0":[m
[32m+[m[32m        return get(ctx, "witness_witv0")[m
[32m+[m[32m    else:[m
[32m+[m[32m        return [][m
[32m+[m
[32m+[m[32mdef default_scriptsig(ctx):[m
[32m+[m[32m    """Default expression for "scriptsig", consisting of inputs and redeemscript, as needed."""[m
[32m+[m[32m    scriptsig = [][m
[32m+[m[32m    mode = get(ctx, "mode")[m
[32m+[m[32m    if mode == "legacy":[m
[32m+[m[32m        scriptsig = get(ctx, "inputs")[m
[32m+[m[32m    redeemscript = get(ctx, "script_p2sh")[m
[32m+[m[32m    if redeemscript is not None:[m
[32m+[m[32m        scriptsig += [bytes(redeemscript)][m
[32m+[m[32m    return scriptsig[m
[32m+[m
[32m+[m[32m# The default context object.[m
[32m+[m[32mDEFAULT_CONTEXT = {[m
[32m+[m[32m    # == The main expressions to evaluate. Only override these for unusual or invalid spends. ==[m
[32m+[m[32m    # The overall witness stack, as a list of bytes objects.[m
[32m+[m[32m    "witness": default_witness,[m
[32m+[m[32m    # The overall scriptsig, as a list of CScript objects (to be concatenated) and bytes objects (to be pushed)[m
[32m+[m[32m    "scriptsig": default_scriptsig,[m
[32m+[m
[32m+[m[32m    # == Expressions you'll generally only override for intentionally invalid spends. ==[m
[32m+[m[32m    # The witness stack for spending a taproot output.[m
[32m+[m[32m    "witness_taproot": default_witness_taproot,[m
[32m+[m[32m    # The witness stack for spending a P2WPKH/P2WSH output.[m
[32m+[m[32m    "witness_witv0": default_witness_witv0,[m
[32m+[m[32m    # The script inputs for a taproot key path spend.[m
[32m+[m[32m    "inputs_keypath": default_inputs_keypath,[m
[32m+[m[32m    # The actual hashtype to use (usually equal to hashtype, but in taproot SIGHASH_SINGLE is not always allowed).[m
[32m+[m[32m    "hashtype_actual": default_hashtype_actual,[m
[32m+[m[32m    # The bytes object for a full signature (including hashtype byte, if needed).[m
[32m+[m[32m    "bytes_hashtype": default_bytes_hashtype,[m
[32m+[m[32m    # A full script signature (bytes including hashtype, if needed)[m
[32m+[m[32m    "sign": default_sign,[m
[32m+[m[32m    # An ECDSA or Schnorr signature (excluding hashtype byte).[m
[32m+[m[32m    "signature": default_signature,[m
[32m+[m[32m    # The 32-byte tweaked key (equal to key for script path spends, or key+tweak for key path spends).[m
[32m+[m[32m    "key_tweaked": default_key_tweaked,[m
[32m+[m[32m    # The tweak to use (None for script path spends, the actual tweak for key path spends).[m
[32m+[m[32m    "tweak": default_tweak,[m
[32m+[m[32m    # The sighash value (32 bytes)[m
[32m+[m[32m    "sighash": default_sighash,[m
[32m+[m[32m    # The information about the chosen script path spend (TaprootLeafInfo object).[m
[32m+[m[32m    "tapleaf": default_tapleaf,[m
[32m+[m[32m    # The script to push, and include in the sighash, for a taproot script path spend.[m
[32m+[m[32m    "script_taproot": default_script_taproot,[m
[32m+[m[32m    # The inner pubkey for a taproot script path spend (32 bytes).[m
[32m+[m[32m    "pubkey_inner": default_pubkey_inner,[m
[32m+[m[32m    # The negation flag of the inner pubkey for a taproot script path spend.[m
[32m+[m[32m    "negflag": default_negflag,[m
[32m+[m[32m    # The leaf version to include in the sighash (this does not affect the one in the control block).[m
[32m+[m[32m    "leafversion": default_leafversion,[m
[32m+[m[32m    # The Merkle path to include in the control block for a script path spend.[m
[32m+[m[32m    "merklebranch": default_merklebranch,[m
[32m+[m[32m    # The control block to push for a taproot script path spend.[m
[32m+[m[32m    "controlblock": default_controlblock,[m
[32m+[m[32m    # Whether to produce signatures with invalid P sign (Schnorr signatures only).[m
[32m+[m[32m    "flag_flip_p": False,[m
[32m+[m[32m    # Whether to produce signatures with invalid R sign (Schnorr signatures only).[m
[32m+[m[32m    "flag_flip_r": False,[m
[32m+[m
[32m+[m[32m    # == Parameters that can be changed without invalidating, but do have a default: ==[m
[32m+[m[32m    # The hashtype (as an integer).[m
[32m+[m[32m    "hashtype": default_hashtype,[m
[32m+[m[32m    # The annex (only when mode=="taproot").[m
[32m+[m[32m    "annex": None,[m
[32m+[m[32m    # The codeseparator position (only when mode=="taproot").[m
[32m+[m[32m    "codeseppos": -1,[m
[32m+[m[32m    # The redeemscript to add to the scriptSig (if P2SH; None implies not P2SH).[m
[32m+[m[32m    "script_p2sh": None,[m
[32m+[m[32m    # The script to add to the witness in (if P2WSH; None implies P2WPKH)[m
[32m+[m[32m    "script_witv0": None,[m
[32m+[m[32m    # The leaf to use in taproot spends (if script path spend; None implies key path spend).[m
[32m+[m[32m    "leaf": None,[m
[32m+[m[32m    # The input arguments to provide to the executed script[m
[32m+[m[32m    "inputs": [],[m
[32m+[m
[32m+[m[32m    # == Parameters to be set before evaluation: ==[m
[32m+[m[32m    # - mode: what spending style to use ("taproot", "witv0", or "legacy").[m
[32m+[m[32m    # - key: the (untweaked) private key to sign with (ECKey object for ECDSA, 32 bytes for Schnorr).[m
[32m+[m[32m    # - tap: the TaprootInfo object (see taproot_construct; needed in mode=="taproot").[m
[32m+[m[32m    # - tx: the transaction to sign.[m
[32m+[m[32m    # - utxos: the UTXOs being spent (needed in mode=="witv0" and mode=="taproot").[m
[32m+[m[32m    # - idx: the input position being signed.[m
[32m+[m[32m    # - scriptcode: the scriptcode to include in legacy and witv0 sighashes.[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mdef flatten(lst):[m
[32m+[m[32m    ret = [][m
[32m+[m[32m    for elem in lst:[m
[32m+[m[32m        if isinstance(elem, list):[m
[32m+[m[32m            ret += flatten(elem)[m
[32m+[m[32m        else:[m
[32m+[m[32m            ret.append(elem)[m
[32m+[m[32m    return ret[m
[32m+[m
[32m+[m[32mdef spend(tx, idx, utxos, **kwargs):[m
[32m+[m[32m    """Sign transaction input idx of tx, provided utxos is the list of outputs being spent.[m
[32m+[m
[32m+[m[32m    Additional arguments may be provided that override any aspect of the signing process.[m
[32m+[m[32m    See DEFAULT_CONTEXT above for what can be overridden, and what must be provided.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    ctx = {**DEFAULT_CONTEXT, "tx":tx, "idx":idx, "utxos":utxos, **kwargs}[m
[32m+[m
[32m+[m[32m    def to_script(elem):[m
[32m+[m[32m        """If fed a CScript, return it; if fed bytes, return a CScript that pushes it."""[m
[32m+[m[32m        if isinstance(elem, CScript):[m
[32m+[m[32m            return elem[m
[32m+[m[32m        else:[m
[32m+[m[32m            return CScript([elem])[m
[32m+[m
[32m+[m[32m    scriptsig_list = flatten(get(ctx, "scriptsig"))[m
[32m+[m[32m    scriptsig = CScript(b"".join(bytes(to_script(elem)) for elem in scriptsig_list))[m
[32m+[m[32m    witness_stack = flatten(get(ctx, "witness"))[m
[32m+[m[32m    return (scriptsig, witness_stack)[m
[32m+[m
[32m+[m
[32m+[m[32m# === Spender objects ===[m
[32m+[m[32m#[m
[32m+[m[32m# Each spender is a tuple of:[m
[32m+[m[32m# - A scriptPubKey which is to be spent from (CScript)[m
[32m+[m[32m# - A comment describing the test (string)[m
[32m+[m[32m# - Whether the spending (on itself) is expected to be standard (bool)[m
[32m+[m[32m# - A tx-signing lambda returning (scriptsig, witness_stack), taking as inputs:[m
[32m+[m[32m#   - A transaction to sign (CTransaction)[m
[32m+[m[32m#   - An input position (int)[m
[32m+[m[32m#   - The spent UTXOs by this transaction (list of CTxOut)[m
[32m+[m[32m#   - Whether to produce a valid spend (bool)[m
[32m+[m[32m# - A string with an expected error message for failure case if known[m
[32m+[m[32m# - The (pre-taproot) sigops weight consumed by a successful spend[m
[32m+[m[32m# - Whether this spend cannot fail[m
[32m+[m[32m# - Whether this test demands being placed in a txin with no corresponding txout (for testing SIGHASH_SINGLE behavior)[m
[32m+[m
[32m+[m[32mSpender = namedtuple("Spender", "script,comment,is_standard,sat_function,err_msg,sigops_weight,no_fail,need_vin_vout_mismatch")[m
[32m+[m
[32m+[m[32mdef make_spender(comment, *, tap=None, witv0=False, script=None, pkh=None, p2sh=False, spk_mutate_pre_p2sh=None, failure=None, standard=True, err_msg=None, sigops_weight=0, need_vin_vout_mismatch=False, **kwargs):[m
[32m+[m[32m    """Helper for constructing Spender objects using the context signing framework.[m
[32m+[m
[32m+[m[32m    * tap: a TaprootInfo object (see taproot_construct), for Taproot spends (cannot be combined with pkh, witv0, or script)[m
[32m+[m[32m    * witv0: boolean indicating the use of witness v0 spending (needs one of script or pkh)[m
[32m+[m[32m    * script: the actual script executed (for bare/P2WSH/P2SH spending)[m
[32m+[m[32m    * pkh: the public key for P2PKH or P2WPKH spending[m
[32m+[m[32m    * p2sh: whether the output is P2SH wrapper (this is supported even for Taproot, where it makes the output unencumbered)[m
[32m+[m[32m    * spk_mutate_pre_psh: a callable to be applied to the script (before potentially P2SH-wrapping it)[m
[32m+[m[32m    * failure: a dict of entries to override in the context when intentionally failing to spend (if None, no_fail will be set)[m
[32m+[m[32m    * standard: whether the (valid version of) spending is expected to be standard[m
[32m+[m[32m    * err_msg: a string with an expected error message for failure (or None, if not cared about)[m
[32m+[m[32m    * sigops_weight: the pre-taproot sigops weight consumed by a successful spend[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    conf = dict()[m
[32m+[m
[32m+[m[32m    # Compute scriptPubKey and set useful defaults based on the inputs.[m
[32m+[m[32m    if witv0:[m
[32m+[m[32m        assert tap is None[m
[32m+[m[32m        conf["mode"] = "witv0"[m
[32m+[m[32m        if pkh is not None:[m
[32m+[m[32m            # P2WPKH[m
[32m+[m[32m            assert script is None[m
[32m+[m[32m            pubkeyhash = hash160(pkh)[m
[32m+[m[32m            spk = CScript([OP_0, pubkeyhash])[m
[32m+[m[32m            conf["scriptcode"] = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])[m
[32m+[m[32m            conf["script_witv0"] = None[m
[32m+[m[32m            conf["inputs"] = [getter("sign"), pkh][m
[32m+[m[32m        elif script is not None:[m
[32m+[m[32m            # P2WSH[m
[32m+[m[32m            spk = CScript([OP_0, sha256(script)])[m
[32m+[m[32m            conf["scriptcode"] = script[m
[32m+[m[32m            conf["script_witv0"] = script[m
[32m+[m[32m        else:[m
[32m+[m[32m            assert False[m
[32m+[m[32m    elif tap is None:[m
[32m+[m[32m        conf["mode"] = "legacy"[m
[32m+[m[32m        if pkh is not None:[m
[32m+[m[32m            # P2PKH[m
[32m+[m[32m            assert script is None[m
[32m+[m[32m            pubkeyhash = hash160(pkh)[m
[32m+[m[32m            spk = CScript([OP_DUP, OP_HASH160, pubkeyhash, OP_EQUALVERIFY, OP_CHECKSIG])[m
[32m+[m[32m            conf["scriptcode"] = spk[m
[32m+[m[32m            conf["inputs"] = [getter("sign"), pkh][m
[32m+[m[32m        elif script is not None:[m
[32m+[m[32m            # bare[m
[32m+[m[32m            spk = script[m
[32m+[m[32m            conf["scriptcode"] = script[m
[32m+[m[32m        else:[m
[32m+[m[32m            assert False[m
[32m+[m[32m    else:[m
[32m+[m[32m        assert script is None[m
[32m+[m[32m        conf["mode"] = "taproot"[m
[32m+[m[32m        conf["tap"] = tap[m
[32m+[m[32m        spk = tap.scriptPubKey[m
[32m+[m
[32m+[m[32m    if spk_mutate_pre_p2sh is not None:[m
[32m+[m[32m        spk = spk_mutate_pre_p2sh(spk)[m
[32m+[m
[32m+[m[32m    if p2sh:[m
[32m+[m[32m        # P2SH wrapper can be combined with anything else[m
[32m+[m[32m        conf["script_p2sh"] = spk[m
[32m+[m[32m        spk = CScript([OP_HASH160, hash160(spk), OP_EQUAL])[m
[32m+[m
[32m+[m[32m    conf = {**conf, **kwargs}[m
[32m+[m
[32m+[m[32m    def sat_fn(tx, idx, utxos, valid):[m
[32m+[m[32m        if valid:[m
[32m+[m[32m            return spend(tx, idx, utxos, **conf)[m
[32m+[m[32m        else:[m
[32m+[m[32m            assert failure is not None[m
[32m+[m[32m            return spend(tx, idx, utxos, **{**conf, **failure})[m
[32m+[m
[32m+[m[32m    return Spender(script=spk, comment=comment, is_standard=standard, sat_function=sat_fn, err_msg=err_msg, sigops_weight=sigops_weight, no_fail=failure is None, need_vin_vout_mismatch=need_vin_vout_mismatch)[m
[32m+[m
[32m+[m[32mdef add_spender(spenders, *args, **kwargs):[m
[32m+[m[32m    """Make a spender using make_spender, and add it to spenders."""[m
[32m+[m[32m    spenders.append(make_spender(*args, **kwargs))[m
[32m+[m
[32m+[m[32m# === Helpers for the test ===[m
[32m+[m
[32m+[m[32mdef random_checksig_style(pubkey):[m
[32m+[m[32m    """Creates a random CHECKSIG* tapscript that would succeed with only the valid signature on witness stack."""[m
[32m+[m[32m    return bytes(CScript([pubkey, OP_CHECKSIG]))[m
[32m+[m[32m    opcode = random.choice([OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_CHECKSIGADD])[m
[32m+[m[32m    if (opcode == OP_CHECKSIGVERIFY):[m
[32m+[m[32m        ret = CScript([pubkey, opcode, OP_1])[m
[32m+[m[32m    elif (opcode == OP_CHECKSIGADD):[m
[32m+[m[32m        num = random.choice([0, 0x7fffffff, -0x7fffffff])[m
[32m+[m[32m        ret = CScript([num, pubkey, opcode, num + 1, OP_EQUAL])[m
[32m+[m[32m    else:[m
[32m+[m[32m        ret = CScript([pubkey, opcode])[m
[32m+[m[32m    return bytes(ret)[m
[32m+[m
[32m+[m[32mdef random_bytes(n):[m
[32m+[m[32m    """Return a random bytes object of length n."""[m
[32m+[m[32m    return bytes(random.getrandbits(8) for i in range(n))[m
[32m+[m
[32m+[m[32mdef bitflipper(expr):[m
[32m+[m[32m    """Return a callable that evaluates expr and returns it with a random bitflip."""[m
[32m+[m[32m    def fn(ctx):[m
[32m+[m[32m        sub = deep_eval(ctx, expr)[m
[32m+[m[32m        assert isinstance(sub, bytes)[m
[32m+[m[32m        return (int.from_bytes(sub, 'little') ^ (1 << random.randrange(len(sub) * 8))).to_bytes(len(sub), 'little')[m
[32m+[m[32m    return fn[m
[32m+[m
[32m+[m[32mdef zero_appender(expr):[m
[32m+[m[32m    """Return a callable that evaluates expr and returns it with a zero added."""[m
[32m+[m[32m    return lambda ctx: deep_eval(ctx, expr) + b"\x00"[m
[32m+[m
[32m+[m[32mdef byte_popper(expr):[m
[32m+[m[32m    """Return a callable that evaluates expr and returns it with its last byte removed."""[m
[32m+[m[32m    return lambda ctx: deep_eval(ctx, expr)[:-1][m
[32m+[m
[32m+[m[32m# Expected error strings[m
[32m+[m
[32m+[m[32mERR_SIG_SIZE = {"err_msg": "Invalid Schnorr signature size"}[m
[32m+[m[32mERR_SIG_HASHTYPE = {"err_msg": "Invalid Schnorr signature hash type"}[m
[32m+[m[32mERR_SIG_SCHNORR = {"err_msg": "Invalid Schnorr signature"}[m
[32m+[m[32mERR_OP_RETURN = {"err_msg": "OP_RETURN was encountered"}[m
[32m+[m[32mERR_CONTROLBLOCK_SIZE = {"err_msg": "Invalid Taproot control block size"}[m
[32m+[m[32mERR_WITNESS_PROGRAM_MISMATCH = {"err_msg": "Witness program hash mismatch"}[m
[32m+[m[32mERR_PUSH_LIMIT = {"err_msg": "Push value size limit exceeded"}[m
[32m+[m[32mERR_DISABLED_OPCODE = {"err_msg": "Attempted to use a disabled opcode"}[m
[32m+[m[32mERR_TAPSCRIPT_CHECKMULTISIG = {"err_msg": "OP_CHECKMULTISIG(VERIFY) is not available in tapscript"}[m
[32m+[m[32mERR_MINIMALIF = {"err_msg": "OP_IF/NOTIF argument must be minimal in tapscript"}[m
[32m+[m[32mERR_UNKNOWN_PUBKEY = {"err_msg": "Public key is neither compressed or uncompressed"}[m
[32m+[m[32mERR_STACK_SIZE = {"err_msg": "Stack size limit exceeded"}[m
[32m+[m[32mERR_CLEANSTACK = {"err_msg": "Stack size must be exactly one after execution"}[m
[32m+[m[32mERR_STACK_EMPTY = {"err_msg": "Operation not valid with the current stack size"}[m
[32m+[m[32mERR_SIGOPS_RATIO = {"err_msg": "Too much signature validation relative to witness weight"}[m
[32m+[m[32mERR_UNDECODABLE = {"err_msg": "Opcode missing or not understood"}[m
[32m+[m[32mERR_NO_SUCCESS = {"err_msg": "Script evaluated without error but finished with a false/empty top stack element"}[m
[32m+[m[32mERR_EMPTY_WITNESS = {"err_msg": "Witness program was passed an empty witness"}[m
[32m+[m[32mERR_CHECKSIGVERIFY = {"err_msg": "Script failed an OP_CHECKSIGVERIFY operation"}[m
[32m+[m
[32m+[m[32mVALID_SIGHASHES_ECDSA = [[m
[32m+[m[32m    SIGHASH_ALL,[m
[32m+[m[32m    SIGHASH_NONE,[m
[32m+[m[32m    SIGHASH_SINGLE,[m
[32m+[m[32m    SIGHASH_ANYONECANPAY + SIGHASH_ALL,[m
[32m+[m[32m    SIGHASH_ANYONECANPAY + SIGHASH_NONE,[m
[32m+[m[32m    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32mVALID_SIGHASHES_TAPROOT = [SIGHASH_DEFAULT] + VALID_SIGHASHES_ECDSA[m
[32m+[m
[32m+[m[32mVALID_SIGHASHES_TAPROOT_SINGLE = [[m
[32m+[m[32m    SIGHASH_SINGLE,[m
[32m+[m[32m    SIGHASH_ANYONECANPAY + SIGHASH_SINGLE[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32mVALID_SIGHASHES_TAPROOT_NO_SINGLE = [h for h in VALID_SIGHASHES_TAPROOT if h not in VALID_SIGHASHES_TAPROOT_SINGLE][m
[32m+[m
[32m+[m[32mSIGHASH_BITFLIP = {"failure": {"sighash": bitflipper(default_sighash)}}[m
[32m+[m[32mSIG_POP_BYTE = {"failure": {"sign": byte_popper(default_sign)}}[m
[32m+[m[32mSINGLE_SIG = {"inputs": [getter("sign")]}[m
[32m+[m[32mSIG_ADD_ZERO = {"failure": {"sign": zero_appender(default_sign)}}[m
[32m+[m
[32m+[m[32mDUST_LIMIT = 600[m
[32m+[m[32mMIN_FEE = 50000[m
[32m+[m
[32m+[m[32m# === Actual test cases ===[m
[32m+[m
[32m+[m
[32m+[m[32mdef spenders_taproot_active():[m
[32m+[m[32m    """Return a list of Spenders for testing post-Taproot activation behavior."""[m
[32m+[m
[32m+[m[32m    secs = [generate_privkey() for _ in range(8)][m
[32m+[m[32m    pubs = [compute_xonly_pubkey(sec)[0] for sec in secs][m
[32m+[m
[32m+[m[32m    spenders = [][m
[32m+[m
[32m+[m[32m    # == Tests for BIP340 signature validation. ==[m
[32m+[m[32m    # These are primarily tested through the test vectors implemented in libsecp256k1, and in src/tests/key_tests.cpp.[m
[32m+[m[32m    # Some things are tested programmatically as well here.[m
[32m+[m
[32m+[m[32m    tap = taproot_construct(pubs[0])[m
[32m+[m[32m    # Test with key with bit flipped.[m
[32m+[m[32m    add_spender(spenders, "sig/key", tap=tap, key=secs[0], failure={"key_tweaked": bitflipper(default_key_tweaked)}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    # Test with sighash with bit flipped.[m
[32m+[m[32m    add_spender(spenders, "sig/sighash", tap=tap, key=secs[0], failure={"sighash": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    # Test with invalid R sign.[m
[32m+[m[32m    add_spender(spenders, "sig/flip_r", tap=tap, key=secs[0], failure={"flag_flip_r": True}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    # Test with invalid P sign.[m
[32m+[m[32m    add_spender(spenders, "sig/flip_p", tap=tap, key=secs[0], failure={"flag_flip_p": True}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    # Test with signature with bit flipped.[m
[32m+[m[32m    add_spender(spenders, "sig/bitflip", tap=tap, key=secs[0], failure={"signature": bitflipper(default_signature)}, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m    # == Tests for signature hashing ==[m
[32m+[m
[32m+[m[32m    # Run all tests once with no annex, and once with a valid random annex.[m
[32m+[m[32m    for annex in [None, lambda _: bytes([ANNEX_TAG]) + random_bytes(random.randrange(0, 250))]:[m
[32m+[m[32m        # Non-empty annex is non-standard[m
[32m+[m[32m        no_annex = annex is None[m
[32m+[m
[32m+[m[32m        # Sighash mutation tests (test all sighash combinations)[m
[32m+[m[32m        for hashtype in VALID_SIGHASHES_TAPROOT:[m
[32m+[m[32m            common = {"annex": annex, "hashtype": hashtype, "standard": no_annex}[m
[32m+[m
[32m+[m[32m            # Pure pubkey[m
[32m+[m[32m            tap = taproot_construct(pubs[0])[m
[32m+[m[32m            add_spender(spenders, "sighash/purepk", tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m            # Pubkey/P2PK script combination[m
[32m+[m[32m            scripts = [("s0", CScript(random_checksig_style(pubs[1])))][m
[32m+[m[32m            tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m            add_spender(spenders, "sighash/keypath_hashtype_%x" % hashtype, tap=tap, key=secs[0], **common, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m[32m            add_spender(spenders, "sighash/scriptpath_hashtype_%x" % hashtype, tap=tap, leaf="s0", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m            # Test SIGHASH_SINGLE behavior in combination with mismatching outputs[m
[32m+[m[32m            if hashtype in VALID_SIGHASHES_TAPROOT_SINGLE:[m
[32m+[m[32m                add_spender(spenders, "sighash/keypath_hashtype_mis_%x" % hashtype, tap=tap, key=secs[0], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), failure={"hashtype_actual": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)[m
[32m+[m[32m                add_spender(spenders, "sighash/scriptpath_hashtype_mis_%x" % hashtype, tap=tap, leaf="s0", key=secs[1], annex=annex, standard=no_annex, hashtype_actual=random.choice(VALID_SIGHASHES_TAPROOT_NO_SINGLE), **SINGLE_SIG, failure={"hashtype_actual": hashtype}, **ERR_SIG_HASHTYPE, need_vin_vout_mismatch=True)[m
[32m+[m
[32m+[m[32m        # Test OP_CODESEPARATOR impact on sighashing.[m
[32m+[m[32m        hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)[m
[32m+[m[32m        common = {"annex": annex, "hashtype": hashtype, "standard": no_annex}[m
[32m+[m[32m        scripts = [[m
[32m+[m[32m            ("pk_codesep", CScript(random_checksig_style(pubs[1]) + bytes([OP_CODESEPARATOR]))),  # codesep after checksig[m
[32m+[m[32m            ("codesep_pk", CScript(bytes([OP_CODESEPARATOR]) + random_checksig_style(pubs[1]))),  # codesep before checksig[m
[32m+[m[32m            ("branched_codesep", CScript([random_bytes(random.randrange(511)), OP_DROP, OP_IF, OP_CODESEPARATOR, pubs[0], OP_ELSE, OP_CODESEPARATOR, pubs[1], OP_ENDIF, OP_CHECKSIG])),  # branch dependent codesep[m
[32m+[m[32m        ][m
[32m+[m[32m        random.shuffle(scripts)[m
[32m+[m[32m        tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m        add_spender(spenders, "sighash/pk_codesep", tap=tap, leaf="pk_codesep", key=secs[1], **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m[32m        add_spender(spenders, "sighash/codesep_pk", tap=tap, leaf="codesep_pk", key=secs[1], codeseppos=0, **common, **SINGLE_SIG, **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m[32m        add_spender(spenders, "sighash/branched_codesep/left", tap=tap, leaf="branched_codesep", key=secs[0], codeseppos=3, **common, inputs=[getter("sign"), b'\x01'], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m[32m        add_spender(spenders, "sighash/branched_codesep/right", tap=tap, leaf="branched_codesep", key=secs[1], codeseppos=6, **common, inputs=[getter("sign"), b''], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m    # Reusing the scripts above, test that various features affect the sighash.[m
[32m+[m[32m    add_spender(spenders, "sighash/annex", tap=tap, leaf="pk_codesep", key=secs[1], hashtype=hashtype, standard=False, **SINGLE_SIG, annex=bytes([ANNEX_TAG]), failure={"sighash": override(default_sighash, annex=None)}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/script", tap=tap, leaf="pk_codesep", key=secs[1], **common, **SINGLE_SIG, failure={"sighash": override(default_sighash, script_taproot=tap.leaves["codesep_pk"].script)}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/leafver", tap=tap, leaf="pk_codesep", key=secs[1], **common, **SINGLE_SIG, failure={"sighash": override(default_sighash, leafversion=random.choice([x & 0xFE for x in range(0x100) if x & 0xFE != 0xC0]))}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/scriptpath", tap=tap, leaf="pk_codesep", key=secs[1], **common, **SINGLE_SIG, failure={"sighash": override(default_sighash, leaf=None)}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/keypath", tap=tap, key=secs[0], **common, failure={"sighash": override(default_sighash, leaf="pk_codesep")}, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m    # Test that invalid hashtypes don't work, both in key path and script path spends[m
[32m+[m[32m    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)[m
[32m+[m[32m    for invalid_hashtype in [x for x in range(0x100) if x not in VALID_SIGHASHES_TAPROOT]:[m
[32m+[m[32m        add_spender(spenders, "sighash/keypath_unk_hashtype_%x" % invalid_hashtype, tap=tap, key=secs[0], hashtype=hashtype, failure={"hashtype": invalid_hashtype}, **ERR_SIG_HASHTYPE)[m
[32m+[m[32m        add_spender(spenders, "sighash/scriptpath_unk_hashtype_%x" % invalid_hashtype, tap=tap, leaf="pk_codesep", key=secs[1], **SINGLE_SIG, hashtype=hashtype, failure={"hashtype": invalid_hashtype}, **ERR_SIG_HASHTYPE)[m
[32m+[m
[32m+[m[32m    # Test that hashtype 0 cannot have a hashtype byte, and 1 must have one.[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype0_byte_keypath", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={"bytes_hashtype": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype0_byte_scriptpath", tap=tap, leaf="pk_codesep", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={"bytes_hashtype": bytes([SIGHASH_DEFAULT])}, **ERR_SIG_HASHTYPE)[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype1_byte_keypath", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={"bytes_hashtype": b''}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype1_byte_scriptpath", tap=tap, leaf="pk_codesep", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={"bytes_hashtype": b''}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    # Test that hashtype 0 and hashtype 1 cannot be transmuted into each other.[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype0to1_keypath", tap=tap, key=secs[0], hashtype=SIGHASH_DEFAULT, failure={"bytes_hashtype": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype0to1_scriptpath", tap=tap, leaf="pk_codesep", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_DEFAULT, failure={"bytes_hashtype": bytes([SIGHASH_ALL])}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype1to0_keypath", tap=tap, key=secs[0], hashtype=SIGHASH_ALL, failure={"bytes_hashtype": b''}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "sighash/hashtype1to0_scriptpath", tap=tap, leaf="pk_codesep", key=secs[1], **SINGLE_SIG, hashtype=SIGHASH_ALL, failure={"bytes_hashtype": b''}, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m    # Test aspects of signatures with unusual lengths[m
[32m+[m[32m    for hashtype in [SIGHASH_DEFAULT, random.choice(VALID_SIGHASHES_TAPROOT)]:[m
[32m+[m[32m        scripts = [[m
[32m+[m[32m            ("csv", CScript([pubs[2], OP_CHECKSIGVERIFY, OP_1])),[m
[32m+[m[32m            ("cs_pos", CScript([pubs[2], OP_CHECKSIG])),[m
[32m+[m[32m            ("csa_pos", CScript([OP_0, pubs[2], OP_CHECKSIGADD, OP_1, OP_EQUAL])),[m
[32m+[m[32m            ("cs_neg", CScript([pubs[2], OP_CHECKSIG, OP_NOT])),[m
[32m+[m[32m            ("csa_neg", CScript([OP_2, pubs[2], OP_CHECKSIGADD, OP_2, OP_EQUAL]))[m
[32m+[m[32m        ][m
[32m+[m[32m        random.shuffle(scripts)[m
[32m+[m[32m        tap = taproot_construct(pubs[3], scripts)[m
[32m+[m[32m        # Empty signatures[m
[32m+[m[32m        add_spender(spenders, "siglen/empty_keypath", tap=tap, key=secs[3], hashtype=hashtype, failure={"sign": b""}, **ERR_SIG_SIZE)[m
[32m+[m[32m        add_spender(spenders, "siglen/empty_csv", tap=tap, key=secs[2], leaf="csv", hashtype=hashtype, **SINGLE_SIG, failure={"sign": b""}, **ERR_CHECKSIGVERIFY)[m
[32m+[m[32m        add_spender(spenders, "siglen/empty_cs", tap=tap, key=secs[2], leaf="cs_pos", hashtype=hashtype, **SINGLE_SIG, failure={"sign": b""}, **ERR_NO_SUCCESS)[m
[32m+[m[32m        add_spender(spenders, "siglen/empty_csa", tap=tap, key=secs[2], leaf="csa_pos", hashtype=hashtype, **SINGLE_SIG, failure={"sign": b""}, **ERR_NO_SUCCESS)[m
[32m+[m[32m        add_spender(spenders, "siglen/empty_cs_neg", tap=tap, key=secs[2], leaf="cs_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", failure={"sign": lambda _: random_bytes(random.randrange(1, 63))}, **ERR_SIG_SIZE)[m
[32m+[m[32m        add_spender(spenders, "siglen/empty_csa_neg", tap=tap, key=secs[2], leaf="csa_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", failure={"sign": lambda _: random_bytes(random.randrange(66, 100))}, **ERR_SIG_SIZE)[m
[32m+[m[32m        # Appending a zero byte to signatures invalidates them[m
[32m+[m[32m        add_spender(spenders, "siglen/padzero_keypath", tap=tap, key=secs[3], hashtype=hashtype, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))[m
[32m+[m[32m        add_spender(spenders, "siglen/padzero_csv", tap=tap, key=secs[2], leaf="csv", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))[m
[32m+[m[32m        add_spender(spenders, "siglen/padzero_cs", tap=tap, key=secs[2], leaf="cs_pos", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))[m
[32m+[m[32m        add_spender(spenders, "siglen/padzero_csa", tap=tap, key=secs[2], leaf="csa_pos", hashtype=hashtype, **SINGLE_SIG, **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))[m
[32m+[m[32m        add_spender(spenders, "siglen/padzero_cs_neg", tap=tap, key=secs[2], leaf="cs_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))[m
[32m+[m[32m        add_spender(spenders, "siglen/padzero_csa_neg", tap=tap, key=secs[2], leaf="csa_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", **SIG_ADD_ZERO, **(ERR_SIG_HASHTYPE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SIZE))[m
[32m+[m[32m        # Removing the last byte from signatures invalidates them[m
[32m+[m[32m        add_spender(spenders, "siglen/popbyte_keypath", tap=tap, key=secs[3], hashtype=hashtype, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))[m
[32m+[m[32m        add_spender(spenders, "siglen/popbyte_csv", tap=tap, key=secs[2], leaf="csv", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))[m
[32m+[m[32m        add_spender(spenders, "siglen/popbyte_cs", tap=tap, key=secs[2], leaf="cs_pos", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))[m
[32m+[m[32m        add_spender(spenders, "siglen/popbyte_csa", tap=tap, key=secs[2], leaf="csa_pos", hashtype=hashtype, **SINGLE_SIG, **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))[m
[32m+[m[32m        add_spender(spenders, "siglen/popbyte_cs_neg", tap=tap, key=secs[2], leaf="cs_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))[m
[32m+[m[32m        add_spender(spenders, "siglen/popbyte_csa_neg", tap=tap, key=secs[2], leaf="csa_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", **SIG_POP_BYTE, **(ERR_SIG_SIZE if hashtype == SIGHASH_DEFAULT else ERR_SIG_SCHNORR))[m
[32m+[m[32m        # Verify that an invalid signature is not allowed, not even when the CHECKSIG* is expected to fail.[m
[32m+[m[32m        add_spender(spenders, "siglen/invalid_cs_neg", tap=tap, key=secs[2], leaf="cs_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", failure={"sign": default_sign, "sighash": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m        add_spender(spenders, "siglen/invalid_csa_neg", tap=tap, key=secs[2], leaf="csa_neg", hashtype=hashtype, **SINGLE_SIG, sign=b"", failure={"sign": default_sign, "sighash": bitflipper(default_sighash)}, **ERR_SIG_SCHNORR)[m
[32m+[m
[32m+[m[32m    # == Test that BIP341 spending only applies to witness version 1, program length 32, no P2SH ==[m
[32m+[m
[32m+[m[32m    for p2sh in [False, True]:[m
[32m+[m[32m        for witver in range(1, 17):[m
[32m+[m[32m            for witlen in [20, 31, 32, 33]:[m
[32m+[m[32m                def mutate(spk):[m
[32m+[m[32m                    prog = spk[2:][m
[32m+[m[32m                    assert len(prog) == 32[m
[32m+[m[32m                    if witlen < 32:[m
[32m+[m[32m                        prog = prog[0:witlen][m
[32m+[m[32m                    elif witlen > 32:[m
[32m+[m[32m                        prog += bytes([0 for _ in range(witlen - 32)])[m
[32m+[m[32m                    return CScript([CScriptOp.encode_op_n(witver), prog])[m
[32m+[m[32m                scripts = [("s0", CScript([pubs[0], OP_CHECKSIG])), ("dummy", CScript([OP_RETURN]))][m
[32m+[m[32m                tap = taproot_construct(pubs[1], scripts)[m
[32m+[m[32m                if not p2sh and witver == 1 and witlen == 32:[m
[32m+[m[32m                    add_spender(spenders, "applic/keypath", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], **SIGHASH_BITFLIP, **ERR_SIG_SCHNORR)[m
[32m+[m[32m                    add_spender(spenders, "applic/scriptpath", p2sh=p2sh, leaf="s0", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, failure={"leaf": "dummy"}, **ERR_OP_RETURN)[m
[32m+[m[32m                else:[m
[32m+[m[32m                    add_spender(spenders, "applic/keypath", p2sh=p2sh, spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[1], standard=False)[m
[32m+[m[32m                    add_spender(spenders, "applic/scriptpath", p2sh=p2sh, leaf="s0", spk_mutate_pre_p2sh=mutate, tap=tap, key=secs[0], **SINGLE_SIG, standard=False)[m
[32m+[m
[32m+[m[32m    # == Test various aspects of BIP341 spending paths ==[m
[32m+[m
[32m+[m[32m    # A set of functions that compute the hashing partner in a Merkle tree, designed to exercise[m
[32m+[m[32m    # edge cases. This relies on the taproot_construct feature that a lambda can be passed in[m
[32m+[m[32m    # instead of a subtree, to compute the partner to be hashed with.[m
[32m+[m[32m    PARTNER_MERKLE_FN = [[m
[32m+[m[32m        # Combine with itself[m
[32m+[m[32m        lambda h: h,[m
[32m+[m[32m        # Combine with hash 0[m
[32m+[m[32m        lambda h: bytes([0 for _ in range(32)]),[m
[32m+[m[32m        # Combine with hash 2^256-1[m
[32m+[m[32m        lambda h: bytes([0xff for _ in range(32)]),[m
[32m+[m[32m        # Combine with itself-1 (BE)[m
[32m+[m[32m        lambda h: (int.from_bytes(h, 'big') - 1).to_bytes(32, 'big'),[m
[32m+[m[32m        # Combine with itself+1 (BE)[m
[32m+[m[32m        lambda h: (int.from_bytes(h, 'big') + 1).to_bytes(32, 'big'),[m
[32m+[m[32m        # Combine with itself-1 (LE)[m
[32m+[m[32m        lambda h: (int.from_bytes(h, 'little') - 1).to_bytes(32, 'big'),[m
[32m+[m[32m        # Combine with itself+1 (LE)[m
[32m+[m[32m        lambda h: (int.from_bytes(h, 'little') + 1).to_bytes(32, 'little'),[m
[32m+[m[32m        # Combine with random bitflipped version of self.[m
[32m+[m[32m        lambda h: (int.from_bytes(h, 'little') ^ (1 << random.randrange(256))).to_bytes(32, 'little')[m
[32m+[m[32m    ][m
[32m+[m[32m    # Start with a tree of that has depth 1 for "128deep" and depth 2 for "129deep".[m
[32m+[m[32m    scripts = [("128deep", CScript([pubs[0], OP_CHECKSIG])), [("129deep", CScript([pubs[0], OP_CHECKSIG])), random.choice(PARTNER_MERKLE_FN)]][m
[32m+[m[32m    # Add 127 nodes on top of that tree, so that "128deep" and "129deep" end up at their designated depths.[m
[32m+[m[32m    for _ in range(127):[m
[32m+[m[32m        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)][m
[32m+[m[32m    tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m    # Test that spends with a depth of 128 work, but 129 doesn't (even with a tree with weird Merkle branches in it).[m
[32m+[m[32m    add_spender(spenders, "spendpath/merklelimit", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"leaf": "129deep"}, **ERR_CONTROLBLOCK_SIZE)[m
[32m+[m[32m    # Test that flipping the negation bit invalidates spends.[m
[32m+[m[32m    add_spender(spenders, "spendpath/negflag", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"negflag": lambda ctx: 1 - default_negflag(ctx)}, **ERR_WITNESS_PROGRAM_MISMATCH)[m
[32m+[m[32m    # Test that bitflips in the Merkle branch invalidate it.[m
[32m+[m[32m    add_spender(spenders, "spendpath/bitflipmerkle", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"merklebranch": bitflipper(default_merklebranch)}, **ERR_WITNESS_PROGRAM_MISMATCH)[m
[32m+[m[32m    # Test that bitflips in the inner pubkey invalidate it.[m
[32m+[m[32m    add_spender(spenders, "spendpath/bitflippubkey", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"pubkey_inner": bitflipper(default_pubkey_inner)}, **ERR_WITNESS_PROGRAM_MISMATCH)[m
[32m+[m[32m    # Test that empty witnesses are invalid.[m
[32m+[m[32m    add_spender(spenders, "spendpath/emptywit", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"witness": []}, **ERR_EMPTY_WITNESS)[m
[32m+[m[32m    # Test that adding garbage to the control block invalidates it.[m
[32m+[m[32m    add_spender(spenders, "spendpath/padlongcontrol", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"controlblock": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)[m
[32m+[m[32m    # Test that truncating the control block invalidates it.[m
[32m+[m[32m    add_spender(spenders, "spendpath/trunclongcontrol", tap=tap, leaf="128deep", **SINGLE_SIG, key=secs[0], failure={"controlblock": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)[m
[32m+[m
[32m+[m[32m    scripts = [("s", CScript([pubs[0], OP_CHECKSIG]))][m
[32m+[m[32m    tap = taproot_construct(pubs[1], scripts)[m
[32m+[m[32m    # Test that adding garbage to the control block invalidates it.[m
[32m+[m[32m    add_spender(spenders, "spendpath/padshortcontrol", tap=tap, leaf="s", **SINGLE_SIG, key=secs[0], failure={"controlblock": lambda ctx: default_controlblock(ctx) + random_bytes(random.randrange(1, 32))}, **ERR_CONTROLBLOCK_SIZE)[m
[32m+[m[32m    # Test that truncating the control block invalidates it.[m
[32m+[m[32m    add_spender(spenders, "spendpath/truncshortcontrol", tap=tap, leaf="s", **SINGLE_SIG, key=secs[0], failure={"controlblock": lambda ctx: default_merklebranch(ctx)[0:random.randrange(1, 32)]}, **ERR_CONTROLBLOCK_SIZE)[m
[32m+[m[32m    # Test that truncating the control block to 1 byte ("-1 Merkle length") invalidates it[m
[32m+[m[32m    add_spender(spenders, "spendpath/trunc1shortcontrol", tap=tap, leaf="s", **SINGLE_SIG, key=secs[0], failure={"controlblock": lambda ctx: default_merklebranch(ctx)[0:1]}, **ERR_CONTROLBLOCK_SIZE)[m
[32m+[m
[32m+[m[32m    # == Test BIP342 edge cases ==[m
[32m+[m
[32m+[m[32m    csa_low_val = random.randrange(0, 17) # Within range for OP_n[m
[32m+[m[32m    csa_low_result = csa_low_val + 1[m
[32m+[m
[32m+[m[32m    csa_high_val = random.randrange(17, 100) if random.getrandbits(1) else random.randrange(-100, -1) # Outside OP_n range[m
[32m+[m[32m    csa_high_result = csa_high_val + 1[m
[32m+[m
[32m+[m[32m    OVERSIZE_NUMBER = 2**31[m
[32m+[m[32m    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER))), 6)[m
[32m+[m[32m    assert_equal(len(CScriptNum.encode(CScriptNum(OVERSIZE_NUMBER-1))), 5)[m
[32m+[m
[32m+[m[32m    big_choices = [][m
[32m+[m[32m    big_scriptops = [][m
[32m+[m[32m    for i in range(1000):[m
[32m+[m[32m        r = random.randrange(len(pubs))[m
[32m+[m[32m        big_choices.append(r)[m
[32m+[m[32m        big_scriptops += [pubs[r], OP_CHECKSIGVERIFY][m
[32m+[m
[32m+[m
[32m+[m[32m    def big_spend_inputs(ctx):[m
[32m+[m[32m        """Helper function to construct the script input for t33/t34 below."""[m
[32m+[m[32m        # Instead of signing 999 times, precompute signatures for every (key, hashtype) combination[m
[32m+[m[32m        sigs = {}[m
[32m+[m[32m        for ht in VALID_SIGHASHES_TAPROOT:[m
[32m+[m[32m            for k in range(len(pubs)):[m
[32m+[m[32m                sigs[(k, ht)] = override(default_sign, hashtype=ht, key=secs[k])(ctx)[m
[32m+[m[32m        num = get(ctx, "num")[m
[32m+[m[32m        return [sigs[(big_choices[i], random.choice(VALID_SIGHASHES_TAPROOT))] for i in range(num - 1, -1, -1)][m
[32m+[m
[32m+[m[32m    # Various BIP342 features[m
[32m+[m[32m    scripts = [[m
[32m+[m[32m        # 0) drop stack element and OP_CHECKSIG[m
[32m+[m[32m        ("t0", CScript([OP_DROP, pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 1) normal OP_CHECKSIG[m
[32m+[m[32m        ("t1", CScript([pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 2) normal OP_CHECKSIGVERIFY[m
[32m+[m[32m        ("t2", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1])),[m
[32m+[m[32m        # 3) Hypothetical OP_CHECKMULTISIG script that takes a single sig as input[m
[32m+[m[32m        ("t3", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIG])),[m
[32m+[m[32m        # 4) Hypothetical OP_CHECKMULTISIGVERIFY script that takes a single sig as input[m
[32m+[m[32m        ("t4", CScript([OP_0, OP_SWAP, OP_1, pubs[1], OP_1, OP_CHECKMULTISIGVERIFY, OP_1])),[m
[32m+[m[32m        # 5) OP_IF script that needs a true input[m
[32m+[m[32m        ("t5", CScript([OP_IF, pubs[1], OP_CHECKSIG, OP_ELSE, OP_RETURN, OP_ENDIF])),[m
[32m+[m[32m        # 6) OP_NOTIF script that needs a true input[m
[32m+[m[32m        ("t6", CScript([OP_NOTIF, OP_RETURN, OP_ELSE, pubs[1], OP_CHECKSIG, OP_ENDIF])),[m
[32m+[m[32m        # 7) OP_CHECKSIG with an empty key[m
[32m+[m[32m        ("t7", CScript([OP_0, OP_CHECKSIG])),[m
[32m+[m[32m        # 8) OP_CHECKSIGVERIFY with an empty key[m
[32m+[m[32m        ("t8", CScript([OP_0, OP_CHECKSIGVERIFY, OP_1])),[m
[32m+[m[32m        # 9) normal OP_CHECKSIGADD that also ensures return value is correct[m
[32m+[m[32m        ("t9", CScript([csa_low_val, pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),[m
[32m+[m[32m        # 10) OP_CHECKSIGADD with empty key[m
[32m+[m[32m        ("t10", CScript([csa_low_val, OP_0, OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),[m
[32m+[m[32m        # 11) OP_CHECKSIGADD with missing counter stack element[m
[32m+[m[32m        ("t11", CScript([pubs[1], OP_CHECKSIGADD, OP_1, OP_EQUAL])),[m
[32m+[m[32m        # 12) OP_CHECKSIG that needs invalid signature[m
[32m+[m[32m        ("t12", CScript([pubs[1], OP_CHECKSIGVERIFY, pubs[0], OP_CHECKSIG, OP_NOT])),[m
[32m+[m[32m        # 13) OP_CHECKSIG with empty key that needs invalid signature[m
[32m+[m[32m        ("t13", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_CHECKSIG, OP_NOT])),[m
[32m+[m[32m        # 14) OP_CHECKSIGADD that needs invalid signature[m
[32m+[m[32m        ("t14", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, pubs[0], OP_CHECKSIGADD, OP_NOT])),[m
[32m+[m[32m        # 15) OP_CHECKSIGADD with empty key that needs invalid signature[m
[32m+[m[32m        ("t15", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGADD, OP_NOT])),[m
[32m+[m[32m        # 16) OP_CHECKSIG with unknown pubkey type[m
[32m+[m[32m        ("t16", CScript([OP_1, OP_CHECKSIG])),[m
[32m+[m[32m        # 17) OP_CHECKSIGADD with unknown pubkey type[m
[32m+[m[32m        ("t17", CScript([OP_0, OP_1, OP_CHECKSIGADD])),[m
[32m+[m[32m        # 18) OP_CHECKSIGVERIFY with unknown pubkey type[m
[32m+[m[32m        ("t18", CScript([OP_1, OP_CHECKSIGVERIFY, OP_1])),[m
[32m+[m[32m        # 19) script longer than 10000 bytes and over 201 non-push opcodes[m
[32m+[m[32m        ("t19", CScript([OP_0, OP_0, OP_2DROP] * 10001 + [pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 20) OP_CHECKSIGVERIFY with empty key[m
[32m+[m[32m        ("t20", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_0, OP_0, OP_CHECKSIGVERIFY, OP_1])),[m
[32m+[m[32m        # 21) Script that grows the stack to 1000 elements[m
[32m+[m[32m        ("t21", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 999 + [OP_DROP] * 999)),[m
[32m+[m[32m        # 22) Script that grows the stack to 1001 elements[m
[32m+[m[32m        ("t22", CScript([pubs[1], OP_CHECKSIGVERIFY, OP_1] + [OP_DUP] * 1000 + [OP_DROP] * 1000)),[m
[32m+[m[32m        # 23) Script that expects an input stack of 1000 elements[m
[32m+[m[32m        ("t23", CScript([OP_DROP] * 999 + [pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 24) Script that expects an input stack of 1001 elements[m
[32m+[m[32m        ("t24", CScript([OP_DROP] * 1000 + [pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 25) Script that pushes a MAX_SCRIPT_ELEMENT_SIZE-bytes element[m
[32m+[m[32m        ("t25", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE), OP_DROP, pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 26) Script that pushes a (MAX_SCRIPT_ELEMENT_SIZE+1)-bytes element[m
[32m+[m[32m        ("t26", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 27) CHECKSIGADD that must fail because numeric argument number is >4 bytes[m
[32m+[m[32m        ("t27", CScript([CScriptNum(OVERSIZE_NUMBER), pubs[1], OP_CHECKSIGADD])),[m
[32m+[m[32m        # 28) Pushes random CScriptNum value, checks OP_CHECKSIGADD result[m
[32m+[m[32m        ("t28", CScript([csa_high_val, pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),[m
[32m+[m[32m        # 29) CHECKSIGADD that succeeds with proper sig because numeric argument number is <=4 bytes[m
[32m+[m[32m        ("t29", CScript([CScriptNum(OVERSIZE_NUMBER-1), pubs[1], OP_CHECKSIGADD])),[m
[32m+[m[32m        # 30) Variant of t1 with "normal" 33-byte pubkey[m
[32m+[m[32m        ("t30", CScript([b'\x03' + pubs[1], OP_CHECKSIG])),[m
[32m+[m[32m        # 31) Variant of t2 with "normal" 33-byte pubkey[m
[32m+[m[32m        ("t31", CScript([b'\x02' + pubs[1], OP_CHECKSIGVERIFY, OP_1])),[m
[32m+[m[32m        # 32) Variant of t28 with "normal" 33-byte pubkey[m
[32m+[m[32m        ("t32", CScript([csa_high_val, b'\x03' + pubs[1], OP_CHECKSIGADD, csa_high_result, OP_EQUAL])),[m
[32m+[m[32m        # 33) 999-of-999 multisig[m
[32m+[m[32m        ("t33", CScript(big_scriptops[:1998] + [OP_1])),[m
[32m+[m[32m        # 34) 1000-of-1000 multisig[m
[32m+[m[32m        ("t34", CScript(big_scriptops[:2000] + [OP_1])),[m
[32m+[m[32m        # 35) Variant of t9 that uses a non-minimally encoded input arg[m
[32m+[m[32m        ("t35", CScript([bytes([csa_low_val]), pubs[1], OP_CHECKSIGADD, csa_low_result, OP_EQUAL])),[m
[32m+[m[32m        # 36) Empty script[m
[32m+[m[32m        ("t36", CScript([])),[m
[32m+[m[32m    ][m
[32m+[m[32m    # Add many dummies to test huge trees[m
[32m+[m[32m    for j in range(100000):[m
[32m+[m[32m        scripts.append((None, CScript([OP_RETURN, random.randrange(100000)])))[m
[32m+[m[32m    random.shuffle(scripts)[m
[32m+[m[32m    tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m    common = {[m
[32m+[m[32m        "hashtype": hashtype,[m
[32m+[m[32m        "key": secs[1],[m
[32m+[m[32m        "tap": tap,[m
[32m+[m[32m    }[m
[32m+[m[32m    # Test that MAX_SCRIPT_ELEMENT_SIZE byte stack element inputs are valid, but not one more (and 80 bytes is standard but 81 is not).[m
[32m+[m[32m    add_spender(spenders, "tapscript/inputmaxlimit", leaf="t0", **common, standard=False, inputs=[getter("sign"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE)], failure={"inputs": [getter("sign"), random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1)]}, **ERR_PUSH_LIMIT)[m
[32m+[m[32m    add_spender(spenders, "tapscript/input80limit", leaf="t0", **common, inputs=[getter("sign"), random_bytes(80)])[m
[32m+[m[32m    add_spender(spenders, "tapscript/input81limit", leaf="t0", **common, standard=False, inputs=[getter("sign"), random_bytes(81)])[m
[32m+[m[32m    # Test that OP_CHECKMULTISIG and OP_CHECKMULTISIGVERIFY cause failure, but OP_CHECKSIG and OP_CHECKSIGVERIFY work.[m
[32m+[m[32m    add_spender(spenders, "tapscript/disabled_checkmultisig", leaf="t1", **common, **SINGLE_SIG, failure={"leaf": "t3"}, **ERR_TAPSCRIPT_CHECKMULTISIG)[m
[32m+[m[32m    add_spender(spenders, "tapscript/disabled_checkmultisigverify", leaf="t2", **common, **SINGLE_SIG, failure={"leaf": "t4"}, **ERR_TAPSCRIPT_CHECKMULTISIG)[m
[32m+[m[32m    # Test that OP_IF and OP_NOTIF do not accept non-0x01 as truth value (the MINIMALIF rule is consensus in Tapscript)[m
[32m+[m[32m    add_spender(spenders, "tapscript/minimalif", leaf="t5", **common, inputs=[getter("sign"), b'\x01'], failure={"inputs": [getter("sign"), b'\x02']}, **ERR_MINIMALIF)[m
[32m+[m[32m    add_spender(spenders, "tapscript/minimalnotif", leaf="t6", **common, inputs=[getter("sign"), b'\x01'], failure={"inputs": [getter("sign"), b'\x03']}, **ERR_MINIMALIF)[m
[32m+[m[32m    add_spender(spenders, "tapscript/minimalif", leaf="t5", **common, inputs=[getter("sign"), b'\x01'], failure={"inputs": [getter("sign"), b'\x0001']}, **ERR_MINIMALIF)[m
[32m+[m[32m    add_spender(spenders, "tapscript/minimalnotif", leaf="t6", **common, inputs=[getter("sign"), b'\x01'], failure={"inputs": [getter("sign"), b'\x0100']}, **ERR_MINIMALIF)[m
[32m+[m[32m    # Test that 1-byte public keys (which are unknown) are acceptable but nonstandard with unrelated signatures, but 0-byte public keys are not valid.[m
[32m+[m[32m    add_spender(spenders, "tapscript/unkpk/checksig", leaf="t16", standard=False, **common, **SINGLE_SIG, failure={"leaf": "t7"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/unkpk/checksigadd", leaf="t17", standard=False, **common, **SINGLE_SIG, failure={"leaf": "t10"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/unkpk/checksigverify", leaf="t18", standard=False, **common, **SINGLE_SIG, failure={"leaf": "t8"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    # Test that 33-byte public keys (which are unknown) are acceptable but nonstandard with valid signatures, but normal pubkeys are not valid in that case.[m
[32m+[m[32m    add_spender(spenders, "tapscript/oldpk/checksig", leaf="t30", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={"leaf": "t1"}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "tapscript/oldpk/checksigadd", leaf="t31", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={"leaf": "t2"}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    add_spender(spenders, "tapscript/oldpk/checksigverify", leaf="t32", standard=False, **common, **SINGLE_SIG, sighash=bitflipper(default_sighash), failure={"leaf": "t28"}, **ERR_SIG_SCHNORR)[m
[32m+[m[32m    # Test that 0-byte public keys are not acceptable.[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptypk/checksig", leaf="t1", **SINGLE_SIG, **common, failure={"leaf": "t7"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptypk/checksigverify", leaf="t2", **SINGLE_SIG, **common, failure={"leaf": "t8"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptypk/checksigadd", leaf="t9", **SINGLE_SIG, **common, failure={"leaf": "t10"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptypk/checksigadd", leaf="t35", standard=False, **SINGLE_SIG, **common, failure={"leaf": "t10"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    # Test that OP_CHECKSIGADD results are as expected[m
[32m+[m[32m    add_spender(spenders, "tapscript/checksigaddresults", leaf="t28", **SINGLE_SIG, **common, failure={"leaf": "t27"}, err_msg="unknown error")[m
[32m+[m[32m    add_spender(spenders, "tapscript/checksigaddoversize", leaf="t29", **SINGLE_SIG, **common, failure={"leaf": "t27"}, err_msg="unknown error")[m
[32m+[m[32m    # Test that OP_CHECKSIGADD requires 3 stack elements.[m
[32m+[m[32m    add_spender(spenders, "tapscript/checksigadd3args", leaf="t9", **SINGLE_SIG, **common, failure={"leaf": "t11"}, **ERR_STACK_EMPTY)[m
[32m+[m[32m    # Test that empty signatures do not cause script failure in OP_CHECKSIG and OP_CHECKSIGADD (but do fail with empty pubkey, and do fail OP_CHECKSIGVERIFY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptysigs/checksig", leaf="t12", **common, inputs=[b'', getter("sign")], failure={"leaf": "t13"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptysigs/nochecksigverify", leaf="t12", **common, inputs=[b'', getter("sign")], failure={"leaf": "t20"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    add_spender(spenders, "tapscript/emptysigs/checksigadd", leaf="t14", **common, inputs=[b'', getter("sign")], failure={"leaf": "t15"}, **ERR_UNKNOWN_PUBKEY)[m
[32m+[m[32m    # Test that scripts over 10000 bytes (and over 201 non-push ops) are acceptable.[m
[32m+[m[32m    add_spender(spenders, "tapscript/no10000limit", leaf="t19", **SINGLE_SIG, **common)[m
[32m+[m[32m    # Test that a stack size of 1000 elements is permitted, but 1001 isn't.[m
[32m+[m[32m    add_spender(spenders, "tapscript/1000stack", leaf="t21", **SINGLE_SIG, **common, failure={"leaf": "t22"}, **ERR_STACK_SIZE)[m
[32m+[m[32m    # Test that an input stack size of 1000 elements is permitted, but 1001 isn't.[m
[32m+[m[32m    add_spender(spenders, "tapscript/1000inputs", leaf="t23", **common, inputs=[getter("sign")] + [b'' for _ in range(999)], failure={"leaf": "t24", "inputs": [getter("sign")] + [b'' for _ in range(1000)]}, **ERR_STACK_SIZE)[m
[32m+[m[32m    # Test that pushing a MAX_SCRIPT_ELEMENT_SIZE byte stack element is valid, but one longer is not.[m
[32m+[m[32m    add_spender(spenders, "tapscript/pushmaxlimit", leaf="t25", **common, **SINGLE_SIG, failure={"leaf": "t26"}, **ERR_PUSH_LIMIT)[m
[32m+[m[32m    # Test that 999-of-999 multisig works (but 1000-of-1000 triggers stack size limits)[m
[32m+[m[32m    add_spender(spenders, "tapscript/bigmulti", leaf="t33", **common, inputs=big_spend_inputs, num=999, failure={"leaf": "t34", "num": 1000}, **ERR_STACK_SIZE)[m
[32m+[m[32m    # Test that the CLEANSTACK rule is consensus critical in tapscript[m
[32m+[m[32m    add_spender(spenders, "tapscript/cleanstack", leaf="t36", tap=tap, inputs=[b'\x01'], failure={"inputs": [b'\x01', b'\x01']}, **ERR_CLEANSTACK)[m
[32m+[m
[32m+[m[32m    # == Test for sigops ratio limit ==[m
[32m+[m
[32m+[m[32m    # Given a number n, and a public key pk, functions that produce a (CScript, sigops). Each script takes as[m
[32m+[m[32m    # input a valid signature with the passed pk followed by a dummy push of bytes that are to be dropped, and[m
[32m+[m[32m    # will execute sigops signature checks.[m
[32m+[m[32m    SIGOPS_RATIO_SCRIPTS = [[m
[32m+[m[32m        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIG.[m
[32m+[m[32m        lambda n, pk: (CScript([OP_DROP, pk] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_CHECKSIG]), n + 1),[m
[32m+[m[32m        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGVERIFY.[m
[32m+[m[32m        lambda n, pk: (CScript([OP_DROP, pk, OP_0, OP_IF, OP_2DUP, OP_CHECKSIGVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_2, OP_SWAP, OP_CHECKSIGADD, OP_3, OP_EQUAL]), n + 1),[m
[32m+[m[32m        # n OP_CHECKSIGVERIFYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIG.[m
[32m+[m[32m        lambda n, pk: (CScript([random_bytes(220), OP_2DROP, pk, OP_1, OP_NOTIF, OP_2DUP, OP_CHECKSIG, OP_VERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_4, OP_SWAP, OP_CHECKSIGADD, OP_5, OP_EQUAL]), n + 1),[m
[32m+[m[32m        # n OP_CHECKSIGVERFIYs and 1 OP_CHECKSIGADD, but also one unexecuted OP_CHECKSIGADD.[m
[32m+[m[32m        lambda n, pk: (CScript([OP_DROP, pk, OP_1, OP_IF, OP_ELSE, OP_2DUP, OP_6, OP_SWAP, OP_CHECKSIGADD, OP_7, OP_EQUALVERIFY, OP_ENDIF] + [OP_2DUP, OP_CHECKSIGVERIFY] * n + [OP_8, OP_SWAP, OP_CHECKSIGADD, OP_9, OP_EQUAL]), n + 1),[m
[32m+[m[32m        # n+1 OP_CHECKSIGs, but also one OP_CHECKSIG with an empty signature.[m
[32m+[m[32m        lambda n, pk: (CScript([OP_DROP, OP_0, pk, OP_CHECKSIG, OP_NOT, OP_VERIFY, pk] + [OP_2DUP, OP_CHECKSIG, OP_VERIFY] * n + [OP_CHECKSIG]), n + 1),[m
[32m+[m[32m        # n OP_CHECKSIGADDs and 1 OP_CHECKSIG, but also an OP_CHECKSIGADD with an empty signature.[m
[32m+[m[32m        lambda n, pk: (CScript([OP_DROP, OP_0, OP_10, pk, OP_CHECKSIGADD, OP_10, OP_EQUALVERIFY, pk] + [OP_2DUP, OP_16, OP_SWAP, OP_CHECKSIGADD, b'\x11', OP_EQUALVERIFY] * n + [OP_CHECKSIG]), n + 1),[m
[32m+[m[32m    ][m
[32m+[m[32m    for annex in [None, bytes([ANNEX_TAG]) + random_bytes(random.randrange(1000))]:[m
[32m+[m[32m        for hashtype in [SIGHASH_DEFAULT, SIGHASH_ALL]:[m
[32m+[m[32m            for pubkey in [pubs[1], random_bytes(random.choice([x for x in range(2, 81) if x != 32]))]:[m
[32m+[m[32m                for fn_num, fn in enumerate(SIGOPS_RATIO_SCRIPTS):[m
[32m+[m[32m                    merkledepth = random.randrange(129)[m
[32m+[m
[32m+[m
[32m+[m[32m                    def predict_sigops_ratio(n, dummy_size):[m
[32m+[m[32m                        """Predict whether spending fn(n, pubkey) with dummy_size will pass the ratio test."""[m
[32m+[m[32m                        script, sigops = fn(n, pubkey)[m
[32m+[m[32m                        # Predict the size of the witness for a given choice of n[m
[32m+[m[32m                        stacklen_size = 1[m
[32m+[m[32m                        sig_size = 64 + (hashtype != SIGHASH_DEFAULT)[m
[32m+[m[32m                        siglen_size = 1[m
[32m+[m[32m                        dummylen_size = 1 + 2 * (dummy_size >= 253)[m
[32m+[m[32m                        script_size = len(script)[m
[32m+[m[32m                        scriptlen_size = 1 + 2 * (script_size >= 253)[m
[32m+[m[32m                        control_size = 33 + 32 * merkledepth[m
[32m+[m[32m                        controllen_size = 1 + 2 * (control_size >= 253)[m
[32m+[m[32m                        annex_size = 0 if annex is None else len(annex)[m
[32m+[m[32m                        annexlen_size = 0 if annex is None else 1 + 2 * (annex_size >= 253)[m
[32m+[m[32m                        witsize = stacklen_size + sig_size + siglen_size + dummy_size + dummylen_size + script_size + scriptlen_size + control_size + controllen_size + annex_size + annexlen_size[m
[32m+[m[32m                        # sigops ratio test[m
[32m+[m[32m                        return witsize + 50 >= 50 * sigops[m
[32m+[m[32m                    # Make sure n is high enough that with empty dummy, the script is not valid[m
[32m+[m[32m                    n = 0[m
[32m+[m[32m                    while predict_sigops_ratio(n, 0):[m
[32m+[m[32m                        n += 1[m
[32m+[m[32m                    # But allow picking a bit higher still[m
[32m+[m[32m                    n += random.randrange(5)[m
[32m+[m[32m                    # Now pick dummy size *just* large enough that the overall construction passes[m
[32m+[m[32m                    dummylen = 0[m
[32m+[m[32m                    while not predict_sigops_ratio(n, dummylen):[m
[32m+[m[32m                        dummylen += 1[m
[32m+[m[32m                    scripts = [("s", fn(n, pubkey)[0])][m
[32m+[m[32m                    for _ in range(merkledepth):[m
[32m+[m[32m                        scripts = [scripts, random.choice(PARTNER_MERKLE_FN)][m
[32m+[m[32m                    tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m                    standard = annex is None and dummylen <= 80 and len(pubkey) == 32[m
[32m+[m[32m                    add_spender(spenders, "tapscript/sigopsratio_%i" % fn_num, tap=tap, leaf="s", annex=annex, hashtype=hashtype, key=secs[1], inputs=[getter("sign"), random_bytes(dummylen)], standard=standard, failure={"inputs": [getter("sign"), random_bytes(dummylen - 1)]}, **ERR_SIGOPS_RATIO)[m
[32m+[m
[32m+[m[32m    # Future leaf versions[m
[32m+[m[32m    for leafver in range(0, 0x100, 2):[m
[32m+[m[32m        if leafver == LEAF_VERSION_TAPSCRIPT or leafver == ANNEX_TAG:[m
[32m+[m[32m            # Skip the defined LEAF_VERSION_TAPSCRIPT, and the ANNEX_TAG which is not usable as leaf version[m
[32m+[m[32m            continue[m
[32m+[m[32m        scripts = [[m
[32m+[m[32m            ("bare_c0", CScript([OP_NOP])),[m
[32m+[m[32m            ("bare_unkver", CScript([OP_NOP]), leafver),[m
[32m+[m[32m            ("return_c0", CScript([OP_RETURN])),[m
[32m+[m[32m            ("return_unkver", CScript([OP_RETURN]), leafver),[m
[32m+[m[32m            ("undecodable_c0", CScript([OP_PUSHDATA1])),[m
[32m+[m[32m            ("undecodable_unkver", CScript([OP_PUSHDATA1]), leafver),[m
[32m+[m[32m            ("bigpush_c0", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP])),[m
[32m+[m[32m            ("bigpush_unkver", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP]), leafver),[m
[32m+[m[32m            ("1001push_c0", CScript([OP_0] * 1001)),[m
[32m+[m[32m            ("1001push_unkver", CScript([OP_0] * 1001), leafver),[m
[32m+[m[32m        ][m
[32m+[m[32m        random.shuffle(scripts)[m
[32m+[m[32m        tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m        add_spender(spenders, "unkver/bare", standard=False, tap=tap, leaf="bare_unkver", failure={"leaf": "bare_c0"}, **ERR_CLEANSTACK)[m
[32m+[m[32m        add_spender(spenders, "unkver/return", standard=False, tap=tap, leaf="return_unkver", failure={"leaf": "return_c0"}, **ERR_OP_RETURN)[m
[32m+[m[32m        add_spender(spenders, "unkver/undecodable", standard=False, tap=tap, leaf="undecodable_unkver", failure={"leaf": "undecodable_c0"}, **ERR_UNDECODABLE)[m
[32m+[m[32m        add_spender(spenders, "unkver/bigpush", standard=False, tap=tap, leaf="bigpush_unkver", failure={"leaf": "bigpush_c0"}, **ERR_PUSH_LIMIT)[m
[32m+[m[32m        add_spender(spenders, "unkver/1001push", standard=False, tap=tap, leaf="1001push_unkver", failure={"leaf": "1001push_c0"}, **ERR_STACK_SIZE)[m
[32m+[m[32m        add_spender(spenders, "unkver/1001inputs", standard=False, tap=tap, leaf="bare_unkver", inputs=[b'']*1001, failure={"leaf": "bare_c0"}, **ERR_STACK_SIZE)[m
[32m+[m
[32m+[m[32m    # OP_SUCCESSx tests.[m
[32m+[m[32m    hashtype = lambda _: random.choice(VALID_SIGHASHES_TAPROOT)[m
[32m+[m[32m    for opval in range(76, 0x100):[m
[32m+[m[32m        opcode = CScriptOp(opval)[m
[32m+[m[32m        if not is_op_success(opcode):[m
[32m+[m[32m            continue[m
[32m+[m[32m        scripts = [[m
[32m+[m[32m            ("bare_success", CScript([opcode])),[m
[32m+[m[32m            ("bare_nop", CScript([OP_NOP])),[m
[32m+[m[32m            ("unexecif_success", CScript([OP_0, OP_IF, opcode, OP_ENDIF])),[m
[32m+[m[32m            ("unexecif_nop", CScript([OP_0, OP_IF, OP_NOP, OP_ENDIF])),[m
[32m+[m[32m            ("return_success", CScript([OP_RETURN, opcode])),[m
[32m+[m[32m            ("return_nop", CScript([OP_RETURN, OP_NOP])),[m
[32m+[m[32m            ("undecodable_success", CScript([opcode, OP_PUSHDATA1])),[m
[32m+[m[32m            ("undecodable_nop", CScript([OP_NOP, OP_PUSHDATA1])),[m
[32m+[m[32m            ("undecodable_bypassed_success", CScript([OP_PUSHDATA1, OP_2, opcode])),[m
[32m+[m[32m            ("bigpush_success", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, opcode])),[m
[32m+[m[32m            ("bigpush_nop", CScript([random_bytes(MAX_SCRIPT_ELEMENT_SIZE+1), OP_DROP, OP_NOP])),[m
[32m+[m[32m            ("1001push_success", CScript([OP_0] * 1001 + [opcode])),[m
[32m+[m[32m            ("1001push_nop", CScript([OP_0] * 1001 + [OP_NOP])),[m
[32m+[m[32m        ][m
[32m+[m[32m        random.shuffle(scripts)[m
[32m+[m[32m        tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/bare", standard=False, tap=tap, leaf="bare_success", failure={"leaf": "bare_nop"}, **ERR_CLEANSTACK)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/unexecif", standard=False, tap=tap, leaf="unexecif_success", failure={"leaf": "unexecif_nop"}, **ERR_CLEANSTACK)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/return", standard=False, tap=tap, leaf="return_success", failure={"leaf": "return_nop"}, **ERR_OP_RETURN)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/undecodable", standard=False, tap=tap, leaf="undecodable_success", failure={"leaf": "undecodable_nop"}, **ERR_UNDECODABLE)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/undecodable_bypass", standard=False, tap=tap, leaf="undecodable_success", failure={"leaf": "undecodable_bypassed_success"}, **ERR_UNDECODABLE)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/bigpush", standard=False, tap=tap, leaf="bigpush_success", failure={"leaf": "bigpush_nop"}, **ERR_PUSH_LIMIT)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/1001push", standard=False, tap=tap, leaf="1001push_success", failure={"leaf": "1001push_nop"}, **ERR_STACK_SIZE)[m
[32m+[m[32m        add_spender(spenders, "opsuccess/1001inputs", standard=False, tap=tap, leaf="bare_success", inputs=[b'']*1001, failure={"leaf": "bare_nop"}, **ERR_STACK_SIZE)[m
[32m+[m
[32m+[m[32m    # Non-OP_SUCCESSx (verify that those aren't accidentally treated as OP_SUCCESSx)[m
[32m+[m[32m    for opval in range(0, 0x100):[m
[32m+[m[32m        opcode = CScriptOp(opval)[m
[32m+[m[32m        if is_op_success(opcode):[m
[32m+[m[32m            continue[m
[32m+[m[32m        scripts = [[m
[32m+[m[32m            ("normal", CScript([OP_RETURN, opcode] + [OP_NOP] * 75)),[m
[32m+[m[32m            ("op_success", CScript([OP_RETURN, CScriptOp(0x50)]))[m
[32m+[m[32m        ][m
[32m+[m[32m        tap = taproot_construct(pubs[0], scripts)[m
[32m+[m[32m        add_spender(spenders, "alwaysvalid/notsuccessx", tap=tap, leaf="op_success", inputs=[], standard=False, failure={"leaf": "normal"}) # err_msg differs based on opcode[m
[32m+[m
[32m+[m[32m    # == Legacy tests ==[m
[32m+[m
[32m+[m[32m    # Also add a few legacy spends into the mix, so that transactions which combine taproot and pre-taproot spends get tested too.[m
[32m+[m[32m    for compressed in [False, True]:[m
[32m+[m[32m        eckey1 = ECKey()[m
[32m+[m[32m        eckey1.set(generate_privkey(), compressed)[m
[32m+[m[32m        pubkey1 = eckey1.get_pubkey().get_bytes()[m
[32m+[m[32m        eckey2 = ECKey()[m
[32m+[m[32m        eckey2.set(generate_privkey(), compressed)[m
[32m+[m[32m        for p2sh in [False, True]:[m
[32m+[m[32m            for witv0 in [False, True]:[m
[32m+[m[32m                for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:[m
[32m+[m[32m                    standard = (hashtype in VALID_SIGHASHES_ECDSA) and (compressed or not witv0)[m
[32m+[m[32m                    add_spender(spenders, "legacy/pk-wrongkey", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([pubkey1, OP_CHECKSIG]), **SINGLE_SIG, key=eckey1, failure={"key": eckey2}, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)[m
[32m+[m[32m                    add_spender(spenders, "legacy/pkh-sighashflip", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, pkh=pubkey1, key=eckey1, **SIGHASH_BITFLIP, sigops_weight=4-3*witv0, **ERR_NO_SUCCESS)[m
[32m+[m
[32m+[m[32m    # Verify that OP_CHECKSIGADD wasn't accidentally added to pre-taproot validation logic.[m
[32m+[m[32m    for p2sh in [False, True]:[m
[32m+[m[32m        for witv0 in [False, True]:[m
[32m+[m[32m            for hashtype in VALID_SIGHASHES_ECDSA + [random.randrange(0x04, 0x80), random.randrange(0x84, 0x100)]:[m
[32m+[m[32m                standard = hashtype in VALID_SIGHASHES_ECDSA and (p2sh or witv0)[m
[32m+[m[32m                add_spender(spenders, "compat/nocsa", hashtype=hashtype, p2sh=p2sh, witv0=witv0, standard=standard, script=CScript([OP_IF, OP_11, pubkey1, OP_CHECKSIGADD, OP_12, OP_EQUAL, OP_ELSE, pubkey1, OP_CHECKSIG, OP_ENDIF]), key=eckey1, sigops_weight=4-3*witv0, inputs=[getter("sign"), b''], failure={"inputs": [getter("sign"), b'\x01']}, **ERR_UNDECODABLE)[m
[32m+[m
[32m+[m[32m    return spenders[m
[32m+[m
[32m+[m[32mdef spenders_taproot_inactive():[m
[32m+[m[32m    """Spenders for testing that pre-activation Taproot rules don't apply."""[m
[32m+[m
[32m+[m[32m    spenders = [][m
[32m+[m
[32m+[m[32m    sec = generate_privkey()[m
[32m+[m[32m    pub, _ = compute_xonly_pubkey(sec)[m
[32m+[m[32m    scripts = [[m
[32m+[m[32m        ("pk", CScript([pub, OP_CHECKSIG])),[m
[32m+[m[32m        ("future_leaf", CScript([pub, OP_CHECKSIG]), 0xc2),[m
[32m+[m[32m        ("op_success", CScript([pub, OP_CHECKSIG, OP_0, OP_IF, CScriptOp(0x50), OP_ENDIF])),[m
[32m+[m[32m    ][m
[32m+[m[32m    tap = taproot_construct(pub, scripts)[m
[32m+[m
[32m+[m[32m    # Test that keypath spending is valid & standard if compliant, but valid and nonstandard otherwise.[m
[32m+[m[32m    add_spender(spenders, "inactive/keypath_valid", key=sec, tap=tap)[m
[32m+[m[32m    add_spender(spenders, "inactive/keypath_invalidsig", key=sec, tap=tap, standard=False, sighash=bitflipper(default_sighash))[m
[32m+[m[32m    add_spender(spenders, "inactive/keypath_empty", key=sec, tap=tap, standard=False, witness=[])[m
[32m+[m
[32m+[m[32m    # Same for scriptpath spending (but using future features like annex, leaf versions, or OP_SUCCESS is nonstandard).[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_valid", key=sec, tap=tap, leaf="pk", inputs=[getter("sign")])[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_invalidsig", key=sec, tap=tap, leaf="pk", standard=False, inputs=[getter("sign")], sighash=bitflipper(default_sighash))[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_invalidcb", key=sec, tap=tap, leaf="pk", standard=False, inputs=[getter("sign")], controlblock=bitflipper(default_controlblock))[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_valid_unkleaf", key=sec, tap=tap, leaf="future_leaf", standard=False, inputs=[getter("sign")])[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_invalid_unkleaf", key=sec, tap=tap, leaf="future_leaf", standard=False, inputs=[getter("sign")], sighash=bitflipper(default_sighash))[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_valid_opsuccess", key=sec, tap=tap, leaf="op_success", standard=False, inputs=[getter("sign")])[m
[32m+[m[32m    add_spender(spenders, "inactive/scriptpath_valid_opsuccess", key=sec, tap=tap, leaf="op_success", standard=False, inputs=[getter("sign")], sighash=bitflipper(default_sighash))[m
[32m+[m
[32m+[m[32m    return spenders[m
[32m+[m
[32m+[m[32m# Consensus validation flags to use in dumps for tests with "legacy/" or "inactive/" prefix.[m
[32m+[m[32mLEGACY_FLAGS = "P2SH,DERSIG,CHECKLOCKTIMEVERIFY,CHECKSEQUENCEVERIFY,WITNESS,NULLDUMMY"[m
[32m+[m[32m# Consensus validation flags to use in dumps for all other tests.[m
[32m+[m[32mTAPROOT_FLAGS = "P2SH,DERSIG,CHECKLOCKTIMEVERIFY,CHECKSEQUENCEVERIFY,WITNESS,NULLDUMMY,TAPROOT"[m
[32m+[m
[32m+[m[32mdef dump_json_test(tx, input_utxos, idx, success, failure):[m
[32m+[m[32m    spender = input_utxos[idx].spender[m
[32m+[m[32m    # Determine flags to dump[m
[32m+[m[32m    flags = LEGACY_FLAGS if spender.comment.startswith("legacy/") or spender.comment.startswith("inactive/") else TAPROOT_FLAGS[m
[32m+[m
[32m+[m[32m    fields = [[m
[32m+[m[32m        ("tx", tx.serialize().hex()),[m
[32m+[m[32m        ("prevouts", [x.output.serialize().hex() for x in input_utxos]),[m
[32m+[m[32m        ("index", idx),[m
[32m+[m[32m        ("flags", flags),[m
[32m+[m[32m        ("comment", spender.comment)[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    # The "final" field indicates that a spend should be always valid, even with more validation flags enabled[m
[32m+[m[32m    # than the listed ones. Use standardness as a proxy for this (which gives a conservative underestimate).[m
[32m+[m[32m    if spender.is_standard:[m
[32m+[m[32m        fields.append(("final", True))[m
[32m+[m
[32m+[m[32m    def dump_witness(wit):[m
[32m+[m[32m        return OrderedDict([("scriptSig", wit[0].hex()), ("witness", [x.hex() for x in wit[1]])])[m
[32m+[m[32m    if success is not None:[m
[32m+[m[32m        fields.append(("success", dump_witness(success)))[m
[32m+[m[32m    if failure is not None:[m
[32m+[m[32m        fields.append(("failure", dump_witness(failure)))[m
[32m+[m
[32m+[m[32m    # Write the dump to $TEST_DUMP_DIR/x/xyz... where x,y,z,... are the SHA1 sum of the dump (which makes the[m
[32m+[m[32m    # file naming scheme compatible with fuzzing infrastructure).[m
[32m+[m[32m    dump = json.dumps(OrderedDict(fields)) + ",\n"[m
[32m+[m[32m    sha1 = hashlib.sha1(dump.encode("utf-8")).hexdigest()[m
[32m+[m[32m    dirname = os.environ.get("TEST_DUMP_DIR", ".") + ("/%s" % sha1[0])[m
[32m+[m[32m    os.makedirs(dirname, exist_ok=True)[m
[32m+[m[32m    with open(dirname + ("/%s" % sha1), 'w', encoding="utf8") as f:[m
[32m+[m[32m        f.write(dump)[m
[32m+[m
[32m+[m[32m# Data type to keep track of UTXOs, where they were created, and how to spend them.[m
[32m+[m[32mUTXOData = namedtuple('UTXOData', 'outpoint,output,spender')[m
[32m+[m
[32m+[m[32mclass TaprootTest(BitcoinTestFramework):[m
[32m+[m[32m    def add_options(self, parser):[m
[32m+[m[32m        parser.add_argument("--dumptests", dest="dump_tests", default=False, action="store_true",[m
[32m+[m[32m                            help="Dump generated test cases to directory set by TEST_DUMP_DIR environment variable")[m
[32m+[m
[32m+[m[32m    def skip_test_if_missing_module(self):[m
[32m+[m[32m        self.skip_if_no_wallet()[m
[32m+[m
[32m+[m[32m    def set_test_params(self):[m
[32m+[m[32m        self.num_nodes = 2[m
[32m+[m[32m        self.setup_clean_chain = True[m
[32m+[m[32m        # Node 0 has Taproot inactive, Node 1 active.[m
[32m+[m[32m        self.extra_args = [["-whitelist=127.0.0.1", "-par=1", "-vbparams=taproot:1:1"], ["-whitelist=127.0.0.1", "-par=1"]][m
[32m+[m
[32m+[m[32m    def block_submit(self, node, txs, msg, err_msg, cb_pubkey=None, fees=0, sigops_weight=0, witness=False, accept=False):[m
[32m+[m
[32m+[m[32m        # Deplete block of any non-tapscript sigops using a single additional 0-value coinbase output.[m
[32m+[m[32m        # It is not impossible to fit enough tapscript sigops to hit the old 80k limit without[m
[32m+[m[32m        # busting txin-level limits. We simply have to account for the p2pk outputs in all[m
[32m+[m[32m        # transactions.[m
[32m+[m[32m        extra_output_script = CScript([OP_CHECKSIG]*((MAX_BLOCK_SIGOPS_WEIGHT - sigops_weight) // WITNESS_SCALE_FACTOR))[m
[32m+[m
[32m+[m[32m        block = create_block(self.tip, create_coinbase(self.lastblockheight + 1, pubkey=cb_pubkey, extra_output_script=extra_output_script, fees=fees), self.lastblocktime + 1)[m
[32m+[m[32m        block.nVersion = 4[m
[32m+[m[32m        for tx in txs:[m
[32m+[m[32m            tx.rehash()[m
[32m+[m[32m            block.vtx.append(tx)[m
[32m+[m[32m        block.hashMerkleRoot = block.calc_merkle_root()[m
[32m+[m[32m        witness and add_witness_commitment(block)[m
[32m+[m[32m        block.rehash()[m
[32m+[m[32m        block.solve()[m
[32m+[m[32m        block_response = node.submitblock(block.serialize(True).hex())[m
[32m+[m[32m        if err_msg is not None:[m
[32m+[m[32m            assert block_response is not None and err_msg in block_response, "Missing error message '%s' from block response '%s': %s" % (err_msg, "(None)" if block_response is None else block_response, msg)[m
[32m+[m[32m        if (accept):[m
[32m+[m[32m            assert node.getbestblockhash() == block.hash, "Failed to accept: %s (response: %s)" % (msg, block_response)[m
[32m+[m[32m            self.tip = block.sha256[m
[32m+[m[32m            self.lastblockhash = block.hash[m
[32m+[m[32m            self.lastblocktime += 1[m
[32m+[m[32m            self.lastblockheight += 1[m
[32m+[m[32m        else:[m
[32m+[m[32m            assert node.getbestblockhash() == self.lastblockhash, "Failed to reject: " + msg[m
[32m+[m
[32m+[m[32m    def test_spenders(self, node, spenders, input_counts):[m
[32m+[m[32m        """Run randomized tests with a number of "spenders".[m
[32m+[m
[32m+[m[32m        Steps:[m
[32m+[m[32m            1) Generate an appropriate UTXO for each spender to test spend conditions[m
[32m+[m[32m            2) Generate 100 random addresses of all wallet types: pkh/sh_wpkh/wpkh[m
[32m+[m[32m            3) Select random number of inputs from (1)[m
[32m+[m[32m            4) Select random number of addresses from (2) as outputs[m
[32m+[m
[32m+[m[32m        Each spender embodies a test; in a large randomized test, it is verified[m
[32m+[m[32m        that toggling the valid argument to each lambda toggles the validity of[m
[32m+[m[32m        the transaction. This is accomplished by constructing transactions consisting[m
[32m+[m[32m        of all valid inputs, except one invalid one.[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        # Construct a bunch of sPKs that send coins back to the host wallet[m
[32m+[m[32m        self.log.info("- Constructing addresses for returning coins")[m
[32m+[m[32m        host_spks = [][m
[32m+[m[32m        host_pubkeys = [][m
[32m+[m[32m        for i in range(16):[m
[32m+[m[32m            addr = node.getnewaddress(address_type=random.choice(["legacy", "p2sh-segwit", "bech32"]))[m
[32m+[m[32m            info = node.getaddressinfo(addr)[m
[32m+[m[32m            spk = bytes.fromhex(info['scriptPubKey'])[m
[32m+[m[32m            host_spks.append(spk)[m
[32m+[m[32m            host_pubkeys.append(bytes.fromhex(info['pubkey']))[m
[32m+[m
[32m+[m[32m        # Initialize variables used by block_submit().[m
[32m+[m[32m        self.lastblockhash = node.getbestblockhash()[m
[32m+[m[32m        self.tip = int(self.lastblockhash, 16)[m
[32m+[m[32m        block = node.getblock(self.lastblockhash)[m
[32m+[m[32m        self.lastblockheight = block['height'][m
[32m+[m[32m        self.lastblocktime = block['time'][m
[32m+[m
[32m+[m[32m        # Create transactions spending up to 50 of the wallet's inputs, with one output for each spender, and[m
[32m+[m[32m        # one change output at the end. The transaction is constructed on the Python side to enable[m
[32m+[m[32m        # having multiple outputs to the same address and outputs with no assigned address. The wallet[m
[32m+[m[32m        # is then asked to sign it through signrawtransactionwithwallet, and then added to a block on the[m
[32m+[m[32m        # Python side (to bypass standardness rules).[m
[32m+[m[32m        self.log.info("- Creating test UTXOs...")[m
[32m+[m[32m        random.shuffle(spenders)[m
[32m+[m[32m        normal_utxos = [][m
[32m+[m[32m        mismatching_utxos = [] # UTXOs with input that requires mismatching output position[m
[32m+[m[32m        done = 0[m
[32m+[m[32m        while done < len(spenders):[m
[32m+[m[32m            # Compute how many UTXOs to create with this transaction[m
[32m+[m[32m            count_this_tx = min(len(spenders) - done, (len(spenders) + 4) // 5, 10000)[m
[32m+[m
[32m+[m[32m            fund_tx = CTransaction()[m
[32m+[m[32m            # Add the 50 highest-value inputs[m
[32m+[m[32m            unspents = node.listunspent()[m
[32m+[m[32m            random.shuffle(unspents)[m
[32m+[m[32m            unspents.sort(key=lambda x: int(x["amount"] * 100000000), reverse=True)[m
[32m+[m[32m            if len(unspents) > 50:[m
[32m+[m[32m                unspents = unspents[:50][m
[32m+[m[32m            random.shuffle(unspents)[m
[32m+[m[32m            balance = 0[m
[32m+[m[32m            for unspent in unspents:[m
[32m+[m[32m                balance += int(unspent["amount"] * 100000000)[m
[32m+[m[32m                txid = int(unspent["txid"], 16)[m
[32m+[m[32m                fund_tx.vin.append(CTxIn(COutPoint(txid, int(unspent["vout"])), CScript()))[m
[32m+[m[32m            # Add outputs[m
[32m+[m[32m            cur_progress = done / len(spenders)[m
[32m+[m[32m            next_progress = (done + count_this_tx) / len(spenders)[m
[32m+[m[32m            change_goal = (1.0 - 0.6 * next_progress) / (1.0 - 0.6 * cur_progress) * balance[m
[32m+[m[32m            self.log.debug("Create %i UTXOs in a transaction spending %i inputs worth %.8f (sending ~%.8f to change)" % (count_this_tx, len(unspents), balance * 0.00000001, change_goal * 0.00000001))[m
[32m+[m[32m            for i in range(count_this_tx):[m
[32m+[m[32m                avg = (balance - change_goal) / (count_this_tx - i)[m
[32m+[m[32m                amount = int(random.randrange(int(avg*0.85 + 0.5), int(avg*1.15 + 0.5)) + 0.5)[m
[32m+[m[32m                balance -= amount[m
[32m+[m[32m                fund_tx.vout.append(CTxOut(amount, spenders[done + i].script))[m
[32m+[m[32m            # Add change[m
[32m+[m[32m            fund_tx.vout.append(CTxOut(balance - 10000, random.choice(host_spks)))[m
[32m+[m[32m            # Ask the wallet to sign[m
[32m+[m[32m            ss = BytesIO(bytes.fromhex(node.signrawtransactionwithwallet(ToHex(fund_tx))["hex"]))[m
[32m+[m[32m            fund_tx.deserialize(ss)[m
[32m+[m[32m            # Construct UTXOData entries[m
[32m+[m[32m            fund_tx.rehash()[m
[32m+[m[32m            for i in range(count_this_tx):[m
[32m+[m[32m                utxodata = UTXOData(outpoint=COutPoint(fund_tx.sha256, i), output=fund_tx.vout[i], spender=spenders[done])[m
[32m+[m[32m                if utxodata.spender.need_vin_vout_mismatch:[m
[32m+[m[32m                    mismatching_utxos.append(utxodata)[m
[32m+[m[32m                else:[m
[32m+[m[32m                    normal_utxos.append(utxodata)[m
[32m+[m[32m                done += 1[m
[32m+[m[32m            # Mine into a block[m
[32m+[m[32m            self.block_submit(node, [fund_tx], "Funding tx", None, random.choice(host_pubkeys), 10000, MAX_BLOCK_SIGOPS_WEIGHT, True, True)[m
[32m+[m
[32m+[m[32m        # Consume groups of choice(input_coins) from utxos in a tx, testing the spenders.[m
[32m+[m[32m        self.log.info("- Running %i spending tests" % done)[m
[32m+[m[32m        random.shuffle(normal_utxos)[m
[32m+[m[32m        random.shuffle(mismatching_utxos)[m
[32m+[m[32m        assert done == len(normal_utxos) + len(mismatching_utxos)[m
[32m+[m
[32m+[m[32m        left = done[m
[32m+[m[32m        while left:[m
[32m+[m[32m            # Construct CTransaction with random nVersion, nLocktime[m
[32m+[m[32m            tx = CTransaction()[m
[32m+[m[32m            tx.nVersion = random.choice([1, 2, random.randint(-0x80000000, 0x7fffffff)])[m
[32m+[m[32m            min_sequence = (tx.nVersion != 1 and tx.nVersion != 0) * 0x80000000  # The minimum sequence number to disable relative locktime[m
[32m+[m[32m            if random.choice([True, False]):[m
[32m+[m[32m                tx.nLockTime = random.randrange(LOCKTIME_THRESHOLD, self.lastblocktime - 7200)  # all absolute locktimes in the past[m
[32m+[m[32m            else:[m
[32m+[m[32m                tx.nLockTime = random.randrange(self.lastblockheight + 1)  # all block heights in the past[m
[32m+[m
[32m+[m[32m            # Decide how many UTXOs to test with.[m
[32m+[m[32m            acceptable = [n for n in input_counts if n <= left and (left - n > max(input_counts) or (left - n) in [0] + input_counts)][m
[32m+[m[32m            num_inputs = random.choice(acceptable)[m
[32m+[m
[32m+[m[32m            # If we have UTXOs that require mismatching inputs/outputs left, include exactly one of those[m
[32m+[m[32m            # unless there is only one normal UTXO left (as tests with mismatching UTXOs require at least one[m
[32m+[m[32m            # normal UTXO to go in the first position), and we don't want to run out of normal UTXOs.[m
[32m+[m[32m            input_utxos = [][m
[32m+[m[32m            while len(mismatching_utxos) and (len(input_utxos) == 0 or len(normal_utxos) == 1):[m
[32m+[m[32m                input_utxos.append(mismatching_utxos.pop())[m
[32m+[m[32m                left -= 1[m
[32m+[m
[32m+[m[32m            # Top up until we hit num_inputs (but include at least one normal UTXO always).[m
[32m+[m[32m            for _ in range(max(1, num_inputs - len(input_utxos))):[m
[32m+[m[32m                input_utxos.append(normal_utxos.pop())[m
[32m+[m[32m                left -= 1[m
[32m+[m
[32m+[m[32m            # The first input cannot require a mismatching output (as there is at least one output).[m
[32m+[m[32m            while True:[m
[32m+[m[32m                random.shuffle(input_utxos)[m
[32m+[m[32m                if not input_utxos[0].spender.need_vin_vout_mismatch:[m
[32m+[m[32m                    break[m
[32m+[m[32m            first_mismatch_input = None[m
[32m+[m[32m            for i in range(len(input_utxos)):[m
[32m+[m[32m                if input_utxos[i].spender.need_vin_vout_mismatch:[m
[32m+[m[32m                    first_mismatch_input = i[m
[32m+[m[32m            assert first_mismatch_input is None or first_mismatch_input > 0[m
[32m+[m
[32m+[m[32m            # Decide fee, and add CTxIns to tx.[m
[32m+[m[32m            amount = sum(utxo.output.nValue for utxo in input_utxos)[m
[32m+[m[32m            fee = min(random.randrange(MIN_FEE * 2, MIN_FEE * 4), amount - DUST_LIMIT)  # 10000-20000 sat fee[m
[32m+[m[32m            in_value = amount - fee[m
[32m+[m[32m            tx.vin = [CTxIn(outpoint=utxo.outpoint, nSequence=random.randint(min_sequence, 0xffffffff)) for utxo in input_utxos][m
[32m+[m[32m            tx.wit.vtxinwit = [CTxInWitness() for _ in range(len(input_utxos))][m
[32m+[m[32m            sigops_weight = sum(utxo.spender.sigops_weight for utxo in input_utxos)[m
[32m+[m[32m            self.log.debug("Test: %s" % (", ".join(utxo.spender.comment for utxo in input_utxos)))[m
[32m+[m
[32m+[m[32m            # Add 1 to 4 random outputs (but constrained by inputs that require mismatching outputs)[m
[32m+[m[32m            num_outputs = random.choice(range(1, 1 + min(4, 4 if first_mismatch_input is None else first_mismatch_input)))[m
[32m+[m[32m            assert in_value >= 0 and fee - num_outputs * DUST_LIMIT >= MIN_FEE[m
[32m+[m[32m            for i in range(num_outputs):[m
[32m+[m[32m                tx.vout.append(CTxOut())[m
[32m+[m[32m                if in_value <= DUST_LIMIT:[m
[32m+[m[32m                    tx.vout[-1].nValue = DUST_LIMIT[m
[32m+[m[32m                elif i < num_outputs - 1:[m
[32m+[m[32m                    tx.vout[-1].nValue = in_value[m
[32m+[m[32m                else:[m
[32m+[m[32m                    tx.vout[-1].nValue = random.randint(DUST_LIMIT, in_value)[m
[32m+[m[32m                in_value -= tx.vout[-1].nValue[m
[32m+[m[32m                tx.vout[-1].scriptPubKey = random.choice(host_spks)[m
[32m+[m[32m                sigops_weight += CScript(tx.vout[-1].scriptPubKey).GetSigOpCount(False) * WITNESS_SCALE_FACTOR[m
[32m+[m[32m            fee += in_value[m
[32m+[m[32m            assert fee >= 0[m
[32m+[m
[32m+[m[32m            # Select coinbase pubkey[m
[32m+[m[32m            cb_pubkey = random.choice(host_pubkeys)[m
[32m+[m[32m            sigops_weight += 1 * WITNESS_SCALE_FACTOR[m
[32m+[m
[32m+[m[32m            # Precompute one satisfying and one failing scriptSig/witness for each input.[m
[32m+[m[32m            input_data = [][m
[32m+[m[32m            for i in range(len(input_utxos)):[m
[32m+[m[32m                fn = input_utxos[i].spender.sat_function[m
[32m+[m[32m                fail = None[m
[32m+[m[32m                success = fn(tx, i, [utxo.output for utxo in input_utxos], True)[m
[32m+[m[32m                if not input_utxos[i].spender.no_fail:[m
[32m+[m[32m                    fail = fn(tx, i, [utxo.output for utxo in input_utxos], False)[m
[32m+[m[32m                input_data.append((fail, success))[m
[32m+[m[32m                if self.options.dump_tests:[m
[32m+[m[32m                    dump_json_test(tx, input_utxos, i, success, fail)[m
[32m+[m
[32m+[m[32m            # Sign each input incorrectly once on each complete signing pass, except the very last.[m
[32m+[m[32m            for fail_input in list(range(len(input_utxos))) + [None]:[m
[32m+[m[32m                # Skip trying to fail at spending something that can't be made to fail.[m
[32m+[m[32m                if fail_input is not None and input_utxos[fail_input].spender.no_fail:[m
[32m+[m[32m                    continue[m
[32m+[m[32m                # Expected message with each input failure, may be None(which is ignored)[m
[32m+[m[32m                expected_fail_msg = None if fail_input is None else input_utxos[fail_input].spender.err_msg[m
[32m+[m[32m                # Fill inputs/witnesses[m
[32m+[m[32m                for i in range(len(input_utxos)):[m
[32m+[m[32m                    tx.vin[i].scriptSig = input_data[i][i != fail_input][0][m
[32m+[m[32m                    tx.wit.vtxinwit[i].scriptWitness.stack = input_data[i][i != fail_input][1][m
[32m+[m[32m                # Submit to mempool to check standardness[m
[32m+[m[32m                is_standard_tx = fail_input is None and all(utxo.spender.is_standard for utxo in input_utxos) and tx.nVersion >= 1 and tx.nVersion <= 2[m
[32m+[m[32m                tx.rehash()[m
[32m+[m[32m                msg = ','.join(utxo.spender.comment + ("*" if n == fail_input else "") for n, utxo in enumerate(input_utxos))[m
[32m+[m[32m                if is_standard_tx:[m
[32m+[m[32m                    node.sendrawtransaction(tx.serialize().hex(), 0)[m
[32m+[m[32m                    assert node.getmempoolentry(tx.hash) is not None, "Failed to accept into mempool: " + msg[m
[32m+[m[32m                else:[m
[32m+[m[32m                    assert_raises_rpc_error(-26, None, node.sendrawtransaction, tx.serialize().hex(), 0)[m
[32m+[m[32m                # Submit in a block[m
[32m+[m[32m                self.block_submit(node, [tx], msg, witness=True, accept=fail_input is None, cb_pubkey=cb_pubkey, fees=fee, sigops_weight=sigops_weight, err_msg=expected_fail_msg)[m
[32m+[m
[32m+[m[32m            if (len(spenders) - left) // 200 > (len(spenders) - left - len(input_utxos)) // 200:[m
[32m+[m[32m                self.log.info("  - %i tests done" % (len(spenders) - left))[m
[32m+[m
[32m+[m[32m        assert left == 0[m
[32m+[m[32m        assert len(normal_utxos) == 0[m
[32m+[m[32m        assert len(mismatching_utxos) == 0[m
[32m+[m[32m        self.log.info("  - Done")[m
[32m+[m
[32m+[m[32m    def run_test(self):[m
[32m+[m[32m        self.connect_nodes(0, 1)[m
[32m+[m
[32m+[m[32m        # Post-taproot activation tests go first (pre-taproot tests' blocks are invalid post-taproot).[m
[32m+[m[32m        self.log.info("Post-activation tests...")[m
[32m+[m[32m        self.nodes[1].generate(101)[m
[32m+[m[32m        self.test_spenders(self.nodes[1], spenders_taproot_active(), input_counts=[1, 2, 2, 2, 2, 3])[m
[32m+[m
[32m+[m[32m        # Transfer % of funds to pre-taproot node.[m
[32m+[m[32m        addr = self.nodes[0].getnewaddress()[m
[32m+[m[32m        self.nodes[1].sendtoaddress(address=addr, amount=int(self.nodes[1].getbalance() * 70000000) / 100000000)[m
[32m+[m[32m        self.nodes[1].generate(1)[m
[32m+[m[32m        self.sync_blocks()[m
[32m+[m
[32m+[m[32m        # Pre-taproot activation tests.[m
[32m+[m[32m        self.log.info("Pre-activation tests...")[m
[32m+[m[32m        self.test_spenders(self.nodes[0], spenders_taproot_inactive(), input_counts=[1, 2, 2, 2, 2, 3])[m
[32m+[m
[32m+[m
[32m+[m[32mif __name__ == '__main__':[m
[32m+[m[32m    TaprootTest().main()[m
[33mdiff --git a/test/functional/p2p_segwit.py b/test/functional/p2p_segwit.py[m
[33mindex d79ed449e5..29735b0fb3 100755[m
[33m--- a/test/functional/p2p_segwit.py[m
[33m+++ b/test/functional/p2p_segwit.py[m
[36m@@ -55,6 +55,7 @@[m [mfrom test_framework.script import ([m
     MAX_SCRIPT_ELEMENT_SIZE,[m
     OP_0,[m
     OP_1,[m
[32m+[m[32m    OP_2,[m
     OP_16,[m
     OP_2DROP,[m
     OP_CHECKMULTISIG,[m
[36m@@ -1400,7 +1401,11 @@[m [mclass SegWitTest(BitcoinTestFramework):[m
         assert_equal(len(self.nodes[1].getrawmempool()), 0)[m
         for version in list(range(OP_1, OP_16 + 1)) + [OP_0]:[m
             # First try to spend to a future version segwit script_pubkey.[m
[31m-            script_pubkey = CScript([CScriptOp(version), witness_hash])[m
[32m+[m[32m            if version == OP_1:[m
[32m+[m[32m                # Don't use 32-byte v1 witness (used by Taproot; see BIP 341)[m
[32m+[m[32m                script_pubkey = CScript([CScriptOp(version), witness_hash + b'\x00'])[m
[32m+[m[32m            else:[m
[32m+[m[32m                script_pubkey = CScript([CScriptOp(version), witness_hash])[m
             tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b"")][m
             tx.vout = [CTxOut(self.utxo[0].nValue - 1000, script_pubkey)][m
             tx.rehash()[m
[36m@@ -1413,9 +1418,9 @@[m [mclass SegWitTest(BitcoinTestFramework):[m
         self.sync_blocks()[m
         assert len(self.nodes[0].getrawmempool()) == 0[m
 [m
[31m-        # Finally, verify that version 0 -> version 1 transactions[m
[32m+[m[32m        # Finally, verify that version 0 -> version 2 transactions[m
         # are standard[m
[31m-        script_pubkey = CScript([CScriptOp(OP_1), witness_hash])[m
[32m+[m[32m        script_pubkey = CScript([CScriptOp(OP_2), witness_hash])[m
         tx2 = CTransaction()[m
         tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b"")][m
         tx2.vout = [CTxOut(tx.vout[0].nValue - 1000, script_pubkey)][m
[33mdiff --git a/test/functional/rpc_blockchain.py b/test/functional/rpc_blockchain.py[m
[33mindex 35cea85c07..f965677408 100755[m
[33m--- a/test/functional/rpc_blockchain.py[m
[33m+++ b/test/functional/rpc_blockchain.py[m
[36m@@ -146,7 +146,19 @@[m [mclass BlockchainTest(BitcoinTestFramework):[m
                         'possible': True,[m
                     },[m
                 },[m
[31m-                'active': False}[m
[32m+[m[32m                'active': False[m
[32m+[m[32m            },[m
[32m+[m[32m            'taproot': {[m
[32m+[m[32m                'type': 'bip9',[m
[32m+[m[32m                'bip9': {[m
[32m+[m[32m                    'status': 'active',[m
[32m+[m[32m                    'start_time': -1,[m
[32m+[m[32m                    'timeout': 9223372036854775807,[m
[32m+[m[32m                    'since': 0[m
[32m+[m[32m                },[m
[32m+[m[32m                'height': 0,[m
[32m+[m[32m                'active': True[m
[32m+[m[32m            }[m
         })[m
 [m
     def _test_getchaintxstats(self):[m
[33mdiff --git a/test/functional/test_framework/bip340_test_vectors.csv b/test/functional/test_framework/bip340_test_vectors.csv[m
[33mnew file mode 100644[m
[33mindex 0000000000..e068322deb[m
[33m--- /dev/null[m
[33m+++ b/test/functional/test_framework/bip340_test_vectors.csv[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32mindex,secret key,public key,aux_rand,message,signature,verification result,comment[m
[32m+[m[32m0,0000000000000000000000000000000000000000000000000000000000000003,F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9,0000000000000000000000000000000000000000000000000000000000000000,0000000000000000000000000000000000000000000000000000000000000000,E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0,TRUE,[m
[32m+[m[32m1,B7E151628AED2A6ABF7158809CF4F3C762E7160F38B4DA56A784D9045190CFEF,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,0000000000000000000000000000000000000000000000000000000000000001,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A,TRUE,[m
[32m+[m[32m2,C90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B14E5C9,DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8,C87AA53824B4D7AE2EB035A2B5BBBCCC080E76CDC6D1692C4B0B62D798E6D906,7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C,5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7,TRUE,[m
[32m+[m[32m3,0B432B2677937381AEF05BB02A66ECD012773062CF3FA2549E44F58ED2401710,25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3,TRUE,test fails if msg is reduced modulo p or n[m
[32m+[m[32m4,,D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9,,4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703,00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4,TRUE,[m
[32m+[m[32m5,,EEFDEA4CDB677750A420FEE807EACF21EB9898AE79B9768766E4FAA04A2D4A34,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,public key not on the curve[m
[32m+[m[32m6,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,FFF97BD5755EEEA420453A14355235D382F6472F8568A18B2F057A14602975563CC27944640AC607CD107AE10923D9EF7A73C643E166BE5EBEAFA34B1AC553E2,FALSE,has_even_y(R) is false[m
[32m+[m[32m7,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,1FA62E331EDBC21C394792D2AB1100A7B432B013DF3F6FF4F99FCB33E0E1515F28890B3EDB6E7189B630448B515CE4F8622A954CFE545735AAEA5134FCCDB2BD,FALSE,negated message[m
[32m+[m[32m8,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769961764B3AA9B2FFCB6EF947B6887A226E8D7C93E00C5ED0C1834FF0D0C2E6DA6,FALSE,negated s value[m
[32m+[m[32m9,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,0000000000000000000000000000000000000000000000000000000000000000123DDA8328AF9C23A94C1FEECFD123BA4FB73476F0D594DCB65C6425BD186051,FALSE,sG - eP is infinite. Test fails in single verification if has_even_y(inf) is defined as true and x(inf) as 0[m
[32m+[m[32m10,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,00000000000000000000000000000000000000000000000000000000000000017615FBAF5AE28864013C099742DEADB4DBA87F11AC6754F93780D5A1837CF197,FALSE,sG - eP is infinite. Test fails in single verification if has_even_y(inf) is defined as true and x(inf) as 1[m
[32m+[m[32m11,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,4A298DACAE57395A15D0795DDBFD1DCB564DA82B0F269BC70A74F8220429BA1D69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,sig[0:32] is not an X coordinate on the curve[m
[32m+[m[32m12,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F69E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,sig[0:32] is equal to field size[m
[32m+[m[32m13,,DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E177769FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141,FALSE,sig[32:64] is equal to curve order[m
[32m+[m[32m14,,FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30,,243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89,6CFF5C3BA86C69EA4B7376F31A9BCB4F74C1976089B2D9963DA2E5543E17776969E89B4C5564D00349106B8497785DD7D1D713A8AE82B32FA79D5F7FC407D39B,FALSE,public key is not a valid X coordinate because it exceeds the field size[m
[33mdiff --git a/test/functional/test_framework/blocktools.py b/test/functional/test_framework/blocktools.py[m
[33mindex afc1995009..4be8b7d80b 100644[m
[33m--- a/test/functional/test_framework/blocktools.py[m
[33m+++ b/test/functional/test_framework/blocktools.py[m
[36m@@ -43,7 +43,9 @@[m [mfrom .script import ([m
 from .util import assert_equal[m
 from io import BytesIO[m
 [m
[32m+[m[32mWITNESS_SCALE_FACTOR = 4[m
 MAX_BLOCK_SIGOPS = 20000[m
[32m+[m[32mMAX_BLOCK_SIGOPS_WEIGHT = MAX_BLOCK_SIGOPS * WITNESS_SCALE_FACTOR[m
 [m
 # Genesis block time (regtest)[m
 TIME_GENESIS_BLOCK = 1296688602[m
[36m@@ -101,22 +103,31 @@[m [mdef script_BIP34_coinbase_height(height):[m
     return CScript([CScriptNum(height)])[m
 [m
 [m
[31m-def create_coinbase(height, pubkey=None):[m
[31m-    """Create a coinbase transaction, assuming no miner fees.[m
[32m+[m[32mdef create_coinbase(height, pubkey=None, extra_output_script=None, fees=0):[m
[32m+[m[32m    """Create a coinbase transaction.[m
 [m
     If pubkey is passed in, the coinbase output will be a P2PK output;[m
[31m-    otherwise an anyone-can-spend output."""[m
[32m+[m[32m    otherwise an anyone-can-spend output.[m
[32m+[m
[32m+[m[32m    If extra_output_script is given, make a 0-value output to that[m
[32m+[m[32m    script. This is useful to pad block weight/sigops as needed. """[m
     coinbase = CTransaction()[m
     coinbase.vin.append(CTxIn(COutPoint(0, 0xffffffff), script_BIP34_coinbase_height(height), 0xffffffff))[m
     coinbaseoutput = CTxOut()[m
     coinbaseoutput.nValue = 50 * COIN[m
     halvings = int(height / 150)  # regtest[m
     coinbaseoutput.nValue >>= halvings[m
[31m-    if (pubkey is not None):[m
[32m+[m[32m    coinbaseoutput.nValue += fees[m
[32m+[m[32m    if pubkey is not None:[m
         coinbaseoutput.scriptPubKey = CScript([pubkey, OP_CHECKSIG])[m
     else:[m
         coinbaseoutput.scriptPubKey = CScript([OP_TRUE])[m
     coinbase.vout = [coinbaseoutput][m
[32m+[m[32m    if extra_output_script is not None:[m
[32m+[m[32m        coinbaseoutput2 = CTxOut()[m
[32m+[m[32m        coinbaseoutput2.nValue = 0[m
[32m+[m[32m        coinbaseoutput2.scriptPubKey = extra_output_script[m
[32m+[m[32m        coinbase.vout.append(coinbaseoutput2)[m
     coinbase.calc_sha256()[m
     return coinbase[m
 [m
[33mdiff --git a/test/functional/test_framework/key.py b/test/functional/test_framework/key.py[m
[33mindex adbffb7dc7..17b869e542 100644[m
[33m--- a/test/functional/test_framework/key.py[m
[33m+++ b/test/functional/test_framework/key.py[m
[36m@@ -1,4 +1,4 @@[m
[31m-# Copyright (c) 2019 Pieter Wuille[m
[32m+[m[32m# Copyright (c) 2019-2020 Pieter Wuille[m
 # Distributed under the MIT software license, see the accompanying[m
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
 """Test-only secp256k1 elliptic curve implementation[m
[36m@@ -6,10 +6,24 @@[m
 WARNING: This code is slow, uses bad randomness, does not properly protect[m
 keys, and is trivially vulnerable to side channel attacks. Do not use for[m
 anything but tests."""[m
[32m+[m[32mimport csv[m
[32m+[m[32mimport hashlib[m
[32m+[m[32mimport os[m
 import random[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport unittest[m
 [m
 from .util import modinv[m
 [m
[32m+[m[32mdef TaggedHash(tag, data):[m
[32m+[m[32m    ss = hashlib.sha256(tag.encode('utf-8')).digest()[m
[32m+[m[32m    ss += ss[m
[32m+[m[32m    ss += data[m
[32m+[m[32m    return hashlib.sha256(ss).digest()[m
[32m+[m
[32m+[m[32mdef xor_bytes(b0, b1):[m
[32m+[m[32m    return bytes(x ^ y for (x, y) in zip(b0, b1))[m
[32m+[m
 def jacobi_symbol(n, k):[m
     """Compute the Jacobi symbol of n modulo k[m
 [m
[36m@@ -68,6 +82,10 @@[m [mclass EllipticCurve:[m
         inv_3 = (inv_2 * inv) % self.p[m
         return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)[m
 [m
[32m+[m[32m    def has_even_y(self, p1):[m
[32m+[m[32m        """Whether the point p1 has an even Y coordinate when expressed in affine coordinates."""[m
[32m+[m[32m        return not (p1[2] == 0 or self.affine(p1)[1] & 1)[m
[32m+[m
     def negate(self, p1):[m
         """Negate a Jacobian point tuple p1."""[m
         x1, y1, z1 = p1[m
[36m@@ -86,13 +104,13 @@[m [mclass EllipticCurve:[m
         return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1[m
 [m
     def lift_x(self, x):[m
[31m-        """Given an X coordinate on the curve, return a corresponding affine point."""[m
[32m+[m[32m        """Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even."""[m
         x_3 = pow(x, 3, self.p)[m
         v = x_3 + self.a * x + self.b[m
         y = modsqrt(v, self.p)[m
         if y is None:[m
             return None[m
[31m-        return (x, y, 1)[m
[32m+[m[32m        return (x, self.p - y if y & 1 else y, 1)[m
 [m
     def double(self, p1):[m
         """Double a Jacobian tuple p1[m
[36m@@ -197,7 +215,8 @@[m [mclass EllipticCurve:[m
                     r = self.add(r, p)[m
         return r[m
 [m
[31m-SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)[m
[32m+[m[32mSECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977[m
[32m+[m[32mSECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)[m
 SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)[m
 SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141[m
 SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2[m
[36m@@ -223,7 +242,7 @@[m [mclass ECPubKey():[m
                 p = SECP256K1.lift_x(x)[m
                 # if the oddness of the y co-ord isn't correct, find the other[m
                 # valid y[m
[31m-                if (p[1] & 1) != (data[0] & 1):[m
[32m+[m[32m                if data[0] & 1:[m
                     p = SECP256K1.negate(p)[m
                 self.p = p[m
                 self.valid = True[m
[36m@@ -307,6 +326,10 @@[m [mclass ECPubKey():[m
             return False[m
         return True[m
 [m
[32m+[m[32mdef generate_privkey():[m
[32m+[m[32m    """Generate a valid random 32-byte private key."""[m
[32m+[m[32m    return random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big')[m
[32m+[m
 class ECKey():[m
     """A secp256k1 private key"""[m
 [m
[36m@@ -324,7 +347,7 @@[m [mclass ECKey():[m
 [m
     def generate(self, compressed=True):[m
         """Generate a random private key (compressed or uncompressed)."""[m
[31m-        self.set(random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big'), compressed)[m
[32m+[m[32m        self.set(generate_privkey(), compressed)[m
 [m
     def get_bytes(self):[m
         """Retrieve the 32-byte representation of this key."""[m
[36m@@ -369,3 +392,161 @@[m [mclass ECKey():[m
         rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')[m
         sb = s.to_bytes((s.bit_length() + 8) // 8, 'big')[m
         return b'\x30' + bytes([4 + len(rb) + len(sb), 2, len(rb)]) + rb + bytes([2, len(sb)]) + sb[m
[32m+[m
[32m+[m[32mdef compute_xonly_pubkey(key):[m
[32m+[m[32m    """Compute an x-only (32 byte) public key from a (32 byte) private key.[m
[32m+[m
[32m+[m[32m    This also returns whether the resulting public key was negated.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    assert len(key) == 32[m
[32m+[m[32m    x = int.from_bytes(key, 'big')[m
[32m+[m[32m    if x == 0 or x >= SECP256K1_ORDER:[m
[32m+[m[32m        return (None, None)[m
[32m+[m[32m    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, x)]))[m
[32m+[m[32m    return (P[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(P))[m
[32m+[m
[32m+[m[32mdef tweak_add_privkey(key, tweak):[m
[32m+[m[32m    """Tweak a private key (after negating it if needed)."""[m
[32m+[m
[32m+[m[32m    assert len(key) == 32[m
[32m+[m[32m    assert len(tweak) == 32[m
[32m+[m
[32m+[m[32m    x = int.from_bytes(key, 'big')[m
[32m+[m[32m    if x == 0 or x >= SECP256K1_ORDER:[m
[32m+[m[32m        return None[m
[32m+[m[32m    if not SECP256K1.has_even_y(SECP256K1.mul([(SECP256K1_G, x)])):[m
[32m+[m[32m       x = SECP256K1_ORDER - x[m
[32m+[m[32m    t = int.from_bytes(tweak, 'big')[m
[32m+[m[32m    if t >= SECP256K1_ORDER:[m
[32m+[m[32m        return None[m
[32m+[m[32m    x = (x + t) % SECP256K1_ORDER[m
[32m+[m[32m    if x == 0:[m
[32m+[m[32m        return None[m
[32m+[m[32m    return x.to_bytes(32, 'big')[m
[32m+[m
[32m+[m[32mdef tweak_add_pubkey(key, tweak):[m
[32m+[m[32m    """Tweak a public key and return whether the result had to be negated."""[m
[32m+[m
[32m+[m[32m    assert len(key) == 32[m
[32m+[m[32m    assert len(tweak) == 32[m
[32m+[m
[32m+[m[32m    x_coord = int.from_bytes(key, 'big')[m
[32m+[m[32m    if x_coord >= SECP256K1_FIELD_SIZE:[m
[32m+[m[32m        return None[m
[32m+[m[32m    P = SECP256K1.lift_x(x_coord)[m
[32m+[m[32m    if P is None:[m
[32m+[m[32m        return None[m
[32m+[m[32m    t = int.from_bytes(tweak, 'big')[m
[32m+[m[32m    if t >= SECP256K1_ORDER:[m
[32m+[m[32m        return None[m
[32m+[m[32m    Q = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, t), (P, 1)]))[m
[32m+[m[32m    if Q is None:[m
[32m+[m[32m        return None[m
[32m+[m[32m    return (Q[0].to_bytes(32, 'big'), not SECP256K1.has_even_y(Q))[m
[32m+[m
[32m+[m[32mdef verify_schnorr(key, sig, msg):[m
[32m+[m[32m    """Verify a Schnorr signature (see BIP 340).[m
[32m+[m
[32m+[m[32m    - key is a 32-byte xonly pubkey (computed using compute_xonly_pubkey).[m
[32m+[m[32m    - sig is a 64-byte Schnorr signature[m
[32m+[m[32m    - msg is a 32-byte message[m
[32m+[m[32m    """[m
[32m+[m[32m    assert len(key) == 32[m
[32m+[m[32m    assert len(msg) == 32[m
[32m+[m[32m    assert len(sig) == 64[m
[32m+[m
[32m+[m[32m    x_coord = int.from_bytes(key, 'big')[m
[32m+[m[32m    if x_coord == 0 or x_coord >= SECP256K1_FIELD_SIZE:[m
[32m+[m[32m        return False[m
[32m+[m[32m    P = SECP256K1.lift_x(x_coord)[m
[32m+[m[32m    if P is None:[m
[32m+[m[32m        return False[m
[32m+[m[32m    r = int.from_bytes(sig[0:32], 'big')[m
[32m+[m[32m    if r >= SECP256K1_FIELD_SIZE:[m
[32m+[m[32m        return False[m
[32m+[m[32m    s = int.from_bytes(sig[32:64], 'big')[m
[32m+[m[32m    if s >= SECP256K1_ORDER:[m
[32m+[m[32m        return False[m
[32m+[m[32m    e = int.from_bytes(TaggedHash("BIP0340/challenge", sig[0:32] + key + msg), 'big') % SECP256K1_ORDER[m
[32m+[m[32m    R = SECP256K1.mul([(SECP256K1_G, s), (P, SECP256K1_ORDER - e)])[m
[32m+[m[32m    if not SECP256K1.has_even_y(R):[m
[32m+[m[32m        return False[m
[32m+[m[32m    if ((r * R[2] * R[2]) % SECP256K1_FIELD_SIZE) != R[0]:[m
[32m+[m[32m        return False[m
[32m+[m[32m    return True[m
[32m+[m
[32m+[m[32mdef sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):[m
[32m+[m[32m    """Create a Schnorr signature (see BIP 340)."""[m
[32m+[m
[32m+[m[32m    if aux is None:[m
[32m+[m[32m        aux = bytes(32)[m
[32m+[m
[32m+[m[32m    assert len(key) == 32[m
[32m+[m[32m    assert len(msg) == 32[m
[32m+[m[32m    assert len(aux) == 32[m
[32m+[m
[32m+[m[32m    sec = int.from_bytes(key, 'big')[m
[32m+[m[32m    if sec == 0 or sec >= SECP256K1_ORDER:[m
[32m+[m[32m        return None[m
[32m+[m[32m    P = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, sec)]))[m
[32m+[m[32m    if SECP256K1.has_even_y(P) == flip_p:[m
[32m+[m[32m        sec = SECP256K1_ORDER - sec[m
[32m+[m[32m    t = (sec ^ int.from_bytes(TaggedHash("BIP0340/aux", aux), 'big')).to_bytes(32, 'big')[m
[32m+[m[32m    kp = int.from_bytes(TaggedHash("BIP0340/nonce", t + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER[m
[32m+[m[32m    assert kp != 0[m
[32m+[m[32m    R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, kp)]))[m
[32m+[m[32m    k = kp if SECP256K1.has_even_y(R) != flip_r else SECP256K1_ORDER - kp[m
[32m+[m[32m    e = int.from_bytes(TaggedHash("BIP0340/challenge", R[0].to_bytes(32, 'big') + P[0].to_bytes(32, 'big') + msg), 'big') % SECP256K1_ORDER[m
[32m+[m[32m    return R[0].to_bytes(32, 'big') + ((k + e * sec) % SECP256K1_ORDER).to_bytes(32, 'big')[m
[32m+[m
[32m+[m[32mclass TestFrameworkKey(unittest.TestCase):[m
[32m+[m[32m    def test_schnorr(self):[m
[32m+[m[32m        """Test the Python Schnorr implementation."""[m
[32m+[m[32m        byte_arrays = [generate_privkey() for _ in range(3)] + [v.to_bytes(32, 'big') for v in [0, SECP256K1_ORDER - 1, SECP256K1_ORDER, 2**256 - 1]][m
[32m+[m[32m        keys = {}[m
[32m+[m[32m        for privkey in byte_arrays:  # build array of key/pubkey pairs[m
[32m+[m[32m            pubkey, _ = compute_xonly_pubkey(privkey)[m
[32m+[m[32m            if pubkey is not None:[m
[32m+[m[32m                keys[privkey] = pubkey[m
[32m+[m[32m        for msg in byte_arrays:  # test every combination of message, signing key, verification key[m
[32m+[m[32m            for sign_privkey, sign_pubkey in keys.items():[m
[32m+[m[32m                sig = sign_schnorr(sign_privkey, msg)[m
[32m+[m[32m                for verify_privkey, verify_pubkey in keys.items():[m
[32m+[m[32m                    if verify_privkey == sign_privkey:[m
[32m+[m[32m                        self.assertTrue(verify_schnorr(verify_pubkey, sig, msg))[m
[32m+[m[32m                        sig = list(sig)[m
[32m+[m[32m                        sig[random.randrange(64)] ^= (1 << (random.randrange(8)))  # damaging signature should break things[m
[32m+[m[32m                        sig = bytes(sig)[m
[32m+[m[32m                    self.assertFalse(verify_schnorr(verify_pubkey, sig, msg))[m
[32m+[m
[32m+[m[32m    def test_schnorr_testvectors(self):[m
[32m+[m[32m        """Implement the BIP340 test vectors (read from bip340_test_vectors.csv)."""[m
[32m+[m[32m        num_tests = 0[m
[32m+[m[32m        with open(os.path.join(sys.path[0], 'test_framework', 'bip340_test_vectors.csv'), newline='', encoding='utf8') as csvfile:[m
[32m+[m[32m            reader = csv.reader(csvfile)[m
[32m+[m[32m            next(reader)[m
[32m+[m[32m            for row in reader:[m
[32m+[m[32m                (i_str, seckey_hex, pubkey_hex, aux_rand_hex, msg_hex, sig_hex, result_str, comment) = row[m
[32m+[m[32m                i = int(i_str)[m
[32m+[m[32m                pubkey = bytes.fromhex(pubkey_hex)[m
[32m+[m[32m                msg = bytes.fromhex(msg_hex)[m
[32m+[m[32m                sig = bytes.fromhex(sig_hex)[m
[32m+[m[32m                result = result_str == 'TRUE'[m
[32m+[m[32m                if seckey_hex != '':[m
[32m+[m[32m                    seckey = bytes.fromhex(seckey_hex)[m
[32m+[m[32m                    pubkey_actual = compute_xonly_pubkey(seckey)[0][m
[32m+[m[32m                    self.assertEqual(pubkey.hex(), pubkey_actual.hex(), "BIP340 test vector %i (%s): pubkey mismatch" % (i, comment))[m
[32m+[m[32m                    aux_rand = bytes.fromhex(aux_rand_hex)[m
[32m+[m[32m                    try:[m
[32m+[m[32m                        sig_actual = sign_schnorr(seckey, msg, aux_rand)[m
[32m+[m[32m                        self.assertEqual(sig.hex(), sig_actual.hex(), "BIP340 test vector %i (%s): sig mismatch" % (i, comment))[m
[32m+[m[32m                    except RuntimeError as e:[m
[32m+[m[32m                        self.assertFalse("BIP340 test vector %i (%s): signing raised exception %s" % (i, comment, e))[m
[32m+[m[32m                result_actual = verify_schnorr(pubkey, sig, msg)[m
[32m+[m[32m                if result:[m
[32m+[m[32m                    self.assertEqual(result, result_actual, "BIP340 test vector %i (%s): verification failed" % (i, comment))[m
[32m+[m[32m                else:[m
[32m+[m[32m                    self.assertEqual(result, result_actual, "BIP340 test vector %i (%s): verification succeeded unexpectedly" % (i, comment))[m
[32m+[m[32m                num_tests += 1[m
[32m+[m[32m        self.assertTrue(num_tests >= 15) # expect at least 15 test vectors[m
[33mdiff --git a/test/functional/test_framework/script.py b/test/functional/test_framework/script.py[m
[33mindex 5e35ba0fce..8e5848d493 100644[m
[33m--- a/test/functional/test_framework/script.py[m
[33m+++ b/test/functional/test_framework/script.py[m
[36m@@ -6,11 +6,15 @@[m
 [m
 This file is modified from python-bitcoinlib.[m
 """[m
[32m+[m
[32m+[m[32mfrom collections import namedtuple[m
 import hashlib[m
 import struct[m
 import unittest[m
 from typing import List, Dict[m
 [m
[32m+[m[32mfrom .key import TaggedHash, tweak_add_pubkey[m
[32m+[m
 from .messages import ([m
     CTransaction,[m
     CTxOut,[m
[36m@@ -22,8 +26,13 @@[m [mfrom .messages import ([m
 )[m
 [m
 MAX_SCRIPT_ELEMENT_SIZE = 520[m
[32m+[m[32mLOCKTIME_THRESHOLD = 500000000[m
[32m+[m[32mANNEX_TAG = 0x50[m
[32m+[m
 OPCODE_NAMES = {}  # type: Dict[CScriptOp, str][m
 [m
[32m+[m[32mLEAF_VERSION_TAPSCRIPT = 0xc0[m
[32m+[m
 def hash160(s):[m
     return hashlib.new('ripemd160', sha256(s)).digest()[m
 [m
[36m@@ -239,11 +248,8 @@[m [mOP_NOP8 = CScriptOp(0xb7)[m
 OP_NOP9 = CScriptOp(0xb8)[m
 OP_NOP10 = CScriptOp(0xb9)[m
 [m
[31m-# template matching params[m
[31m-OP_SMALLINTEGER = CScriptOp(0xfa)[m
[31m-OP_PUBKEYS = CScriptOp(0xfb)[m
[31m-OP_PUBKEYHASH = CScriptOp(0xfd)[m
[31m-OP_PUBKEY = CScriptOp(0xfe)[m
[32m+[m[32m# BIP 342 opcodes (Tapscript)[m
[32m+[m[32mOP_CHECKSIGADD = CScriptOp(0xba)[m
 [m
 OP_INVALIDOPCODE = CScriptOp(0xff)[m
 [m
[36m@@ -359,10 +365,7 @@[m [mOPCODE_NAMES.update({[m
     OP_NOP8: 'OP_NOP8',[m
     OP_NOP9: 'OP_NOP9',[m
     OP_NOP10: 'OP_NOP10',[m
[31m-    OP_SMALLINTEGER: 'OP_SMALLINTEGER',[m
[31m-    OP_PUBKEYS: 'OP_PUBKEYS',[m
[31m-    OP_PUBKEYHASH: 'OP_PUBKEYHASH',[m
[31m-    OP_PUBKEY: 'OP_PUBKEY',[m
[32m+[m[32m    OP_CHECKSIGADD: 'OP_CHECKSIGADD',[m
     OP_INVALIDOPCODE: 'OP_INVALIDOPCODE',[m
 })[m
 [m
[36m@@ -593,6 +596,7 @@[m [mclass CScript(bytes):[m
         return n[m
 [m
 [m
[32m+[m[32mSIGHASH_DEFAULT = 0 # Taproot-only default, semantics same as SIGHASH_ALL[m
 SIGHASH_ALL = 1[m
 SIGHASH_NONE = 2[m
 SIGHASH_SINGLE = 3[m
[36m@@ -615,7 +619,6 @@[m [mdef FindAndDelete(script, sig):[m
         r += script[last_sop_idx:][m
     return CScript(r)[m
 [m
[31m-[m
 def LegacySignatureHash(script, txTo, inIdx, hashtype):[m
     """Consensus-correct SignatureHash[m
 [m
[36m@@ -738,3 +741,113 @@[m [mclass TestFrameworkScript(unittest.TestCase):[m
         values = [0, 1, -1, -2, 127, 128, -255, 256, (1 << 15) - 1, -(1 << 16), (1 << 24) - 1, (1 << 31), 1 - (1 << 32), 1 << 40, 1500, -1500][m
         for value in values:[m
             self.assertEqual(CScriptNum.decode(CScriptNum.encode(CScriptNum(value))), value)[m
[32m+[m
[32m+[m[32mdef TaprootSignatureHash(txTo, spent_utxos, hash_type, input_index = 0, scriptpath = False, script = CScript(), codeseparator_pos = -1, annex = None, leaf_ver = LEAF_VERSION_TAPSCRIPT):[m
[32m+[m[32m    assert (len(txTo.vin) == len(spent_utxos))[m
[32m+[m[32m    assert (input_index < len(txTo.vin))[m
[32m+[m[32m    out_type = SIGHASH_ALL if hash_type == 0 else hash_type & 3[m
[32m+[m[32m    in_type = hash_type & SIGHASH_ANYONECANPAY[m
[32m+[m[32m    spk = spent_utxos[input_index].scriptPubKey[m
[32m+[m[32m    ss = bytes([0, hash_type]) # epoch, hash_type[m
[32m+[m[32m    ss += struct.pack("<i", txTo.nVersion)[m
[32m+[m[32m    ss += struct.pack("<I", txTo.nLockTime)[m
[32m+[m[32m    if in_type != SIGHASH_ANYONECANPAY:[m
[32m+[m[32m        ss += sha256(b"".join(i.prevout.serialize() for i in txTo.vin))[m
[32m+[m[32m        ss += sha256(b"".join(struct.pack("<q", u.nValue) for u in spent_utxos))[m
[32m+[m[32m        ss += sha256(b"".join(ser_string(u.scriptPubKey) for u in spent_utxos))[m
[32m+[m[32m        ss += sha256(b"".join(struct.pack("<I", i.nSequence) for i in txTo.vin))[m
[32m+[m[32m    if out_type == SIGHASH_ALL:[m
[32m+[m[32m        ss += sha256(b"".join(o.serialize() for o in txTo.vout))[m
[32m+[m[32m    spend_type = 0[m
[32m+[m[32m    if annex is not None:[m
[32m+[m[32m        spend_type |= 1[m
[32m+[m[32m    if (scriptpath):[m
[32m+[m[32m        spend_type |= 2[m
[32m+[m[32m    ss += bytes([spend_type])[m
[32m+[m[32m    if in_type == SIGHASH_ANYONECANPAY:[m
[32m+[m[32m        ss += txTo.vin[input_index].prevout.serialize()[m
[32m+[m[32m        ss += struct.pack("<q", spent_utxos[input_index].nValue)[m
[32m+[m[32m        ss += ser_string(spk)[m
[32m+[m[32m        ss += struct.pack("<I", txTo.vin[input_index].nSequence)[m
[32m+[m[32m    else:[m
[32m+[m[32m        ss += struct.pack("<I", input_index)[m
[32m+[m[32m    if (spend_type & 1):[m
[32m+[m[32m        ss += sha256(ser_string(annex))[m
[32m+[m[32m    if out_type == SIGHASH_SINGLE:[m
[32m+[m[32m        if input_index < len(txTo.vout):[m
[32m+[m[32m            ss += sha256(txTo.vout[input_index].serialize())[m
[32m+[m[32m        else:[m
[32m+[m[32m            ss += bytes(0 for _ in range(32))[m
[32m+[m[32m    if (scriptpath):[m
[32m+[m[32m        ss += TaggedHash("TapLeaf", bytes([leaf_ver]) + ser_string(script))[m
[32m+[m[32m        ss += bytes([0])[m
[32m+[m[32m        ss += struct.pack("<i", codeseparator_pos)[m
[32m+[m[32m    assert len(ss) ==  175 - (in_type == SIGHASH_ANYONECANPAY) * 49 - (out_type != SIGHASH_ALL and out_type != SIGHASH_SINGLE) * 32 + (annex is not None) * 32 + scriptpath * 37[m
[32m+[m[32m    return TaggedHash("TapSighash", ss)[m
[32m+[m
[32m+[m[32mdef taproot_tree_helper(scripts):[m
[32m+[m[32m    if len(scripts) == 0:[m
[32m+[m[32m        return ([], bytes(0 for _ in range(32)))[m
[32m+[m[32m    if len(scripts) == 1:[m
[32m+[m[32m        # One entry: treat as a leaf[m
[32m+[m[32m        script = scripts[0][m
[32m+[m[32m        assert(not callable(script))[m
[32m+[m[32m        if isinstance(script, list):[m
[32m+[m[32m            return taproot_tree_helper(script)[m
[32m+[m[32m        assert(isinstance(script, tuple))[m
[32m+[m[32m        version = LEAF_VERSION_TAPSCRIPT[m
[32m+[m[32m        name = script[0][m
[32m+[m[32m        code = script[1][m
[32m+[m[32m        if len(script) == 3:[m
[32m+[m[32m            version = script[2][m
[32m+[m[32m        assert version & 1 == 0[m
[32m+[m[32m        assert isinstance(code, bytes)[m
[32m+[m[32m        h = TaggedHash("TapLeaf", bytes([version]) + ser_string(code))[m
[32m+[m[32m        if name is None:[m
[32m+[m[32m            return ([], h)[m
[32m+[m[32m        return ([(name, version, code, bytes())], h)[m
[32m+[m[32m    elif len(scripts) == 2 and callable(scripts[1]):[m
[32m+[m[32m        # Two entries, and the right one is a function[m
[32m+[m[32m        left, left_h = taproot_tree_helper(scripts[0:1])[m
[32m+[m[32m        right_h = scripts[1](left_h)[m
[32m+[m[32m        left = [(name, version, script, control + right_h) for name, version, script, control in left][m
[32m+[m[32m        right = [][m
[32m+[m[32m    else:[m
[32m+[m[32m        # Two or more entries: descend into each side[m
[32m+[m[32m        split_pos = len(scripts) // 2[m
[32m+[m[32m        left, left_h = taproot_tree_helper(scripts[0:split_pos])[m
[32m+[m[32m        right, right_h = taproot_tree_helper(scripts[split_pos:])[m
[32m+[m[32m        left = [(name, version, script, control + right_h) for name, version, script, control in left][m
[32m+[m[32m        right = [(name, version, script, control + left_h) for name, version, script, control in right][m
[32m+[m[32m    if right_h < left_h:[m
[32m+[m[32m        right_h, left_h = left_h, right_h[m
[32m+[m[32m    h = TaggedHash("TapBranch", left_h + right_h)[m
[32m+[m[32m    return (left + right, h)[m
[32m+[m
[32m+[m[32mTaprootInfo = namedtuple("TaprootInfo", "scriptPubKey,inner_pubkey,negflag,tweak,leaves")[m
[32m+[m[32mTaprootLeafInfo = namedtuple("TaprootLeafInfo", "script,version,merklebranch")[m
[32m+[m
[32m+[m[32mdef taproot_construct(pubkey, scripts=None):[m
[32m+[m[32m    """Construct a tree of Taproot spending conditions[m
[32m+[m
[32m+[m[32m    pubkey: an ECPubKey object for the internal pubkey[m
[32m+[m[32m    scripts: a list of items; each item is either:[m
[32m+[m[32m             - a (name, CScript) tuple[m
[32m+[m[32m             - a (name, CScript, leaf version) tuple[m
[32m+[m[32m             - another list of items (with the same structure)[m
[32m+[m[32m             - a function, which specifies how to compute the hashing partner[m
[32m+[m[32m               in function of the hash of whatever it is combined with[m
[32m+[m
[32m+[m[32m    Returns: script (sPK or redeemScript), tweak, {name:(script, leaf version, negation flag, innerkey, merklepath), ...}[m
[32m+[m[32m    """[m
[32m+[m[32m    if scripts is None:[m
[32m+[m[32m        scripts = [][m
[32m+[m
[32m+[m[32m    ret, h = taproot_tree_helper(scripts)[m
[32m+[m[32m    tweak = TaggedHash("TapTweak", pubkey + h)[m
[32m+[m[32m    tweaked, negated = tweak_add_pubkey(pubkey, tweak)[m
[32m+[m[32m    leaves = dict((name, TaprootLeafInfo(script, version, merklebranch)) for name, version, script, merklebranch in ret)[m
[32m+[m[32m    return TaprootInfo(CScript([OP_1, tweaked]), pubkey, negated + 0, tweak, leaves)[m
[32m+[m
[32m+[m[32mdef is_op_success(o):[m
[32m+[m[32m    return o == 0x50 or o == 0x62 or o == 0x89 or o == 0x8a or o == 0x8d or o == 0x8e or (o >= 0x7e and o <= 0x81) or (o >= 0x83 and o <= 0x86) or (o >= 0x95 and o <= 0x99) or (o >= 0xbb and o <= 0xfe)[m
[33mdiff --git a/test/functional/test_runner.py b/test/functional/test_runner.py[m
[33mindex cb86305cc6..ed6e830bb9 100755[m
[33m--- a/test/functional/test_runner.py[m
[33m+++ b/test/functional/test_runner.py[m
[36m@@ -70,6 +70,7 @@[m [mTEST_FRAMEWORK_MODULES = [[m
     "address",[m
     "blocktools",[m
     "muhash",[m
[32m+[m[32m    "key",[m
     "script",[m
     "segwit_addr",[m
     "util",[m
[36m@@ -106,6 +107,7 @@[m [mBASE_SCRIPTS = [[m
     'mempool_updatefromblock.py',[m
     'wallet_dump.py',[m
     'wallet_listtransactions.py',[m
[32m+[m[32m    'feature_taproot.py',[m
     # vv Tests less than 60s vv[m
     'p2p_sendheaders.py',[m
     'wallet_importmulti.py',[m