[33mdiff --git a/ci/test/06_script_b.sh b/ci/test/06_script_b.sh[m
[33mindex bdb68e0f6f..8c4fa6adf6 100755[m
[33m--- a/ci/test/06_script_b.sh[m
[33m+++ b/ci/test/06_script_b.sh[m
[36m@@ -41,6 +41,7 @@[m [mif [ "${RUN_TIDY}" = "true" ]; then[m
   CI_EXEC "python3 ${DIR_IWYU}/include-what-you-use/iwyu_tool.py"\[m
           " src/compat"\[m
           " src/init"\[m
[32m+[m[32m          " src/kernel"\[m
           " src/policy/feerate.cpp"\[m
           " src/policy/packages.cpp"\[m
           " src/policy/settings.cpp"\[m
[33mdiff --git a/src/bitcoin-chainstate.cpp b/src/bitcoin-chainstate.cpp[m
[33mindex 1817aa1a53..ba469d7248 100644[m
[33m--- a/src/bitcoin-chainstate.cpp[m
[33m+++ b/src/bitcoin-chainstate.cpp[m
[36m@@ -18,6 +18,7 @@[m
 #include <consensus/validation.h>[m
 #include <core_io.h>[m
 #include <node/blockstorage.h>[m
[32m+[m[32m#include <node/caches.h>[m
 #include <node/chainstate.h>[m
 #include <scheduler.h>[m
 #include <script/sigcache.h>[m
[36m@@ -83,27 +84,19 @@[m [mint main(int argc, char* argv[])[m
     };[m
     ChainstateManager chainman{chainman_opts};[m
 [m
[31m-    auto rv = node::LoadChainstate(false,[m
[31m-                                   std::ref(chainman),[m
[31m-                                   nullptr,[m
[31m-                                   false,[m
[31m-                                   false,[m
[31m-                                   2 << 20,[m
[31m-                                   2 << 22,[m
[31m-                                   (450 << 20) - (2 << 20) - (2 << 22),[m
[31m-                                   false,[m
[31m-                                   false,[m
[31m-                                   []() { return false; });[m
[31m-    if (rv.has_value()) {[m
[32m+[m[32m    node::CacheSizes cache_sizes;[m
[32m+[m[32m    cache_sizes.block_tree_db = 2 << 20;[m
[32m+[m[32m    cache_sizes.coins_db = 2 << 22;[m
[32m+[m[32m    cache_sizes.coins = (450 << 20) - (2 << 20) - (2 << 22);[m
[32m+[m[32m    node::ChainstateLoadOptions options;[m
[32m+[m[32m    options.check_interrupt = [] { return false; };[m
[32m+[m[32m    auto [status, error] = node::LoadChainstate(chainman, cache_sizes, options);[m
[32m+[m[32m    if (status != node::ChainstateLoadStatus::SUCCESS) {[m
         std::cerr << "Failed to load Chain state from your datadir." << std::endl;[m
         goto epilogue;[m
     } else {[m
[31m-        auto maybe_verify_error = node::VerifyLoadedChainstate(std::ref(chainman),[m
[31m-                                                               false,[m
[31m-                                                               false,[m
[31m-                                                               DEFAULT_CHECKBLOCKS,[m
[31m-                                                               DEFAULT_CHECKLEVEL);[m
[31m-        if (maybe_verify_error.has_value()) {[m
[32m+[m[32m        std::tie(status, error) = node::VerifyLoadedChainstate(chainman, options);[m
[32m+[m[32m        if (status != node::ChainstateLoadStatus::SUCCESS) {[m
             std::cerr << "Failed to verify loaded Chain state from your datadir." << std::endl;[m
             goto epilogue;[m
         }[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex d844e9b169..30dcb63f7f 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -105,8 +105,6 @@[m
 [m
 using node::CacheSizes;[m
 using node::CalculateCacheSizes;[m
[31m-using node::ChainstateLoadVerifyError;[m
[31m-using node::ChainstateLoadingError;[m
 using node::CleanupBlockRevFiles;[m
 using node::DEFAULT_PRINTPRIORITY;[m
 using node::DEFAULT_STOPAFTERBLOCKIMPORT;[m
[36m@@ -1092,21 +1090,8 @@[m [mstatic bool LockDataDirectory(bool probeOnly)[m
 bool AppInitSanityChecks(const kernel::Context& kernel)[m
 {[m
     // ********************************************************* Step 4: sanity checks[m
[31m-    auto maybe_error = kernel::SanityChecks(kernel);[m
[31m-[m
[31m-    if (maybe_error.has_value()) {[m
[31m-        switch (maybe_error.value()) {[m
[31m-        case kernel::SanityCheckError::ERROR_ECC:[m
[31m-            InitError(Untranslated("Elliptic curve cryptography sanity check failure. Aborting."));[m
[31m-            break;[m
[31m-        case kernel::SanityCheckError::ERROR_RANDOM:[m
[31m-            InitError(Untranslated("OS cryptographic RNG sanity check failure. Aborting."));[m
[31m-            break;[m
[31m-        case kernel::SanityCheckError::ERROR_CHRONO:[m
[31m-            InitError(Untranslated("Clock epoch mismatch. Aborting."));[m
[31m-            break;[m
[31m-        } // no default case, so the compiler can warn about missing cases[m
[31m-[m
[32m+[m[32m    if (auto error = kernel::SanityChecks(kernel)) {[m
[32m+[m[32m        InitError(*error);[m
         return InitError(strprintf(_("Initialization sanity check failed. %s is shutting down."), PACKAGE_NAME));[m
     }[m
 [m
[36m@@ -1446,112 +1431,54 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
         node.chainman = std::make_unique<ChainstateManager>(chainman_opts);[m
         ChainstateManager& chainman = *node.chainman;[m
 [m
[31m-        const bool fReset = fReindex;[m
[31m-        bilingual_str strLoadError;[m
[32m+[m[32m        node::ChainstateLoadOptions options;[m
[32m+[m[32m        options.mempool = Assert(node.mempool.get());[m
[32m+[m[32m        options.reindex = node::fReindex;[m
[32m+[m[32m        options.reindex_chainstate = fReindexChainState;[m
[32m+[m[32m        options.prune = node::fPruneMode;[m
[32m+[m[32m        options.check_blocks = args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS);[m
[32m+[m[32m        options.check_level = args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL);[m
[32m+[m[32m        options.check_interrupt = ShutdownRequested;[m
[32m+[m[32m        options.coins_error_cb = [] {[m
[32m+[m[32m            uiInterface.ThreadSafeMessageBox([m
[32m+[m[32m                _("Error reading from database, shutting down."),[m
[32m+[m[32m                "", CClientUIInterface::MSG_ERROR);[m
[32m+[m[32m        };[m
 [m
         uiInterface.InitMessage(_("Loading block indexâ€¦").translated);[m
         const int64_t load_block_index_start_time = GetTimeMillis();[m
[31m-        std::optional<ChainstateLoadingError> maybe_load_error;[m
[31m-        try {[m
[31m-            maybe_load_error = LoadChainstate(fReset,[m
[31m-                                              chainman,[m
[31m-                                              Assert(node.mempool.get()),[m
[31m-                                              fPruneMode,[m
[31m-                                              fReindexChainState,[m
[31m-                                              cache_sizes.block_tree_db,[m
[31m-                                              cache_sizes.coins_db,[m
[31m-                                              cache_sizes.coins,[m
[31m-                                              /*block_tree_db_in_memory=*/false,[m
[31m-                                              /*coins_db_in_memory=*/false,[m
[31m-                                              /*shutdown_requested=*/ShutdownRequested,[m
[31m-                                              /*coins_error_cb=*/[]() {[m
[31m-                                                  uiInterface.ThreadSafeMessageBox([m
[31m-                                                                                   _("Error reading from database, shutting down."),[m
[31m-                                                                                   "", CClientUIInterface::MSG_ERROR);[m
[31m-                                              });[m
[31m-        } catch (const std::exception& e) {[m
[31m-            LogPrintf("%s\n", e.what());[m
[31m-            maybe_load_error = ChainstateLoadingError::ERROR_GENERIC_BLOCKDB_OPEN_FAILED;[m
[31m-        }[m
[31m-        if (maybe_load_error.has_value()) {[m
[31m-            switch (maybe_load_error.value()) {[m
[31m-            case ChainstateLoadingError::ERROR_LOADING_BLOCK_DB:[m
[31m-                strLoadError = _("Error loading block database");[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::ERROR_BAD_GENESIS_BLOCK:[m
[31m-                // If the loaded chain has a wrong genesis, bail out immediately[m
[31m-                // (we're likely using a testnet datadir, or the other way around).[m
[31m-                return InitError(_("Incorrect or no genesis block found. Wrong datadir for network?"));[m
[31m-            case ChainstateLoadingError::ERROR_PRUNED_NEEDS_REINDEX:[m
[31m-                strLoadError = _("You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain");[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::ERROR_LOAD_GENESIS_BLOCK_FAILED:[m
[31m-                strLoadError = _("Error initializing block database");[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::ERROR_CHAINSTATE_UPGRADE_FAILED:[m
[31m-                return InitError(_("Unsupported chainstate database format found. "[m
[31m-                                   "Please restart with -reindex-chainstate. This will "[m
[31m-                                   "rebuild the chainstate database."));[m
[31m-            case ChainstateLoadingError::ERROR_REPLAYBLOCKS_FAILED:[m
[31m-                strLoadError = _("Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.");[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::ERROR_LOADCHAINTIP_FAILED:[m
[31m-                strLoadError = _("Error initializing block database");[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::ERROR_GENERIC_BLOCKDB_OPEN_FAILED:[m
[31m-                strLoadError = _("Error opening block database");[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::ERROR_BLOCKS_WITNESS_INSUFFICIENTLY_VALIDATED:[m
[31m-                strLoadError = strprintf(_("Witness data for blocks after height %d requires validation. Please restart with -reindex."),[m
[31m-                                         chainman.GetConsensus().SegwitHeight);[m
[31m-                break;[m
[31m-            case ChainstateLoadingError::SHUTDOWN_PROBED:[m
[31m-                break;[m
[31m-            }[m
[31m-        } else {[m
[31m-            std::optional<ChainstateLoadVerifyError> maybe_verify_error;[m
[32m+[m[32m        auto catch_exceptions = [](auto&& f) {[m
             try {[m
[31m-                uiInterface.InitMessage(_("Verifying blocksâ€¦").translated);[m
[31m-                auto check_blocks = args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS);[m
[31m-                if (chainman.m_blockman.m_have_pruned && check_blocks > MIN_BLOCKS_TO_KEEP) {[m
[31m-                    LogPrintfCategory(BCLog::PRUNE, "pruned datadir may not have more than %d blocks; only checking available blocks\n",[m
[31m-                                      MIN_BLOCKS_TO_KEEP);[m
[31m-                }[m
[31m-                maybe_verify_error = VerifyLoadedChainstate(chainman,[m
[31m-                                                            fReset,[m
[31m-                                                            fReindexChainState,[m
[31m-                                                            check_blocks,[m
[31m-                                                            args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL));[m
[32m+[m[32m                return f();[m
             } catch (const std::exception& e) {[m
                 LogPrintf("%s\n", e.what());[m
[31m-                maybe_verify_error = ChainstateLoadVerifyError::ERROR_GENERIC_FAILURE;[m
[32m+[m[32m                return std::make_tuple(node::ChainstateLoadStatus::FAILURE, _("Error opening block database"));[m
             }[m
[31m-            if (maybe_verify_error.has_value()) {[m
[31m-                switch (maybe_verify_error.value()) {[m
[31m-                case ChainstateLoadVerifyError::ERROR_BLOCK_FROM_FUTURE:[m
[31m-                    strLoadError = _("The block database contains a block which appears to be from the future. "[m
[31m-                                     "This may be due to your computer's date and time being set incorrectly. "[m
[31m-                                     "Only rebuild the block database if you are sure that your computer's date and time are correct");[m
[31m-                    break;[m
[31m-                case ChainstateLoadVerifyError::ERROR_CORRUPTED_BLOCK_DB:[m
[31m-                    strLoadError = _("Corrupted block database detected");[m
[31m-                    break;[m
[31m-                case ChainstateLoadVerifyError::ERROR_GENERIC_FAILURE:[m
[31m-                    strLoadError = _("Error opening block database");[m
[31m-                    break;[m
[31m-                }[m
[31m-            } else {[m
[32m+[m[32m        };[m
[32m+[m[32m        auto [status, error] = catch_exceptions([&]{ return LoadChainstate(chainman, cache_sizes, options); });[m
[32m+[m[32m        if (status == node::ChainstateLoadStatus::SUCCESS) {[m
[32m+[m[32m            uiInterface.InitMessage(_("Verifying blocksâ€¦").translated);[m
[32m+[m[32m            if (chainman.m_blockman.m_have_pruned && options.check_blocks > MIN_BLOCKS_TO_KEEP) {[m
[32m+[m[32m                LogPrintfCategory(BCLog::PRUNE, "pruned datadir may not have more than %d blocks; only checking available blocks\n",[m
[32m+[m[32m                                  MIN_BLOCKS_TO_KEEP);[m
[32m+[m[32m            }[m
[32m+[m[32m            std::tie(status, error) = catch_exceptions([&]{ return VerifyLoadedChainstate(chainman, options);});[m
[32m+[m[32m            if (status == node::ChainstateLoadStatus::SUCCESS) {[m
                 fLoaded = true;[m
                 LogPrintf(" block index %15dms\n", GetTimeMillis() - load_block_index_start_time);[m
             }[m
         }[m
 [m
[32m+[m[32m        if (status == node::ChainstateLoadStatus::FAILURE_INCOMPATIBLE_DB) {[m
[32m+[m[32m            return InitError(error);[m
[32m+[m[32m        }[m
[32m+[m
         if (!fLoaded && !ShutdownRequested()) {[m
             // first suggest a reindex[m
[31m-            if (!fReset) {[m
[32m+[m[32m            if (!options.reindex) {[m
                 bool fRet = uiInterface.ThreadSafeQuestion([m
[31m-                    strLoadError + Untranslated(".\n\n") + _("Do you want to rebuild the block database now?"),[m
[31m-                    strLoadError.original + ".\nPlease restart with -reindex or -reindex-chainstate to recover.",[m
[32m+[m[32m                    error + Untranslated(".\n\n") + _("Do you want to rebuild the block database now?"),[m
[32m+[m[32m                    error.original + ".\nPlease restart with -reindex or -reindex-chainstate to recover.",[m
                     "", CClientUIInterface::MSG_ERROR | CClientUIInterface::BTN_ABORT);[m
                 if (fRet) {[m
                     fReindex = true;[m
[36m@@ -1561,7 +1488,7 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
                     return false;[m
                 }[m
             } else {[m
[31m-                return InitError(strLoadError);[m
[32m+[m[32m                return InitError(error);[m
             }[m
         }[m
     }[m
[33mdiff --git a/src/kernel/checks.cpp b/src/kernel/checks.cpp[m
[33mindex 2a1dd3bfa2..4c303c172c 100644[m
[33m--- a/src/kernel/checks.cpp[m
[33m+++ b/src/kernel/checks.cpp[m
[36m@@ -7,21 +7,24 @@[m
 #include <key.h>[m
 #include <random.h>[m
 #include <util/time.h>[m
[32m+[m[32m#include <util/translation.h>[m
[32m+[m
[32m+[m[32m#include <memory>[m
 [m
 namespace kernel {[m
 [m
[31m-std::optional<SanityCheckError> SanityChecks(const Context&)[m
[32m+[m[32mstd::optional<bilingual_str> SanityChecks(const Context&)[m
 {[m
     if (!ECC_InitSanityCheck()) {[m
[31m-        return SanityCheckError::ERROR_ECC;[m
[32m+[m[32m        return Untranslated("Elliptic curve cryptography sanity check failure. Aborting.");[m
     }[m
 [m
     if (!Random_SanityCheck()) {[m
[31m-        return SanityCheckError::ERROR_RANDOM;[m
[32m+[m[32m        return Untranslated("OS cryptographic RNG sanity check failure. Aborting.");[m
     }[m
 [m
     if (!ChronoSanityCheck()) {[m
[31m-        return SanityCheckError::ERROR_CHRONO;[m
[32m+[m[32m        return Untranslated("Clock epoch mismatch. Aborting.");[m
     }[m
 [m
     return std::nullopt;[m
[33mdiff --git a/src/kernel/checks.h b/src/kernel/checks.h[m
[33mindex 80b207f607..3eb14824fb 100644[m
[33m--- a/src/kernel/checks.h[m
[33m+++ b/src/kernel/checks.h[m
[36m@@ -7,20 +7,16 @@[m
 [m
 #include <optional>[m
 [m
[32m+[m[32mstruct bilingual_str;[m
[32m+[m
 namespace kernel {[m
 [m
 struct Context;[m
 [m
[31m-enum class SanityCheckError {[m
[31m-    ERROR_ECC,[m
[31m-    ERROR_RANDOM,[m
[31m-    ERROR_CHRONO,[m
[31m-};[m
[31m-[m
 /**[m
  *  Ensure a usable environment with all necessary library support.[m
  */[m
[31m-std::optional<SanityCheckError> SanityChecks(const Context&);[m
[32m+[m[32mstd::optional<bilingual_str> SanityChecks(const Context&);[m
 [m
 }[m
 [m
[33mdiff --git a/src/kernel/coinstats.cpp b/src/kernel/coinstats.cpp[m
[33mindex f380871627..8d948bfc1d 100644[m
[33m--- a/src/kernel/coinstats.cpp[m
[33m+++ b/src/kernel/coinstats.cpp[m
[36m@@ -4,16 +4,32 @@[m
 [m
 #include <kernel/coinstats.h>[m
 [m
[32m+[m[32m#include <chain.h>[m
 #include <coins.h>[m
 #include <crypto/muhash.h>[m
 #include <hash.h>[m
[32m+[m[32m#include <node/blockstorage.h>[m
[32m+[m[32m#include <primitives/transaction.h>[m
[32m+[m[32m#include <script/script.h>[m
 #include <serialize.h>[m
[32m+[m[32m#include <span.h>[m
[32m+[m[32m#include <streams.h>[m
[32m+[m[32m#include <sync.h>[m
[32m+[m[32m#include <tinyformat.h>[m
 #include <uint256.h>[m
[32m+[m[32m#include <util/check.h>[m
 #include <util/overflow.h>[m
 #include <util/system.h>[m
 #include <validation.h>[m
[32m+[m[32m#include <version.h>[m
 [m
[32m+[m[32m#include <cassert>[m
[32m+[m[32m#include <iosfwd>[m
[32m+[m[32m#include <iterator>[m
 #include <map>[m
[32m+[m[32m#include <memory>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <utility>[m
 [m
 namespace kernel {[m
 [m
[33mdiff --git a/src/kernel/coinstats.h b/src/kernel/coinstats.h[m
[33mindex a15957233f..b7c1328e93 100644[m
[33m--- a/src/kernel/coinstats.h[m
[33m+++ b/src/kernel/coinstats.h[m
[36m@@ -5,16 +5,18 @@[m
 #ifndef BITCOIN_KERNEL_COINSTATS_H[m
 #define BITCOIN_KERNEL_COINSTATS_H[m
 [m
[31m-#include <chain.h>[m
[31m-#include <coins.h>[m
 #include <consensus/amount.h>[m
 #include <streams.h>[m
 #include <uint256.h>[m
 [m
 #include <cstdint>[m
 #include <functional>[m
[32m+[m[32m#include <optional>[m
 [m
 class CCoinsView;[m
[32m+[m[32mclass Coin;[m
[32m+[m[32mclass COutPoint;[m
[32m+[m[32mclass CScript;[m
 namespace node {[m
 class BlockManager;[m
 } // namespace node[m
[33mdiff --git a/src/node/chainstate.cpp b/src/node/chainstate.cpp[m
[33mindex 54ba5b7966..55b373338b 100644[m
[33m--- a/src/node/chainstate.cpp[m
[33m+++ b/src/node/chainstate.cpp[m
[36m@@ -6,64 +6,58 @@[m
 [m
 #include <consensus/params.h>[m
 #include <node/blockstorage.h>[m
[32m+[m[32m#include <node/caches.h>[m
 #include <validation.h>[m
 [m
 namespace node {[m
[31m-std::optional<ChainstateLoadingError> LoadChainstate(bool fReset,[m
[31m-                                                     ChainstateManager& chainman,[m
[31m-                                                     CTxMemPool* mempool,[m
[31m-                                                     bool fPruneMode,[m
[31m-                                                     bool fReindexChainState,[m
[31m-                                                     int64_t nBlockTreeDBCache,[m
[31m-                                                     int64_t nCoinDBCache,[m
[31m-                                                     int64_t nCoinCacheUsage,[m
[31m-                                                     bool block_tree_db_in_memory,[m
[31m-                                                     bool coins_db_in_memory,[m
[31m-                                                     std::function<bool()> shutdown_requested,[m
[31m-                                                     std::function<void()> coins_error_cb)[m
[32m+[m[32mChainstateLoadResult LoadChainstate(ChainstateManager& chainman, const CacheSizes& cache_sizes,[m
[32m+[m[32m                                    const ChainstateLoadOptions& options)[m
 {[m
     auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {[m
[31m-        return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();[m
[32m+[m[32m        return options.reindex || options.reindex_chainstate || chainstate->CoinsTip().GetBestBlock().IsNull();[m
     };[m
 [m
     LOCK(cs_main);[m
[31m-    chainman.InitializeChainstate(mempool);[m
[31m-    chainman.m_total_coinstip_cache = nCoinCacheUsage;[m
[31m-    chainman.m_total_coinsdb_cache = nCoinDBCache;[m
[32m+[m[32m    chainman.InitializeChainstate(options.mempool);[m
[32m+[m[32m    chainman.m_total_coinstip_cache = cache_sizes.coins;[m
[32m+[m[32m    chainman.m_total_coinsdb_cache = cache_sizes.coins_db;[m
 [m
     auto& pblocktree{chainman.m_blockman.m_block_tree_db};[m
     // new CBlockTreeDB tries to delete the existing file, which[m
     // fails if it's still open from the previous loop. Close it first:[m
     pblocktree.reset();[m
[31m-    pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, block_tree_db_in_memory, fReset));[m
[32m+[m[32m    pblocktree.reset(new CBlockTreeDB(cache_sizes.block_tree_db, options.block_tree_db_in_memory, options.reindex));[m
 [m
[31m-    if (fReset) {[m
[32m+[m[32m    if (options.reindex) {[m
         pblocktree->WriteReindexing(true);[m
         //If we're reindexing in prune mode, wipe away unusable block files and all undo data files[m
[31m-        if (fPruneMode)[m
[32m+[m[32m        if (options.prune) {[m
             CleanupBlockRevFiles();[m
[32m+[m[32m        }[m
     }[m
 [m
[31m-    if (shutdown_requested && shutdown_requested()) return ChainstateLoadingError::SHUTDOWN_PROBED;[m
[32m+[m[32m    if (options.check_interrupt && options.check_interrupt()) return {ChainstateLoadStatus::INTERRUPTED, {}};[m
 [m
     // LoadBlockIndex will load m_have_pruned if we've ever removed a[m
     // block file from disk.[m
[31m-    // Note that it also sets fReindex based on the disk flag![m
[31m-    // From here on out fReindex and fReset mean something different![m
[32m+[m[32m    // Note that it also sets fReindex global based on the disk flag![m
[32m+[m[32m    // From here on, fReindex and options.reindex values may be different![m
     if (!chainman.LoadBlockIndex()) {[m
[31m-        if (shutdown_requested && shutdown_requested()) return ChainstateLoadingError::SHUTDOWN_PROBED;[m
[31m-        return ChainstateLoadingError::ERROR_LOADING_BLOCK_DB;[m
[32m+[m[32m        if (options.check_interrupt && options.check_interrupt()) return {ChainstateLoadStatus::INTERRUPTED, {}};[m
[32m+[m[32m        return {ChainstateLoadStatus::FAILURE, _("Error loading block database")};[m
     }[m
 [m
     if (!chainman.BlockIndex().empty() &&[m
             !chainman.m_blockman.LookupBlockIndex(chainman.GetConsensus().hashGenesisBlock)) {[m
[31m-        return ChainstateLoadingError::ERROR_BAD_GENESIS_BLOCK;[m
[32m+[m[32m        // If the loaded chain has a wrong genesis, bail out immediately[m
[32m+[m[32m        // (we're likely using a testnet datadir, or the other way around).[m
[32m+[m[32m        return {ChainstateLoadStatus::FAILURE_INCOMPATIBLE_DB, _("Incorrect or no genesis block found. Wrong datadir for network?")};[m
     }[m
 [m
     // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks[m
     // in the past, but is now trying to run unpruned.[m
[31m-    if (chainman.m_blockman.m_have_pruned && !fPruneMode) {[m
[31m-        return ChainstateLoadingError::ERROR_PRUNED_NEEDS_REINDEX;[m
[32m+[m[32m    if (chainman.m_blockman.m_have_pruned && !options.prune) {[m
[32m+[m[32m        return {ChainstateLoadStatus::FAILURE, _("You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain")};[m
     }[m
 [m
     // At this point blocktree args are consistent with what's on disk.[m
[36m@@ -71,7 +65,7 @@[m [mstd::optional<ChainstateLoadingError> LoadChainstate(bool fReset,[m
     // (otherwise we use the one already on disk).[m
     // This is called again in ThreadImport after the reindex completes.[m
     if (!fReindex && !chainman.ActiveChainstate().LoadGenesisBlock()) {[m
[31m-        return ChainstateLoadingError::ERROR_LOAD_GENESIS_BLOCK_FAILED;[m
[32m+[m[32m        return {ChainstateLoadStatus::FAILURE, _("Error initializing block database")};[m
     }[m
 [m
     // At this point we're either in reindex or we've loaded a useful[m
[36m@@ -79,57 +73,56 @@[m [mstd::optional<ChainstateLoadingError> LoadChainstate(bool fReset,[m
 [m
     for (CChainState* chainstate : chainman.GetAll()) {[m
         chainstate->InitCoinsDB([m
[31m-            /*cache_size_bytes=*/nCoinDBCache,[m
[31m-            /*in_memory=*/coins_db_in_memory,[m
[31m-            /*should_wipe=*/fReset || fReindexChainState);[m
[32m+[m[32m            /*cache_size_bytes=*/cache_sizes.coins_db,[m
[32m+[m[32m            /*in_memory=*/options.coins_db_in_memory,[m
[32m+[m[32m            /*should_wipe=*/options.reindex || options.reindex_chainstate);[m
 [m
[31m-        if (coins_error_cb) {[m
[31m-            chainstate->CoinsErrorCatcher().AddReadErrCallback(coins_error_cb);[m
[32m+[m[32m        if (options.coins_error_cb) {[m
[32m+[m[32m            chainstate->CoinsErrorCatcher().AddReadErrCallback(options.coins_error_cb);[m
         }[m
 [m
         // Refuse to load unsupported database format.[m
         // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate[m
         if (chainstate->CoinsDB().NeedsUpgrade()) {[m
[31m-            return ChainstateLoadingError::ERROR_CHAINSTATE_UPGRADE_FAILED;[m
[32m+[m[32m            return {ChainstateLoadStatus::FAILURE_INCOMPATIBLE_DB, _("Unsupported chainstate database format found. "[m
[32m+[m[32m                                                                     "Please restart with -reindex-chainstate. This will "[m
[32m+[m[32m                                                                     "rebuild the chainstate database.")};[m
         }[m
 [m
         // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate[m
         if (!chainstate->ReplayBlocks()) {[m
[31m-            return ChainstateLoadingError::ERROR_REPLAYBLOCKS_FAILED;[m
[32m+[m[32m            return {ChainstateLoadStatus::FAILURE, _("Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.")};[m
         }[m
 [m
         // The on-disk coinsdb is now in a good state, create the cache[m
[31m-        chainstate->InitCoinsCache(nCoinCacheUsage);[m
[32m+[m[32m        chainstate->InitCoinsCache(cache_sizes.coins);[m
         assert(chainstate->CanFlushToDisk());[m
 [m
         if (!is_coinsview_empty(chainstate)) {[m
             // LoadChainTip initializes the chain based on CoinsTip()'s best block[m
             if (!chainstate->LoadChainTip()) {[m
[31m-                return ChainstateLoadingError::ERROR_LOADCHAINTIP_FAILED;[m
[32m+[m[32m                return {ChainstateLoadStatus::FAILURE, _("Error initializing block database")};[m
             }[m
             assert(chainstate->m_chain.Tip() != nullptr);[m
         }[m
     }[m
 [m
[31m-    if (!fReset) {[m
[32m+[m[32m    if (!options.reindex) {[m
         auto chainstates{chainman.GetAll()};[m
         if (std::any_of(chainstates.begin(), chainstates.end(),[m
                         [](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(); })) {[m
[31m-            return ChainstateLoadingError::ERROR_BLOCKS_WITNESS_INSUFFICIENTLY_VALIDATED;[m
[31m-        }[m
[32m+[m[32m            return {ChainstateLoadStatus::FAILURE, strprintf(_("Witness data for blocks after height %d requires validation. Please restart with -reindex."),[m
[32m+[m[32m                                                             chainman.GetConsensus().SegwitHeight)};[m
[32m+[m[32m        };[m
     }[m
 [m
[31m-    return std::nullopt;[m
[32m+[m[32m    return {ChainstateLoadStatus::SUCCESS, {}};[m
 }[m
 [m
[31m-std::optional<ChainstateLoadVerifyError> VerifyLoadedChainstate(ChainstateManager& chainman,[m
[31m-                                                                bool fReset,[m
[31m-                                                                bool fReindexChainState,[m
[31m-                                                                int check_blocks,[m
[31m-                                                                int check_level)[m
[32m+[m[32mChainstateLoadResult VerifyLoadedChainstate(ChainstateManager& chainman, const ChainstateLoadOptions& options)[m
 {[m
     auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {[m
[31m-        return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();[m
[32m+[m[32m        return options.reindex || options.reindex_chainstate || chainstate->CoinsTip().GetBestBlock().IsNull();[m
     };[m
 [m
     LOCK(cs_main);[m
[36m@@ -138,18 +131,20 @@[m [mstd::optional<ChainstateLoadVerifyError> VerifyLoadedChainstate(ChainstateManage[m
         if (!is_coinsview_empty(chainstate)) {[m
             const CBlockIndex* tip = chainstate->m_chain.Tip();[m
             if (tip && tip->nTime > GetTime() + MAX_FUTURE_BLOCK_TIME) {[m
[31m-                return ChainstateLoadVerifyError::ERROR_BLOCK_FROM_FUTURE;[m
[32m+[m[32m                return {ChainstateLoadStatus::FAILURE, _("The block database contains a block which appears to be from the future. "[m
[32m+[m[32m                                                         "This may be due to your computer's date and time being set incorrectly. "[m
[32m+[m[32m                                                         "Only rebuild the block database if you are sure that your computer's date and time are correct")};[m
             }[m
 [m
             if (!CVerifyDB().VerifyDB([m
                     *chainstate, chainman.GetConsensus(), chainstate->CoinsDB(),[m
[31m-                    check_level,[m
[31m-                    check_blocks)) {[m
[31m-                return ChainstateLoadVerifyError::ERROR_CORRUPTED_BLOCK_DB;[m
[32m+[m[32m                    options.check_level,[m
[32m+[m[32m                    options.check_blocks)) {[m
[32m+[m[32m                return {ChainstateLoadStatus::FAILURE, _("Corrupted block database detected")};[m
             }[m
         }[m
     }[m
 [m
[31m-    return std::nullopt;[m
[32m+[m[32m    return {ChainstateLoadStatus::SUCCESS, {}};[m
 }[m
 } // namespace node[m
[33mdiff --git a/src/node/chainstate.h b/src/node/chainstate.h[m
[33mindex ff7935e8e0..c12539e697 100644[m
[33m--- a/src/node/chainstate.h[m
[33m+++ b/src/node/chainstate.h[m
[36m@@ -5,6 +5,8 @@[m
 #ifndef BITCOIN_NODE_CHAINSTATE_H[m
 #define BITCOIN_NODE_CHAINSTATE_H[m
 [m
[32m+[m[32m#include <validation.h>[m
[32m+[m
 #include <cstdint>[m
 #include <functional>[m
 #include <optional>[m
[36m@@ -16,19 +18,31 @@[m [mstruct Params;[m
 } // namespace Consensus[m
 [m
 namespace node {[m
[31m-enum class ChainstateLoadingError {[m
[31m-    ERROR_LOADING_BLOCK_DB,[m
[31m-    ERROR_BAD_GENESIS_BLOCK,[m
[31m-    ERROR_PRUNED_NEEDS_REINDEX,[m
[31m-    ERROR_LOAD_GENESIS_BLOCK_FAILED,[m
[31m-    ERROR_CHAINSTATE_UPGRADE_FAILED,[m
[31m-    ERROR_REPLAYBLOCKS_FAILED,[m
[31m-    ERROR_LOADCHAINTIP_FAILED,[m
[31m-    ERROR_GENERIC_BLOCKDB_OPEN_FAILED,[m
[31m-    ERROR_BLOCKS_WITNESS_INSUFFICIENTLY_VALIDATED,[m
[31m-    SHUTDOWN_PROBED,[m
[32m+[m
[32m+[m[32mstruct CacheSizes;[m
[32m+[m
[32m+[m[32mstruct ChainstateLoadOptions {[m
[32m+[m[32m    CTxMemPool* mempool{nullptr};[m
[32m+[m[32m    bool block_tree_db_in_memory{false};[m
[32m+[m[32m    bool coins_db_in_memory{false};[m
[32m+[m[32m    bool reindex{false};[m
[32m+[m[32m    bool reindex_chainstate{false};[m
[32m+[m[32m    bool prune{false};[m
[32m+[m[32m    int64_t check_blocks{DEFAULT_CHECKBLOCKS};[m
[32m+[m[32m    int64_t check_level{DEFAULT_CHECKLEVEL};[m
[32m+[m[32m    std::function<bool()> check_interrupt;[m
[32m+[m[32m    std::function<void()> coins_error_cb;[m
 };[m
 [m
[32m+[m[32m//! Chainstate load status. Simple applications can just check for the success[m
[32m+[m[32m//! case, and treat other cases as errors. More complex applications may want to[m
[32m+[m[32m//! try reindexing in the generic failure case, and pass an interrupt callback[m
[32m+[m[32m//! and exit cleanly in the interrupted case.[m
[32m+[m[32menum class ChainstateLoadStatus { SUCCESS, FAILURE, FAILURE_INCOMPATIBLE_DB, INTERRUPTED };[m
[32m+[m
[32m+[m[32m//! Chainstate load status code and optional error string.[m
[32m+[m[32musing ChainstateLoadResult = std::tuple<ChainstateLoadStatus, bilingual_str>;[m
[32m+[m
 /** This sequence can have 4 types of outcomes:[m
  *[m
  *  1. Success[m
[36m@@ -40,45 +54,11 @@[m [menum class ChainstateLoadingError {[m
  *  4. Hard failure[m
  *    - a failure that definitively cannot be recovered from with a reindex[m
  *[m
[31m- *  Currently, LoadChainstate returns a std::optional<ChainstateLoadingError>[m
[31m- *  which:[m
[31m- *[m
[31m- *  - if has_value()[m
[31m- *      - Either "Soft failure", "Hard failure", or "Shutdown requested",[m
[31m- *        differentiable by the specific enumerator.[m
[31m- *[m
[31m- *        Note that a return value of SHUTDOWN_PROBED means ONLY that "during[m
[31m- *        this sequence, when we explicitly checked shutdown_requested() at[m
[31m- *        arbitrary points, one of those calls returned true". Therefore, a[m
[31m- *        return value other than SHUTDOWN_PROBED does not guarantee that[m
[31m- *        shutdown hasn't been called indirectly.[m
[31m- *  - else[m
[31m- *      - Success![m
[32m+[m[32m *  LoadChainstate returns a (status code, error string) tuple.[m
  */[m
[31m-std::optional<ChainstateLoadingError> LoadChainstate(bool fReset,[m
[31m-                                                     ChainstateManager& chainman,[m
[31m-                                                     CTxMemPool* mempool,[m
[31m-                                                     bool fPruneMode,[m
[31m-                                                     bool fReindexChainState,[m
[31m-                                                     int64_t nBlockTreeDBCache,[m
[31m-                                                     int64_t nCoinDBCache,[m
[31m-                                                     int64_t nCoinCacheUsage,[m
[31m-                                                     bool block_tree_db_in_memory,[m
[31m-                                                     bool coins_db_in_memory,[m
[31m-                                                     std::function<bool()> shutdown_requested = nullptr,[m
[31m-                                                     std::function<void()> coins_error_cb = nullptr);[m
[31m-[m
[31m-enum class ChainstateLoadVerifyError {[m
[31m-    ERROR_BLOCK_FROM_FUTURE,[m
[31m-    ERROR_CORRUPTED_BLOCK_DB,[m
[31m-    ERROR_GENERIC_FAILURE,[m
[31m-};[m
[31m-[m
[31m-std::optional<ChainstateLoadVerifyError> VerifyLoadedChainstate(ChainstateManager& chainman,[m
[31m-                                                                bool fReset,[m
[31m-                                                                bool fReindexChainState,[m
[31m-                                                                int check_blocks,[m
[31m-                                                                int check_level);[m
[32m+[m[32mChainstateLoadResult LoadChainstate(ChainstateManager& chainman, const CacheSizes& cache_sizes,[m
[32m+[m[32m                                    const ChainstateLoadOptions& options);[m
[32m+[m[32mChainstateLoadResult VerifyLoadedChainstate(ChainstateManager& chainman, const ChainstateLoadOptions& options);[m
 } // namespace node[m
 [m
 #endif // BITCOIN_NODE_CHAINSTATE_H[m
[33mdiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp[m
[33mindex 0c9e880d67..cf2f70cda6 100644[m
[33m--- a/src/test/util/setup_common.cpp[m
[33m+++ b/src/test/util/setup_common.cpp[m
[36m@@ -55,8 +55,6 @@[m
 [m
 using node::BlockAssembler;[m
 using node::CalculateCacheSizes;[m
[31m-using node::fPruneMode;[m
[31m-using node::fReindex;[m
 using node::LoadChainstate;[m
 using node::NodeContext;[m
 using node::RegenerateCommitments;[m
[36m@@ -219,25 +217,20 @@[m [mTestingSetup::TestingSetup(const std::string& chainName, const std::vector<const[m
     // instead of unit tests, but for now we need these here.[m
     RegisterAllCoreRPCCommands(tableRPC);[m
 [m
[31m-    auto maybe_load_error = LoadChainstate(fReindex.load(),[m
[31m-                                           *Assert(m_node.chainman.get()),[m
[31m-                                           Assert(m_node.mempool.get()),[m
[31m-                                           fPruneMode,[m
[31m-                                           m_args.GetBoolArg("-reindex-chainstate", false),[m
[31m-                                           m_cache_sizes.block_tree_db,[m
[31m-                                           m_cache_sizes.coins_db,[m
[31m-                                           m_cache_sizes.coins,[m
[31m-                                           /*block_tree_db_in_memory=*/true,[m
[31m-                                           /*coins_db_in_memory=*/true);[m
[31m-    assert(!maybe_load_error.has_value());[m
[31m-[m
[31m-    auto maybe_verify_error = VerifyLoadedChainstate([m
[31m-        *Assert(m_node.chainman),[m
[31m-        fReindex.load(),[m
[31m-        m_args.GetBoolArg("-reindex-chainstate", false),[m
[31m-        m_args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS),[m
[31m-        m_args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL));[m
[31m-    assert(!maybe_verify_error.has_value());[m
[32m+[m[32m    node::ChainstateLoadOptions options;[m
[32m+[m[32m    options.mempool = Assert(m_node.mempool.get());[m
[32m+[m[32m    options.block_tree_db_in_memory = true;[m
[32m+[m[32m    options.coins_db_in_memory = true;[m
[32m+[m[32m    options.reindex = node::fReindex;[m
[32m+[m[32m    options.reindex_chainstate = m_args.GetBoolArg("-reindex-chainstate", false);[m
[32m+[m[32m    options.prune = node::fPruneMode;[m
[32m+[m[32m    options.check_blocks = m_args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS);[m
[32m+[m[32m    options.check_level = m_args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL);[m
[32m+[m[32m    auto [status, error] = LoadChainstate(*Assert(m_node.chainman), m_cache_sizes, options);[m
[32m+[m[32m    assert(status == node::ChainstateLoadStatus::SUCCESS);[m
[32m+[m
[32m+[m[32m    std::tie(status, error) = VerifyLoadedChainstate(*Assert(m_node.chainman), options);[m
[32m+[m[32m    assert(status == node::ChainstateLoadStatus::SUCCESS);[m
 [m
     BlockValidationState state;[m
     if (!m_node.chainman->ActiveChainstate().ActivateBestChain(state)) {[m