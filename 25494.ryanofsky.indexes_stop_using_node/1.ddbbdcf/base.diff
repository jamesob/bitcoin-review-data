[33mdiff --git a/src/Makefile.am b/src/Makefile.am[m
[33mindex f90c14bab8..c000c32666 100644[m
[33m--- a/src/Makefile.am[m
[33m+++ b/src/Makefile.am[m
[36m@@ -191,6 +191,7 @@[m [mBITCOIN_CORE_H = \[m
   netmessagemaker.h \[m
   node/blockstorage.h \[m
   node/caches.h \[m
[32m+[m[32m  node/chain.h \[m
   node/chainstate.h \[m
   node/coin.h \[m
   node/context.h \[m
[36m@@ -367,6 +368,7 @@[m [mlibbitcoin_node_a_SOURCES = \[m
   net_processing.cpp \[m
   node/blockstorage.cpp \[m
   node/caches.cpp \[m
[32m+[m[32m  node/chain.cpp \[m
   node/chainstate.cpp \[m
   node/coin.cpp \[m
   node/context.cpp \[m
[36m@@ -876,6 +878,7 @@[m [mlibbitcoinkernel_la_SOURCES = \[m
   key.cpp \[m
   logging.cpp \[m
   node/blockstorage.cpp \[m
[32m+[m[32m  node/chain.cpp \[m
   node/chainstate.cpp \[m
   node/interface_ui.cpp \[m
   policy/feerate.cpp \[m
[33mdiff --git a/src/index/base.cpp b/src/index/base.cpp[m
[33mindex 323547900d..466a8ef7e4 100644[m
[33m--- a/src/index/base.cpp[m
[33m+++ b/src/index/base.cpp[m
[36m@@ -4,7 +4,10 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/base.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <node/blockstorage.h>[m
[32m+[m[32m#include <node/chain.h>[m
[32m+[m[32m#include <node/context.h>[m
 #include <node/interface_ui.h>[m
 #include <shutdown.h>[m
 #include <tinyformat.h>[m
[36m@@ -31,6 +34,15 @@[m [mstatic void FatalError(const char* fmt, const Args&... args)[m
     StartShutdown();[m
 }[m
 [m
[32m+[m[32mCBlockLocator GetLocator(interfaces::Chain& chain, const uint256& block_hash)[m
[32m+[m[32m{[m
[32m+[m[32m    CBlockLocator locator;[m
[32m+[m[32m    bool found = chain.findBlock(block_hash, interfaces::FoundBlock().locator(locator));[m
[32m+[m[32m    assert(found);[m
[32m+[m[32m    assert(!locator.IsNull());[m
[32m+[m[32m    return locator;[m
[32m+[m[32m}[m
[32m+[m
 BaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :[m
     CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)[m
 {}[m
[36m@@ -49,6 +61,9 @@[m [mvoid BaseIndex::DB::WriteBestBlock(CDBBatch& batch, const CBlockLocator& locator[m
     batch.Write(DB_BEST_BLOCK, locator);[m
 }[m
 [m
[32m+[m[32mBaseIndex::BaseIndex(std::unique_ptr<interfaces::Chain> chain)[m
[32m+[m[32m    : m_chain{std::move(chain)} {}[m
[32m+[m
 BaseIndex::~BaseIndex()[m
 {[m
     Interrupt();[m
[36m@@ -175,12 +190,15 @@[m [mvoid BaseIndex::ThreadSync()[m
             }[m
 [m
             CBlock block;[m
[32m+[m[32m            interfaces::BlockInfo block_info = node::MakeBlockInfo(pindex);[m
             if (!ReadBlockFromDisk(block, pindex, consensus_params)) {[m
                 FatalError("%s: Failed to read block %s from disk",[m
                            __func__, pindex->GetBlockHash().ToString());[m
                 return;[m
[32m+[m[32m            } else {[m
[32m+[m[32m                block_info.data = &block;[m
             }[m
[31m-            if (!WriteBlock(block, pindex)) {[m
[32m+[m[32m            if (!CustomAppend(block_info)) {[m
                 FatalError("%s: Failed to write block %s to index database",[m
                            __func__, pindex->GetBlockHash().ToString());[m
                 return;[m
[36m@@ -197,22 +215,19 @@[m [mvoid BaseIndex::ThreadSync()[m
 [m
 bool BaseIndex::Commit()[m
 {[m
[31m-    CDBBatch batch(GetDB());[m
[31m-    if (!CommitInternal(batch) || !GetDB().WriteBatch(batch)) {[m
[2m-        return error("%s: Failed to commit latest %s state", __func__, GetName());[m
[2m-    }[m
[31m-    return true;[m
[31m-}[m
[31m-[m
[31m-bool BaseIndex::CommitInternal(CDBBatch& batch)[m
[31m-{[m
[31m-    LOCK(cs_main);[m
     // Don't commit anything if we haven't indexed any block yet[m
     // (this could happen if init is interrupted).[m
     if (m_best_block_index == nullptr) {[m
         return false;[m
     }[m
[31m-    GetDB().WriteBestBlock(batch, m_chainstate->m_chain.GetLocator(m_best_block_index));[m
[32m+[m[32m    CDBBatch batch(GetDB());[m
[32m+[m[32m    bool success = CustomCommit(batch);[m
[32m+[m[32m    if (success) {[m
[32m+[m[32m        GetDB().WriteBestBlock(batch, GetLocator(*m_chain, m_best_block_index.load()->GetBlockHash()));[m
[32m+[m[32m    }[m
[32m+[m[32m    if (!success || !GetDB().WriteBatch(batch)) {[m
[2m+[m[2m        return error("%s: Failed to commit latest %s state", __func__, GetName());[m
[2m+[m[2m    }[m
     return true;[m
 }[m
 [m
[36m@@ -221,6 +236,10 @@[m [mbool BaseIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_ti[m
     assert(current_tip == m_best_block_index);[m
     assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);[m
 [m
[32m+[m[32m    if (!CustomRewind({current_tip->GetBlockHash(), current_tip->nHeight}, {new_tip->GetBlockHash(), new_tip->nHeight})) {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m
     // In the case of a reorg, ensure persisted block locator is not stale.[m
     // Pruning has a minimum of 288 blocks-to-keep and getting the index[m
     // out of sync may be possible but a users fault.[m
[36m@@ -268,8 +287,8 @@[m [mvoid BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const[m
             return;[m
         }[m
     }[m
[31m-[m
[31m-    if (WriteBlock(*block, pindex)) {[m
[32m+[m[32m    interfaces::BlockInfo block_info = node::MakeBlockInfo(pindex, block.get());[m
[32m+[m[32m    if (CustomAppend(block_info)) {[m
         SetBestBlockIndex(pindex);[m
     } else {[m
         FatalError("%s: Failed to write block %s to index",[m
[36m@@ -346,13 +365,18 @@[m [mvoid BaseIndex::Interrupt()[m
     m_interrupt();[m
 }[m
 [m
[31m-bool BaseIndex::Start(CChainState& active_chainstate)[m
[32m+[m[32mbool BaseIndex::Start()[m
 {[m
[31m-    m_chainstate = &active_chainstate;[m
[32m+[m[32m    // m_chainstate member gives indexing code access to node internals. It[m
[32m+[m[32m    // will be removed in upcoming commit[m
[32m+[m[32m    m_chainstate = &m_chain->context()->chainman->ActiveChainstate();[m
     // Need to register this ValidationInterface before running Init(), so that[m
     // callbacks are not missed if Init sets m_synced to true.[m
     RegisterValidationInterface(this);[m
[31m-    if (!Init()) {[m
[32m+[m[32m    if (!Init()) return false;[m
[32m+[m
[32m+[m[32m    const CBlockIndex* index = m_best_block_index.load();[m
[32m+[m[32m    if (!CustomInit(index ? std::make_optional(interfaces::BlockKey{index->GetBlockHash(), index->nHeight}) : std::nullopt)) {[m
         return false;[m
     }[m
 [m
[33mdiff --git a/src/index/base.h b/src/index/base.h[m
[33mindex a8f6a18c8d..77c46dd428 100644[m
[33m--- a/src/index/base.h[m
[33m+++ b/src/index/base.h[m
[36m@@ -6,12 +6,16 @@[m
 #define BITCOIN_INDEX_BASE_H[m
 [m
 #include <dbwrapper.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <threadinterrupt.h>[m
 #include <validationinterface.h>[m
 [m
 class CBlock;[m
 class CBlockIndex;[m
 class CChainState;[m
[32m+[m[32mnamespace interfaces {[m
[32m+[m[32mclass Chain;[m
[32m+[m[32m} // namespace interfaces[m
 [m
 struct IndexSummary {[m
     std::string name;[m
[36m@@ -59,6 +63,9 @@[m [mprivate:[m
     std::thread m_thread_sync;[m
     CThreadInterrupt m_interrupt;[m
 [m
[32m+[m[32m    /// Read best block locator and check that data needed to sync has not been pruned.[m
[32m+[m[32m    bool Init();[m
[32m+[m
     /// Sync the index with the block index starting from the current best block.[m
     /// Intended to be run in its own thread, m_thread_sync, and can be[m
     /// interrupted with m_interrupt. Once the index gets in sync, the m_synced[m
[36m@@ -76,30 +83,32 @@[m [mprivate:[m
     /// getting corrupted.[m
     bool Commit();[m
 [m
[32m+[m[32m    /// Loop over disconnected blocks and call CustomRewind.[m
[32m+[m[32m    bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip);[m
[32m+[m
     virtual bool AllowPrune() const = 0;[m
 [m
 protected:[m
[32m+[m[32m    std::unique_ptr<interfaces::Chain> m_chain;[m
     CChainState* m_chainstate{nullptr};[m
 [m
     void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex) override;[m
 [m
     void ChainStateFlushed(const CBlockLocator& locator) override;[m
 [m
[31m-    const CBlockIndex* CurrentIndex() { return m_best_block_index.load(); };[m
[31m-[m
     /// Initialize internal state from the database and block index.[m
[31m-    [[nodiscard]] virtual bool Init();[m
[32m+[m[32m    [[nodiscard]] virtual bool CustomInit(const std::optional<interfaces::BlockKey>& block) { return true; }[m
 [m
     /// Write update index entries for a newly connected block.[m
[31m-    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }[m
[32m+[m[32m    [[nodiscard]] virtual bool CustomAppend(const interfaces::BlockInfo& block) { return true; }[m
 [m
     /// Virtual method called internally by Commit that can be overridden to atomically[m
     /// commit more index state.[m
[31m-    virtual bool CommitInternal(CDBBatch& batch);[m
[32m+[m[32m    virtual bool CustomCommit(CDBBatch& batch) { return true; }[m
 [m
     /// Rewind index to an earlier chain tip during a chain reorg. The tip must[m
     /// be an ancestor of the current best block.[m
[31m-    virtual bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip);[m
[32m+[m[32m    [[nodiscard]] virtual bool CustomRewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip) { return true; }[m
 [m
     virtual DB& GetDB() const = 0;[m
 [m
[36m@@ -110,6 +119,7 @@[m [mprotected:[m
     void SetBestBlockIndex(const CBlockIndex* block);[m
 [m
 public:[m
[32m+[m[32m    BaseIndex(std::unique_ptr<interfaces::Chain> chain);[m
     /// Destructor interrupts sync thread if running and blocks until it exits.[m
     virtual ~BaseIndex();[m
 [m
[36m@@ -124,7 +134,7 @@[m [mpublic:[m
 [m
     /// Start initializes the sync state and registers the instance as a[m
     /// ValidationInterface so that it stays in sync with blockchain updates.[m
[31m-    [[nodiscard]] bool Start(CChainState& active_chainstate);[m
[32m+[m[32m    [[nodiscard]] bool Start();[m
 [m
     /// Stops the instance from staying in sync with blockchain updates.[m
     void Stop();[m
[33mdiff --git a/src/index/blockfilterindex.cpp b/src/index/blockfilterindex.cpp[m
[33mindex c92b8c7e19..fad4897e66 100644[m
[33m--- a/src/index/blockfilterindex.cpp[m
[33m+++ b/src/index/blockfilterindex.cpp[m
[36m@@ -8,6 +8,7 @@[m
 #include <index/blockfilterindex.h>[m
 #include <node/blockstorage.h>[m
 #include <util/system.h>[m
[32m+[m[32m#include <validation.h>[m
 [m
 using node::UndoReadFromDisk;[m
 [m
[36m@@ -93,9 +94,9 @@[m [mstruct DBHashKey {[m
 [m
 static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;[m
 [m
[31m-BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32mBlockFilterIndex::BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, BlockFilterType filter_type,[m
                                    size_t n_cache_size, bool f_memory, bool f_wipe)[m
[31m-    : m_filter_type(filter_type)[m
[32m+[m[32m    : BaseIndex(std::move(chain)), m_filter_type(filter_type)[m
 {[m
     const std::string& filter_name = BlockFilterTypeName(filter_type);[m
     if (filter_name.empty()) throw std::invalid_argument("unknown filter_type");[m
[36m@@ -108,7 +109,7 @@[m [mBlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,[m
     m_filter_fileseq = std::make_unique<FlatFileSeq>(std::move(path), "fltr", FLTR_FILE_CHUNK_SIZE);[m
 }[m
 [m
[31m-bool BlockFilterIndex::Init()[m
[32m+[m[32mbool BlockFilterIndex::CustomInit(const std::optional<interfaces::BlockKey>& block)[m
 {[m
     if (!m_db->Read(DB_FILTER_POS, m_next_filter_pos)) {[m
         // Check that the cause of the read failure is that the key does not exist. Any other errors[m
[36m@@ -123,10 +124,10 @@[m [mbool BlockFilterIndex::Init()[m
         m_next_filter_pos.nFile = 0;[m
         m_next_filter_pos.nPos = 0;[m
     }[m
[31m-    return BaseIndex::Init();[m
[32m+[m[32m    return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::CommitInternal(CDBBatch& batch)[m
[32m+[m[32mbool BlockFilterIndex::CustomCommit(CDBBatch& batch)[m
 {[m
     const FlatFilePos& pos = m_next_filter_pos;[m
 [m
[36m@@ -140,7 +141,7 @@[m [mbool BlockFilterIndex::CommitInternal(CDBBatch& batch)[m
     }[m
 [m
     batch.Write(DB_FILTER_POS, pos);[m
[31m-    return BaseIndex::CommitInternal(batch);[m
[32m+[m[32m    return true;[m
 }[m
 [m
 bool BlockFilterIndex::ReadFilterFromDisk(const FlatFilePos& pos, BlockFilter& filter) const[m
[36m@@ -209,22 +210,25 @@[m [msize_t BlockFilterIndex::WriteFilterToDisk(FlatFilePos& pos, const BlockFilter&[m
     return data_size;[m
 }[m
 [m
[31m-bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool BlockFilterIndex::CustomAppend(const interfaces::BlockInfo& block)[m
 {[m
     CBlockUndo block_undo;[m
     uint256 prev_header;[m
 [m
[31m-    if (pindex->nHeight > 0) {[m
[32m+[m[32m    if (block.height > 0) {[m
[32m+[m[32m        // pindex variable gives indexing code access to node internals. It[m
[32m+[m[32m        // will be removed in upcoming commit[m
[32m+[m[32m        const CBlockIndex* pindex = WITH_LOCK(cs_main, return m_chainstate->m_blockman.LookupBlockIndex(block.hash));[m
         if (!UndoReadFromDisk(block_undo, pindex)) {[m
             return false;[m
         }[m
 [m
         std::pair<uint256, DBVal> read_out;[m
[31m-        if (!m_db->Read(DBHeightKey(pindex->nHeight - 1), read_out)) {[m
[32m+[m[32m        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {[m
             return false;[m
         }[m
 [m
[31m-        uint256 expected_block_hash = pindex->pprev->GetBlockHash();[m
[32m+[m[32m        uint256 expected_block_hash = *block.prev_hash;[m
         if (read_out.first != expected_block_hash) {[m
             return error("%s: previous block header belongs to unexpected block %s; expected %s",[m
                          __func__, read_out.first.ToString(), expected_block_hash.ToString());[m
[36m@@ -233,18 +237,18 @@[m [mbool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex[m
         prev_header = read_out.second.header;[m
     }[m
 [m
[31m-    BlockFilter filter(m_filter_type, block, block_undo);[m
[32m+[m[32m    BlockFilter filter(m_filter_type, *block.data, block_undo);[m
 [m
     size_t bytes_written = WriteFilterToDisk(m_next_filter_pos, filter);[m
     if (bytes_written == 0) return false;[m
 [m
     std::pair<uint256, DBVal> value;[m
[31m-    value.first = pindex->GetBlockHash();[m
[32m+[m[32m    value.first = block.hash;[m
     value.second.hash = filter.GetHash();[m
     value.second.header = filter.ComputeHeader(prev_header);[m
     value.second.pos = m_next_filter_pos;[m
 [m
[31m-    if (!m_db->Write(DBHeightKey(pindex->nHeight), value)) {[m
[32m+[m[32m    if (!m_db->Write(DBHeightKey(block.height), value)) {[m
         return false;[m
     }[m
 [m
[36m@@ -278,17 +282,15 @@[m [mstatic bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,[m
     return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)[m
[32m+[m[32mbool BlockFilterIndex::CustomRewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip)[m
 {[m
[31m-    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);[m
[31m-[m
     CDBBatch batch(*m_db);[m
     std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());[m
 [m
     // During a reorg, we need to copy all filters for blocks that are getting disconnected from the[m
     // height index to the hash index so we can still find them when the height index entries are[m
     // overwritten.[m
[31m-    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip->nHeight, current_tip->nHeight)) {[m
[32m+[m[32m    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip.height, current_tip.height)) {[m
         return false;[m
     }[m
 [m
[36m@@ -298,7 +300,7 @@[m [mbool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex*[m
     batch.Write(DB_FILTER_POS, m_next_filter_pos);[m
     if (!m_db->WriteBatch(batch)) return false;[m
 [m
[31m-    return BaseIndex::Rewind(current_tip, new_tip);[m
[32m+[m[32m    return true;[m
 }[m
 [m
 static bool LookupOne(const CDBWrapper& db, const CBlockIndex* block_index, DBVal& result)[m
[36m@@ -462,12 +464,12 @@[m [mvoid ForEachBlockFilterIndex(std::function<void (BlockFilterIndex&)> fn)[m
     for (auto& entry : g_filter_indexes) fn(entry.second);[m
 }[m
 [m
[31m-bool InitBlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32mbool InitBlockFilterIndex(std::function<std::unique_ptr<interfaces::Chain>()> make_chain, BlockFilterType filter_type,[m
                           size_t n_cache_size, bool f_memory, bool f_wipe)[m
 {[m
     auto result = g_filter_indexes.emplace(std::piecewise_construct,[m
                                            std::forward_as_tuple(filter_type),[m
[31m-                                           std::forward_as_tuple(filter_type,[m
[32m+[m[32m                                           std::forward_as_tuple(make_chain(), filter_type,[m
                                                                  n_cache_size, f_memory, f_wipe));[m
     return result.second;[m
 }[m
[33mdiff --git a/src/index/blockfilterindex.h b/src/index/blockfilterindex.h[m
[33mindex 6deff59000..6bfc59688b 100644[m
[33m--- a/src/index/blockfilterindex.h[m
[33m+++ b/src/index/blockfilterindex.h[m
[36m@@ -41,13 +41,13 @@[m [mprivate:[m
     bool AllowPrune() const override { return true; }[m
 [m
 protected:[m
[31m-    bool Init() override;[m
[32m+[m[32m    bool CustomInit(const std::optional<interfaces::BlockKey>& block) override;[m
 [m
[31m-    bool CommitInternal(CDBBatch& batch) override;[m
[32m+[m[32m    bool CustomCommit(CDBBatch& batch) override;[m
 [m
[31m-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    bool CustomAppend(const interfaces::BlockInfo& block) override;[m
 [m
[31m-    bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip) override;[m
[32m+[m[32m    bool CustomRewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip) override;[m
 [m
     BaseIndex::DB& GetDB() const override { return *m_db; }[m
 [m
[36m@@ -55,7 +55,7 @@[m [mprotected:[m
 [m
 public:[m
     /** Constructs the index, which becomes available to be queried. */[m
[31m-    explicit BlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32m    explicit BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, BlockFilterType filter_type,[m
                               size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
     BlockFilterType GetFilterType() const { return m_filter_type; }[m
[36m@@ -88,7 +88,7 @@[m [mvoid ForEachBlockFilterIndex(std::function<void (BlockFilterIndex&)> fn);[m
  * Initialize a block filter index for the given type if one does not already exist. Returns true if[m
  * a new index is created and false if one has already been initialized.[m
  */[m
[31m-bool InitBlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32mbool InitBlockFilterIndex(std::function<std::unique_ptr<interfaces::Chain>()> make_chain, BlockFilterType filter_type,[m
                           size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
 /**[m
[33mdiff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp[m
[33mindex 687e330fe0..89717fc4f7 100644[m
[33m--- a/src/index/coinstatsindex.cpp[m
[33m+++ b/src/index/coinstatsindex.cpp[m
[36m@@ -102,7 +102,7 @@[m [mstruct DBHashKey {[m
 [m
 std::unique_ptr<CoinStatsIndex> g_coin_stats_index;[m
 [m
[31m-CoinStatsIndex::CoinStatsIndex(size_t n_cache_size, bool f_memory, bool f_wipe)[m
[32m+[m[32mCoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe) : BaseIndex(std::move(chain))[m
 {[m
     fs::path path{gArgs.GetDataDirNet() / "indexes" / "coinstats"};[m
     fs::create_directories(path);[m
[36m@@ -110,24 +110,27 @@[m [mCoinStatsIndex::CoinStatsIndex(size_t n_cache_size, bool f_memory, bool f_wipe)[m
     m_db = std::make_unique<CoinStatsIndex::DB>(path / "db", n_cache_size, f_memory, f_wipe);[m
 }[m
 [m
[31m-bool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)[m
 {[m
     CBlockUndo block_undo;[m
[31m-    const CAmount block_subsidy{GetBlockSubsidy(pindex->nHeight, Params().GetConsensus())};[m
[32m+[m[32m    const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};[m
     m_total_subsidy += block_subsidy;[m
 [m
     // Ignore genesis block[m
[31m-    if (pindex->nHeight > 0) {[m
[32m+[m[32m    if (block.height > 0) {[m
[32m+[m[32m        // pindex variable gives indexing code access to node internals. It[m
[32m+[m[32m        // will be removed in upcoming commit[m
[32m+[m[32m        const CBlockIndex* pindex = WITH_LOCK(cs_main, return m_chainstate->m_blockman.LookupBlockIndex(block.hash));[m
         if (!UndoReadFromDisk(block_undo, pindex)) {[m
             return false;[m
         }[m
 [m
         std::pair<uint256, DBVal> read_out;[m
[31m-        if (!m_db->Read(DBHeightKey(pindex->nHeight - 1), read_out)) {[m
[32m+[m[32m        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {[m
             return false;[m
         }[m
 [m
[31m-        uint256 expected_block_hash{pindex->pprev->GetBlockHash()};[m
[32m+[m[32m        uint256 expected_block_hash{*block.prev_hash};[m
         if (read_out.first != expected_block_hash) {[m
             LogPrintf("WARNING: previous block header belongs to unexpected block %s; expected %s\n",[m
                       read_out.first.ToString(), expected_block_hash.ToString());[m
[36m@@ -139,12 +142,13 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
         }[m
 [m
         // TODO: Deduplicate BIP30 related code[m
[31m-        bool is_bip30_block{(pindex->nHeight == 91722 && pindex->GetBlockHash() == uint256S("0x00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")) ||[m
[31m-                            (pindex->nHeight == 91812 && pindex->GetBlockHash() == uint256S("0x00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"))};[m
[32m+[m[32m        bool is_bip30_block{(block.height == 91722 && block.hash == uint256S("0x00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")) ||[m
[32m+[m[32m                            (block.height == 91812 && block.hash == uint256S("0x00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"))};[m
 [m
         // Add the new utxos created from the block[m
[31m-        for (size_t i = 0; i < block.vtx.size(); ++i) {[m
[31m-            const auto& tx{block.vtx.at(i)};[m
[32m+[m[32m        assert(block.data);[m
[32m+[m[32m        for (size_t i = 0; i < block.data->vtx.size(); ++i) {[m
[32m+[m[32m            const auto& tx{block.data->vtx.at(i)};[m
 [m
             // Skip duplicate txid coinbase transactions (BIP30).[m
             if (is_bip30_block && tx->IsCoinBase()) {[m
[36m@@ -155,7 +159,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
 [m
             for (uint32_t j = 0; j < tx->vout.size(); ++j) {[m
                 const CTxOut& out{tx->vout[j]};[m
[31m-                Coin coin{out, pindex->nHeight, tx->IsCoinBase()};[m
[32m+[m[32m                Coin coin{out, block.height, tx->IsCoinBase()};[m
                 COutPoint outpoint{tx->GetHash(), j};[m
 [m
                 // Skip unspendable coins[m
[36m@@ -211,7 +215,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
     m_total_unspendables_unclaimed_rewards += unclaimed_rewards;[m
 [m
     std::pair<uint256, DBVal> value;[m
[31m-    value.first = pindex->GetBlockHash();[m
[32m+[m[32m    value.first = block.hash;[m
     value.second.transaction_output_count = m_transaction_output_count;[m
     value.second.bogo_size = m_bogo_size;[m
     value.second.total_amount = m_total_amount;[m
[36m@@ -231,7 +235,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
 [m
     // Intentionally do not update DB_MUHASH here so it stays in sync with[m
     // DB_BEST_BLOCK, and the index is not corrupted if there is an unclean shutdown.[m
[31m-    return m_db->Write(DBHeightKey(pindex->nHeight), value);[m
[32m+[m[32m    return m_db->Write(DBHeightKey(block.height), value);[m
 }[m
 [m
 static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,[m
[36m@@ -260,17 +264,15 @@[m [mstatic bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,[m
     return true;[m
 }[m
 [m
[31m-bool CoinStatsIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)[m
[32m+[m[32mbool CoinStatsIndex::CustomRewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip)[m
 {[m
[31m-    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);[m
[31m-[m
     CDBBatch batch(*m_db);[m
     std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());[m
 [m
     // During a reorg, we need to copy all hash digests for blocks that are[m
     // getting disconnected from the height index to the hash index so we can[m
     // still find them when the height index entries are overwritten.[m
[31m-    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip->nHeight, current_tip->nHeight)) {[m
[32m+[m[32m    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip.height, current_tip.height)) {[m
         return false;[m
     }[m
 [m
[36m@@ -278,7 +280,8 @@[m [mbool CoinStatsIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* n[m
 [m
     {[m
         LOCK(cs_main);[m
[31m-        const CBlockIndex* iter_tip{m_chainstate->m_blockman.LookupBlockIndex(current_tip->GetBlockHash())};[m
[32m+[m[32m        const CBlockIndex* iter_tip{m_chainstate->m_blockman.LookupBlockIndex(current_tip.hash)};[m
[32m+[m[32m        const CBlockIndex* new_tip_index{m_chainstate->m_blockman.LookupBlockIndex(new_tip.hash)};[m
         const auto& consensus_params{Params().GetConsensus()};[m
 [m
         do {[m
[36m@@ -292,29 +295,29 @@[m [mbool CoinStatsIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* n[m
             ReverseBlock(block, iter_tip);[m
 [m
             iter_tip = iter_tip->GetAncestor(iter_tip->nHeight - 1);[m
[31m-        } while (new_tip != iter_tip);[m
[32m+[m[32m        } while (new_tip_index != iter_tip);[m
     }[m
 [m
[31m-    return BaseIndex::Rewind(current_tip, new_tip);[m
[32m+[m[32m    return true;[m
 }[m
 [m
[31m-static bool LookUpOne(const CDBWrapper& db, const CBlockIndex* block_index, DBVal& result)[m
[32m+[m[32mstatic bool LookUpOne(const CDBWrapper& db, const interfaces::BlockKey& block, DBVal& result)[m
 {[m
     // First check if the result is stored under the height index and the value[m
     // there matches the block hash. This should be the case if the block is on[m
     // the active chain.[m
     std::pair<uint256, DBVal> read_out;[m
[31m-    if (!db.Read(DBHeightKey(block_index->nHeight), read_out)) {[m
[32m+[m[32m    if (!db.Read(DBHeightKey(block.height), read_out)) {[m
         return false;[m
     }[m
[31m-    if (read_out.first == block_index->GetBlockHash()) {[m
[32m+[m[32m    if (read_out.first == block.hash) {[m
         result = std::move(read_out.second);[m
         return true;[m
     }[m
 [m
     // If value at the height index corresponds to an different block, the[m
     // result will be stored in the hash index.[m
[31m-    return db.Read(DBHashKey(block_index->GetBlockHash()), result);[m
[32m+[m[32m    return db.Read(DBHashKey(block.hash), result);[m
 }[m
 [m
 std::optional<CCoinsStats> CoinStatsIndex::LookUpStats(const CBlockIndex* block_index) const[m
[36m@@ -323,7 +326,7 @@[m [mstd::optional<CCoinsStats> CoinStatsIndex::LookUpStats(const CBlockIndex* block_[m
     stats.index_used = true;[m
 [m
     DBVal entry;[m
[31m-    if (!LookUpOne(*m_db, block_index, entry)) {[m
[32m+[m[32m    if (!LookUpOne(*m_db, {block_index->GetBlockHash(), block_index->nHeight}, entry)) {[m
         return std::nullopt;[m
     }[m
 [m
[36m@@ -344,7 +347,7 @@[m [mstd::optional<CCoinsStats> CoinStatsIndex::LookUpStats(const CBlockIndex* block_[m
     return stats;[m
 }[m
 [m
[31m-bool CoinStatsIndex::Init()[m
[32m+[m[32mbool CoinStatsIndex::CustomInit(const std::optional<interfaces::BlockKey>& block)[m
 {[m
     if (!m_db->Read(DB_MUHASH, m_muhash)) {[m
         // Check that the cause of the read failure is that the key does not[m
[36m@@ -356,13 +359,9 @@[m [mbool CoinStatsIndex::Init()[m
         }[m
     }[m
 [m
[31m-    if (!BaseIndex::Init()) return false;[m
[31m-[m
[31m-    const CBlockIndex* pindex{CurrentIndex()};[m
[31m-[m
[31m-    if (pindex) {[m
[32m+[m[32m    if (block) {[m
         DBVal entry;[m
[31m-        if (!LookUpOne(*m_db, pindex, entry)) {[m
[32m+[m[32m        if (!LookUpOne(*m_db, *block, entry)) {[m
             return error("%s: Cannot read current %s state; index may be corrupted",[m
                          __func__, GetName());[m
         }[m
[36m@@ -391,12 +390,12 @@[m [mbool CoinStatsIndex::Init()[m
     return true;[m
 }[m
 [m
[31m-bool CoinStatsIndex::CommitInternal(CDBBatch& batch)[m
[32m+[m[32mbool CoinStatsIndex::CustomCommit(CDBBatch& batch)[m
 {[m
     // DB_MUHASH should always be committed in a batch together with DB_BEST_BLOCK[m
     // to prevent an inconsistent state of the DB.[m
     batch.Write(DB_MUHASH, m_muhash);[m
[31m-    return BaseIndex::CommitInternal(batch);[m
[32m+[m[32m    return true;[m
 }[m
 [m
 // Reverse a single block as part of a reorg[m
[33mdiff --git a/src/index/coinstatsindex.h b/src/index/coinstatsindex.h[m
[33mindex cae052d913..c4af223388 100644[m
[33m--- a/src/index/coinstatsindex.h[m
[33m+++ b/src/index/coinstatsindex.h[m
[36m@@ -39,13 +39,13 @@[m [mprivate:[m
     bool AllowPrune() const override { return true; }[m
 [m
 protected:[m
[31m-    bool Init() override;[m
[32m+[m[32m    bool CustomInit(const std::optional<interfaces::BlockKey>& block) override;[m
 [m
[31m-    bool CommitInternal(CDBBatch& batch) override;[m
[32m+[m[32m    bool CustomCommit(CDBBatch& batch) override;[m
 [m
[31m-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    bool CustomAppend(const interfaces::BlockInfo& block) override;[m
 [m
[31m-    bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip) override;[m
[32m+[m[32m    bool CustomRewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip) override;[m
 [m
     BaseIndex::DB& GetDB() const override { return *m_db; }[m
 [m
[36m@@ -53,7 +53,7 @@[m [mprotected:[m
 [m
 public:[m
     // Constructs the index, which becomes available to be queried.[m
[31m-    explicit CoinStatsIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
[32m+[m[32m    explicit CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
     // Look up stats for a specific block using CBlockIndex[m
     std::optional<kernel::CCoinsStats> LookUpStats(const CBlockIndex* block_index) const;[m
[33mdiff --git a/src/index/txindex.cpp b/src/index/txindex.cpp[m
[33mindex 97c11c4383..b719aface8 100644[m
[33m--- a/src/index/txindex.cpp[m
[33m+++ b/src/index/txindex.cpp[m
[36m@@ -48,23 +48,22 @@[m [mbool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_[m
     return WriteBatch(batch);[m
 }[m
 [m
[31m-TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)[m
[31m-    : m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))[m
[32m+[m[32mTxIndex::TxIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe)[m
[32m+[m[32m    : BaseIndex(std::move(chain)), m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))[m
 {}[m
 [m
 TxIndex::~TxIndex() = default;[m
 [m
[31m-bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool TxIndex::CustomAppend(const interfaces::BlockInfo& block)[m
 {[m
     // Exclude genesis block transaction because outputs are not spendable.[m
[31m-    if (pindex->nHeight == 0) return true;[m
[32m+[m[32m    if (block.height == 0) return true;[m
 [m
[31m-    CDiskTxPos pos{[m
[31m-        WITH_LOCK(::cs_main, return pindex->GetBlockPos()),[m
[31m-        GetSizeOfCompactSize(block.vtx.size())};[m
[32m+[m[32m    assert(block.data);[m
[32m+[m[32m    CDiskTxPos pos({block.file_number, block.data_pos}, GetSizeOfCompactSize(block.data->vtx.size()));[m
     std::vector<std::pair<uint256, CDiskTxPos>> vPos;[m
[31m-    vPos.reserve(block.vtx.size());[m
[31m-    for (const auto& tx : block.vtx) {[m
[32m+[m[32m    vPos.reserve(block.data->vtx.size());[m
[32m+[m[32m    for (const auto& tx : block.data->vtx) {[m
         vPos.emplace_back(tx->GetHash(), pos);[m
         pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);[m
     }[m
[33mdiff --git a/src/index/txindex.h b/src/index/txindex.h[m
[33mindex ec339abaa1..be240c4582 100644[m
[33m--- a/src/index/txindex.h[m
[33m+++ b/src/index/txindex.h[m
[36m@@ -23,7 +23,7 @@[m [mprivate:[m
     bool AllowPrune() const override { return false; }[m
 [m
 protected:[m
[31m-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    bool CustomAppend(const interfaces::BlockInfo& block) override;[m
 [m
     BaseIndex::DB& GetDB() const override;[m
 [m
[36m@@ -31,7 +31,7 @@[m [mprotected:[m
 [m
 public:[m
     /// Constructs the index, which becomes available to be queried.[m
[31m-    explicit TxIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
[32m+[m[32m    explicit TxIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
     // Destructor is declared because this class contains a unique_ptr to an incomplete type.[m
     virtual ~TxIndex() override;[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex f20c55dcb1..bdfc2fb6c6 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -1579,22 +1579,22 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
             return InitError(*error);[m
         }[m
 [m
[31m-        g_txindex = std::make_unique<TxIndex>(cache_sizes.tx_index, false, fReindex);[m
[31m-        if (!g_txindex->Start(chainman.ActiveChainstate())) {[m
[32m+[m[32m        g_txindex = std::make_unique<TxIndex>(interfaces::MakeChain(node), cache_sizes.tx_index, false, fReindex);[m
[32m+[m[32m        if (!g_txindex->Start()) {[m
             return false;[m
         }[m
     }[m
 [m
     for (const auto& filter_type : g_enabled_filter_types) {[m
[31m-        InitBlockFilterIndex(filter_type, cache_sizes.filter_index, false, fReindex);[m
[31m-        if (!GetBlockFilterIndex(filter_type)->Start(chainman.ActiveChainstate())) {[m
[32m+[m[32m        InitBlockFilterIndex([&]{ return interfaces::MakeChain(node); }, filter_type, cache_sizes.filter_index, false, fReindex);[m
[32m+[m[32m        if (!GetBlockFilterIndex(filter_type)->Start()) {[m
             return false;[m
         }[m
     }[m
 [m
     if (args.GetBoolArg("-coinstatsindex", DEFAULT_COINSTATSINDEX)) {[m
[31m-        g_coin_stats_index = std::make_unique<CoinStatsIndex>(/* cache size */ 0, false, fReindex);[m
[31m-        if (!g_coin_stats_index->Start(chainman.ActiveChainstate())) {[m
[32m+[m[32m        g_coin_stats_index = std::make_unique<CoinStatsIndex>(interfaces::MakeChain(node), /* cache size */ 0, false, fReindex);[m
[32m+[m[32m        if (!g_coin_stats_index->Start()) {[m
             return false;[m
         }[m
     }[m
[33mdiff --git a/src/interfaces/chain.h b/src/interfaces/chain.h[m
[33mindex ddfb4bda95..1e5c4f13ba 100644[m
[33m--- a/src/interfaces/chain.h[m
[33m+++ b/src/interfaces/chain.h[m
[36m@@ -18,6 +18,7 @@[m
 [m
 class ArgsManager;[m
 class CBlock;[m
[32m+[m[32mclass CBlockUndo;[m
 class CFeeRate;[m
 class CRPCCommand;[m
 class CScheduler;[m
[36m@@ -37,6 +38,12 @@[m [mnamespace interfaces {[m
 class Handler;[m
 class Wallet;[m
 [m
[32m+[m[32m//! Hash/height pair to help track and identify blocks.[m
[32m+[m[32mstruct BlockKey {[m
[32m+[m[32m    uint256 hash;[m
[32m+[m[32m    int height = -1;[m
[32m+[m[32m};[m
[32m+[m
 //! Helper for findBlock to selectively return pieces of block data. If block is[m
 //! found, data will be returned by setting specified output variables. If block[m
 //! is not found, output variables will keep their previous values.[m
[36m@@ -50,6 +57,8 @@[m [mpublic:[m
     FoundBlock& mtpTime(int64_t& mtp_time) { m_mtp_time = &mtp_time; return *this; }[m
     //! Return whether block is in the active (most-work) chain.[m
     FoundBlock& inActiveChain(bool& in_active_chain) { m_in_active_chain = &in_active_chain; return *this; }[m
[32m+[m[32m    //! Return locator if block is in the active chain.[m
[32m+[m[32m    FoundBlock& locator(CBlockLocator& locator) { m_locator = &locator; return *this; }[m
     //! Return next block in the active chain if current block is in the active chain.[m
     FoundBlock& nextBlock(const FoundBlock& next_block) { m_next_block = &next_block; return *this; }[m
     //! Read block data from disk. If the block exists but doesn't have data[m
[36m@@ -62,11 +71,25 @@[m [mpublic:[m
     int64_t* m_max_time = nullptr;[m
     int64_t* m_mtp_time = nullptr;[m
     bool* m_in_active_chain = nullptr;[m
[32m+[m[32m    CBlockLocator* m_locator = nullptr;[m
     const FoundBlock* m_next_block = nullptr;[m
     CBlock* m_data = nullptr;[m
     mutable bool found = false;[m
 };[m
 [m
[32m+[m[32m//! Block data sent with blockConnected, blockDisconnected notifications.[m
[32m+[m[32mstruct BlockInfo {[m
[32m+[m[32m    const uint256& hash;[m
[32m+[m[32m    const uint256* prev_hash = nullptr;[m
[32m+[m[32m    int height = -1;[m
[32m+[m[32m    int file_number = -1;[m
[32m+[m[32m    unsigned data_pos = 0;[m
[32m+[m[32m    const CBlock* data = nullptr;[m
[32m+[m[32m    const CBlockUndo* undo_data = nullptr;[m
[32m+[m
[32m+[m[32m    BlockInfo(const uint256& hash) : hash(hash) {}[m
[32m+[m[32m};[m
[32m+[m
 //! Interface giving clients (wallet processes, maybe other analysis tools in[m
 //! the future) ability to access to the chain state, receive notifications,[m
 //! estimate fees, and submit transactions.[m
[36m@@ -235,8 +258,8 @@[m [mpublic:[m
         virtual ~Notifications() {}[m
         virtual void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}[m
         virtual void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}[m
[31m-        virtual void blockConnected(const CBlock& block, int height) {}[m
[31m-        virtual void blockDisconnected(const CBlock& block, int height) {}[m
[32m+[m[32m        virtual void blockConnected(const BlockInfo& block) {}[m
[32m+[m[32m        virtual void blockDisconnected(const BlockInfo& block) {}[m
         virtual void updatedBlockTip() {}[m
         virtual void chainStateFlushed(const CBlockLocator& locator) {}[m
     };[m
[36m@@ -283,6 +306,10 @@[m [mpublic:[m
     //! to be prepared to handle this by ignoring notifications about unknown[m
     //! removed transactions and already added new transactions.[m
     virtual void requestMempoolTransactions(Notifications& notifications) = 0;[m
[32m+[m
[32m+[m[32m    //! Get internal node context. Useful for testing, but not[m
[32m+[m[32m    //! accessible across processes.[m
[32m+[m[32m    virtual node::NodeContext* context() { return nullptr; }[m
 };[m
 [m
 //! Interface to let node manage chain clients (wallets, or maybe tools for[m
[33mdiff --git a/src/node/chain.cpp b/src/node/chain.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..b43b1f7fe5[m
[33m--- /dev/null[m
[33m+++ b/src/node/chain.cpp[m
[36m@@ -0,0 +1,23 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <chain.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
[32m+[m[32m#include <uint256.h>[m
[32m+[m
[32m+[m[32mnamespace node {[m
[32m+[m[32minterfaces::BlockInfo MakeBlockInfo(const CBlockIndex* index, const CBlock* data)[m
[32m+[m[32m{[m
[32m+[m[32m    interfaces::BlockInfo info{index ? *index->phashBlock : uint256::ZERO};[m
[32m+[m[32m    if (index) {[m
[32m+[m[32m        info.prev_hash = index->pprev ? index->pprev->phashBlock : nullptr;[m
[32m+[m[32m        info.height = index->nHeight;[m
[32m+[m[32m        LOCK(::cs_main);[m
[32m+[m[32m        info.file_number = index->nFile;[m
[32m+[m[32m        info.data_pos = index->nDataPos;[m
[32m+[m[32m    }[m
[32m+[m[32m    info.data = data;[m
[32m+[m[32m    return info;[m
[32m+[m[32m}[m
[32m+[m[32m} // namespace node[m
[33mdiff --git a/src/node/chain.h b/src/node/chain.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..cc8f008987[m
[33m--- /dev/null[m
[33m+++ b/src/node/chain.h[m
[36m@@ -0,0 +1,19 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_NODE_CHAIN_H[m
[32m+[m[32m#define BITCOIN_NODE_CHAIN_H[m
[32m+[m
[32m+[m[32mclass CBlock;[m
[32m+[m[32mclass CBlockIndex;[m
[32m+[m[32mnamespace interfaces {[m
[32m+[m[32mstruct BlockInfo;[m
[32m+[m[32m} // namespace interfaces[m
[32m+[m
[32m+[m[32mnamespace node {[m
[32m+[m[32m//! Return data from block index.[m
[32m+[m[32minterfaces::BlockInfo MakeBlockInfo(const CBlockIndex* block_index, const CBlock* data = nullptr);[m
[32m+[m[32m} // namespace node[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_NODE_CHAIN_H[m
[33mdiff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp[m
[33mindex 1905a4df29..f99f4632a0 100644[m
[33m--- a/src/node/interfaces.cpp[m
[33m+++ b/src/node/interfaces.cpp[m
[36m@@ -19,6 +19,7 @@[m
 #include <netaddress.h>[m
 #include <netbase.h>[m
 #include <node/blockstorage.h>[m
[32m+[m[32m#include <node/chain.h>[m
 #include <node/coin.h>[m
 #include <node/context.h>[m
 #include <node/transaction.h>[m
[36m@@ -401,6 +402,7 @@[m [mbool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec[m
     if (block.m_max_time) *block.m_max_time = index->GetBlockTimeMax();[m
     if (block.m_mtp_time) *block.m_mtp_time = index->GetMedianTimePast();[m
     if (block.m_in_active_chain) *block.m_in_active_chain = active[index->nHeight] == index;[m
[32m+[m[32m    if (block.m_locator) { *block.m_locator = active.GetLocator(index); }[m
     if (block.m_next_block) FillBlock(active[index->nHeight] == index ? active[index->nHeight + 1] : nullptr, *block.m_next_block, lock, active);[m
     if (block.m_data) {[m
         REVERSE_LOCK(lock);[m
[36m@@ -426,11 +428,11 @@[m [mpublic:[m
     }[m
     void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override[m
     {[m
[31m-        m_notifications->blockConnected(*block, index->nHeight);[m
[32m+[m[32m        m_notifications->blockConnected(node::MakeBlockInfo(index, block.get()));[m
     }[m
     void BlockDisconnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override[m
     {[m
[31m-        m_notifications->blockDisconnected(*block, index->nHeight);[m
[32m+[m[32m        m_notifications->blockDisconnected(node::MakeBlockInfo(index, block.get()));[m
     }[m
     void UpdatedBlockTip(const CBlockIndex* index, const CBlockIndex* fork_index, bool is_ibd) override[m
     {[m
[36m@@ -767,6 +769,7 @@[m [mpublic:[m
             notifications.transactionAddedToMempool(entry.GetSharedTx(), 0 /* mempool_sequence */);[m
         }[m
     }[m
[32m+[m[32m    NodeContext* context() override { return &m_node; }[m
     NodeContext& m_node;[m
 };[m
 } // namespace[m
[33mdiff --git a/src/test/blockfilter_index_tests.cpp b/src/test/blockfilter_index_tests.cpp[m
[33mindex ba1eacfc78..48b8a08516 100644[m
[33m--- a/src/test/blockfilter_index_tests.cpp[m
[33m+++ b/src/test/blockfilter_index_tests.cpp[m
[36m@@ -7,6 +7,7 @@[m
 #include <consensus/merkle.h>[m
 #include <consensus/validation.h>[m
 #include <index/blockfilterindex.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <node/miner.h>[m
 #include <pow.h>[m
 #include <script/standard.h>[m
[36m@@ -110,7 +111,7 @@[m [mbool BuildChainTestingSetup::BuildChain(const CBlockIndex* pindex,[m
 [m
 BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)[m
 {[m
[31m-    BlockFilterIndex filter_index(BlockFilterType::BASIC, 1 << 20, true);[m
[32m+[m[32m    BlockFilterIndex filter_index(interfaces::MakeChain(m_node), BlockFilterType::BASIC, 1 << 20, true);[m
 [m
     uint256 last_header;[m
 [m
[36m@@ -137,7 +138,7 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)[m
     // BlockUntilSyncedToCurrentChain should return false before index is started.[m
     BOOST_CHECK(!filter_index.BlockUntilSyncedToCurrentChain());[m
 [m
[31m-    BOOST_REQUIRE(filter_index.Start(m_node.chainman->ActiveChainstate()));[m
[32m+[m[32m    BOOST_REQUIRE(filter_index.Start());[m
 [m
     // Allow filter index to catch up with the block index.[m
     constexpr int64_t timeout_ms = 10 * 1000;[m
[36m@@ -279,14 +280,14 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_init_destroy, BasicTestingSetup)[m
     filter_index = GetBlockFilterIndex(BlockFilterType::BASIC);[m
     BOOST_CHECK(filter_index == nullptr);[m
 [m
[31m-    BOOST_CHECK(InitBlockFilterIndex(BlockFilterType::BASIC, 1 << 20, true, false));[m
[32m+[m[32m    BOOST_CHECK(InitBlockFilterIndex([&]{ return interfaces::MakeChain(m_node); }, BlockFilterType::BASIC, 1 << 20, true, false));[m
 [m
     filter_index = GetBlockFilterIndex(BlockFilterType::BASIC);[m
     BOOST_CHECK(filter_index != nullptr);[m
     BOOST_CHECK(filter_index->GetFilterType() == BlockFilterType::BASIC);[m
 [m
     // Initialize returns false if index already exists.[m
[31m-    BOOST_CHECK(!InitBlockFilterIndex(BlockFilterType::BASIC, 1 << 20, true, false));[m
[32m+[m[32m    BOOST_CHECK(!InitBlockFilterIndex([&]{ return interfaces::MakeChain(m_node); }, BlockFilterType::BASIC, 1 << 20, true, false));[m
 [m
     int iter_count = 0;[m
     ForEachBlockFilterIndex([&iter_count](BlockFilterIndex& _index) { iter_count++; });[m
[36m@@ -301,7 +302,7 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_init_destroy, BasicTestingSetup)[m
     BOOST_CHECK(filter_index == nullptr);[m
 [m
     // Reinitialize index.[m
[31m-    BOOST_CHECK(InitBlockFilterIndex(BlockFilterType::BASIC, 1 << 20, true, false));[m
[32m+[m[32m    BOOST_CHECK(InitBlockFilterIndex([&]{ return interfaces::MakeChain(m_node); }, BlockFilterType::BASIC, 1 << 20, true, false));[m
 [m
     DestroyAllBlockFilterIndexes();[m
 [m
[33mdiff --git a/src/test/coinstatsindex_tests.cpp b/src/test/coinstatsindex_tests.cpp[m
[33mindex 50eb479035..4777ce46a9 100644[m
[33m--- a/src/test/coinstatsindex_tests.cpp[m
[33m+++ b/src/test/coinstatsindex_tests.cpp[m
[36m@@ -4,6 +4,7 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/coinstatsindex.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <test/util/setup_common.h>[m
 #include <test/util/validation.h>[m
 #include <util/time.h>[m
[36m@@ -31,7 +32,7 @@[m [mstatic void IndexWaitSynced(BaseIndex& index)[m
 [m
 BOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)[m
 {[m
[31m-    CoinStatsIndex coin_stats_index{1 << 20, true};[m
[32m+[m[32m    CoinStatsIndex coin_stats_index{interfaces::MakeChain(m_node), 1 << 20, true};[m
 [m
     const CBlockIndex* block_index;[m
     {[m
[36m@@ -46,7 +47,7 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)[m
     // is started.[m
     BOOST_CHECK(!coin_stats_index.BlockUntilSyncedToCurrentChain());[m
 [m
[31m-    BOOST_REQUIRE(coin_stats_index.Start(m_node.chainman->ActiveChainstate()));[m
[32m+[m[32m    BOOST_REQUIRE(coin_stats_index.Start());[m
 [m
     IndexWaitSynced(coin_stats_index);[m
 [m
[36m@@ -90,8 +91,8 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)[m
     CChainState& chainstate = Assert(m_node.chainman)->ActiveChainstate();[m
     const CChainParams& params = Params();[m
     {[m
[31m-        CoinStatsIndex index{1 << 20};[m
[31m-        BOOST_REQUIRE(index.Start(chainstate));[m
[32m+[m[32m        CoinStatsIndex index{interfaces::MakeChain(m_node), 1 << 20};[m
[32m+[m[32m        BOOST_REQUIRE(index.Start());[m
         IndexWaitSynced(index);[m
         std::shared_ptr<const CBlock> new_block;[m
         CBlockIndex* new_block_index = nullptr;[m
[36m@@ -116,9 +117,9 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)[m
     }[m
 [m
     {[m
[31m-        CoinStatsIndex index{1 << 20};[m
[32m+[m[32m        CoinStatsIndex index{interfaces::MakeChain(m_node), 1 << 20};[m
         // Make sure the index can be loaded.[m
[31m-        BOOST_REQUIRE(index.Start(chainstate));[m
[32m+[m[32m        BOOST_REQUIRE(index.Start());[m
         index.Stop();[m
     }[m
 }[m
[33mdiff --git a/src/test/txindex_tests.cpp b/src/test/txindex_tests.cpp[m
[33mindex 15213f826b..62c7ddb673 100644[m
[33m--- a/src/test/txindex_tests.cpp[m
[33m+++ b/src/test/txindex_tests.cpp[m
[36m@@ -4,6 +4,7 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/txindex.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <script/standard.h>[m
 #include <test/util/setup_common.h>[m
 #include <util/time.h>[m
[36m@@ -15,7 +16,7 @@[m [mBOOST_AUTO_TEST_SUITE(txindex_tests)[m
 [m
 BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)[m
 {[m
[31m-    TxIndex txindex(1 << 20, true);[m
[32m+[m[32m    TxIndex txindex(interfaces::MakeChain(m_node), 1 << 20, true);[m
 [m
     CTransactionRef tx_disk;[m
     uint256 block_hash;[m
[36m@@ -28,7 +29,7 @@[m [mBOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)[m
     // BlockUntilSyncedToCurrentChain should return false before txindex is started.[m
     BOOST_CHECK(!txindex.BlockUntilSyncedToCurrentChain());[m
 [m
[31m-    BOOST_REQUIRE(txindex.Start(m_node.chainman->ActiveChainstate()));[m
[32m+[m[32m    BOOST_REQUIRE(txindex.Start());[m
 [m
     // Allow tx index to catch up with the block index.[m
     constexpr int64_t timeout_ms = 10 * 1000;[m
[33mdiff --git a/src/wallet/test/fuzz/notifications.cpp b/src/wallet/test/fuzz/notifications.cpp[m
[33mindex 9089c8ff46..46f8b61f4b 100644[m
[33m--- a/src/wallet/test/fuzz/notifications.cpp[m
[33m+++ b/src/wallet/test/fuzz/notifications.cpp[m
[36m@@ -138,8 +138,14 @@[m [mFUZZ_TARGET_INIT(wallet_notifications, initialize_setup)[m
                     block.vtx.emplace_back(MakeTransactionRef(tx));[m
                 }[m
                 // Mine block[m
[31m-                a.wallet->blockConnected(block, chain.size());[m
[31m-                b.wallet->blockConnected(block, chain.size());[m
[32m+[m[32m                const uint256& hash = block.GetHash();[m
[32m+[m[32m                const uint256& prev_hash = std::get<1>(chain.back()).GetHash();[m
[32m+[m[32m                interfaces::BlockInfo info{hash};[m
[32m+[m[32m                info.prev_hash = &prev_hash;[m
[32m+[m[32m                info.height = chain.size();[m
[32m+[m[32m                info.data = &block;[m
[32m+[m[32m                a.wallet->blockConnected(info);[m
[32m+[m[32m                b.wallet->blockConnected(info);[m
                 // Store the coins for the next block[m
                 Coins coins_new;[m
                 for (const auto& tx : block.vtx) {[m
[36m@@ -155,8 +161,14 @@[m [mFUZZ_TARGET_INIT(wallet_notifications, initialize_setup)[m
                 auto& [coins, block]{chain.back()};[m
                 if (block.vtx.empty()) return; // Can only disconnect if the block was submitted first[m
                 // Disconnect block[m
[31m-                a.wallet->blockDisconnected(block, chain.size() - 1);[m
[31m-                b.wallet->blockDisconnected(block, chain.size() - 1);[m
[32m+[m[32m                const uint256& hash = block.GetHash();[m
[32m+[m[32m                const uint256& prev_hash = chain.size() >= 2 ? std::get<1>(chain[chain.size() - 2]).GetHash() : uint256();[m
[32m+[m[32m                interfaces::BlockInfo info{hash};[m
[32m+[m[32m                info.prev_hash = &prev_hash;[m
[32m+[m[32m                info.height = chain.size() - 1;[m
[32m+[m[32m                info.data = &block;[m
[32m+[m[32m                a.wallet->blockDisconnected(info);[m
[32m+[m[32m                b.wallet->blockDisconnected(info);[m
                 chain.pop_back();[m
             });[m
         auto& [coins, first_block]{chain.front()};[m
[33mdiff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp[m
[33mindex 910562e669..e65d4ba2d1 100644[m
[33m--- a/src/wallet/wallet.cpp[m
[33m+++ b/src/wallet/wallet.cpp[m
[36m@@ -1323,30 +1323,31 @@[m [mvoid CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRe[m
     }[m
 }[m
 [m
[31m-void CWallet::blockConnected(const CBlock& block, int height)[m
[32m+[m[32mvoid CWallet::blockConnected(const interfaces::BlockInfo& block)[m
 {[m
[31m-    const uint256& block_hash = block.GetHash();[m
[32m+[m[32m    assert(block.data);[m
     LOCK(cs_wallet);[m
 [m
[31m-    m_last_block_processed_height = height;[m
[31m-    m_last_block_processed = block_hash;[m
[31m-    for (size_t index = 0; index < block.vtx.size(); index++) {[m
[31m-        SyncTransaction(block.vtx[index], TxStateConfirmed{block_hash, height, static_cast<int>(index)});[m
[31m-        transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);[m
[32m+[m[32m    m_last_block_processed_height = block.height;[m
[32m+[m[32m    m_last_block_processed = block.hash;[m
[32m+[m[32m    for (size_t index = 0; index < block.data->vtx.size(); index++) {[m
[32m+[m[32m        SyncTransaction(block.data->vtx[index], TxStateConfirmed{block.hash, block.height, static_cast<int>(index)});[m
[32m+[m[32m        transactionRemovedFromMempool(block.data->vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);[m
     }[m
 }[m
 [m
[31m-void CWallet::blockDisconnected(const CBlock& block, int height)[m
[32m+[m[32mvoid CWallet::blockDisconnected(const interfaces::BlockInfo& block)[m
 {[m
[32m+[m[32m    assert(block.data);[m
     LOCK(cs_wallet);[m
 [m
     // At block disconnection, this will change an abandoned transaction to[m
     // be unconfirmed, whether or not the transaction is added back to the mempool.[m
     // User may have to call abandontransaction again. It may be addressed in the[m
     // future with a stickier abandoned state or even removing abandontransaction call.[m
[31m-    m_last_block_processed_height = height - 1;[m
[31m-    m_last_block_processed = block.hashPrevBlock;[m
[31m-    for (const CTransactionRef& ptx : block.vtx) {[m
[32m+[m[32m    m_last_block_processed_height = block.height - 1;[m
[32m+[m[32m    m_last_block_processed = *block.prev_hash;[m
[32m+[m[32m    for (const CTransactionRef& ptx : block.data->vtx) {[m
         SyncTransaction(ptx, TxStateInactive{});[m
     }[m
 }[m
[33mdiff --git a/src/wallet/wallet.h b/src/wallet/wallet.h[m
[33mindex 7da601c3b7..3ed53057ab 100644[m
[33m--- a/src/wallet/wallet.h[m
[33m+++ b/src/wallet/wallet.h[m
[36m@@ -508,8 +508,8 @@[m [mpublic:[m
     CWalletTx* AddToWallet(CTransactionRef tx, const TxState& state, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true, bool rescanning_old_block = false);[m
     bool LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
     void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override;[m
[31m-    void blockConnected(const CBlock& block, int height) override;[m
[31m-    void blockDisconnected(const CBlock& block, int height) override;[m
[32m+[m[32m    void blockConnected(const interfaces::BlockInfo& block) override;[m
[32m+[m[32m    void blockDisconnected(const interfaces::BlockInfo& block) override;[m
     void updatedBlockTip() override;[m
     int64_t RescanFromTime(int64_t startTime, const WalletRescanReserver& reserver, bool update);[m
 [m
[33mdiff --git a/test/lint/lint-circular-dependencies.py b/test/lint/lint-circular-dependencies.py[m
[33mindex 5d157eb4b1..fc23d44ef0 100755[m
[33m--- a/test/lint/lint-circular-dependencies.py[m
[33m+++ b/test/lint/lint-circular-dependencies.py[m
[36m@@ -22,6 +22,9 @@[m [mEXPECTED_CIRCULAR_DEPENDENCIES = ([m
     "wallet/fees -> wallet/wallet -> wallet/fees",[m
     "wallet/wallet -> wallet/walletdb -> wallet/wallet",[m
     "kernel/coinstats -> validation -> kernel/coinstats",[m
[32m+[m
[32m+[m[32m    # Temporary, removed in followup https://github.com/bitcoin/bitcoin/pull/24230[m
[32m+[m[32m    "index/base -> node/context -> net_processing -> index/blockfilterindex -> index/base",[m
 )[m
 [m
 CODE_DIR = "src"[m