[33mdiff --git a/.appveyor.yml b/.appveyor.yml[m
[33mindex 7dcf9388b9..6722c1fbec 100644[m
[33m--- a/.appveyor.yml[m
[33m+++ b/.appveyor.yml[m
[36m@@ -11,7 +11,7 @@[m [menvironment:[m
   QT_DOWNLOAD_HASH: '9a8c6eb20967873785057fdcd329a657c7f922b0af08c5fde105cc597dd37e21'[m
   QT_LOCAL_PATH: 'C:\Qt5.9.8_x64_static_vs2019'[m
   VCPKG_INSTALL_PATH: 'C:\tools\vcpkg\installed'[m
[31m-  VCPKG_COMMIT_ID: 'ed0df8ecc4ed7e755ea03e18aaf285fd9b4b4a74'[m
[32m+[m[32m  VCPKG_COMMIT_ID: 'f3f329a048eaff759c1992c458f2e12351486bc7'[m
 install:[m
 # Disable zmq test for now since python zmq library on Windows would cause Access violation sometimes.[m
 # - cmd: pip install zmq[m
[33mdiff --git a/build_msvc/common.init.vcxproj b/build_msvc/common.init.vcxproj[m
[33mindex 4fd516fff5..a080fd2aa4 100644[m
[33m--- a/build_msvc/common.init.vcxproj[m
[33m+++ b/build_msvc/common.init.vcxproj[m
[36m@@ -110,7 +110,7 @@[m
       <AdditionalOptions>/utf-8 /std:c++17 %(AdditionalOptions)</AdditionalOptions>[m
       <DisableSpecificWarnings>4018;4221;4244;4267;4334;4715;4805;4834</DisableSpecificWarnings>[m
       <TreatWarningAsError>true</TreatWarningAsError>[m
[31m-      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING;ZMQ_STATIC;NOMINMAX;WIN32;HAVE_CONFIG_H;_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;_CONSOLE;_WIN32_WINNT=0x0601;%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
[32m+[m[32m      <PreprocessorDefinitions>_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING;_SILENCE_CXX17_OLD_ALLOCATOR_MEMBERS_DEPRECATION_WARNING;ZMQ_STATIC;NOMINMAX;WIN32;HAVE_CONFIG_H;_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;_CONSOLE;_WIN32_WINNT=0x0601;_WIN32_IE=0x0501;WIN32_LEAN_AND_MEAN;%(PreprocessorDefinitions)</PreprocessorDefinitions>[m
       <AdditionalIncludeDirectories>..\..\src;..\..\src\univalue\include;..\..\src\secp256k1\include;..\..\src\leveldb\include;..\..\src\leveldb\helpers\memenv;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>[m
     </ClCompile>[m
     <Link>[m
[33mdiff --git a/ci/test/00_setup_env_native_qt5.sh b/ci/test/00_setup_env_native_qt5.sh[m
[33mindex f9d869b4fd..6f2e39429c 100644[m
[33m--- a/ci/test/00_setup_env_native_qt5.sh[m
[33m+++ b/ci/test/00_setup_env_native_qt5.sh[m
[36m@@ -15,5 +15,5 @@[m [mexport RUN_SECURITY_TESTS="true"[m
 export RUN_UNIT_TESTS_SEQUENTIAL="true"[m
 export RUN_UNIT_TESTS="false"[m
 export GOAL="install"[m
[31m-export PREVIOUS_RELEASES_TO_DOWNLOAD="v0.15.2 v0.16.3 v0.17.1 v0.18.1 v0.19.1"[m
[32m+[m[32mexport PREVIOUS_RELEASES_TO_DOWNLOAD="v0.15.2 v0.16.3 v0.17.2 v0.18.1 v0.19.1"[m
 export BITCOIN_CONFIG="--enable-zmq --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports --enable-c++17 --enable-debug CFLAGS=\"-g0 -O2 -funsigned-char\" CXXFLAGS=\"-g0 -O2 -funsigned-char\" --with-boost-process"[m
[33mdiff --git a/ci/test/05_before_script.sh b/ci/test/05_before_script.sh[m
[33mindex 131ea21677..8ce839fc04 100755[m
[33m--- a/ci/test/05_before_script.sh[m
[33m+++ b/ci/test/05_before_script.sh[m
[36m@@ -48,6 +48,6 @@[m [mif [ -z "$NO_DEPENDS" ]; then[m
 fi[m
 if [ -n "$PREVIOUS_RELEASES_TO_DOWNLOAD" ]; then[m
   BEGIN_FOLD previous-versions[m
[31m-  DOCKER_EXEC contrib/devtools/previous_release.py -b -t "$PREVIOUS_RELEASES_DIR" "${PREVIOUS_RELEASES_TO_DOWNLOAD}"[m
[32m+[m[32m  DOCKER_EXEC test/get_previous_releases.py -b -t "$PREVIOUS_RELEASES_DIR" "${PREVIOUS_RELEASES_TO_DOWNLOAD}"[m
   END_FOLD[m
 fi[m
[33mdiff --git a/configure.ac b/configure.ac[m
[33mindex edb4ef0dc8..14ce47092b 100644[m
[33m--- a/configure.ac[m
[33m+++ b/configure.ac[m
[36m@@ -604,7 +604,7 @@[m [mcase $host in[m
        AC_MSG_ERROR("windres not found")[m
      fi[m
 [m
[31m-     CPPFLAGS="$CPPFLAGS -D_MT -DWIN32 -D_WINDOWS -DBOOST_THREAD_USE_LIB -D_WIN32_WINNT=0x0601"[m
[32m+[m[32m     CPPFLAGS="$CPPFLAGS -D_MT -DWIN32 -D_WINDOWS -DBOOST_THREAD_USE_LIB -D_WIN32_WINNT=0x0601 -D_WIN32_IE=0x0501 -DWIN32_LEAN_AND_MEAN"[m
 [m
      dnl libtool insists upon adding -nostdlib and a list of objects/libs to link against.[m
      dnl That breaks our ability to build dll's with static libgcc/libstdc++/libssp. Override[m
[36m@@ -795,6 +795,14 @@[m [mif test x$use_hardening != xno; then[m
   AX_CHECK_COMPILE_FLAG([-Wstack-protector],[HARDENED_CXXFLAGS="$HARDENED_CXXFLAGS -Wstack-protector"])[m
   AX_CHECK_COMPILE_FLAG([-fstack-protector-all],[HARDENED_CXXFLAGS="$HARDENED_CXXFLAGS -fstack-protector-all"])[m
 [m
[32m+[m[32m  AX_CHECK_COMPILE_FLAG([-fcf-protection=full],[HARDENED_CXXFLAGS="$HARDENED_CXXFLAGS -fcf-protection=full"])[m
[32m+[m
[32m+[m[32m  dnl stack-clash-protection does not work properly when building for Windows.[m
[32m+[m[32m  dnl We use the test case from https://gcc.gnu.org/bugzilla/show_bug.cgi?id=90458[m
[32m+[m[32m  dnl to determine if it can be enabled.[m
[32m+[m[32m  AX_CHECK_COMPILE_FLAG([-fstack-clash-protection],[HARDENED_CXXFLAGS="$HARDENED_CXXFLAGS -fstack-clash-protection"],[],["-O0"],[m
[32m+[m[32m    [AC_LANG_SOURCE([[class D {public: unsigned char buf[32768];}; int main() {D d; return 0;}]])])[m
[32m+[m
   dnl When enable_debug is yes, all optimizations are disabled.[m
   dnl However, FORTIFY_SOURCE requires that there is some level of optimization, otherwise it does nothing and just creates a compiler warning.[m
   dnl Since FORTIFY_SOURCE is a no-op without optimizations, do not enable it when enable_debug is yes.[m
[36m@@ -1039,13 +1047,13 @@[m [mAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <stdint.h>[m
  [ AC_MSG_RESULT(no)][m
 )[m
 [m
[31m-dnl LevelDB platform checks[m
 AC_MSG_CHECKING(for fdatasync)[m
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>]],[m
  [[ fdatasync(0); ]])],[m
  [ AC_MSG_RESULT(yes); HAVE_FDATASYNC=1 ],[m
  [ AC_MSG_RESULT(no); HAVE_FDATASYNC=0 ][m
 )[m
[32m+[m[32mAC_DEFINE_UNQUOTED([HAVE_FDATASYNC], [$HAVE_FDATASYNC], [Define to 1 if fdatasync is available.])[m
 [m
 AC_MSG_CHECKING(for F_FULLFSYNC)[m
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <fcntl.h>]],[m
[33mdiff --git a/depends/packages/bdb.mk b/depends/packages/bdb.mk[m
[33mindex b679438c6f..06cf974f75 100644[m
[33m--- a/depends/packages/bdb.mk[m
[33m+++ b/depends/packages/bdb.mk[m
[36m@@ -4,6 +4,7 @@[m [m$(package)_download_path=https://download.oracle.com/berkeley-db[m
 $(package)_file_name=db-$($(package)_version).NC.tar.gz[m
 $(package)_sha256_hash=12edc0df75bf9abd7f82f821795bcee50f42cb2e5f76a6a281b85732798364ef[m
 $(package)_build_subdir=build_unix[m
[32m+[m[32m$(package)_patches=clang_cxx_11.patch[m
 [m
 define $(package)_set_vars[m
 $(package)_config_opts=--disable-shared --enable-cxx --disable-replication --enable-option-checking[m
[36m@@ -14,8 +15,7 @@[m [m$(package)_cppflags_mingw32=-DUNICODE -D_UNICODE[m
 endef[m
 [m
 define $(package)_preprocess_cmds[m
[31m-  sed -i.old 's/__atomic_compare_exchange/__atomic_compare_exchange_db/' dbinc/atomic.h && \[m
[31m-  sed -i.old 's/atomic_init/atomic_init_db/' dbinc/atomic.h mp/mp_region.c mp/mp_mvcc.c mp/mp_fget.c mutex/mut_method.c mutex/mut_tas.c && \[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/clang_cxx_11.patch && \[m
   cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub dist[m
 endef[m
 [m
[33mdiff --git a/depends/packages/boost.mk b/depends/packages/boost.mk[m
[33mindex 4f6b543aff..d8bce108b1 100644[m
[33m--- a/depends/packages/boost.mk[m
[33m+++ b/depends/packages/boost.mk[m
[36m@@ -3,6 +3,7 @@[m [m$(package)_version=1_70_0[m
 $(package)_download_path=https://dl.bintray.com/boostorg/release/1.70.0/source/[m
 $(package)_file_name=boost_$($(package)_version).tar.bz2[m
 $(package)_sha256_hash=430ae8354789de4fd19ee52f3b1f739e1fba576f0aded0897c3c2bc00fb38778[m
[32m+[m[32m$(package)_patches=unused_var_in_process.patch[m
 [m
 define $(package)_set_vars[m
 $(package)_config_opts_release=variant=release[m
[36m@@ -31,9 +32,8 @@[m [m$(package)_cxxflags_linux=-fPIC[m
 $(package)_cxxflags_android=-fPIC[m
 endef[m
 [m
[31m-# Fix unused variable in boost_process, can be removed after upgrading to 1.72[m
 define $(package)_preprocess_cmds[m
[31m-  sed -i.old "s/int ret_sig = 0;//" boost/process/detail/posix/wait_group.hpp && \[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/unused_var_in_process.patch && \[m
   echo "using $($(package)_toolset_$(host_os)) : : $($(package)_cxx) : <cxxflags>\"$($(package)_cxxflags) $($(package)_cppflags)\" <linkflags>\"$($(package)_ldflags)\" <archiver>\"$($(package)_archiver_$(host_os))\" <striper>\"$(host_STRIP)\"  <ranlib>\"$(host_RANLIB)\" <rc>\"$(host_WINDRES)\" : ;" > user-config.jam[m
 endef[m
 [m
[33mdiff --git a/depends/packages/fontconfig.mk b/depends/packages/fontconfig.mk[m
[33mindex 128599ba77..0d5f94f380 100644[m
[33m--- a/depends/packages/fontconfig.mk[m
[33m+++ b/depends/packages/fontconfig.mk[m
[36m@@ -4,23 +4,23 @@[m [m$(package)_download_path=https://www.freedesktop.org/software/fontconfig/release[m
 $(package)_file_name=$(package)-$($(package)_version).tar.bz2[m
 $(package)_sha256_hash=b449a3e10c47e1d1c7a6ec6e2016cca73d3bd68fbbd4f0ae5cc6b573f7d6c7f3[m
 $(package)_dependencies=freetype expat[m
[32m+[m[32m$(package)_patches=remove_char_width_usage.patch gperf_header_regen.patch[m
 [m
 define $(package)_set_vars[m
   $(package)_config_opts=--disable-docs --disable-static --disable-libxml2 --disable-iconv[m
   $(package)_config_opts += --disable-dependency-tracking --enable-option-checking[m
 endef[m
 [m
[32m+[m[32mdefine $(package)_preprocess_cmds[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/remove_char_width_usage.patch && \[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/gperf_header_regen.patch[m
[32m+[m[32mendef[m
[32m+[m
 define $(package)_config_cmds[m
   $($(package)_autoconf)[m
 endef[m
 [m
[31m-# 2.12.1 uses CHAR_WIDTH which is reserved and clashes with some glibc versions, but newer versions of fontconfig[m
[31m-# have broken makefiles which needlessly attempt to re-generate headers with gperf.[m
[31m-# Instead, change all uses of CHAR_WIDTH, and disable the rule that forces header re-generation.[m
[31m-# This can be removed once the upstream build is fixed.[m
 define $(package)_build_cmds[m
[31m-  sed -i 's/CHAR_WIDTH/CHARWIDTH/g' fontconfig/fontconfig.h src/fcobjshash.gperf src/fcobjs.h src/fcobjshash.h && \[m
[31m-  sed -i 's/fcobjshash.h: fcobjshash.gperf/fcobjshash.h:/' src/Makefile && \[m
   $(MAKE)[m
 endef[m
 [m
[33mdiff --git a/depends/packages/miniupnpc.mk b/depends/packages/miniupnpc.mk[m
[33mindex fdbe22cda6..49a584e462 100644[m
[33m--- a/depends/packages/miniupnpc.mk[m
[33m+++ b/depends/packages/miniupnpc.mk[m
[36m@@ -3,6 +3,7 @@[m [m$(package)_version=2.0.20180203[m
 $(package)_download_path=https://miniupnp.tuxfamily.org/files/[m
 $(package)_file_name=$(package)-$($(package)_version).tar.gz[m
 $(package)_sha256_hash=90dda8c7563ca6cd4a83e23b3c66dbbea89603a1675bfdb852897c2c9cc220b7[m
[32m+[m[32m$(package)_patches=dont_use_wingen.patch[m
 [m
 define $(package)_set_vars[m
 $(package)_build_opts=CC="$($(package)_cc)"[m
[36m@@ -14,7 +15,7 @@[m [mendef[m
 define $(package)_preprocess_cmds[m
   mkdir dll && \[m
   sed -e 's|MINIUPNPC_VERSION_STRING \"version\"|MINIUPNPC_VERSION_STRING \"$($(package)_version)\"|' -e 's|OS/version|$(host)|' miniupnpcstrings.h.in > miniupnpcstrings.h && \[m
[31m-  sed -i.old "s|miniupnpcstrings.h: miniupnpcstrings.h.in wingenminiupnpcstrings|miniupnpcstrings.h: miniupnpcstrings.h.in|" Makefile.mingw[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/dont_use_wingen.patch[m
 endef[m
 [m
 define $(package)_build_cmds[m
[33mdiff --git a/depends/packages/native_cctools.mk b/depends/packages/native_cctools.mk[m
[33mindex 5022ed980f..d56b636695 100644[m
[33m--- a/depends/packages/native_cctools.mk[m
[33m+++ b/depends/packages/native_cctools.mk[m
[36m@@ -4,6 +4,8 @@[m [m$(package)_download_path=https://github.com/tpoechtrager/cctools-port/archive[m
 $(package)_file_name=$($(package)_version).tar.gz[m
 $(package)_sha256_hash=e51995a843533a3dac155dd0c71362dd471597a2d23f13dff194c6285362f875[m
 $(package)_build_subdir=cctools[m
[32m+[m[32m$(package)_patches=ld64_disable_threading.patch[m
[32m+[m
 ifeq ($(strip $(FORCE_USE_SYSTEM_CLANG)),)[m
 $(package)_clang_version=8.0.0[m
 $(package)_clang_download_path=https://releases.llvm.org/$($(package)_clang_version)[m
[36m@@ -78,7 +80,7 @@[m [mendef[m
 define $(package)_preprocess_cmds[m
   CC=$($(package)_cc) CXX=$($(package)_cxx) INSTALLPREFIX=$($(package)_extract_dir) ./libtapi/build.sh && \[m
   CC=$($(package)_cc) CXX=$($(package)_cxx) INSTALLPREFIX=$($(package)_extract_dir) ./libtapi/install.sh && \[m
[31m-  sed -i.old "/define HAVE_PTHREADS/d" $($(package)_build_subdir)/ld64/src/ld/InputFiles.h[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/ld64_disable_threading.patch[m
 endef[m
 [m
 define $(package)_config_cmds[m
[33mdiff --git a/depends/packages/qt.mk b/depends/packages/qt.mk[m
[33mindex 500881e442..f560099b6a 100644[m
[33m--- a/depends/packages/qt.mk[m
[33m+++ b/depends/packages/qt.mk[m
[36m@@ -8,7 +8,10 @@[m [m$(package)_dependencies=zlib[m
 $(package)_linux_dependencies=freetype fontconfig libxcb[m
 $(package)_build_subdir=qtbase[m
 $(package)_qt_libs=corelib network widgets gui plugins testlib[m
[31m-$(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_configure_mac.patch fix_no_printer.patch fix_rcc_determinism.patch fix_riscv64_arch.patch xkb-default.patch no-xlib.patch fix_android_qmake_conf.patch fix_android_jni_static.patch[m
[32m+[m[32m$(package)_patches=fix_qt_pkgconfig.patch mac-qmake.conf fix_configure_mac.patch fix_no_printer.patch[m
[32m+[m[32m$(package)_patches+= fix_rcc_determinism.patch fix_riscv64_arch.patch xkb-default.patch no-xlib.patch[m
[32m+[m[32m$(package)_patches+= fix_android_qmake_conf.patch fix_android_jni_static.patch dont_hardcode_pwd.patch[m
[32m+[m[32m$(package)_patches+= freetype_back_compat.patch drop_lrelease_dependency.patch[m
 [m
 # Update OSX_QT_TRANSLATIONS when this is updated[m
 $(package)_qttranslations_file_name=qttranslations-$($(package)_suffix)[m
[36m@@ -190,11 +193,10 @@[m [mdefine $(package)_extract_cmds[m
 endef[m
 [m
 define $(package)_preprocess_cmds[m
[31m-  sed -i.old "s|FT_Get_Font_Format|FT_Get_X11_Font_Format|" qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp && \[m
[32m+[m[32m  patch -p1 -i $($(package)_patch_dir)/freetype_back_compat.patch && \[m
   sed -i.old "s|updateqm.commands = \$$$$\$$$$LRELEASE|updateqm.commands = $($(package)_extract_dir)/qttools/bin/lrelease|" qttranslations/translations/translations.pro && \[m
[31m-  sed -i.old "/updateqm.depends =/d" qttranslations/translations/translations.pro && \[m
[31m-  sed -i.old "s/src_plugins.depends = src_sql src_network/src_plugins.depends = src_network/" qtbase/src/src.pro && \[m
[31m-  sed -i.old -e 's/if \[ "$$$$XPLATFORM_MAC" = "yes" \]; then xspecvals=$$$$(macSDKify/if \[ "$$$$BUILD_ON_MAC" = "yes" \]; then xspecvals=$$$$(macSDKify/' -e 's|/bin/pwd|pwd|' qtbase/configure && \[m
[32m+[m[32m  patch -p1 -i $($(package)_patch_dir)/drop_lrelease_dependency.patch && \[m
[32m+[m[32m  patch -p1 -i $($(package)_patch_dir)/dont_hardcode_pwd.patch &&\[m
   mkdir -p qtbase/mkspecs/macx-clang-linux &&\[m
   cp -f qtbase/mkspecs/macx-clang/Info.plist.lib qtbase/mkspecs/macx-clang-linux/ &&\[m
   cp -f qtbase/mkspecs/macx-clang/Info.plist.app qtbase/mkspecs/macx-clang-linux/ &&\[m
[33mdiff --git a/depends/packages/zeromq.mk b/depends/packages/zeromq.mk[m
[33mindex 6f35ede248..c93aa1a74d 100644[m
[33m--- a/depends/packages/zeromq.mk[m
[33m+++ b/depends/packages/zeromq.mk[m
[36m@@ -3,7 +3,7 @@[m [m$(package)_version=4.3.1[m
 $(package)_download_path=https://github.com/zeromq/libzmq/releases/download/v$($(package)_version)/[m
 $(package)_file_name=$(package)-$($(package)_version).tar.gz[m
 $(package)_sha256_hash=bcbabe1e2c7d0eec4ed612e10b94b112dd5f06fcefa994a0c79a45d835cd21eb[m
[31m-$(package)_patches=0001-fix-build-with-older-mingw64.patch 0002-disable-pthread_set_name_np.patch[m
[32m+[m[32m$(package)_patches=remove_libstd_link.patch[m
 [m
 define $(package)_set_vars[m
   $(package)_config_opts=--without-docs --disable-shared --disable-curve --disable-curve-keygen --disable-perf[m
[36m@@ -16,9 +16,8 @@[m [mdefine $(package)_set_vars[m
 endef[m
 [m
 define $(package)_preprocess_cmds[m
[31m-   patch -p1 < $($(package)_patch_dir)/0001-fix-build-with-older-mingw64.patch && \[m
[31m-   patch -p1 < $($(package)_patch_dir)/0002-disable-pthread_set_name_np.patch && \[m
[31m-   cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub config[m
[32m+[m[32m  patch -p1 < $($(package)_patch_dir)/remove_libstd_link.patch && \[m
[32m+[m[32m  cp -f $(BASEDIR)/config.guess $(BASEDIR)/config.sub config[m
 endef[m
 [m
 define $(package)_config_cmds[m
[36m@@ -34,6 +33,5 @@[m [mdefine $(package)_stage_cmds[m
 endef[m
 [m
 define $(package)_postprocess_cmds[m
[31m-  sed -i.old "s/ -lstdc++//" lib/pkgconfig/libzmq.pc && \[m
   rm -rf bin share lib/*.la[m
 endef[m
[33mdiff --git a/depends/patches/bdb/clang_cxx_11.patch b/depends/patches/bdb/clang_cxx_11.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..58f7ddc7d5[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/bdb/clang_cxx_11.patch[m
[36m@@ -0,0 +1,147 @@[m
[32m+[m[32mcommit 3311d68f11d1697565401eee6efc85c34f022ea7[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Mon Aug 17 20:03:56 2020 +0800[m
[32m+[m
[32m+[m[32m    Fix C++11 compatibility[m
[32m+[m
[32m+[m[32mdiff --git a/dbinc/atomic.h b/dbinc/atomic.h[m
[32m+[m[32mindex 0034dcc..7c11d4a 100644[m
[32m+[m[32m--- a/dbinc/atomic.h[m
[32m+[m[32m+++ b/dbinc/atomic.h[m
[32m+[m[32m@@ -70,7 +70,7 @@ typedef struct {[m
[32m+[m[32m  * These have no memory barriers; the caller must include them when necessary.[m
[32m+[m[32m  */[m
[32m+[m[32m #define	atomic_read(p)		((p)->value)[m
[32m+[m[32m-#define	atomic_init(p, val)	((p)->value = (val))[m
[32m+[m[32m+#define	atomic_init_db(p, val)	((p)->value = (val))[m
[32m+[m[7;31m [m
[32m+[m[32m #ifdef HAVE_ATOMIC_SUPPORT[m
[32m+[m[7;31m [m
[32m+[m[32m@@ -144,7 +144,7 @@ typedef LONG volatile *interlocked_val;[m
[32m+[m[32m #define	atomic_inc(env, p)	__atomic_inc(p)[m
[32m+[m[32m #define	atomic_dec(env, p)	__atomic_dec(p)[m
[32m+[m[32m #define	atomic_compare_exchange(env, p, o, n)	\[m
[32m+[m[32m-	__atomic_compare_exchange((p), (o), (n))[m
[32m+[m[32m+	__atomic_compare_exchange_db((p), (o), (n))[m
[32m+[m[32m static inline int __atomic_inc(db_atomic_t *p)[m
[32m+[m[32m {[m
[32m+[m[7;31m [m	[32mint	temp;[m
[32m+[m[32m@@ -176,7 +176,7 @@ static inline int __atomic_dec(db_atomic_t *p)[m
[32m+[m[32m  * http://gcc.gnu.org/onlinedocs/gcc-4.1.0/gcc/Atomic-Builtins.html[m
[32m+[m[32m  * which configure could be changed to use.[m
[32m+[m[32m  */[m
[32m+[m[32m-static inline int __atomic_compare_exchange([m
[32m+[m[32m+static inline int __atomic_compare_exchange_db([m
[32m+[m[7;31m [m	[32mdb_atomic_t *p, atomic_value_t oldval, atomic_value_t newval)[m
[32m+[m[32m {[m
[32m+[m[7;31m [m	[32matomic_value_t was;[m
[32m+[m[32m@@ -206,7 +206,7 @@ static inline int __atomic_compare_exchange([m
[32m+[m[32m #define	atomic_dec(env, p)	(--(p)->value)[m
[32m+[m[32m #define	atomic_compare_exchange(env, p, oldval, newval)		\[m
[32m+[m[7;31m [m	[32m(DB_ASSERT(env, atomic_read(p) == (oldval)),		\[m
[32m+[m[32m-	atomic_init(p, (newval)), 1)[m
[32m+[m[32m+	atomic_init_db(p, (newval)), 1)[m
[32m+[m[32m #else[m
[32m+[m[32m #define atomic_inc(env, p)	__atomic_inc(env, p)[m
[32m+[m[32m #define atomic_dec(env, p)	__atomic_dec(env, p)[m
[32m+[m[32mdiff --git a/mp/mp_fget.c b/mp/mp_fget.c[m
[32m+[m[32mindex 5fdee5a..0b75f57 100644[m
[32m+[m[32m--- a/mp/mp_fget.c[m
[32m+[m[32m+++ b/mp/mp_fget.c[m
[32m+[m[32m@@ -617,7 +617,7 @@ alloc:		/* Allocate a new buffer header and data space. */[m
[32m+[m[7;31m [m
[32m+[m[7;31m [m		[32m/* Initialize enough so we can call __memp_bhfree. */[m
[32m+[m[7;31m [m		[32malloc_bhp->flags = 0;[m
[32m+[m[32m-		atomic_init(&alloc_bhp->ref, 1);[m
[32m+[m[32m+		atomic_init_db(&alloc_bhp->ref, 1);[m
[32m+[m[32m #ifdef DIAGNOSTIC[m
[32m+[m[7;31m [m		[32mif ((uintptr_t)alloc_bhp->buf & (sizeof(size_t) - 1)) {[m
[32m+[m[7;31m [m			[32m__db_errx(env,[m
[32m+[m[32m@@ -911,7 +911,7 @@ alloc:		/* Allocate a new buffer header and data space. */[m
[32m+[m[7;31m [m			[32mMVCC_MPROTECT(bhp->buf, mfp->stat.st_pagesize,[m
[32m+[m[7;31m [m			[32m    PROT_READ);[m
[32m+[m[7;31m [m
[32m+[m[32m-		atomic_init(&alloc_bhp->ref, 1);[m
[32m+[m[32m+		atomic_init_db(&alloc_bhp->ref, 1);[m
[32m+[m[7;31m [m		[32mMUTEX_LOCK(env, alloc_bhp->mtx_buf);[m
[32m+[m[7;31m [m		[32malloc_bhp->priority = bhp->priority;[m
[32m+[m[7;31m [m		[32malloc_bhp->pgno = bhp->pgno;[m
[32m+[m[32mdiff --git a/mp/mp_mvcc.c b/mp/mp_mvcc.c[m
[32m+[m[32mindex 34467d2..f05aa0c 100644[m
[32m+[m[32m--- a/mp/mp_mvcc.c[m
[32m+[m[32m+++ b/mp/mp_mvcc.c[m
[32m+[m[32m@@ -276,7 +276,7 @@ __memp_bh_freeze(dbmp, infop, hp, bhp, need_frozenp)[m
[32m+[m[32m #else[m
[32m+[m[7;31m [m	[32mmemcpy(frozen_bhp, bhp, SSZA(BH, buf));[m
[32m+[m[32m #endif[m
[32m+[m[32m-	atomic_init(&frozen_bhp->ref, 0);[m
[32m+[m[32m+	atomic_init_db(&frozen_bhp->ref, 0);[m
[32m+[m[7;31m [m	[32mif (mutex != MUTEX_INVALID)[m
[32m+[m[7;31m [m		[32mfrozen_bhp->mtx_buf = mutex;[m
[32m+[m[7;31m [m	[32melse if ((ret = __mutex_alloc(env, MTX_MPOOL_BH,[m
[32m+[m[32m@@ -428,7 +428,7 @@ __memp_bh_thaw(dbmp, infop, hp, frozen_bhp, alloc_bhp)[m
[32m+[m[32m #endif[m
[32m+[m[7;31m [m		[32malloc_bhp->mtx_buf = mutex;[m
[32m+[m[7;31m [m		[32mMUTEX_LOCK(env, alloc_bhp->mtx_buf);[m
[32m+[m[32m-		atomic_init(&alloc_bhp->ref, 1);[m
[32m+[m[32m+		atomic_init_db(&alloc_bhp->ref, 1);[m
[32m+[m[7;31m [m		[32mF_CLR(alloc_bhp, BH_FROZEN);[m
[32m+[m[7;31m [m	[32m}[m
[32m+[m[7;31m [m
[32m+[m[32mdiff --git a/mp/mp_region.c b/mp/mp_region.c[m
[32m+[m[32mindex e6cece9..ddbe906 100644[m
[32m+[m[32m--- a/mp/mp_region.c[m
[32m+[m[32m+++ b/mp/mp_region.c[m
[32m+[m[32m@@ -224,7 +224,7 @@ __memp_init(env, dbmp, reginfo_off, htab_buckets, max_nreg)[m
[32m+[m[7;31m [m			[32m     MTX_MPOOL_FILE_BUCKET, 0, &htab[i].mtx_hash)) != 0)[m
[32m+[m[7;31m [m				[32mreturn (ret);[m
[32m+[m[7;31m [m			[32mSH_TAILQ_INIT(&htab[i].hash_bucket);[m
[32m+[m[32m-			atomic_init(&htab[i].hash_page_dirty, 0);[m
[32m+[m[32m+			atomic_init_db(&htab[i].hash_page_dirty, 0);[m
[32m+[m[7;31m [m		[32m}[m
[32m+[m[7;31m [m
[32m+[m[7;31m [m		[32m/*[m
[32m+[m[32m@@ -269,7 +269,7 @@ __memp_init(env, dbmp, reginfo_off, htab_buckets, max_nreg)[m
[32m+[m[7;31m [m		[32mhp->mtx_hash = (mtx_base == MUTEX_INVALID) ? MUTEX_INVALID :[m
[32m+[m[7;31m [m		[32m    mtx_base + i;[m
[32m+[m[7;31m [m		[32mSH_TAILQ_INIT(&hp->hash_bucket);[m
[32m+[m[32m-		atomic_init(&hp->hash_page_dirty, 0);[m
[32m+[m[32m+		atomic_init_db(&hp->hash_page_dirty, 0);[m
[32m+[m[32m #ifdef HAVE_STATISTICS[m
[32m+[m[7;31m [m		[32mhp->hash_io_wait = 0;[m
[32m+[m[7;31m [m		[32mhp->hash_frozen = hp->hash_thawed = hp->hash_frozen_freed = 0;[m
[32m+[m[32mdiff --git a/mutex/mut_method.c b/mutex/mut_method.c[m
[32m+[m[32mindex 2588763..5c6d516 100644[m
[32m+[m[32m--- a/mutex/mut_method.c[m
[32m+[m[32m+++ b/mutex/mut_method.c[m
[32m+[m[32m@@ -426,7 +426,7 @@ atomic_compare_exchange(env, v, oldval, newval)[m
[32m+[m[7;31m [m	[32mMUTEX_LOCK(env, mtx);[m
[32m+[m[7;31m [m	[32mret = atomic_read(v) == oldval;[m
[32m+[m[7;31m [m	[32mif (ret)[m
[32m+[m[32m-		atomic_init(v, newval);[m
[32m+[m[32m+		atomic_init_db(v, newval);[m
[32m+[m[7;31m [m	[32mMUTEX_UNLOCK(env, mtx);[m
[32m+[m[7;31m [m
[32m+[m[7;31m [m	[32mreturn (ret);[m
[32m+[m[32mdiff --git a/mutex/mut_tas.c b/mutex/mut_tas.c[m
[32m+[m[32mindex f3922e0..e40fcdf 100644[m
[32m+[m[32m--- a/mutex/mut_tas.c[m
[32m+[m[32m+++ b/mutex/mut_tas.c[m
[32m+[m[32m@@ -46,7 +46,7 @@ __db_tas_mutex_init(env, mutex, flags)[m
[32m+[m[7;31m [m
[32m+[m[32m #ifdef HAVE_SHARED_LATCHES[m
[32m+[m[7;31m [m	[32mif (F_ISSET(mutexp, DB_MUTEX_SHARED))[m
[32m+[m[32m-		atomic_init(&mutexp->sharecount, 0);[m
[32m+[m[32m+		atomic_init_db(&mutexp->sharecount, 0);[m
[32m+[m[7;31m [m	[32melse[m
[32m+[m[32m #endif[m
[32m+[m[7;31m [m	[32mif (MUTEX_INIT(&mutexp->tas)) {[m
[32m+[m[32m@@ -486,7 +486,7 @@ __db_tas_mutex_unlock(env, mutex)[m
[32m+[m[7;31m [m			[32mF_CLR(mutexp, DB_MUTEX_LOCKED);[m
[32m+[m[7;31m [m			[32m/* Flush flag update before zeroing count */[m
[32m+[m[7;31m [m			[32mMEMBAR_EXIT();[m
[32m+[m[32m-			atomic_init(&mutexp->sharecount, 0);[m
[32m+[m[32m+			atomic_init_db(&mutexp->sharecount, 0);[m
[32m+[m[7;31m [m		[32m} else {[m
[32m+[m[7;31m [m			[32mDB_ASSERT(env, sharecount > 0);[m
[32m+[m[7;31m [m			[32mMEMBAR_EXIT();[m
[33mdiff --git a/depends/patches/boost/unused_var_in_process.patch b/depends/patches/boost/unused_var_in_process.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..722f7bb5ea[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/boost/unused_var_in_process.patch[m
[36m@@ -0,0 +1,22 @@[m
[32m+[m[32mcommit dbd95cdaefdea95307d004f019a1c394cf9389f0[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Mon Aug 17 20:15:17 2020 +0800[m
[32m+[m
[32m+[m[32m    Remove unused variable in Boost Process[m
[32m+[m
[32m+[m[32m    This causes issues with our linters / CI.[m
[32m+[m
[32m+[m[32m    Can be removed once depends Boost is 1.71.0 or later.[m
[32m+[m
[32m+[m[32mdiff --git a/boost/process/detail/posix/wait_group.hpp b/boost/process/detail/posix/wait_group.hpp[m
[32m+[m[32mindex 9dc249803..2502d9772 100644[m
[32m+[m[32m--- a/boost/process/detail/posix/wait_group.hpp[m
[32m+[m[32m+++ b/boost/process/detail/posix/wait_group.hpp[m
[32m+[m[32m@@ -137,7 +137,6 @@ inline bool wait_until([m
[32m+[m
[32m+[m[32m     do[m
[32m+[m[32m     {[m
[32m+[m[32m-        int ret_sig = 0;[m
[32m+[m[32m         int status;[m
[32m+[m[32m         if ((::waitpid(timeout_pid, &status, WNOHANG) != 0)[m
[32m+[m[32m             && (WIFEXITED(status) || WIFSIGNALED(status)))[m
[33mdiff --git a/depends/patches/fontconfig/gperf_header_regen.patch b/depends/patches/fontconfig/gperf_header_regen.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..7401b83d84[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/fontconfig/gperf_header_regen.patch[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32mcommit 7b6eb33ecd88768b28c67ce5d2d68a7eed5936b6[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 25 14:34:53 2020 +0800[m
[32m+[m
[32m+[m[32m    Remove rule that causes inadvertant header regeneration[m
[32m+[m
[32m+[m[32m    Otherwise the makefile will needlessly attempt to re-generate the[m
[32m+[m[32m    headers with gperf. This can be dropped once the upstream build is fixed.[m
[32m+[m
[32m+[m[32m    See #10851.[m
[32m+[m
[32m+[m[32mdiff --git a/src/Makefile.in b/src/Makefile.in[m
[32m+[m[32mindex f4626ad..4ae1b00 100644[m
[32m+[m[32m--- a/src/Makefile.in[m
[32m+[m[32m+++ b/src/Makefile.in[m
[32m+[m[32m@@ -903,7 +903,7 @@ fcobjshash.gperf: fcobjshash.gperf.h fcobjs.h[m
[32m+[m[7;31m [m	[32m' - > $@.tmp && \[m
[32m+[m[7;31m [m	[32mmv -f $@.tmp $@ || ( $(RM) $@.tmp && false )[m
[32m+[m
[32m+[m[32m-fcobjshash.h: fcobjshash.gperf[m
[32m+[m[32m+fcobjshash.h:[m
[32m+[m[7;31m [m	[32m$(AM_V_GEN) $(GPERF) -m 100 $< > $@.tmp && \[m
[32m+[m[7;31m [m	[32mmv -f $@.tmp $@ || ( $(RM) $@.tmp && false )[m
[32m+[m
[33mdiff --git a/depends/patches/fontconfig/remove_char_width_usage.patch b/depends/patches/fontconfig/remove_char_width_usage.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..9f69081890[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/fontconfig/remove_char_width_usage.patch[m
[36m@@ -0,0 +1,62 @@[m
[32m+[m[32mcommit 28165a9b078583dc8e9e5c344510e37582284cef[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Mon Aug 17 20:35:42 2020 +0800[m
[32m+[m
[32m+[m[32m    Remove usage of CHAR_WIDTH[m
[32m+[m
[32m+[m[32m    CHAR_WIDTH which is reserved and clashes with glibc 2.25+[m
[32m+[m
[32m+[m[32m    See #10851.[m
[32m+[m
[32m+[m[32mdiff --git a/fontconfig/fontconfig.h b/fontconfig/fontconfig.h[m
[32m+[m[32mindex 5c72b22..843c532 100644[m
[32m+[m[32m--- a/fontconfig/fontconfig.h[m
[32m+[m[32m+++ b/fontconfig/fontconfig.h[m
[32m+[m[32m@@ -128,7 +128,7 @@ typedef int		FcBool;[m
[32m+[m[32m #define FC_USER_CACHE_FILE	    ".fonts.cache-" FC_CACHE_VERSION[m
[32m+[m
[32m+[m[32m /* Adjust outline rasterizer */[m
[32m+[m[32m-#define FC_CHAR_WIDTH	    "charwidth"	/* Int */[m
[32m+[m[32m+#define FC_CHARWIDTH	    "charwidth"	/* Int */[m
[32m+[m[32m #define FC_CHAR_HEIGHT	    "charheight"/* Int */[m
[32m+[m[32m #define FC_MATRIX	    "matrix"    /* FcMatrix */[m
[32m+[m
[32m+[m[32mdiff --git a/src/fcobjs.h b/src/fcobjs.h[m
[32m+[m[32mindex 1fc4f65..d27864b 100644[m
[32m+[m[32m--- a/src/fcobjs.h[m
[32m+[m[32m+++ b/src/fcobjs.h[m
[32m+[m[32m@@ -51,7 +51,7 @@ FC_OBJECT (DPI,			FcTypeDouble,	NULL)[m
[32m+[m[32m FC_OBJECT (RGBA,		FcTypeInteger,	NULL)[m
[32m+[m[32m FC_OBJECT (SCALE,		FcTypeDouble,	NULL)[m
[32m+[m[32m FC_OBJECT (MINSPACE,		FcTypeBool,	NULL)[m
[32m+[m[32m-FC_OBJECT (CHAR_WIDTH,		FcTypeInteger,	NULL)[m
[32m+[m[32m+FC_OBJECT (CHARWIDTH,		FcTypeInteger,	NULL)[m
[32m+[m[32m FC_OBJECT (CHAR_HEIGHT,		FcTypeInteger,	NULL)[m
[32m+[m[32m FC_OBJECT (MATRIX,		FcTypeMatrix,	NULL)[m
[32m+[m[32m FC_OBJECT (CHARSET,		FcTypeCharSet,	FcCompareCharSet)[m
[32m+[m[32mdiff --git a/src/fcobjshash.gperf b/src/fcobjshash.gperf[m
[32m+[m[32mindex 80a0237..eb4ad84 100644[m
[32m+[m[32m--- a/src/fcobjshash.gperf[m
[32m+[m[32m+++ b/src/fcobjshash.gperf[m
[32m+[m[32m@@ -44,7 +44,7 @@ int id;[m
[32m+[m[32m "rgba",FC_RGBA_OBJECT[m
[32m+[m[32m "scale",FC_SCALE_OBJECT[m
[32m+[m[32m "minspace",FC_MINSPACE_OBJECT[m
[32m+[m[32m-"charwidth",FC_CHAR_WIDTH_OBJECT[m
[32m+[m[32m+"charwidth",FC_CHARWIDTH_OBJECT[m
[32m+[m[32m "charheight",FC_CHAR_HEIGHT_OBJECT[m
[32m+[m[32m "matrix",FC_MATRIX_OBJECT[m
[32m+[m[32m "charset",FC_CHARSET_OBJECT[m
[32m+[m[32mdiff --git a/src/fcobjshash.h b/src/fcobjshash.h[m
[32m+[m[32mindex 5a4d1ea..4e66bb0 100644[m
[32m+[m[32m--- a/src/fcobjshash.h[m
[32m+[m[32m+++ b/src/fcobjshash.h[m
[32m+[m[32m@@ -284,7 +284,7 @@ FcObjectTypeLookup (register const char *str, register unsigned int len)[m
[32m+[m[32m       {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str43,FC_CHARSET_OBJECT},[m
[32m+[m[32m       {-1},[m
[32m+[m[32m #line 47 "fcobjshash.gperf"[m
[32m+[m[32m-      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str45,FC_CHAR_WIDTH_OBJECT},[m
[32m+[m[32m+      {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str45,FC_CHARWIDTH_OBJECT},[m
[32m+[m[32m #line 48 "fcobjshash.gperf"[m
[32m+[m[32m       {(int)(long)&((struct FcObjectTypeNamePool_t *)0)->FcObjectTypeNamePool_str46,FC_CHAR_HEIGHT_OBJECT},[m
[32m+[m[32m #line 55 "fcobjshash.gperf"[m
[33mdiff --git a/depends/patches/miniupnpc/dont_use_wingen.patch b/depends/patches/miniupnpc/dont_use_wingen.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..a1cc9b50d1[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/miniupnpc/dont_use_wingen.patch[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mcommit e8077044df239bcf0d9e9980b0e1afb9f1f5c446[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 18 20:50:19 2020 +0800[m
[32m+[m
[32m+[m[32m    Don't use wingenminiupnpcstrings when generating miniupnpcstrings.h[m
[32m+[m
[32m+[m[32m    The wingenminiupnpcstrings tool is used on Windows to generate version[m
[32m+[m[32m    information. This information is irrelevant for us, and trying to use[m
[32m+[m[32m    wingenminiupnpcstrings would cause builds to fail, so just don't use it.[m
[32m+[m
[32m+[m[32m    We should be able to drop this once we are using 2.1 or later. See[m
[32m+[m[32m    upstream commit: 9663c55c61408fdcc39a82987d2243f816b22932.[m
[32m+[m
[32m+[m[32mdiff --git a/Makefile.mingw b/Makefile.mingw[m
[32m+[m[32mindex 574720e..fcc17bb 100644[m
[32m+[m[32m--- a/Makefile.mingw[m
[32m+[m[32m+++ b/Makefile.mingw[m
[32m+[m[32m@@ -74,7 +74,7 @@ wingenminiupnpcstrings:	wingenminiupnpcstrings.o[m
[32m+[m
[32m+[m[32m wingenminiupnpcstrings.o:	wingenminiupnpcstrings.c[m
[32m+[m
[32m+[m[32m-miniupnpcstrings.h: miniupnpcstrings.h.in wingenminiupnpcstrings[m
[32m+[m[32m+miniupnpcstrings.h: miniupnpcstrings.h.in[m
[32m+[m[7;31m [m	[32mwingenminiupnpcstrings $< $@[m
[32m+[m
[32m+[m[32m minixml.o:	minixml.c minixml.h[m
[33mdiff --git a/depends/patches/native_cctools/ld64_disable_threading.patch b/depends/patches/native_cctools/ld64_disable_threading.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..d6c58c102f[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/native_cctools/ld64_disable_threading.patch[m
[36m@@ -0,0 +1,26 @@[m
[32m+[m[32mcommit 584668415039adeed073decee7e04de28248afd3[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 18 01:20:24 2020 +0000[m
[32m+[m
[32m+[m[32m    Disable threading to fix non-determinism[m
[32m+[m
[32m+[m[32m    A bug in the file parser can cause dependencies to be calculated[m
[32m+[m[32m    differently based on which files have already been parsed. This is more[m
[32m+[m[32m    likely to occur on systems with more CPUs.[m
[32m+[m
[32m+[m[32m    Just disable threading for now. There is no noticable slowdown.[m
[32m+[m
[32m+[m[32m    See #9891.[m
[32m+[m
[32m+[m[32mdiff --git a/cctools/ld64/src/ld/InputFiles.h b/cctools/ld64/src/ld/InputFiles.h[m
[32m+[m[32mindex ef9c756..90a70b6 100644[m
[32m+[m[32m--- a/cctools/ld64/src/ld/InputFiles.h[m
[32m+[m[32m+++ b/cctools/ld64/src/ld/InputFiles.h[m
[32m+[m[32m@@ -25,7 +25,6 @@[m
[32m+[m[32m #ifndef __INPUT_FILES_H__[m
[32m+[m[32m #define __INPUT_FILES_H__[m
[32m+[m
[32m+[m[32m-#define HAVE_PTHREADS 1[m
[32m+[m
[32m+[m[32m #include <stdlib.h>[m
[32m+[m[32m #include <sys/types.h>[m
[33mdiff --git a/depends/patches/qt/dont_hardcode_pwd.patch b/depends/patches/qt/dont_hardcode_pwd.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..a74e9cb098[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/qt/dont_hardcode_pwd.patch[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32mcommit 0e953866fc4672486e29e1ba6d83b4207e7b2f0b[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 18 15:09:06 2020 +0800[m
[32m+[m
[32m+[m[32m    Don't hardcode pwd path[m
[32m+[m
[32m+[m[32m    Let a man use his builtins if he wants to! Also, removes the unnecessary[m
[32m+[m[32m    assumption that pwd lives under /bin/pwd.[m
[32m+[m
[32m+[m[32m    See #15581.[m
[32m+[m
[32m+[m[32mdiff --git a/qtbase/configure b/qtbase/configure[m
[32m+[m[32mindex 08b49a8d..faea5b55 100755[m
[32m+[m[32m--- a/qtbase/configure[m
[32m+[m[32m+++ b/qtbase/configure[m
[32m+[m[32m@@ -36,9 +36,9 @@[m
[32m+[m[32m relconf=`basename $0`[m
[32m+[m[32m # the directory of this script is the "source tree"[m
[32m+[m[32m relpath=`dirname $0`[m
[32m+[m[32m-relpath=`(cd "$relpath"; /bin/pwd)`[m
[32m+[m[32m+relpath=`(cd "$relpath"; pwd)`[m
[32m+[m[32m # the current directory is the "build tree" or "object tree"[m
[32m+[m[32m-outpath=`/bin/pwd`[m
[32m+[m[32m+outpath=`pwd`[m
[32m+[m
[32m+[m[32m WHICH="which"[m
[32m+[m
[33mdiff --git a/depends/patches/qt/drop_lrelease_dependency.patch b/depends/patches/qt/drop_lrelease_dependency.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..f6b2c9fc80[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/qt/drop_lrelease_dependency.patch[m
[36m@@ -0,0 +1,20 @@[m
[32m+[m[32mcommit 67b3ed7406e1d0762188dbad2c44a06824ba0778[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 18 15:24:01 2020 +0800[m
[32m+[m
[32m+[m[32m    Drop dependency on lrelease[m
[32m+[m
[32m+[m[32m    Qts buildsystem insists on using the installed lrelease, but gets[m
[32m+[m[32m    confused about how to find it. Since we manually control the build[m
[32m+[m[32m    order, just drop the dependency.[m
[32m+[m
[32m+[m[32m    See #9469[m
[32m+[m
[32m+[m[32mdiff --git a/qttranslations/translations/translations.pro b/qttranslations/translations/translations.pro[m
[32m+[m[32mindex 694544c..eff339d 100644[m
[32m+[m[32m--- a/qttranslations/translations/translations.pro[m
[32m+[m[32m+++ b/qttranslations/translations/translations.pro[m
[32m+[m[32m@@ -109,3 +109,2 @@ updateqm.commands = $$LRELEASE ${QMAKE_FILE_IN} -qm ${QMAKE_FILE_OUT}[m
[32m+[m[32m silent:updateqm.commands = @echo lrelease ${QMAKE_FILE_IN} && $$updateqm.commands[m
[32m+[m[32m-updateqm.depends = $$LRELEASE_EXE[m
[32m+[m[32m updateqm.name = LRELEASE ${QMAKE_FILE_IN}[m
[33mdiff --git a/depends/patches/qt/freetype_back_compat.patch b/depends/patches/qt/freetype_back_compat.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..b0f1c98aa6[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/qt/freetype_back_compat.patch[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32mcommit 14bc77db61bf9d56f9b6c8b84aa02573605c19c6[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 18 15:15:08 2020 +0800[m
[32m+[m
[32m+[m[32m    Fix backwards compatibility with older Freetype versions at runtime[m
[32m+[m
[32m+[m[32m    A few years ago, libfreetype introduced FT_Get_Font_Format() as an alias[m
[32m+[m[32m    for FT_Get_X11_Font_Format(), but FT_Get_X11_Font_Format() was kept for abi[m
[32m+[m[32m    backwards-compatibility.[m
[32m+[m
[32m+[m[32m    Qt 5.9 introduced a call to FT_Get_Font_Format(). Replace it with FT_Get_X11_Font_Format()[m
[32m+[m[32m    in order to remain compatibile with older freetype, which is still used by e.g. Ubuntu Trusty.[m
[32m+[m
[32m+[m[32m    See #14348.[m
[32m+[m
[32m+[m[32mdiff --git a/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp b/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp[m
[32m+[m[32mindex 3f543755..8ecc1c8c 100644[m
[32m+[m[32m--- a/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp[m
[32m+[m[32m+++ b/qtbase/src/platformsupport/fontdatabases/freetype/qfontengine_ft.cpp[m
[32m+[m[32m@@ -898,7 +898,7 @@ bool QFontEngineFT::init(FaceId faceId, bool antialias, GlyphFormat format,[m
[32m+[m[32m         }[m
[32m+[m[32m     }[m
[32m+[m[32m #if defined(FT_FONT_FORMATS_H)[m
[32m+[m[32m-    const char *fmt = FT_Get_Font_Format(face);[m
[32m+[m[32m+    const char *fmt = FT_Get_X11_Font_Format(face);[m
[32m+[m[32m     if (fmt && qstrncmp(fmt, "CFF", 4) == 0) {[m
[32m+[m[32m         FT_Bool no_stem_darkening = true;[m
[32m+[m[32m         FT_Error err = FT_Property_Get(qt_getFreetype(), "cff", "no-stem-darkening", &no_stem_darkening);[m
[33mdiff --git a/depends/patches/zeromq/0001-fix-build-with-older-mingw64.patch b/depends/patches/zeromq/0001-fix-build-with-older-mingw64.patch[m
[33mdeleted file mode 100644[m
[33mindex b911ac5672..0000000000[m
[33m--- a/depends/patches/zeromq/0001-fix-build-with-older-mingw64.patch[m
[33m+++ /dev/null[m
[36m@@ -1,30 +0,0 @@[m
[31m-From f6866b0f166ad168618aae64c7fbee8775d3eb23 Mon Sep 17 00:00:00 2001[m
[31m-From: mruddy <6440430+mruddy@users.noreply.github.com>[m
[31m-Date: Sat, 30 Jun 2018 09:44:58 -0400[m
[31m-Subject: [PATCH] fix build with older mingw64[m
[31m-[m
[31m----[m
[31m- src/windows.hpp | 7 +++++++[m
[31m- 1 file changed, 7 insertions(+)[m
[31m-[m
[31m-diff --git a/src/windows.hpp b/src/windows.hpp[m
[31m-index 6c3839fd..2c32ec79 100644[m
[31m---- a/src/windows.hpp[m
[31m-+++ b/src/windows.hpp[m
[31m-@@ -58,6 +58,13 @@[m
[31m- #include <winsock2.h>[m
[31m- #include <windows.h>[m
[31m- #include <mswsock.h>[m
[31m-+[m
[31m-+#if defined __MINGW64_VERSION_MAJOR && __MINGW64_VERSION_MAJOR < 4[m
[31m-+// Workaround for mingw-w64 < v4.0 which did not include ws2ipdef.h in iphlpapi.h.[m
[31m-+// Fixed in mingw-w64 by 9bd8fe9148924840d315b4c915dd099955ea89d1.[m
[31m-+#include <ws2def.h>[m
[31m-+#include <ws2ipdef.h>[m
[31m-+#endif[m
[31m- #include <iphlpapi.h>[m
[31m- [m
[31m- #if !defined __MINGW32__[m
[31m--- [m
[31m-2.17.1[m
[31m-[m
[33mdiff --git a/depends/patches/zeromq/0002-disable-pthread_set_name_np.patch b/depends/patches/zeromq/0002-disable-pthread_set_name_np.patch[m
[33mdeleted file mode 100644[m
[33mindex b1c6f78a70..0000000000[m
[33m--- a/depends/patches/zeromq/0002-disable-pthread_set_name_np.patch[m
[33m+++ /dev/null[m
[36m@@ -1,35 +0,0 @@[m
[31m-From c9bbdd6581d07acfe8971e4bcebe278a3676cf03 Mon Sep 17 00:00:00 2001[m
[31m-From: mruddy <6440430+mruddy@users.noreply.github.com>[m
[31m-Date: Sat, 30 Jun 2018 09:57:18 -0400[m
[31m-Subject: [PATCH] disable pthread_set_name_np[m
[31m-[m
[31m-pthread_set_name_np adds a Glibc requirement on >= 2.12.[m
[31m----[m
[31m- src/thread.cpp | 4 +++-[m
[31m- 1 file changed, 3 insertions(+), 1 deletion(-)[m
[31m-[m
[31m-diff --git a/src/thread.cpp b/src/thread.cpp[m
[31m-index a1086b0c..9943f354 100644[m
[31m---- a/src/thread.cpp[m
[31m-+++ b/src/thread.cpp[m
[31m-@@ -308,7 +308,7 @@ void zmq::thread_t::setThreadName (const char *name_)[m
[31m-  */[m
[31m-     if (!name_)[m
[31m-         return;[m
[31m--[m
[31m-+#if 0[m
[31m- #if defined(ZMQ_HAVE_PTHREAD_SETNAME_1)[m
[31m-     int rc = pthread_setname_np (name_);[m
[31m-     if (rc)[m
[31m-@@ -324,6 +324,8 @@ void zmq::thread_t::setThreadName (const char *name_)[m
[31m- #elif defined(ZMQ_HAVE_PTHREAD_SET_NAME)[m
[31m-     pthread_set_name_np (_descriptor, name_);[m
[31m- #endif[m
[31m-+#endif[m
[31m-+    return;[m
[31m- }[m
[31m- [m
[31m- #endif[m
[31m--- [m
[31m-2.17.1[m
[31m-[m
[33mdiff --git a/depends/patches/zeromq/remove_libstd_link.patch b/depends/patches/zeromq/remove_libstd_link.patch[m
[33mnew file mode 100644[m
[33mindex 0000000000..ddf91e6abf[m
[33m--- /dev/null[m
[33m+++ b/depends/patches/zeromq/remove_libstd_link.patch[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32mcommit 47d4cd12a2c051815ddda78adebdb3923b260d8a[m
[32m+[m[32mAuthor: fanquake <fanquake@gmail.com>[m
[32m+[m[32mDate:   Tue Aug 18 14:45:40 2020 +0800[m
[32m+[m
[32m+[m[32m    Remove needless linking against libstdc++[m
[32m+[m
[32m+[m[32m    This is broken for a number of reasons, including:[m
[32m+[m[32m    - g++ understands "static-libstdc++ -lstdc++" to mean "link against[m
[32m+[m[32m      whatever libstdc++ exists, probably shared", which in itself is buggy.[m
[32m+[m[32m    - another stdlib (libc++ for example) may be in use[m
[32m+[m
[32m+[m[32m    See #11981.[m
[32m+[m
[32m+[m[32mdiff --git a/src/libzmq.pc.in b/src/libzmq.pc.in[m
[32m+[m[32mindex 233bc3a..3c2bf0d 100644[m
[32m+[m[32m--- a/src/libzmq.pc.in[m
[32m+[m[32m+++ b/src/libzmq.pc.in[m
[32m+[m[32m@@ -7,6 +7,6 @@ Name: libzmq[m
[32m+[m[32m Description: 0MQ c++ library[m
[32m+[m[32m Version: @VERSION@[m
[32m+[m[32m Libs: -L${libdir} -lzmq[m
[32m+[m[32m-Libs.private: -lstdc++ @pkg_config_libs_private@[m
[32m+[m[32m+Libs.private: @pkg_config_libs_private@[m
[32m+[m[32m Requires.private: @pkg_config_names_private@[m
[32m+[m[32m Cflags: -I${includedir} @pkg_config_defines@[m
[33mdiff --git a/doc/developer-notes.md b/doc/developer-notes.md[m
[33mindex 6ae7e770e8..ef9ecbb085 100644[m
[33m--- a/doc/developer-notes.md[m
[33m+++ b/doc/developer-notes.md[m
[36m@@ -746,6 +746,72 @@[m [mthe upper cycle, etc.[m
 Threads and synchronization[m
 ----------------------------[m
 [m
[32m+[m[32m- Prefer `Mutex` type to `RecursiveMutex` one[m
[32m+[m
[32m+[m[32m- Consistently use [Clang Thread Safety Analysis](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html) annotations to[m
[32m+[m[32m  get compile-time warnings about potential race conditions in code. Combine annotations in function declarations with[m
[32m+[m[32m  run-time asserts in function definitions:[m
[32m+[m
[32m+[m[32m```C++[m
[32m+[m[32m// txmempool.h[m
[32m+[m[32mclass CTxMemPool[m
[32m+[m[32m{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    ...[m
[32m+[m[32m    mutable RecursiveMutex cs;[m
[32m+[m[32m    ...[m
[32m+[m[32m    void UpdateTransactionsFromBlock(...) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, cs);[m
[32m+[m[32m    ...[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// txmempool.cpp[m
[32m+[m[32mvoid CTxMemPool::UpdateTransactionsFromBlock(...)[m
[32m+[m[32m{[m
[32m+[m[32m    AssertLockHeld(::cs_main);[m
[32m+[m[32m    AssertLockHeld(cs);[m
[32m+[m[32m    ...[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m```C++[m
[32m+[m[32m// validation.h[m
[32m+[m[32mclass ChainstateManager[m
[32m+[m[32m{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    ...[m
[32m+[m[32m    bool ProcessNewBlock(...) EXCLUSIVE_LOCKS_REQUIRED(!::cs_main);[m
[32m+[m[32m    ...[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// validation.cpp[m
[32m+[m[32mbool ChainstateManager::ProcessNewBlock(...)[m
[32m+[m[32m{[m
[32m+[m[32m    AssertLockNotHeld(::cs_main);[m
[32m+[m[32m    ...[m
[32m+[m[32m    LOCK(::cs_main);[m
[32m+[m[32m    ...[m
[32m+[m[32m}[m
[32m+[m[32m```[m
[32m+[m
[32m+[m[32m- When Clang Thread Safety Analysis is unable to determine if a mutex is locked, use `LockAssertion` class instances:[m
[32m+[m
[32m+[m[32m```C++[m
[32m+[m[32m// net_processing.h[m
[32m+[m[32mvoid RelayTransaction(...) EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[32m+[m
[32m+[m[32m// net_processing.cpp[m
[32m+[m[32mvoid RelayTransaction(...)[m
[32m+[m[32m{[m
[32m+[m[32m    AssertLockHeld(::cs_main);[m
[32m+[m
[32m+[m[32m    connman.ForEachNode([&txid, &wtxid](CNode* pnode) {[m
[32m+[m[32m        LockAssertion lock(::cs_main);[m
[32m+[m[32m        ...[m
[32m+[m[32m    });[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m```[m
[32m+[m
 - Build and run tests with `-DDEBUG_LOCKORDER` to verify that no potential[m
   deadlocks are introduced. As of 0.12, this is defined by default when[m
   configuring with `--enable-debug`.[m
[33mdiff --git a/doc/release-notes-18244.md b/doc/release-notes-18244.md[m
[33mnew file mode 100644[m
[33mindex 0000000000..625fbaf7a1[m
[33m--- /dev/null[m
[33m+++ b/doc/release-notes-18244.md[m
[36m@@ -0,0 +1,7 @@[m
[32m+[m[32mUpdated RPCs[m
[32m+[m[32m------------[m
[32m+[m
[32m+[m[32m- `fundrawtransaction` and `walletcreatefundedpsbt` when used with the `lockUnspents`[m
[32m+[m[32m   argument now lock manually selected coins, in addition to automatically selected[m
[32m+[m[32m   coins. Note that locked coins are never used in automatic coin selection, but[m
[32m+[m[32m   can still be manually selected.[m
[33mdiff --git a/doc/release-notes-19671.md b/doc/release-notes-19671.md[m
[33mnew file mode 100644[m
[33mindex 0000000000..fb2d56d9a5[m
[33m--- /dev/null[m
[33m+++ b/doc/release-notes-19671.md[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mWallet[m
[32m+[m[32m------[m
[32m+[m
[32m+[m[32m* The `-zapwallettxes` startup option has been removed and its functionality removed from the wallet.[m
[32m+[m[32m  This option was originally intended to allow for the fee bumping of transactions that did not[m
[32m+[m[32m  signal RBF. This functionality has been superseded with the abandon transaction feature.[m
[33mdiff --git a/doc/release-notes.md b/doc/release-notes.md[m
[33mindex 4656963f5a..a8bd68370d 100644[m
[33m--- a/doc/release-notes.md[m
[33m+++ b/doc/release-notes.md[m
[36m@@ -139,6 +139,10 @@[m [mUpdated settings[m
   in future releases. Refer to the help of the affected settings `-whitebind`[m
   and `-whitelist` for more details. (#19191)[m
 [m
[32m+[m[32m- Netmasks that contain 1-bits after 0-bits (the 1-bits are not contiguous on[m
[32m+[m[32m  the left side, e.g. 255.0.255.255) are no longer accepted. They are invalid[m
[32m+[m[32m  according to RFC 4632.[m
[32m+[m
 Changes to Wallet or GUI related settings can be found in the GUI or Wallet  section below.[m
 [m
 Tools and Utilities[m
[33mdiff --git a/src/Makefile.test.include b/src/Makefile.test.include[m
[33mindex 0068c94070..91cdecad40 100644[m
[33m--- a/src/Makefile.test.include[m
[33m+++ b/src/Makefile.test.include[m
[36m@@ -70,6 +70,7 @@[m [mFUZZ_TARGETS = \[m
   test/fuzz/message \[m
   test/fuzz/messageheader_deserialize \[m
   test/fuzz/multiplication_overflow \[m
[32m+[m[32m  test/fuzz/net \[m
   test/fuzz/net_permissions \[m
   test/fuzz/netaddr_deserialize \[m
   test/fuzz/netaddress \[m
[36m@@ -132,6 +133,8 @@[m [mFUZZ_TARGETS = \[m
   test/fuzz/script_sigcache \[m
   test/fuzz/script_sign \[m
   test/fuzz/scriptnum_ops \[m
[32m+[m[32m  test/fuzz/secp256k1_ec_seckey_import_export_der \[m
[32m+[m[32m  test/fuzz/secp256k1_ecdsa_signature_parse_der_lax \[m
   test/fuzz/service_deserialize \[m
   test/fuzz/signature_checker \[m
   test/fuzz/snapshotmetadata_deserialize \[m
[36m@@ -722,6 +725,12 @@[m [mtest_fuzz_multiplication_overflow_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
 test_fuzz_multiplication_overflow_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)[m
 test_fuzz_multiplication_overflow_SOURCES = test/fuzz/multiplication_overflow.cpp[m
 [m
[32m+[m[32mtest_fuzz_net_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)[m
[32m+[m[32mtest_fuzz_net_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
[32m+[m[32mtest_fuzz_net_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[32m+[m[32mtest_fuzz_net_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)[m
[32m+[m[32mtest_fuzz_net_SOURCES = test/fuzz/net.cpp[m
[32m+[m
 test_fuzz_net_permissions_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)[m
 test_fuzz_net_permissions_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
 test_fuzz_net_permissions_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[36m@@ -1094,6 +1103,18 @@[m [mtest_fuzz_scriptnum_ops_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
 test_fuzz_scriptnum_ops_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)[m
 test_fuzz_scriptnum_ops_SOURCES = test/fuzz/scriptnum_ops.cpp[m
 [m
[32m+[m[32mtest_fuzz_secp256k1_ec_seckey_import_export_der_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)[m
[32m+[m[32mtest_fuzz_secp256k1_ec_seckey_import_export_der_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
[32m+[m[32mtest_fuzz_secp256k1_ec_seckey_import_export_der_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[32m+[m[32mtest_fuzz_secp256k1_ec_seckey_import_export_der_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)[m
[32m+[m[32mtest_fuzz_secp256k1_ec_seckey_import_export_der_SOURCES = test/fuzz/secp256k1_ec_seckey_import_export_der.cpp[m
[32m+[m
[32m+[m[32mtest_fuzz_secp256k1_ecdsa_signature_parse_der_lax_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)[m
[32m+[m[32mtest_fuzz_secp256k1_ecdsa_signature_parse_der_lax_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
[32m+[m[32mtest_fuzz_secp256k1_ecdsa_signature_parse_der_lax_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[32m+[m[32mtest_fuzz_secp256k1_ecdsa_signature_parse_der_lax_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)[m
[32m+[m[32mtest_fuzz_secp256k1_ecdsa_signature_parse_der_lax_SOURCES = test/fuzz/secp256k1_ecdsa_signature_parse_der_lax.cpp[m
[32m+[m
 test_fuzz_service_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DSERVICE_DESERIALIZE=1[m
 test_fuzz_service_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)[m
 test_fuzz_service_deserialize_LDADD = $(FUZZ_SUITE_LD_COMMON)[m
[33mdiff --git a/src/addrman.cpp b/src/addrman.cpp[m
[33mindex 7636c6bad2..f4a779ee0f 100644[m
[33m--- a/src/addrman.cpp[m
[33m+++ b/src/addrman.cpp[m
[36m@@ -9,6 +9,9 @@[m
 #include <logging.h>[m
 #include <serialize.h>[m
 [m
[32m+[m[32m#include <unordered_map>[m
[32m+[m[32m#include <unordered_set>[m
[32m+[m
 int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const[m
 {[m
     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();[m
[36m@@ -73,12 +76,12 @@[m [mdouble CAddrInfo::GetChance(int64_t nNow) const[m
 [m
 CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)[m
 {[m
[31m-    std::map<CNetAddr, int>::iterator it = mapAddr.find(addr);[m
[32m+[m[32m    const auto it = mapAddr.find(addr);[m
     if (it == mapAddr.end())[m
         return nullptr;[m
     if (pnId)[m
         *pnId = (*it).second;[m
[31m-    std::map<int, CAddrInfo>::iterator it2 = mapInfo.find((*it).second);[m
[32m+[m[32m    const auto it2 = mapInfo.find((*it).second);[m
     if (it2 != mapInfo.end())[m
         return &(*it2).second;[m
     return nullptr;[m
[36m@@ -404,8 +407,8 @@[m [mCAddrInfo CAddrMan::Select_(bool newOnly)[m
 #ifdef DEBUG_ADDRMAN[m
 int CAddrMan::Check_()[m
 {[m
[31m-    std::set<int> setTried;[m
[31m-    std::map<int, int> mapNew;[m
[32m+[m[32m    std::unordered_set<int> setTried;[m
[32m+[m[32m    std::unordered_map<int, int> mapNew;[m
 [m
     if (vRandom.size() != (size_t)(nTried + nNew))[m
         return -7;[m
[33mdiff --git a/src/addrman.h b/src/addrman.h[m
[33mindex ca045b91cd..c00d262b65 100644[m
[33m--- a/src/addrman.h[m
[33m+++ b/src/addrman.h[m
[36m@@ -7,20 +7,20 @@[m
 #define BITCOIN_ADDRMAN_H[m
 [m
 #include <clientversion.h>[m
[2m+[m[2m#include <fs.h>[m
[2m+[m[2m#include <hash.h>[m
 #include <netaddress.h>[m
 #include <protocol.h>[m
 #include <random.h>[m
[32m+[m[32m#include <streams.h>[m
 #include <sync.h>[m
 #include <timedata.h>[m
 #include <util/system.h>[m
 [m
[2m-#include <fs.h>[m
[2m-#include <hash.h>[m
 #include <iostream>[m
[31m-#include <map>[m
 #include <set>[m
 #include <stdint.h>[m
[31m-#include <streams.h>[m
[32m+[m[32m#include <unordered_map>[m
 #include <vector>[m
 [m
 /**[m
[36m@@ -175,14 +175,17 @@[m [mprotected:[m
     mutable RecursiveMutex cs;[m
 [m
 private:[m
[32m+[m[32m    using MapInfo = std::unordered_map<int, CAddrInfo>;[m
[32m+[m[32m    using MapAddr = std::unordered_map<CNetAddr, int, CNetAddrHash>;[m
[32m+[m
     //! last used nId[m
     int nIdCount GUARDED_BY(cs);[m
 [m
     //! table with information about all nIds[m
[31m-    std::map<int, CAddrInfo> mapInfo GUARDED_BY(cs);[m
[32m+[m[32m    MapInfo mapInfo GUARDED_BY(cs);[m
 [m
     //! find an nId based on its network address[m
[31m-    std::map<CNetAddr, int> mapAddr GUARDED_BY(cs);[m
[32m+[m[32m    MapAddr mapAddr GUARDED_BY(cs);[m
 [m
     //! randomly-ordered vector of all nIds[m
     std::vector<int> vRandom GUARDED_BY(cs);[m
[36m@@ -327,7 +330,7 @@[m [mpublic:[m
 [m
         int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);[m
         s << nUBuckets;[m
[31m-        std::map<int, int> mapUnkIds;[m
[32m+[m[32m        std::unordered_map<int, int> mapUnkIds;[m
         int nIds = 0;[m
         for (const auto& entry : mapInfo) {[m
             mapUnkIds[entry.first] = nIds;[m
[36m@@ -430,7 +433,7 @@[m [mpublic:[m
         nTried -= nLost;[m
 [m
         // Store positions in the new table buckets to apply later (if possible).[m
[31m-        std::map<int, int> entryToBucket; // Represents which entry belonged to which bucket when serializing[m
[32m+[m[32m        std::unordered_map<int, int> entryToBucket; // Represents which entry belonged to which bucket when serializing[m
 [m
         for (int bucket = 0; bucket < nUBuckets; bucket++) {[m
             int nSize = 0;[m
[36m@@ -477,15 +480,28 @@[m [mpublic:[m
 [m
         // Prune new entries with refcount 0 (as a result of collisions).[m
         int nLostUnk = 0;[m
[31m-        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ) {[m
[32m+[m[32m#if __cplusplus >= 201402L // C++14 or higher, erasing from unordered_map is guaranteed to preserve the order of not deleted elements[m
[32m+[m[32m        for (MapInfo::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ) {[m
             if (it->second.fInTried == false && it->second.nRefCount == 0) {[m
[31m-                std::map<int, CAddrInfo>::const_iterator itCopy = it++;[m
[32m+[m[32m                auto itCopy = it++;[m
                 Delete(itCopy->first);[m
                 nLostUnk++;[m
             } else {[m
[31m-                it++;[m
[32m+[m[32m                ++it;[m
             }[m
         }[m
[32m+[m[32m#else // pre C++14, drop this once we switch to C++14 or higher[m
[32m+[m[32m        std::vector<MapInfo::const_iterator> to_delete;[m
[32m+[m[32m        for (MapInfo::const_iterator it = mapInfo.begin(); it != mapInfo.end(); ++it) {[m
[32m+[m[32m            if (it->second.fInTried == false && it->second.nRefCount == 0) {[m
[32m+[m[32m                to_delete.push_back(it);[m
[32m+[m[32m                nLostUnk++;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        for (auto& it : to_delete) {[m
[32m+[m[32m            Delete(it->first);[m
[32m+[m[32m        }[m
[32m+[m[32m#endif[m
         if (nLost + nLostUnk > 0) {[m
             LogPrint(BCLog::ADDRMAN, "addrman lost %i new and %i tried addresses due to collisions\n", nLostUnk, nLost);[m
         }[m
[33mdiff --git a/src/base58.cpp b/src/base58.cpp[m
[33mindex 18cd2090e0..0dc6044145 100644[m
[33m--- a/src/base58.cpp[m
[33m+++ b/src/base58.cpp[m
[36m@@ -35,7 +35,7 @@[m [mstatic const int8_t mapBase58[256] = {[m
     -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,[m
 };[m
 [m
[31m-bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch, int max_ret_len)[m
[32m+[m[32mNODISCARD static bool DecodeBase58(const char* psz, std::vector<unsigned char>& vch, int max_ret_len)[m
 {[m
     // Skip leading spaces.[m
     while (*psz && IsSpace(*psz))[m
[36m@@ -141,7 +141,7 @@[m [mstd::string EncodeBase58Check(Span<const unsigned char> input)[m
     return EncodeBase58(vch);[m
 }[m
 [m
[31m-bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet, int max_ret_len)[m
[32m+[m[32mNODISCARD static bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet, int max_ret_len)[m
 {[m
     if (!DecodeBase58(psz, vchRet, max_ret_len > std::numeric_limits<int>::max() - 4 ? std::numeric_limits<int>::max() : max_ret_len + 4) ||[m
         (vchRet.size() < 4)) {[m
[33mdiff --git a/src/base58.h b/src/base58.h[m
[33mindex b87664b78b..468c3e2589 100644[m
[33m--- a/src/base58.h[m
[33m+++ b/src/base58.h[m
[36m@@ -25,13 +25,6 @@[m
  */[m
 std::string EncodeBase58(Span<const unsigned char> input);[m
 [m
[31m-/**[m
[31m- * Decode a base58-encoded string (psz) into a byte vector (vchRet).[m
[31m- * return true if decoding is successful.[m
[31m- * psz cannot be nullptr.[m
[31m- */[m
[31m-NODISCARD bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet, int max_ret_len);[m
[31m-[m
 /**[m
  * Decode a base58-encoded string (str) into a byte vector (vchRet).[m
  * return true if decoding is successful.[m
[36m@@ -43,12 +36,6 @@[m [mNODISCARD bool DecodeBase58(const std::string& str, std::vector<unsigned char>&[m
  */[m
 std::string EncodeBase58Check(Span<const unsigned char> input);[m
 [m
[31m-/**[m
[31m- * Decode a base58-encoded string (psz) that includes a checksum into a byte[m
[31m- * vector (vchRet), return true if decoding is successful[m
[31m- */[m
[31m-NODISCARD bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet, int max_ret_len);[m
[31m-[m
 /**[m
  * Decode a base58-encoded string (str) that includes a checksum into a byte[m
  * vector (vchRet), return true if decoding is successful[m
[33mdiff --git a/src/bench/bench.cpp b/src/bench/bench.cpp[m
[33mindex 01466d0b6f..012057e792 100644[m
[33m--- a/src/bench/bench.cpp[m
[33m+++ b/src/bench/bench.cpp[m
[36m@@ -70,7 +70,10 @@[m [mvoid benchmark::BenchRunner::RunAll(const Args& args)[m
             }[m
             std::cout << bench.complexityBigO() << std::endl;[m
         }[m
[31m-        benchmarkResults.push_back(bench.results().back());[m
[32m+[m
[32m+[m[32m        if (!bench.results().empty()) {[m
[32m+[m[32m            benchmarkResults.push_back(bench.results().back());[m
[32m+[m[32m        }[m
     }[m
 [m
     GenerateTemplateResults(benchmarkResults, args.output_csv, "# Benchmark, evals, iterations, total, min, max, median\n"[m
[33mdiff --git a/src/bench/checkqueue.cpp b/src/bench/checkqueue.cpp[m
[33mindex 19d7bc0dbc..ffa772d8c1 100644[m
[33m--- a/src/bench/checkqueue.cpp[m
[33m+++ b/src/bench/checkqueue.cpp[m
[36m@@ -14,8 +14,6 @@[m
 [m
 #include <vector>[m
 [m
[31m-[m
[31m-static const int MIN_CORES = 2;[m
 static const size_t BATCHES = 101;[m
 static const size_t BATCH_SIZE = 30;[m
 static const int PREVECTOR_SIZE = 28;[m
[36m@@ -26,6 +24,9 @@[m [mstatic const unsigned int QUEUE_BATCH_SIZE = 128;[m
 // and there is a little bit of work done between calls to Add.[m
 static void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)[m
 {[m
[32m+[m[32m    // We shouldn't ever be running with the checkqueue on a single core machine.[m
[32m+[m[32m    if (GetNumCores() <= 1) return;[m
[32m+[m
     const ECCVerifyHandle verify_handle;[m
     ECC_Start();[m
 [m
[36m@@ -44,7 +45,9 @@[m [mstatic void CCheckQueueSpeedPrevectorJob(benchmark::Bench& bench)[m
     };[m
     CCheckQueue<PrevectorJob> queue {QUEUE_BATCH_SIZE};[m
     boost::thread_group tg;[m
[31m-    for (auto x = 0; x < std::max(MIN_CORES, GetNumCores()); ++x) {[m
[32m+[m[32m    // The main thread should be counted to prevent thread oversubscription, and[m
[32m+[m[32m    // to decrease the variance of benchmark results.[m
[32m+[m[32m    for (auto x = 0; x < GetNumCores() - 1; ++x) {[m
        tg.create_thread([&]{queue.Thread();});[m
     }[m
 [m
[33mdiff --git a/src/bitcoind.cpp b/src/bitcoind.cpp[m
[33mindex b04cc12059..02074f820a 100644[m
[33m--- a/src/bitcoind.cpp[m
[33m+++ b/src/bitcoind.cpp[m
[36m@@ -44,34 +44,28 @@[m [mstatic void WaitForShutdown(NodeContext& node)[m
 static bool AppInit(int argc, char* argv[])[m
 {[m
     NodeContext node;[m
[2m-    node.chain = interfaces::MakeChain(node);[m
 [m
     bool fRet = false;[m
 [m
     util::ThreadSetInternalName("init");[m
 [m
[31m-    //[m
[31m-    // Parameters[m
[31m-    //[m
     // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()[m
     SetupServerArgs(node);[m
[32m+[m[32m    ArgsManager& args = *Assert(node.args);[m
     std::string error;[m
[2m-    if (!gArgs.ParseParameters(argc, argv, error)) {[m
[32m+[m[32m    if (!args.ParseParameters(argc, argv, error)) {[m
         return InitError(Untranslated(strprintf("Error parsing command line arguments: %s\n", error)));[m
     }[m
 [m
     // Process help and version before taking care about datadir[m
[31m-    if (HelpRequested(gArgs) || gArgs.IsArgSet("-version")) {[m
[32m+[m[32m    if (HelpRequested(args) || args.IsArgSet("-version")) {[m
         std::string strUsage = PACKAGE_NAME " version " + FormatFullVersion() + "\n";[m
 [m
[31m-        if (gArgs.IsArgSet("-version"))[m
[31m-        {[m
[32m+[m[32m        if (args.IsArgSet("-version")) {[m
             strUsage += FormatParagraph(LicenseInfo()) + "\n";[m
[31m-        }[m
[31m-        else[m
[31m-        {[m
[32m+[m[32m        } else {[m
             strUsage += "\nUsage:  bitcoind [options]                     Start " PACKAGE_NAME "\n";[m
[31m-            strUsage += "\n" + gArgs.GetHelpMessage();[m
[32m+[m[32m            strUsage += "\n" + args.GetHelpMessage();[m
         }[m
 [m
         tfm::format(std::cout, "%s", strUsage);[m
[36m@@ -82,14 +76,14 @@[m [mstatic bool AppInit(int argc, char* argv[])[m
     try[m
     {[m
         if (!CheckDataDirOption()) {[m
[31m-            return InitError(Untranslated(strprintf("Specified data directory \"%s\" does not exist.\n", gArgs.GetArg("-datadir", ""))));[m
[32m+[m[32m            return InitError(Untranslated(strprintf("Specified data directory \"%s\" does not exist.\n", args.GetArg("-datadir", ""))));[m
         }[m
[31m-        if (!gArgs.ReadConfigFiles(error, true)) {[m
[32m+[m[32m        if (!args.ReadConfigFiles(error, true)) {[m
             return InitError(Untranslated(strprintf("Error reading configuration file: %s\n", error)));[m
         }[m
         // Check for -chain, -testnet or -regtest parameter (Params() calls are only valid after this clause)[m
         try {[m
[2m-            SelectParams(gArgs.GetChainName());[m
[32m+[m[32m            SelectParams(args.GetChainName());[m
         } catch (const std::exception& e) {[m
             return InitError(Untranslated(strprintf("%s\n", e.what())));[m
         }[m
[36m@@ -101,23 +95,21 @@[m [mstatic bool AppInit(int argc, char* argv[])[m
             }[m
         }[m
 [m
[31m-        if (!gArgs.InitSettings(error)) {[m
[32m+[m[32m        if (!args.InitSettings(error)) {[m
             InitError(Untranslated(error));[m
             return false;[m
         }[m
 [m
         // -server defaults to true for bitcoind but not for the GUI so do this here[m
[31m-        gArgs.SoftSetBoolArg("-server", true);[m
[32m+[m[32m        args.SoftSetBoolArg("-server", true);[m
         // Set this early so that parameter interactions go to console[m
[31m-        InitLogging();[m
[31m-        InitParameterInteraction();[m
[31m-        if (!AppInitBasicSetup())[m
[31m-        {[m
[32m+[m[32m        InitLogging(args);[m
[32m+[m[32m        InitParameterInteraction(args);[m
[32m+[m[32m        if (!AppInitBasicSetup(args)) {[m
             // InitError will have been called with detailed error, which ends up on console[m
             return false;[m
         }[m
[31m-        if (!AppInitParameterInteraction())[m
[31m-        {[m
[32m+[m[32m        if (!AppInitParameterInteraction(args)) {[m
             // InitError will have been called with detailed error, which ends up on console[m
             return false;[m
         }[m
[36m@@ -126,8 +118,7 @@[m [mstatic bool AppInit(int argc, char* argv[])[m
             // InitError will have been called with detailed error, which ends up on console[m
             return false;[m
         }[m
[31m-        if (gArgs.GetBoolArg("-daemon", false))[m
[31m-        {[m
[32m+[m[32m        if (args.GetBoolArg("-daemon", false)) {[m
 #if HAVE_DECL_DAEMON[m
 #if defined(MAC_OSX)[m
 #pragma GCC diagnostic push[m
[36m@@ -152,7 +143,7 @@[m [mstatic bool AppInit(int argc, char* argv[])[m
             // If locking the data directory failed, exit immediately[m
             return false;[m
         }[m
[31m-        fRet = AppInitMain(context, node);[m
[32m+[m[32m        fRet = AppInitInterfaces(node) && AppInitMain(context, node);[m
     }[m
     catch (const std::exception& e) {[m
         PrintExceptionContinue(&e, "AppInit()");[m
[33mdiff --git a/src/chain.h b/src/chain.h[m
[33mindex 802e23f775..43e8a39f36 100644[m
[33m--- a/src/chain.h[m
[33m+++ b/src/chain.h[m
[36m@@ -398,12 +398,6 @@[m [mpublic:[m
         return vChain[nHeight];[m
     }[m
 [m
[31m-    /** Compare two chains efficiently. */[m
[31m-    friend bool operator==(const CChain &a, const CChain &b) {[m
[31m-        return a.vChain.size() == b.vChain.size() &&[m
[31m-               a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];[m
[31m-    }[m
[31m-[m
     /** Efficiently check whether a block is present in this chain. */[m
     bool Contains(const CBlockIndex *pindex) const {[m
         return (*this)[pindex->nHeight] == pindex;[m
[33mdiff --git a/src/compat.h b/src/compat.h[m
[33mindex 68f6eb692c..0be02cae03 100644[m
[33m--- a/src/compat.h[m
[33m+++ b/src/compat.h[m
[36m@@ -11,9 +11,6 @@[m
 #endif[m
 [m
 #ifdef WIN32[m
[31m-#ifndef WIN32_LEAN_AND_MEAN[m
[31m-#define WIN32_LEAN_AND_MEAN 1[m
[31m-#endif[m
 #ifndef NOMINMAX[m
 #define NOMINMAX[m
 #endif[m
[33mdiff --git a/src/dummywallet.cpp b/src/dummywallet.cpp[m
[33mindex 380d4eb8ac..8d2dcd0279 100644[m
[33m--- a/src/dummywallet.cpp[m
[33m+++ b/src/dummywallet.cpp[m
[36m@@ -4,11 +4,8 @@[m
 [m
 #include <util/system.h>[m
 #include <walletinitinterface.h>[m
[31m-#include <support/allocators/secure.h>[m
 [m
 class CWallet;[m
[2m-enum class WalletCreationStatus;[m
[31m-struct bilingual_str;[m
 [m
 namespace interfaces {[m
 class Chain;[m
[36m@@ -49,7 +46,6 @@[m [mvoid DummyWalletInit::AddWalletOptions(ArgsManager& argsman) const[m
         "-walletdir=<dir>",[m
         "-walletnotify=<cmd>",[m
         "-walletrbf",[m
[31m-        "-zapwallettxes=<mode>",[m
         "-dblogsize=<n>",[m
         "-flushwallet",[m
         "-privdb",[m
[36m@@ -59,37 +55,6 @@[m [mvoid DummyWalletInit::AddWalletOptions(ArgsManager& argsman) const[m
 [m
 const WalletInitInterface& g_wallet_init_interface = DummyWalletInit();[m
 [m
[31m-fs::path GetWalletDir()[m
[31m-{[m
[31m-    throw std::logic_error("Wallet function called in non-wallet build.");[m
[31m-}[m
[31m-[m
[31m-std::vector<fs::path> ListWalletDir()[m
[31m-{[m
[31m-    throw std::logic_error("Wallet function called in non-wallet build.");[m
[31m-}[m
[31m-[m
[31m-std::vector<std::shared_ptr<CWallet>> GetWallets()[m
[31m-{[m
[31m-    throw std::logic_error("Wallet function called in non-wallet build.");[m
[31m-}[m
[31m-[m
[31m-std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings)[m
[31m-{[m
[31m-    throw std::logic_error("Wallet function called in non-wallet build.");[m
[31m-}[m
[31m-[m
[31m-WalletCreationStatus CreateWallet(interfaces::Chain& chain, const SecureString& passphrase, uint64_t wallet_creation_flags, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings, std::shared_ptr<CWallet>& result)[m
[31m-{[m
[31m-    throw std::logic_error("Wallet function called in non-wallet build.");[m
[31m-}[m
[31m-[m
[31m-using LoadWalletFn = std::function<void(std::unique_ptr<interfaces::Wallet> wallet)>;[m
[31m-std::unique_ptr<interfaces::Handler> HandleLoadWallet(LoadWalletFn load_wallet)[m
[31m-{[m
[31m-    throw std::logic_error("Wallet function called in non-wallet build.");[m
[31m-}[m
[31m-[m
 namespace interfaces {[m
 [m
 std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)[m
[33mdiff --git a/src/hash.cpp b/src/hash.cpp[m
[33mindex 4c09f5f646..83b90ae063 100644[m
[33m--- a/src/hash.cpp[m
[33m+++ b/src/hash.cpp[m
[36m@@ -77,3 +77,10 @@[m [mvoid BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char he[m
     num[3] = (nChild >>  0) & 0xFF;[m
     CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);[m
 }[m
[32m+[m
[32m+[m[32muint256 SHA256Uint256(const uint256& input)[m
[32m+[m[32m{[m
[32m+[m[32m    uint256 result;[m
[32m+[m[32m    CSHA256().Write(input.begin(), 32).Finalize(result.begin());[m
[32m+[m[32m    return result;[m
[32m+[m[32m}[m
[33mdiff --git a/src/hash.h b/src/hash.h[m
[33mindex 71806483ff..c16bbb48ce 100644[m
[33m--- a/src/hash.h[m
[33m+++ b/src/hash.h[m
[36m@@ -6,6 +6,7 @@[m
 #ifndef BITCOIN_HASH_H[m
 #define BITCOIN_HASH_H[m
 [m
[32m+[m[32m#include <attributes.h>[m
 #include <crypto/common.h>[m
 #include <crypto/ripemd160.h>[m
 #include <crypto/sha256.h>[m
[36m@@ -98,7 +99,7 @@[m [minline uint160 Hash160(const T1& in1)[m
 class CHashWriter[m
 {[m
 private:[m
[31m-    CHash256 ctx;[m
[32m+[m[32m    CSHA256 ctx;[m
 [m
     const int nType;[m
     const int nVersion;[m
[36m@@ -110,13 +111,27 @@[m [mpublic:[m
     int GetVersion() const { return nVersion; }[m
 [m
     void write(const char *pch, size_t size) {[m
[31m-        ctx.Write({(const unsigned char*)pch, size});[m
[32m+[m[32m        ctx.Write((const unsigned char*)pch, size);[m
     }[m
 [m
[31m-    // invalidates the object[m
[32m+[m[32m    /** Compute the double-SHA256 hash of all data written to this object.[m
[32m+[m[32m     *[m
[32m+[m[32m     * Invalidates this object.[m
[32m+[m[32m     */[m
     uint256 GetHash() {[m
         uint256 result;[m
[31m-        ctx.Finalize(result);[m
[32m+[m[32m        ctx.Finalize(result.begin());[m
[32m+[m[32m        ctx.Reset().Write(result.begin(), CSHA256::OUTPUT_SIZE).Finalize(result.begin());[m
[32m+[m[32m        return result;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /** Compute the SHA256 hash of all data written to this object.[m
[32m+[m[32m     *[m
[32m+[m[32m     * Invalidates this object.[m
[32m+[m[32m     */[m
[32m+[m[32m    uint256 GetSHA256() {[m
[32m+[m[32m        uint256 result;[m
[32m+[m[32m        ctx.Finalize(result.begin());[m
         return result;[m
     }[m
 [m
[36m@@ -124,9 +139,8 @@[m [mpublic:[m
      * Returns the first 64 bits from the resulting hash.[m
      */[m
     inline uint64_t GetCheapHash() {[m
[31m-        unsigned char result[CHash256::OUTPUT_SIZE];[m
[31m-        ctx.Finalize(result);[m
[31m-        return ReadLE64(result);[m
[32m+[m[32m        uint256 result = GetHash();[m
[32m+[m[32m        return ReadLE64(result.begin());[m
     }[m
 [m
     template<typename T>[m
[36m@@ -181,6 +195,9 @@[m [muint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL[m
     return ss.GetHash();[m
 }[m
 [m
[32m+[m[32m/** Single-SHA256 a 32-byte input (represented as uint256). */[m
[32m+[m[32mNODISCARD uint256 SHA256Uint256(const uint256& input);[m
[32m+[m
 unsigned int MurmurHash3(unsigned int nHashSeed, Span<const unsigned char> vDataToHash);[m
 [m
 void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex ebea6037d6..4b689d6153 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -107,14 +107,14 @@[m [mstatic const char* DEFAULT_ASMAP_FILENAME="ip_asn.map";[m
  */[m
 static const char* BITCOIN_PID_FILENAME = "bitcoind.pid";[m
 [m
[31m-static fs::path GetPidFile()[m
[32m+[m[32mstatic fs::path GetPidFile(const ArgsManager& args)[m
 {[m
[31m-    return AbsPathForConfigVal(fs::path(gArgs.GetArg("-pid", BITCOIN_PID_FILENAME)));[m
[32m+[m[32m    return AbsPathForConfigVal(fs::path(args.GetArg("-pid", BITCOIN_PID_FILENAME)));[m
 }[m
 [m
[31m-NODISCARD static bool CreatePidFile()[m
[32m+[m[32mNODISCARD static bool CreatePidFile(const ArgsManager& args)[m
 {[m
[31m-    fsbridge::ofstream file{GetPidFile()};[m
[32m+[m[32m    fsbridge::ofstream file{GetPidFile(args)};[m
     if (file) {[m
 #ifdef WIN32[m
         tfm::format(file, "%d\n", GetCurrentProcessId());[m
[36m@@ -123,7 +123,7 @@[m [mNODISCARD static bool CreatePidFile()[m
 #endif[m
         return true;[m
     } else {[m
[31m-        return InitError(strprintf(_("Unable to create the PID file '%s': %s"), GetPidFile().string(), std::strerror(errno)));[m
[32m+[m[32m        return InitError(strprintf(_("Unable to create the PID file '%s': %s"), GetPidFile(args).string(), std::strerror(errno)));[m
     }[m
 }[m
 [m
[36m@@ -180,6 +180,7 @@[m [mvoid Shutdown(NodeContext& node)[m
     TRY_LOCK(g_shutdown_mutex, lock_shutdown);[m
     if (!lock_shutdown) return;[m
     LogPrintf("%s: In progress...\n", __func__);[m
[32m+[m[32m    Assert(node.args);[m
 [m
     /// Note: Shutdown() must be able to handle cases in which initialization failed part of the way,[m
     /// for example if the data directory was found to be locked.[m
[36m@@ -230,7 +231,7 @@[m [mvoid Shutdown(NodeContext& node)[m
     node.connman.reset();[m
     node.banman.reset();[m
 [m
[31m-    if (::mempool.IsLoaded() && gArgs.GetArg("-persistmempool", DEFAULT_PERSIST_MEMPOOL)) {[m
[32m+[m[32m    if (::mempool.IsLoaded() && node.args->GetArg("-persistmempool", DEFAULT_PERSIST_MEMPOOL)) {[m
         DumpMempool(::mempool);[m
     }[m
 [m
[36m@@ -301,19 +302,19 @@[m [mvoid Shutdown(NodeContext& node)[m
     GetMainSignals().UnregisterBackgroundSignalScheduler();[m
     globalVerifyHandle.reset();[m
     ECC_Stop();[m
[31m-    node.args = nullptr;[m
     node.mempool = nullptr;[m
     node.chainman = nullptr;[m
     node.scheduler.reset();[m
 [m
     try {[m
[31m-        if (!fs::remove(GetPidFile())) {[m
[32m+[m[32m        if (!fs::remove(GetPidFile(*node.args))) {[m
             LogPrintf("%s: Unable to remove PID file: File does not exist\n", __func__);[m
         }[m
     } catch (const fs::filesystem_error& e) {[m
         LogPrintf("%s: Unable to remove PID file: %s\n", __func__, fsbridge::get_filesystem_error_message(e));[m
     }[m
 [m
[32m+[m[32m    node.args = nullptr;[m
     LogPrintf("%s: done\n", __func__);[m
 }[m
 [m
[36m@@ -372,7 +373,7 @@[m [mvoid SetupServerArgs(NodeContext& node)[m
     node.args = &gArgs;[m
     ArgsManager& argsman = *node.args;[m
 [m
[31m-    SetupHelpOptions(gArgs);[m
[32m+[m[32m    SetupHelpOptions(argsman);[m
     argsman.AddArg("-help-debug", "Print help message with debugging options and exit", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now[m
 [m
     const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);[m
[36m@@ -599,21 +600,6 @@[m [mstd::string LicenseInfo()[m
            "\n";[m
 }[m
 [m
[31m-#if HAVE_SYSTEM[m
[31m-static void BlockNotifyCallback(SynchronizationState sync_state, const CBlockIndex* pBlockIndex)[m
[31m-{[m
[31m-    if (sync_state != SynchronizationState::POST_INIT || !pBlockIndex)[m
[31m-        return;[m
[31m-[m
[31m-    std::string strCmd = gArgs.GetArg("-blocknotify", "");[m
[31m-    if (!strCmd.empty()) {[m
[31m-        boost::replace_all(strCmd, "%s", pBlockIndex->GetBlockHash().GetHex());[m
[31m-        std::thread t(runCommand, strCmd);[m
[31m-        t.detach(); // thread runs free[m
[31m-    }[m
[31m-}[m
[31m-#endif[m
[31m-[m
 static bool fHaveGenesis = false;[m
 static Mutex g_genesis_wait_mutex;[m
 static std::condition_variable g_genesis_wait_cv;[m
[36m@@ -684,7 +670,7 @@[m [mstatic void CleanupBlockRevFiles()[m
     }[m
 }[m
 [m
[31m-static void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles)[m
[32m+[m[32mstatic void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImportFiles, const ArgsManager& args)[m
 {[m
     const CChainParams& chainparams = Params();[m
     ScheduleBatchPriority();[m
[36m@@ -746,13 +732,13 @@[m [mstatic void ThreadImport(ChainstateManager& chainman, std::vector<fs::path> vImp[m
         }[m
     }[m
 [m
[31m-    if (gArgs.GetBoolArg("-stopafterblockimport", DEFAULT_STOPAFTERBLOCKIMPORT)) {[m
[32m+[m[32m    if (args.GetBoolArg("-stopafterblockimport", DEFAULT_STOPAFTERBLOCKIMPORT)) {[m
         LogPrintf("Stopping after block import\n");[m
         StartShutdown();[m
         return;[m
     }[m
     } // End scope of CImportingNow[m
[31m-    if (gArgs.GetArg("-persistmempool", DEFAULT_PERSIST_MEMPOOL)) {[m
[32m+[m[32m    if (args.GetArg("-persistmempool", DEFAULT_PERSIST_MEMPOOL)) {[m
         LoadMempool(::mempool);[m
     }[m
     ::mempool.SetIsLoaded(!ShutdownRequested());[m
[36m@@ -780,6 +766,7 @@[m [mstatic bool InitSanityCheck()[m
 [m
 static bool AppInitServers(const util::Ref& context, NodeContext& node)[m
 {[m
[32m+[m[32m    const ArgsManager& args = *Assert(node.args);[m
     RPCServer::OnStarted(&OnRPCStarted);[m
     RPCServer::OnStopped(&OnRPCStopped);[m
     if (!InitHTTPServer())[m
[36m@@ -788,71 +775,71 @@[m [mstatic bool AppInitServers(const util::Ref& context, NodeContext& node)[m
     node.rpc_interruption_point = RpcInterruptionPoint;[m
     if (!StartHTTPRPC(context))[m
         return false;[m
[31m-    if (gArgs.GetBoolArg("-rest", DEFAULT_REST_ENABLE)) StartREST(context);[m
[32m+[m[32m    if (args.GetBoolArg("-rest", DEFAULT_REST_ENABLE)) StartREST(context);[m
     StartHTTPServer();[m
     return true;[m
 }[m
 [m
 // Parameter interaction based on rules[m
[31m-void InitParameterInteraction()[m
[32m+[m[32mvoid InitParameterInteraction(ArgsManager& args)[m
 {[m
     // when specifying an explicit binding address, you want to listen on it[m
     // even when -connect or -proxy is specified[m
[31m-    if (gArgs.IsArgSet("-bind")) {[m
[31m-        if (gArgs.SoftSetBoolArg("-listen", true))[m
[32m+[m[32m    if (args.IsArgSet("-bind")) {[m
[32m+[m[32m        if (args.SoftSetBoolArg("-listen", true))[m
             LogPrintf("%s: parameter interaction: -bind set -> setting -listen=1\n", __func__);[m
     }[m
[31m-    if (gArgs.IsArgSet("-whitebind")) {[m
[31m-        if (gArgs.SoftSetBoolArg("-listen", true))[m
[32m+[m[32m    if (args.IsArgSet("-whitebind")) {[m
[32m+[m[32m        if (args.SoftSetBoolArg("-listen", true))[m
             LogPrintf("%s: parameter interaction: -whitebind set -> setting -listen=1\n", __func__);[m
     }[m
 [m
[31m-    if (gArgs.IsArgSet("-connect")) {[m
[32m+[m[32m    if (args.IsArgSet("-connect")) {[m
         // when only connecting to trusted nodes, do not seed via DNS, or listen by default[m
[31m-        if (gArgs.SoftSetBoolArg("-dnsseed", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-dnsseed", false))[m
             LogPrintf("%s: parameter interaction: -connect set -> setting -dnsseed=0\n", __func__);[m
[31m-        if (gArgs.SoftSetBoolArg("-listen", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-listen", false))[m
             LogPrintf("%s: parameter interaction: -connect set -> setting -listen=0\n", __func__);[m
     }[m
 [m
[31m-    if (gArgs.IsArgSet("-proxy")) {[m
[32m+[m[32m    if (args.IsArgSet("-proxy")) {[m
         // to protect privacy, do not listen by default if a default proxy server is specified[m
[31m-        if (gArgs.SoftSetBoolArg("-listen", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-listen", false))[m
             LogPrintf("%s: parameter interaction: -proxy set -> setting -listen=0\n", __func__);[m
         // to protect privacy, do not use UPNP when a proxy is set. The user may still specify -listen=1[m
         // to listen locally, so don't rely on this happening through -listen below.[m
[31m-        if (gArgs.SoftSetBoolArg("-upnp", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-upnp", false))[m
             LogPrintf("%s: parameter interaction: -proxy set -> setting -upnp=0\n", __func__);[m
         // to protect privacy, do not discover addresses by default[m
[31m-        if (gArgs.SoftSetBoolArg("-discover", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-discover", false))[m
             LogPrintf("%s: parameter interaction: -proxy set -> setting -discover=0\n", __func__);[m
     }[m
 [m
[31m-    if (!gArgs.GetBoolArg("-listen", DEFAULT_LISTEN)) {[m
[32m+[m[32m    if (!args.GetBoolArg("-listen", DEFAULT_LISTEN)) {[m
         // do not map ports or try to retrieve public IP when not listening (pointless)[m
[31m-        if (gArgs.SoftSetBoolArg("-upnp", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-upnp", false))[m
             LogPrintf("%s: parameter interaction: -listen=0 -> setting -upnp=0\n", __func__);[m
[31m-        if (gArgs.SoftSetBoolArg("-discover", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-discover", false))[m
             LogPrintf("%s: parameter interaction: -listen=0 -> setting -discover=0\n", __func__);[m
[31m-        if (gArgs.SoftSetBoolArg("-listenonion", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-listenonion", false))[m
             LogPrintf("%s: parameter interaction: -listen=0 -> setting -listenonion=0\n", __func__);[m
     }[m
 [m
[31m-    if (gArgs.IsArgSet("-externalip")) {[m
[32m+[m[32m    if (args.IsArgSet("-externalip")) {[m
         // if an explicit public IP is specified, do not try to find others[m
[31m-        if (gArgs.SoftSetBoolArg("-discover", false))[m
[32m+[m[32m        if (args.SoftSetBoolArg("-discover", false))[m
             LogPrintf("%s: parameter interaction: -externalip set -> setting -discover=0\n", __func__);[m
     }[m
 [m
     // disable whitelistrelay in blocksonly mode[m
[31m-    if (gArgs.GetBoolArg("-blocksonly", DEFAULT_BLOCKSONLY)) {[m
[31m-        if (gArgs.SoftSetBoolArg("-whitelistrelay", false))[m
[32m+[m[32m    if (args.GetBoolArg("-blocksonly", DEFAULT_BLOCKSONLY)) {[m
[32m+[m[32m        if (args.SoftSetBoolArg("-whitelistrelay", false))[m
             LogPrintf("%s: parameter interaction: -blocksonly=1 -> setting -whitelistrelay=0\n", __func__);[m
     }[m
 [m
     // Forcing relay from whitelisted hosts implies we will accept relays from them in the first place.[m
[31m-    if (gArgs.GetBoolArg("-whitelistforcerelay", DEFAULT_WHITELISTFORCERELAY)) {[m
[31m-        if (gArgs.SoftSetBoolArg("-whitelistrelay", true))[m
[32m+[m[32m    if (args.GetBoolArg("-whitelistforcerelay", DEFAULT_WHITELISTFORCERELAY)) {[m
[32m+[m[32m        if (args.SoftSetBoolArg("-whitelistrelay", true))[m
             LogPrintf("%s: parameter interaction: -whitelistforcerelay=1 -> setting -whitelistrelay=1\n", __func__);[m
     }[m
 }[m
[36m@@ -863,18 +850,18 @@[m [mvoid InitParameterInteraction()[m
  * Note that this is called very early in the process lifetime, so you should be[m
  * careful about what global state you rely on here.[m
  */[m
[31m-void InitLogging()[m
[32m+[m[32mvoid InitLogging(const ArgsManager& args)[m
 {[m
[31m-    LogInstance().m_print_to_file = !gArgs.IsArgNegated("-debuglogfile");[m
[31m-    LogInstance().m_file_path = AbsPathForConfigVal(gArgs.GetArg("-debuglogfile", DEFAULT_DEBUGLOGFILE));[m
[31m-    LogInstance().m_print_to_console = gArgs.GetBoolArg("-printtoconsole", !gArgs.GetBoolArg("-daemon", false));[m
[31m-    LogInstance().m_log_timestamps = gArgs.GetBoolArg("-logtimestamps", DEFAULT_LOGTIMESTAMPS);[m
[31m-    LogInstance().m_log_time_micros = gArgs.GetBoolArg("-logtimemicros", DEFAULT_LOGTIMEMICROS);[m
[32m+[m[32m    LogInstance().m_print_to_file = !args.IsArgNegated("-debuglogfile");[m
[32m+[m[32m    LogInstance().m_file_path = AbsPathForConfigVal(args.GetArg("-debuglogfile", DEFAULT_DEBUGLOGFILE));[m
[32m+[m[32m    LogInstance().m_print_to_console = args.GetBoolArg("-printtoconsole", !args.GetBoolArg("-daemon", false));[m
[32m+[m[32m    LogInstance().m_log_timestamps = args.GetBoolArg("-logtimestamps", DEFAULT_LOGTIMESTAMPS);[m
[32m+[m[32m    LogInstance().m_log_time_micros = args.GetBoolArg("-logtimemicros", DEFAULT_LOGTIMEMICROS);[m
 #ifdef HAVE_THREAD_LOCAL[m
[31m-    LogInstance().m_log_threadnames = gArgs.GetBoolArg("-logthreadnames", DEFAULT_LOGTHREADNAMES);[m
[32m+[m[32m    LogInstance().m_log_threadnames = args.GetBoolArg("-logthreadnames", DEFAULT_LOGTHREADNAMES);[m
 #endif[m
 [m
[31m-    fLogIPs = gArgs.GetBoolArg("-logips", DEFAULT_LOGIPS);[m
[32m+[m[32m    fLogIPs = args.GetBoolArg("-logips", DEFAULT_LOGIPS);[m
 [m
     std::string version_string = FormatFullVersion();[m
 #ifdef DEBUG[m
[36m@@ -909,7 +896,7 @@[m [mstd::set<BlockFilterType> g_enabled_filter_types;[m
     std::terminate();[m
 };[m
 [m
[31m-bool AppInitBasicSetup()[m
[32m+[m[32mbool AppInitBasicSetup(ArgsManager& args)[m
 {[m
     // ********************************************************* Step 1: setup[m
 #ifdef _MSC_VER[m
[36m@@ -929,7 +916,7 @@[m [mbool AppInitBasicSetup()[m
     }[m
 [m
 #ifndef WIN32[m
[31m-    if (!gArgs.GetBoolArg("-sysperms", false)) {[m
[32m+[m[32m    if (!args.GetBoolArg("-sysperms", false)) {[m
         umask(077);[m
     }[m
 [m
[36m@@ -951,7 +938,7 @@[m [mbool AppInitBasicSetup()[m
     return true;[m
 }[m
 [m
[31m-bool AppInitParameterInteraction()[m
[32m+[m[32mbool AppInitParameterInteraction(const ArgsManager& args)[m
 {[m
     const CChainParams& chainparams = Params();[m
     // ********************************************************* Step 2: parameter interactions[m
[36m@@ -961,9 +948,9 @@[m [mbool AppInitParameterInteraction()[m
     // Error if network-specific options (-addnode, -connect, etc) are[m
     // specified in default section of config file, but not overridden[m
     // on the command line or in this network's section of the config file.[m
[31m-    std::string network = gArgs.GetChainName();[m
[32m+[m[32m    std::string network = args.GetChainName();[m
     bilingual_str errors;[m
[31m-    for (const auto& arg : gArgs.GetUnsuitableSectionOnlyArgs()) {[m
[32m+[m[32m    for (const auto& arg : args.GetUnsuitableSectionOnlyArgs()) {[m
         errors += strprintf(_("Config setting for %s only applied on %s network when in [%s] section.") + Untranslated("\n"), arg, network, network);[m
     }[m
 [m
[36m@@ -973,7 +960,7 @@[m [mbool AppInitParameterInteraction()[m
 [m
     // Warn if unrecognized section name are present in the config file.[m
     bilingual_str warnings;[m
[31m-    for (const auto& section : gArgs.GetUnrecognizedSections()) {[m
[32m+[m[32m    for (const auto& section : args.GetUnrecognizedSections()) {[m
         warnings += strprintf(Untranslated("%s:%i ") + _("Section [%s] is not recognized.") + Untranslated("\n"), section.m_file, section.m_line, section.m_name);[m
     }[m
 [m
[36m@@ -982,15 +969,15 @@[m [mbool AppInitParameterInteraction()[m
     }[m
 [m
     if (!fs::is_directory(GetBlocksDir())) {[m
[31m-        return InitError(strprintf(_("Specified blocks directory \"%s\" does not exist."), gArgs.GetArg("-blocksdir", "")));[m
[32m+[m[32m        return InitError(strprintf(_("Specified blocks directory \"%s\" does not exist."), args.GetArg("-blocksdir", "")));[m
     }[m
 [m
     // parse and validate enabled filter types[m
[31m-    std::string blockfilterindex_value = gArgs.GetArg("-blockfilterindex", DEFAULT_BLOCKFILTERINDEX);[m
[32m+[m[32m    std::string blockfilterindex_value = args.GetArg("-blockfilterindex", DEFAULT_BLOCKFILTERINDEX);[m
     if (blockfilterindex_value == "" || blockfilterindex_value == "1") {[m
         g_enabled_filter_types = AllBlockFilterTypes();[m
     } else if (blockfilterindex_value != "0") {[m
[31m-        const std::vector<std::string> names = gArgs.GetArgs("-blockfilterindex");[m
[32m+[m[32m        const std::vector<std::string> names = args.GetArgs("-blockfilterindex");[m
         for (const auto& name : names) {[m
             BlockFilterType filter_type;[m
             if (!BlockFilterTypeByName(name, filter_type)) {[m
[36m@@ -1001,7 +988,7 @@[m [mbool AppInitParameterInteraction()[m
     }[m
 [m
     // Signal NODE_COMPACT_FILTERS if peerblockfilters and basic filters index are both enabled.[m
[31m-    if (gArgs.GetBoolArg("-peerblockfilters", DEFAULT_PEERBLOCKFILTERS)) {[m
[32m+[m[32m    if (args.GetBoolArg("-peerblockfilters", DEFAULT_PEERBLOCKFILTERS)) {[m
         if (g_enabled_filter_types.count(BlockFilterType::BASIC) != 1) {[m
             return InitError(_("Cannot set -peerblockfilters without -blockfilterindex."));[m
         }[m
[36m@@ -1010,8 +997,8 @@[m [mbool AppInitParameterInteraction()[m
     }[m
 [m
     // if using block pruning, then disallow txindex[m
[31m-    if (gArgs.GetArg("-prune", 0)) {[m
[31m-        if (gArgs.GetBoolArg("-txindex", DEFAULT_TXINDEX))[m
[32m+[m[32m    if (args.GetArg("-prune", 0)) {[m
[32m+[m[32m        if (args.GetBoolArg("-txindex", DEFAULT_TXINDEX))[m
             return InitError(_("Prune mode is incompatible with -txindex."));[m
         if (!g_enabled_filter_types.empty()) {[m
             return InitError(_("Prune mode is incompatible with -blockfilterindex."));[m
[36m@@ -1019,14 +1006,14 @@[m [mbool AppInitParameterInteraction()[m
     }[m
 [m
     // -bind and -whitebind can't be set when not listening[m
[31m-    size_t nUserBind = gArgs.GetArgs("-bind").size() + gArgs.GetArgs("-whitebind").size();[m
[31m-    if (nUserBind != 0 && !gArgs.GetBoolArg("-listen", DEFAULT_LISTEN)) {[m
[32m+[m[32m    size_t nUserBind = args.GetArgs("-bind").size() + args.GetArgs("-whitebind").size();[m
[32m+[m[32m    if (nUserBind != 0 && !args.GetBoolArg("-listen", DEFAULT_LISTEN)) {[m
         return InitError(Untranslated("Cannot set -bind or -whitebind together with -listen=0"));[m
     }[m
 [m
     // Make sure enough file descriptors are available[m
     int nBind = std::max(nUserBind, size_t(1));[m
[31m-    nUserMaxConnections = gArgs.GetArg("-maxconnections", DEFAULT_MAX_PEER_CONNECTIONS);[m
[32m+[m[32m    nUserMaxConnections = args.GetArg("-maxconnections", DEFAULT_MAX_PEER_CONNECTIONS);[m
     nMaxConnections = std::max(nUserMaxConnections, 0);[m
 [m
     // Trim requested connection counts, to fit into system limitations[m
[36m@@ -1046,9 +1033,9 @@[m [mbool AppInitParameterInteraction()[m
         InitWarning(strprintf(_("Reducing -maxconnections from %d to %d, because of system limitations."), nUserMaxConnections, nMaxConnections));[m
 [m
     // ********************************************************* Step 3: parameter-to-internal-flags[m
[31m-    if (gArgs.IsArgSet("-debug")) {[m
[32m+[m[32m    if (args.IsArgSet("-debug")) {[m
         // Special-case: if -debug=0/-nodebug is set, turn off debugging messages[m
[31m-        const std::vector<std::string> categories = gArgs.GetArgs("-debug");[m
[32m+[m[32m        const std::vector<std::string> categories = args.GetArgs("-debug");[m
 [m
         if (std::none_of(categories.begin(), categories.end(),[m
             [](std::string cat){return cat == "0" || cat == "none";})) {[m
[36m@@ -1061,28 +1048,28 @@[m [mbool AppInitParameterInteraction()[m
     }[m
 [m
     // Now remove the logging categories which were explicitly excluded[m
[31m-    for (const std::string& cat : gArgs.GetArgs("-debugexclude")) {[m
[32m+[m[32m    for (const std::string& cat : args.GetArgs("-debugexclude")) {[m
         if (!LogInstance().DisableCategory(cat)) {[m
             InitWarning(strprintf(_("Unsupported logging category %s=%s."), "-debugexclude", cat));[m
         }[m
     }[m
 [m
     // Checkmempool and checkblockindex default to true in regtest mode[m
[31m-    int ratio = std::min<int>(std::max<int>(gArgs.GetArg("-checkmempool", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);[m
[32m+[m[32m    int ratio = std::min<int>(std::max<int>(args.GetArg("-checkmempool", chainparams.DefaultConsistencyChecks() ? 1 : 0), 0), 1000000);[m
     if (ratio != 0) {[m
         mempool.setSanityCheck(1.0 / ratio);[m
     }[m
[31m-    fCheckBlockIndex = gArgs.GetBoolArg("-checkblockindex", chainparams.DefaultConsistencyChecks());[m
[31m-    fCheckpointsEnabled = gArgs.GetBoolArg("-checkpoints", DEFAULT_CHECKPOINTS_ENABLED);[m
[32m+[m[32m    fCheckBlockIndex = args.GetBoolArg("-checkblockindex", chainparams.DefaultConsistencyChecks());[m
[32m+[m[32m    fCheckpointsEnabled = args.GetBoolArg("-checkpoints", DEFAULT_CHECKPOINTS_ENABLED);[m
 [m
[31m-    hashAssumeValid = uint256S(gArgs.GetArg("-assumevalid", chainparams.GetConsensus().defaultAssumeValid.GetHex()));[m
[32m+[m[32m    hashAssumeValid = uint256S(args.GetArg("-assumevalid", chainparams.GetConsensus().defaultAssumeValid.GetHex()));[m
     if (!hashAssumeValid.IsNull())[m
         LogPrintf("Assuming ancestors of block %s have valid signatures.\n", hashAssumeValid.GetHex());[m
     else[m
         LogPrintf("Validating signatures for all blocks.\n");[m
 [m
[31m-    if (gArgs.IsArgSet("-minimumchainwork")) {[m
[31m-        const std::string minChainWorkStr = gArgs.GetArg("-minimumchainwork", "");[m
[32m+[m[32m    if (args.IsArgSet("-minimumchainwork")) {[m
[32m+[m[32m        const std::string minChainWorkStr = args.GetArg("-minimumchainwork", "");[m
         if (!IsHexNumber(minChainWorkStr)) {[m
             return InitError(strprintf(Untranslated("Invalid non-hex (%s) minimum chain work value specified"), minChainWorkStr));[m
         }[m
[36m@@ -1096,22 +1083,21 @@[m [mbool AppInitParameterInteraction()[m
     }[m
 [m
     // mempool limits[m
[31m-    int64_t nMempoolSizeMax = gArgs.GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;[m
[31m-    int64_t nMempoolSizeMin = gArgs.GetArg("-limitdescendantsize", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40;[m
[32m+[m[32m    int64_t nMempoolSizeMax = args.GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;[m
[32m+[m[32m    int64_t nMempoolSizeMin = args.GetArg("-limitdescendantsize", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000 * 40;[m
     if (nMempoolSizeMax < 0 || nMempoolSizeMax < nMempoolSizeMin)[m
         return InitError(strprintf(_("-maxmempool must be at least %d MB"), std::ceil(nMempoolSizeMin / 1000000.0)));[m
     // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool[m
     // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting.[m
[31m-    if (gArgs.IsArgSet("-incrementalrelayfee"))[m
[31m-    {[m
[32m+[m[32m    if (args.IsArgSet("-incrementalrelayfee")) {[m
         CAmount n = 0;[m
[31m-        if (!ParseMoney(gArgs.GetArg("-incrementalrelayfee", ""), n))[m
[31m-            return InitError(AmountErrMsg("incrementalrelayfee", gArgs.GetArg("-incrementalrelayfee", "")));[m
[32m+[m[32m        if (!ParseMoney(args.GetArg("-incrementalrelayfee", ""), n))[m
[32m+[m[32m            return InitError(AmountErrMsg("incrementalrelayfee", args.GetArg("-incrementalrelayfee", "")));[m
         incrementalRelayFee = CFeeRate(n);[m
     }[m
 [m
     // block pruning; get the amount of disk space (in MiB) to allot for block & undo files[m
[31m-    int64_t nPruneArg = gArgs.GetArg("-prune", 0);[m
[32m+[m[32m    int64_t nPruneArg = args.GetArg("-prune", 0);[m
     if (nPruneArg < 0) {[m
         return InitError(_("Prune cannot be configured with a negative value."));[m
     }[m
[36m@@ -1128,20 +1114,20 @@[m [mbool AppInitParameterInteraction()[m
         fPruneMode = true;[m
     }[m
 [m
[31m-    nConnectTimeout = gArgs.GetArg("-timeout", DEFAULT_CONNECT_TIMEOUT);[m
[32m+[m[32m    nConnectTimeout = args.GetArg("-timeout", DEFAULT_CONNECT_TIMEOUT);[m
     if (nConnectTimeout <= 0) {[m
         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;[m
     }[m
 [m
[31m-    peer_connect_timeout = gArgs.GetArg("-peertimeout", DEFAULT_PEER_CONNECT_TIMEOUT);[m
[32m+[m[32m    peer_connect_timeout = args.GetArg("-peertimeout", DEFAULT_PEER_CONNECT_TIMEOUT);[m
     if (peer_connect_timeout <= 0) {[m
         return InitError(Untranslated("peertimeout cannot be configured with a negative value."));[m
     }[m
 [m
[31m-    if (gArgs.IsArgSet("-minrelaytxfee")) {[m
[32m+[m[32m    if (args.IsArgSet("-minrelaytxfee")) {[m
         CAmount n = 0;[m
[31m-        if (!ParseMoney(gArgs.GetArg("-minrelaytxfee", ""), n)) {[m
[31m-            return InitError(AmountErrMsg("minrelaytxfee", gArgs.GetArg("-minrelaytxfee", "")));[m
[32m+[m[32m        if (!ParseMoney(args.GetArg("-minrelaytxfee", ""), n)) {[m
[32m+[m[32m            return InitError(AmountErrMsg("minrelaytxfee", args.GetArg("-minrelaytxfee", "")));[m
         }[m
         // High fee check is done afterward in CWallet::CreateWalletFromFile()[m
         ::minRelayTxFee = CFeeRate(n);[m
[36m@@ -1153,48 +1139,46 @@[m [mbool AppInitParameterInteraction()[m
 [m
     // Sanity check argument for min fee for including tx in block[m
     // TODO: Harmonize which arguments need sanity checking and where that happens[m
[31m-    if (gArgs.IsArgSet("-blockmintxfee"))[m
[31m-    {[m
[32m+[m[32m    if (args.IsArgSet("-blockmintxfee")) {[m
         CAmount n = 0;[m
[31m-        if (!ParseMoney(gArgs.GetArg("-blockmintxfee", ""), n))[m
[31m-            return InitError(AmountErrMsg("blockmintxfee", gArgs.GetArg("-blockmintxfee", "")));[m
[32m+[m[32m        if (!ParseMoney(args.GetArg("-blockmintxfee", ""), n))[m
[32m+[m[32m            return InitError(AmountErrMsg("blockmintxfee", args.GetArg("-blockmintxfee", "")));[m
     }[m
 [m
     // Feerate used to define dust.  Shouldn't be changed lightly as old[m
     // implementations may inadvertently create non-standard transactions[m
[31m-    if (gArgs.IsArgSet("-dustrelayfee"))[m
[31m-    {[m
[32m+[m[32m    if (args.IsArgSet("-dustrelayfee")) {[m
         CAmount n = 0;[m
[31m-        if (!ParseMoney(gArgs.GetArg("-dustrelayfee", ""), n))[m
[31m-            return InitError(AmountErrMsg("dustrelayfee", gArgs.GetArg("-dustrelayfee", "")));[m
[32m+[m[32m        if (!ParseMoney(args.GetArg("-dustrelayfee", ""), n))[m
[32m+[m[32m            return InitError(AmountErrMsg("dustrelayfee", args.GetArg("-dustrelayfee", "")));[m
         dustRelayFee = CFeeRate(n);[m
     }[m
 [m
[31m-    fRequireStandard = !gArgs.GetBoolArg("-acceptnonstdtxn", !chainparams.RequireStandard());[m
[32m+[m[32m    fRequireStandard = !args.GetBoolArg("-acceptnonstdtxn", !chainparams.RequireStandard());[m
     if (!chainparams.IsTestChain() && !fRequireStandard) {[m
         return InitError(strprintf(Untranslated("acceptnonstdtxn is not currently supported for %s chain"), chainparams.NetworkIDString()));[m
     }[m
[31m-    nBytesPerSigOp = gArgs.GetArg("-bytespersigop", nBytesPerSigOp);[m
[32m+[m[32m    nBytesPerSigOp = args.GetArg("-bytespersigop", nBytesPerSigOp);[m
 [m
     if (!g_wallet_init_interface.ParameterInteraction()) return false;[m
 [m
[31m-    fIsBareMultisigStd = gArgs.GetBoolArg("-permitbaremultisig", DEFAULT_PERMIT_BAREMULTISIG);[m
[31m-    fAcceptDatacarrier = gArgs.GetBoolArg("-datacarrier", DEFAULT_ACCEPT_DATACARRIER);[m
[31m-    nMaxDatacarrierBytes = gArgs.GetArg("-datacarriersize", nMaxDatacarrierBytes);[m
[32m+[m[32m    fIsBareMultisigStd = args.GetBoolArg("-permitbaremultisig", DEFAULT_PERMIT_BAREMULTISIG);[m
[32m+[m[32m    fAcceptDatacarrier = args.GetBoolArg("-datacarrier", DEFAULT_ACCEPT_DATACARRIER);[m
[32m+[m[32m    nMaxDatacarrierBytes = args.GetArg("-datacarriersize", nMaxDatacarrierBytes);[m
 [m
     // Option to startup with mocktime set (used for regression testing):[m
[31m-    SetMockTime(gArgs.GetArg("-mocktime", 0)); // SetMockTime(0) is a no-op[m
[32m+[m[32m    SetMockTime(args.GetArg("-mocktime", 0)); // SetMockTime(0) is a no-op[m
 [m
[31m-    if (gArgs.GetBoolArg("-peerbloomfilters", DEFAULT_PEERBLOOMFILTERS))[m
[32m+[m[32m    if (args.GetBoolArg("-peerbloomfilters", DEFAULT_PEERBLOOMFILTERS))[m
         nLocalServices = ServiceFlags(nLocalServices | NODE_BLOOM);[m
 [m
[31m-    if (gArgs.GetArg("-rpcserialversion", DEFAULT_RPC_SERIALIZE_VERSION) < 0)[m
[32m+[m[32m    if (args.GetArg("-rpcserialversion", DEFAULT_RPC_SERIALIZE_VERSION) < 0)[m
         return InitError(Untranslated("rpcserialversion must be non-negative."));[m
 [m
[31m-    if (gArgs.GetArg("-rpcserialversion", DEFAULT_RPC_SERIALIZE_VERSION) > 1)[m
[32m+[m[32m    if (args.GetArg("-rpcserialversion", DEFAULT_RPC_SERIALIZE_VERSION) > 1)[m
         return InitError(Untranslated("Unknown rpcserialversion requested."));[m
 [m
[31m-    nMaxTipAge = gArgs.GetArg("-maxtipage", DEFAULT_MAX_TIP_AGE);[m
[32m+[m[32m    nMaxTipAge = args.GetArg("-maxtipage", DEFAULT_MAX_TIP_AGE);[m
 [m
     return true;[m
 }[m
[36m@@ -1245,16 +1229,28 @@[m [mbool AppInitLockDataDirectory()[m
     return true;[m
 }[m
 [m
[32m+[m[32mbool AppInitInterfaces(NodeContext& node)[m
[32m+[m[32m{[m
[1;33m+[m[1;33m    node.chain = interfaces::MakeChain(node);[m
[1;36m+[m[1;36m    // Create client interfaces for wallets that are supposed to be loaded[m
[2m+[m[2m    // according to -wallet and -disablewallet options. This only constructs[m
[2m+[m[2m    // the interfaces, it doesn't load wallet data. Wallets actually get loaded[m
[2m+[m[2m    // when load() and start() interface methods are called below.[m
[2m+[m[2m    g_wallet_init_interface.Construct(node);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
 bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
 {[m
[32m+[m[32m    const ArgsManager& args = *Assert(node.args);[m
     const CChainParams& chainparams = Params();[m
     // ********************************************************* Step 4a: application initialization[m
[31m-    if (!CreatePidFile()) {[m
[32m+[m[32m    if (!CreatePidFile(args)) {[m
         // Detailed error printed inside CreatePidFile().[m
         return false;[m
     }[m
     if (LogInstance().m_print_to_file) {[m
[31m-        if (gArgs.GetBoolArg("-shrinkdebugfile", LogInstance().DefaultShrinkDebugFile())) {[m
[32m+[m[32m        if (args.GetBoolArg("-shrinkdebugfile", LogInstance().DefaultShrinkDebugFile())) {[m
             // Do this first since it both loads a bunch of debug.log into memory,[m
             // and because this needs to happen before any other debug.log printing[m
             LogInstance().ShrinkDebugFile();[m
[36m@@ -1271,10 +1267,10 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     LogPrintf("Using data directory %s\n", GetDataDir().string());[m
 [m
     // Only log conf file usage message if conf file actually exists.[m
[31m-    fs::path config_file_path = GetConfigFile(gArgs.GetArg("-conf", BITCOIN_CONF_FILENAME));[m
[32m+[m[32m    fs::path config_file_path = GetConfigFile(args.GetArg("-conf", BITCOIN_CONF_FILENAME));[m
     if (fs::exists(config_file_path)) {[m
         LogPrintf("Config file: %s\n", config_file_path.string());[m
[31m-    } else if (gArgs.IsArgSet("-conf")) {[m
[32m+[m[32m    } else if (args.IsArgSet("-conf")) {[m
         // Warn if no conf file exists at path provided by user[m
         InitWarning(strprintf(_("The specified config file %s does not exist\n"), config_file_path.string()));[m
     } else {[m
[36m@@ -1283,23 +1279,23 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     }[m
 [m
     // Log the config arguments to debug.log[m
[31m-    gArgs.LogArgs();[m
[32m+[m[32m    args.LogArgs();[m
 [m
     LogPrintf("Using at most %i automatic connections (%i file descriptors available)\n", nMaxConnections, nFD);[m
 [m
     // Warn about relative -datadir path.[m
[31m-    if (gArgs.IsArgSet("-datadir") && !fs::path(gArgs.GetArg("-datadir", "")).is_absolute()) {[m
[32m+[m[32m    if (args.IsArgSet("-datadir") && !fs::path(args.GetArg("-datadir", "")).is_absolute()) {[m
         LogPrintf("Warning: relative datadir option '%s' specified, which will be interpreted relative to the " /* Continued */[m
                   "current working directory '%s'. This is fragile, because if bitcoin is started in the future "[m
                   "from a different location, it will be unable to locate the current data files. There could "[m
                   "also be data loss if bitcoin is started while in a temporary directory.\n",[m
[31m-            gArgs.GetArg("-datadir", ""), fs::current_path().string());[m
[32m+[m[32m                  args.GetArg("-datadir", ""), fs::current_path().string());[m
     }[m
 [m
     InitSignatureCache();[m
     InitScriptExecutionCache();[m
 [m
[31m-    int script_threads = gArgs.GetArg("-par", DEFAULT_SCRIPTCHECK_THREADS);[m
[32m+[m[32m    int script_threads = args.GetArg("-par", DEFAULT_SCRIPTCHECK_THREADS);[m
     if (script_threads <= 0) {[m
         // -par=0 means autodetect (number of cores - 1 script threads)[m
         // -par=-n means "leave n cores free" (number of cores - n - 1 script threads)[m
[36m@@ -1333,12 +1329,6 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
 [m
     GetMainSignals().RegisterBackgroundSignalScheduler(*node.scheduler);[m
 [m
[2m-    // Create client interfaces for wallets that are supposed to be loaded[m
[2m-    // according to -wallet and -disablewallet options. This only constructs[m
[2m-    // the interfaces, it doesn't load wallet data. Wallets actually get loaded[m
[2m-    // when load() and start() interface methods are called below.[m
[2m-    g_wallet_init_interface.Construct(node);[m
[31m-[m
     /* Register RPC commands regardless of -server setting so they will be[m
      * available in the GUI RPC console even if external calls are disabled.[m
      */[m
[36m@@ -1355,8 +1345,7 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
      * that the server is there and will be ready later).  Warmup mode will[m
      * be disabled when initialisation is finished.[m
      */[m
[31m-    if (gArgs.GetBoolArg("-server", false))[m
[31m-    {[m
[32m+[m[32m    if (args.GetBoolArg("-server", false)) {[m
         uiInterface.InitMessage_connect(SetRPCWarmupStatus);[m
         if (!AppInitServers(context, node))[m
             return InitError(_("Unable to start HTTP server. See debug log for details."));[m
[36m@@ -1376,9 +1365,9 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     // need to reindex later.[m
 [m
     assert(!node.banman);[m
[31m-    node.banman = MakeUnique<BanMan>(GetDataDir() / "banlist.dat", &uiInterface, gArgs.GetArg("-bantime", DEFAULT_MISBEHAVING_BANTIME));[m
[32m+[m[32m    node.banman = MakeUnique<BanMan>(GetDataDir() / "banlist.dat", &uiInterface, args.GetArg("-bantime", DEFAULT_MISBEHAVING_BANTIME));[m
     assert(!node.connman);[m
[31m-    node.connman = MakeUnique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), gArgs.GetBoolArg("-networkactive", true));[m
[32m+[m[32m    node.connman = MakeUnique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), args.GetBoolArg("-networkactive", true));[m
     // Make mempool generally available in the node context. For example the connection manager, wallet, or RPC threads,[m
     // which are all started after this, may use it from the node context.[m
     assert(!node.mempool);[m
[36m@@ -1392,7 +1381,7 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
 [m
     // sanitize comments per BIP-0014, format user agent and check total size[m
     std::vector<std::string> uacomments;[m
[31m-    for (const std::string& cmt : gArgs.GetArgs("-uacomment")) {[m
[32m+[m[32m    for (const std::string& cmt : args.GetArgs("-uacomment")) {[m
         if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))[m
             return InitError(strprintf(_("User Agent comment (%s) contains unsafe characters."), cmt));[m
         uacomments.push_back(cmt);[m
[36m@@ -1403,9 +1392,9 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
             strSubVersion.size(), MAX_SUBVERSION_LENGTH));[m
     }[m
 [m
[31m-    if (gArgs.IsArgSet("-onlynet")) {[m
[32m+[m[32m    if (args.IsArgSet("-onlynet")) {[m
         std::set<enum Network> nets;[m
[31m-        for (const std::string& snet : gArgs.GetArgs("-onlynet")) {[m
[32m+[m[32m        for (const std::string& snet : args.GetArgs("-onlynet")) {[m
             enum Network net = ParseNetwork(snet);[m
             if (net == NET_UNROUTABLE)[m
                 return InitError(strprintf(_("Unknown network specified in -onlynet: '%s'"), snet));[m
[36m@@ -1419,12 +1408,12 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     }[m
 [m
     // Check for host lookup allowed before parsing any network related parameters[m
[31m-    fNameLookup = gArgs.GetBoolArg("-dns", DEFAULT_NAME_LOOKUP);[m
[32m+[m[32m    fNameLookup = args.GetBoolArg("-dns", DEFAULT_NAME_LOOKUP);[m
 [m
[31m-    bool proxyRandomize = gArgs.GetBoolArg("-proxyrandomize", DEFAULT_PROXYRANDOMIZE);[m
[32m+[m[32m    bool proxyRandomize = args.GetBoolArg("-proxyrandomize", DEFAULT_PROXYRANDOMIZE);[m
     // -proxy sets a proxy for all outgoing network traffic[m
     // -noproxy (or -proxy=0) as well as the empty string can be used to not set a proxy, this is the default[m
[31m-    std::string proxyArg = gArgs.GetArg("-proxy", "");[m
[32m+[m[32m    std::string proxyArg = args.GetArg("-proxy", "");[m
     SetReachable(NET_ONION, false);[m
     if (proxyArg != "" && proxyArg != "0") {[m
         CService proxyAddr;[m
[36m@@ -1446,7 +1435,7 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     // -onion can be used to set only a proxy for .onion, or override normal proxy for .onion addresses[m
     // -noonion (or -onion=0) disables connecting to .onion entirely[m
     // An empty string is used to not override the onion proxy (in which case it defaults to -proxy set above, or none)[m
[31m-    std::string onionArg = gArgs.GetArg("-onion", "");[m
[32m+[m[32m    std::string onionArg = args.GetArg("-onion", "");[m
     if (onionArg != "") {[m
         if (onionArg == "0") { // Handle -noonion/-onion=0[m
             SetReachable(NET_ONION, false);[m
[36m@@ -1464,11 +1453,11 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     }[m
 [m
     // see Step 2: parameter interactions for more information about these[m
[31m-    fListen = gArgs.GetBoolArg("-listen", DEFAULT_LISTEN);[m
[31m-    fDiscover = gArgs.GetBoolArg("-discover", true);[m
[31m-    g_relay_txes = !gArgs.GetBoolArg("-blocksonly", DEFAULT_BLOCKSONLY);[m
[32m+[m[32m    fListen = args.GetBoolArg("-listen", DEFAULT_LISTEN);[m
[32m+[m[32m    fDiscover = args.GetBoolArg("-discover", true);[m
[32m+[m[32m    g_relay_txes = !args.GetBoolArg("-blocksonly", DEFAULT_BLOCKSONLY);[m
 [m
[31m-    for (const std::string& strAddr : gArgs.GetArgs("-externalip")) {[m
[32m+[m[32m    for (const std::string& strAddr : args.GetArgs("-externalip")) {[m
         CService addrLocal;[m
         if (Lookup(strAddr, addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())[m
             AddLocal(addrLocal, LOCAL_MANUAL);[m
[36m@@ -1477,8 +1466,8 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     }[m
 [m
     // Read asmap file if configured[m
[31m-    if (gArgs.IsArgSet("-asmap")) {[m
[31m-        fs::path asmap_path = fs::path(gArgs.GetArg("-asmap", ""));[m
[32m+[m[32m    if (args.IsArgSet("-asmap")) {[m
[32m+[m[32m        fs::path asmap_path = fs::path(args.GetArg("-asmap", ""));[m
         if (asmap_path.empty()) {[m
             asmap_path = DEFAULT_ASMAP_FILENAME;[m
         }[m
[36m@@ -1511,22 +1500,22 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     uint64_t nMaxOutboundLimit = 0; //unlimited unless -maxuploadtarget is set[m
     uint64_t nMaxOutboundTimeframe = MAX_UPLOAD_TIMEFRAME;[m
 [m
[31m-    if (gArgs.IsArgSet("-maxuploadtarget")) {[m
[31m-        nMaxOutboundLimit = gArgs.GetArg("-maxuploadtarget", DEFAULT_MAX_UPLOAD_TARGET)*1024*1024;[m
[32m+[m[32m    if (args.IsArgSet("-maxuploadtarget")) {[m
[32m+[m[32m        nMaxOutboundLimit = args.GetArg("-maxuploadtarget", DEFAULT_MAX_UPLOAD_TARGET) * 1024 * 1024;[m
     }[m
 [m
     // ********************************************************* Step 7: load block chain[m
 [m
[31m-    fReindex = gArgs.GetBoolArg("-reindex", false);[m
[31m-    bool fReindexChainState = gArgs.GetBoolArg("-reindex-chainstate", false);[m
[32m+[m[32m    fReindex = args.GetBoolArg("-reindex", false);[m
[32m+[m[32m    bool fReindexChainState = args.GetBoolArg("-reindex-chainstate", false);[m
 [m
     // cache size calculations[m
[31m-    int64_t nTotalCache = (gArgs.GetArg("-dbcache", nDefaultDbCache) << 20);[m
[32m+[m[32m    int64_t nTotalCache = (args.GetArg("-dbcache", nDefaultDbCache) << 20);[m
     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache[m
     nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greater than nMaxDbcache[m
     int64_t nBlockTreeDBCache = std::min(nTotalCache / 8, nMaxBlockDBCache << 20);[m
     nTotalCache -= nBlockTreeDBCache;[m
[31m-    int64_t nTxIndexCache = std::min(nTotalCache / 8, gArgs.GetBoolArg("-txindex", DEFAULT_TXINDEX) ? nMaxTxIndexCache << 20 : 0);[m
[32m+[m[32m    int64_t nTxIndexCache = std::min(nTotalCache / 8, args.GetBoolArg("-txindex", DEFAULT_TXINDEX) ? nMaxTxIndexCache << 20 : 0);[m
     nTotalCache -= nTxIndexCache;[m
     int64_t filter_index_cache = 0;[m
     if (!g_enabled_filter_types.empty()) {[m
[36m@@ -1539,10 +1528,10 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache[m
     nTotalCache -= nCoinDBCache;[m
     int64_t nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache[m
[31m-    int64_t nMempoolSizeMax = gArgs.GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;[m
[32m+[m[32m    int64_t nMempoolSizeMax = args.GetArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;[m
     LogPrintf("Cache configuration:\n");[m
     LogPrintf("* Using %.1f MiB for block index database\n", nBlockTreeDBCache * (1.0 / 1024 / 1024));[m
[31m-    if (gArgs.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {[m
[32m+[m[32m    if (args.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {[m
         LogPrintf("* Using %.1f MiB for transaction index database\n", nTxIndexCache * (1.0 / 1024 / 1024));[m
     }[m
     for (BlockFilterType filter_type : g_enabled_filter_types) {[m
[36m@@ -1566,7 +1555,7 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
             const int64_t load_block_index_start_time = GetTimeMillis();[m
             try {[m
                 LOCK(cs_main);[m
[31m-                chainman.InitializeChainstate();[m
[32m+[m[32m                chainman.InitializeChainstate(*Assert(node.mempool));[m
                 chainman.m_total_coinstip_cache = nCoinCacheUsage;[m
                 chainman.m_total_coinsdb_cache = nCoinDBCache;[m
 [m
[36m@@ -1707,7 +1696,7 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
                 for (CChainState* chainstate : chainman.GetAll()) {[m
                     if (!is_coinsview_empty(chainstate)) {[m
                         uiInterface.InitMessage(_("Verifying blocks...").translated);[m
[31m-                        if (fHavePruned && gArgs.GetArg("-checkblocks", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {[m
[32m+[m[32m                        if (fHavePruned && args.GetArg("-checkblocks", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {[m
                             LogPrintf("Prune: pruned datadir may not have more than %d blocks; only checking available blocks\n",[m
                                 MIN_BLOCKS_TO_KEEP);[m
                         }[m
[36m@@ -1725,10 +1714,10 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
                         // Only verify the DB of the active chainstate. This is fixed in later[m
                         // work when we allow VerifyDB to be parameterized by chainstate.[m
                         if (&::ChainstateActive() == chainstate &&[m
[31m-                                !CVerifyDB().VerifyDB([m
[32m+[m[32m                            !CVerifyDB().VerifyDB([m
                                 chainparams, &chainstate->CoinsDB(),[m
[31m-                                gArgs.GetArg("-checklevel", DEFAULT_CHECKLEVEL),[m
[31m-                                gArgs.GetArg("-checkblocks", DEFAULT_CHECKBLOCKS))) {[m
[32m+[m[32m                                args.GetArg("-checklevel", DEFAULT_CHECKLEVEL),[m
[32m+[m[32m                                args.GetArg("-checkblocks", DEFAULT_CHECKBLOCKS))) {[m
                             strLoadError = _("Corrupted block database detected");[m
                             failed_verification = true;[m
                             break;[m
[36m@@ -1784,7 +1773,7 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     fFeeEstimatesInitialized = true;[m
 [m
     // ********************************************************* Step 8: start indexers[m
[31m-    if (gArgs.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {[m
[32m+[m[32m    if (args.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {[m
         g_txindex = MakeUnique<TxIndex>(nTxIndexCache, false, fReindex);[m
         g_txindex->Start();[m
     }[m
[36m@@ -1844,16 +1833,31 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     }[m
 [m
 #if HAVE_SYSTEM[m
[31m-    if (gArgs.IsArgSet("-blocknotify"))[m
[32m+[m[32m    if (args.IsArgSet("-blocknotify")) {[m
[32m+[m[32m        const std::string block_notify = args.GetArg("-blocknotify", "");[m
[32m+[m[32m        const auto BlockNotifyCallback = [block_notify](SynchronizationState sync_state, const CBlockIndex* pBlockIndex) {[m
[32m+[m[32m            if (sync_state != SynchronizationState::POST_INIT || !pBlockIndex)[m
[32m+[m[32m                return;[m
[32m+[m
[32m+[m[32m            std::string strCmd = block_notify;[m
[32m+[m[32m            if (!strCmd.empty()) {[m
[32m+[m[32m                boost::replace_all(strCmd, "%s", pBlockIndex->GetBlockHash().GetHex());[m
[32m+[m[32m                std::thread t(runCommand, strCmd);[m
[32m+[m[32m                t.detach(); // thread runs free[m
[32m+[m[32m            }[m
[32m+[m[32m        };[m
         uiInterface.NotifyBlockTip_connect(BlockNotifyCallback);[m
[32m+[m[32m    }[m
 #endif[m
 [m
     std::vector<fs::path> vImportFiles;[m
[31m-    for (const std::string& strFile : gArgs.GetArgs("-loadblock")) {[m
[32m+[m[32m    for (const std::string& strFile : args.GetArgs("-loadblock")) {[m
         vImportFiles.push_back(strFile);[m
     }[m
 [m
[31m-    g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman]{ ThreadImport(chainman, vImportFiles); });[m
[32m+[m[32m    g_load_block = std::thread(&TraceThread<std::function<void()>>, "loadblk", [=, &chainman, &args] {[m
[32m+[m[32m        ThreadImport(chainman, vImportFiles, args);[m
[32m+[m[32m    });[m
 [m
     // Wait for genesis block to be processed[m
     {[m
[36m@@ -1892,13 +1896,13 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     }[m
     LogPrintf("nBestHeight = %d\n", chain_active_height);[m
 [m
[31m-    if (gArgs.GetBoolArg("-listenonion", DEFAULT_LISTEN_ONION))[m
[32m+[m[32m    if (args.GetBoolArg("-listenonion", DEFAULT_LISTEN_ONION))[m
         StartTorControl();[m
 [m
     Discover();[m
 [m
     // Map ports with UPnP[m
[31m-    if (gArgs.GetBoolArg("-upnp", DEFAULT_UPNP)) {[m
[32m+[m[32m    if (args.GetBoolArg("-upnp", DEFAULT_UPNP)) {[m
         StartMapPort();[m
     }[m
 [m
[36m@@ -1913,41 +1917,41 @@[m [mbool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA[m
     connOptions.uiInterface = &uiInterface;[m
     connOptions.m_banman = node.banman.get();[m
     connOptions.m_msgproc = node.peer_logic.get();[m
[31m-    connOptions.nSendBufferMaxSize = 1000*gArgs.GetArg("-maxsendbuffer", DEFAULT_MAXSENDBUFFER);[m
[31m-    connOptions.nReceiveFloodSize = 1000*gArgs.GetArg("-maxreceivebuffer", DEFAULT_MAXRECEIVEBUFFER);[m
[31m-    connOptions.m_added_nodes = gArgs.GetArgs("-addnode");[m
[32m+[m[32m    connOptions.nSendBufferMaxSize = 1000 * args.GetArg("-maxsendbuffer", DEFAULT_MAXSENDBUFFER);[m
[32m+[m[32m    connOptions.nReceiveFloodSize = 1000 * args.GetArg("-maxreceivebuffer", DEFAULT_MAXRECEIVEBUFFER);[m
[32m+[m[32m    connOptions.m_added_nodes = args.GetArgs("-addnode");[m
 [m
     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;[m
     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;[m
     connOptions.m_peer_connect_timeout = peer_connect_timeout;[m
 [m
[31m-    for (const std::string& strBind : gArgs.GetArgs("-bind")) {[m
[32m+[m[32m    for (const std::string& strBind : args.GetArgs("-bind")) {[m
         CService addrBind;[m
         if (!Lookup(strBind, addrBind, GetListenPort(), false)) {[m
             return InitError(ResolveErrMsg("bind", strBind));[m
         }[m
         connOptions.vBinds.push_back(addrBind);[m
     }[m
[31m-    for (const std::string& strBind : gArgs.GetArgs("-whitebind")) {[m
[32m+[m[32m    for (const std::string& strBind : args.GetArgs("-whitebind")) {[m
         NetWhitebindPermissions whitebind;[m
         bilingual_str error;[m
         if (!NetWhitebindPermissions::TryParse(strBind, whitebind, error)) return InitError(error);[m
         connOptions.vWhiteBinds.push_back(whitebind);[m
     }[m
 [m
[31m-    for (const auto& net : gArgs.GetArgs("-whitelist")) {[m
[32m+[m[32m    for (const auto& net : args.GetArgs("-whitelist")) {[m
         NetWhitelistPermissions subnet;[m
         bilingual_str error;[m
         if (!NetWhitelistPermissions::TryParse(net, subnet, error)) return InitError(error);[m
         connOptions.vWhitelistedRange.push_back(subnet);[m
     }[m
 [m
[31m-    connOptions.vSeedNodes = gArgs.GetArgs("-seednode");[m
[32m+[m[32m    connOptions.vSeedNodes = args.GetArgs("-seednode");[m
 [m
     // Initiate outbound connections unless connect=0[m
[31m-    connOptions.m_use_addrman_outgoing = !gArgs.IsArgSet("-connect");[m
[32m+[m[32m    connOptions.m_use_addrman_outgoing = !args.IsArgSet("-connect");[m
     if (!connOptions.m_use_addrman_outgoing) {[m
[31m-        const auto connect = gArgs.GetArgs("-connect");[m
[32m+[m[32m        const auto connect = args.GetArgs("-connect");[m
         if (connect.size() != 1 || connect[0] != "0") {[m
             connOptions.m_specified_outgoing = connect;[m
         }[m
[33mdiff --git a/src/init.h b/src/init.h[m
[33mindex 20008ba5be..679e875da1 100644[m
[33m--- a/src/init.h[m
[33m+++ b/src/init.h[m
[36m@@ -8,8 +8,8 @@[m
 [m
 #include <memory>[m
 #include <string>[m
[31m-#include <util/system.h>[m
 [m
[32m+[m[32mclass ArgsManager;[m
 struct NodeContext;[m
 namespace interfaces {[m
 struct BlockAndHeaderTipInfo;[m
[36m@@ -25,21 +25,21 @@[m [mclass Ref;[m
 void Interrupt(NodeContext& node);[m
 void Shutdown(NodeContext& node);[m
 //!Initialize the logging infrastructure[m
[31m-void InitLogging();[m
[32m+[m[32mvoid InitLogging(const ArgsManager& args);[m
 //!Parameter interaction: change current parameters depending on various rules[m
[31m-void InitParameterInteraction();[m
[32m+[m[32mvoid InitParameterInteraction(ArgsManager& args);[m
 [m
 /** Initialize bitcoin core: Basic context setup.[m
  *  @note This can be done before daemonization. Do not call Shutdown() if this function fails.[m
  *  @pre Parameters should be parsed and config file should be read.[m
  */[m
[31m-bool AppInitBasicSetup();[m
[32m+[m[32mbool AppInitBasicSetup(ArgsManager& args);[m
 /**[m
  * Initialization: parameter interaction.[m
  * @note This can be done before daemonization. Do not call Shutdown() if this function fails.[m
  * @pre Parameters should be parsed and config file should be read, AppInitBasicSetup should have been called.[m
  */[m
[31m-bool AppInitParameterInteraction();[m
[32m+[m[32mbool AppInitParameterInteraction(const ArgsManager& args);[m
 /**[m
  * Initialization sanity checks: ecc init, sanity checks, dir lock.[m
  * @note This can be done before daemonization. Do not call Shutdown() if this function fails.[m
[36m@@ -52,6 +52,10 @@[m [mbool AppInitSanityChecks();[m
  * @pre Parameters should be parsed and config file should be read, AppInitSanityChecks should have been called.[m
  */[m
 bool AppInitLockDataDirectory();[m
[32m+[m[32m/**[m
[32m+[m[32m * Initialize node and wallet interface pointers. Has no prerequisites or side effects besides allocating memory.[m
[32m+[m[32m */[m
[32m+[m[32mbool AppInitInterfaces(NodeContext& node);[m
 /**[m
  * Bitcoin core main initialization.[m
  * @note This should only be done after daemonization. Call Shutdown() if this function fails.[m
[33mdiff --git a/src/interfaces/chain.h b/src/interfaces/chain.h[m
[33mindex 053d40335f..6e50ccb27a 100644[m
[33m--- a/src/interfaces/chain.h[m
[33m+++ b/src/interfaces/chain.h[m
[36m@@ -314,24 +314,11 @@[m [mpublic:[m
 [m
     //! Set mock time.[m
     virtual void setMockTime(int64_t time) = 0;[m
[31m-[m
[31m-    //! Return interfaces for accessing wallets (if any).[m
[31m-    virtual std::vector<std::unique_ptr<Wallet>> getWallets() = 0;[m
 };[m
 [m
 //! Return implementation of Chain interface.[m
 std::unique_ptr<Chain> MakeChain(NodeContext& node);[m
 [m
[2m-//! Return implementation of ChainClient interface for a wallet client. This[m
[2m-//! function will be undefined in builds where ENABLE_WALLET is false.[m
[31m-//![m
[31m-//! Currently, wallets are the only chain clients. But in the future, other[m
[31m-//! types of chain clients could be added, such as tools for monitoring,[m
[31m-//! analysis, or fee estimation. These clients need to expose their own[m
[31m-//! MakeXXXClient functions returning their implementations of the ChainClient[m
[31m-//! interface.[m
[31m-std::unique_ptr<ChainClient> MakeWalletClient(Chain& chain, ArgsManager& args, std::vector<std::string> wallet_filenames);[m
[31m-[m
 } // namespace interfaces[m
 [m
 #endif // BITCOIN_INTERFACES_CHAIN_H[m
[33mdiff --git a/src/interfaces/node.cpp b/src/interfaces/node.cpp[m
[33mindex 21400d00f8..2c5f8627e6 100644[m
[33m--- a/src/interfaces/node.cpp[m
[33m+++ b/src/interfaces/node.cpp[m
[36m@@ -27,6 +27,7 @@[m
 #include <support/allocators/secure.h>[m
 #include <sync.h>[m
 #include <txmempool.h>[m
[32m+[m[32m#include <util/check.h>[m
 #include <util/ref.h>[m
 #include <util/system.h>[m
 #include <util/translation.h>[m
[36m@@ -41,48 +42,24 @@[m
 [m
 #include <boost/signals2/signal.hpp>[m
 [m
[31m-class CWallet;[m
[31m-fs::path GetWalletDir();[m
[31m-std::vector<fs::path> ListWalletDir();[m
[31m-std::vector<std::shared_ptr<CWallet>> GetWallets();[m
[31m-std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings);[m
[31m-WalletCreationStatus CreateWallet(interfaces::Chain& chain, const SecureString& passphrase, uint64_t wallet_creation_flags, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings, std::shared_ptr<CWallet>& result);[m
[31m-std::unique_ptr<interfaces::Handler> HandleLoadWallet(interfaces::Node::LoadWalletFn load_wallet);[m
[31m-[m
 namespace interfaces {[m
[31m-[m
 namespace {[m
 [m
 class NodeImpl : public Node[m
 {[m
 public:[m
     NodeImpl(NodeContext* context) { setContext(context); }[m
[31m-    void initError(const bilingual_str& message) override { InitError(message); }[m
[31m-    bool parseParameters(int argc, const char* const argv[], std::string& error) override[m
[31m-    {[m
[31m-        return gArgs.ParseParameters(argc, argv, error);[m
[31m-    }[m
[31m-    bool readConfigFiles(std::string& error) override { return gArgs.ReadConfigFiles(error, true); }[m
[31m-    void forceSetArg(const std::string& arg, const std::string& value) override { gArgs.ForceSetArg(arg, value); }[m
[31m-    bool softSetArg(const std::string& arg, const std::string& value) override { return gArgs.SoftSetArg(arg, value); }[m
[31m-    bool softSetBoolArg(const std::string& arg, bool value) override { return gArgs.SoftSetBoolArg(arg, value); }[m
[31m-    void selectParams(const std::string& network) override { SelectParams(network); }[m
[31m-    bool initSettings(std::string& error) override { return gArgs.InitSettings(error); }[m
[31m-    uint64_t getAssumedBlockchainSize() override { return Params().AssumedBlockchainSize(); }[m
[31m-    uint64_t getAssumedChainStateSize() override { return Params().AssumedChainStateSize(); }[m
[31m-    std::string getNetwork() override { return Params().NetworkIDString(); }[m
[31m-    void initLogging() override { InitLogging(); }[m
[31m-    void initParameterInteraction() override { InitParameterInteraction(); }[m
[32m+[m[32m    void initLogging() override { InitLogging(*Assert(m_context->args)); }[m
[32m+[m[32m    void initParameterInteraction() override { InitParameterInteraction(*Assert(m_context->args)); }[m
     bilingual_str getWarnings() override { return GetWarnings(true); }[m
     uint32_t getLogCategories() override { return LogInstance().GetCategoryMask(); }[m
     bool baseInitialize() override[m
     {[m
[31m-        return AppInitBasicSetup() && AppInitParameterInteraction() && AppInitSanityChecks() &&[m
[31m-               AppInitLockDataDirectory();[m
[32m+[m[32m        return AppInitBasicSetup(gArgs) && AppInitParameterInteraction(gArgs) && AppInitSanityChecks() &&[m
[32m+[m[32m               AppInitLockDataDirectory() && AppInitInterfaces(*m_context);[m
     }[m
     bool appInitMain(interfaces::BlockAndHeaderTipInfo* tip_info) override[m
     {[m
[31m-        m_context->chain = MakeChain(*m_context);[m
         return AppInitMain(m_context_ref, *m_context, tip_info);[m
     }[m
     void appShutdown() override[m
[36m@@ -109,7 +86,6 @@[m [mpublic:[m
             StopMapPort();[m
         }[m
     }[m
[31m-    void setupServerArgs() override { return SetupServerArgs(*m_context); }[m
     bool getProxy(Network net, proxyType& proxy_info) override { return GetProxy(net, proxy_info); }[m
     size_t getNodeCount(CConnman::NumConnections flags) override[m
     {[m
[36m@@ -255,36 +231,9 @@[m [mpublic:[m
         LOCK(::cs_main);[m
         return ::ChainstateActive().CoinsTip().GetCoin(output, coin);[m
     }[m
[2m-    std::string getWalletDir() override[m
[2m-    {[m
[2m-        return GetWalletDir().string();[m
[2m-    }[m
[2m-    std::vector<std::string> listWalletDir() override[m
[2m-    {[m
[2m-        std::vector<std::string> paths;[m
[2m-        for (auto& path : ListWalletDir()) {[m
[2m-            paths.push_back(path.string());[m
[2m-        }[m
[2m-        return paths;[m
[2m-    }[m
[31m-    std::vector<std::unique_ptr<Wallet>> getWallets() override[m
[32m+[m[32m    WalletClient& walletClient() override[m
     {[m
[31m-        std::vector<std::unique_ptr<Wallet>> wallets;[m
[31m-        for (auto& client : m_context->chain_clients) {[m
[31m-            auto client_wallets = client->getWallets();[m
[31m-            std::move(client_wallets.begin(), client_wallets.end(), std::back_inserter(wallets));[m
[31m-        }[m
[31m-        return wallets;[m
[2;3m-    }[m
[2;3m-    std::unique_ptr<Wallet> loadWallet(const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings) override[m
[2;3m-    {[m
[31m-        return MakeWallet(LoadWallet(*m_context->chain, name, error, warnings));[m
[31m-    }[m
[31m-    std::unique_ptr<Wallet> createWallet(const SecureString& passphrase, uint64_t wallet_creation_flags, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings, WalletCreationStatus& status) override[m
[2;3m-    {[m
[2;3m-        std::shared_ptr<CWallet> wallet;[m
[31m-        status = CreateWallet(*m_context->chain, passphrase, wallet_creation_flags, name, error, warnings, wallet);[m
[31m-        return MakeWallet(wallet);[m
[32m+[m[32m        return *Assert(m_context->wallet_client);[m
     }[m
     std::unique_ptr<Handler> handleInitMessage(InitMessageFn fn) override[m
     {[m
[36m@@ -302,10 +251,6 @@[m [mpublic:[m
     {[m
         return MakeHandler(::uiInterface.ShowProgress_connect(fn));[m
     }[m
[2m-    std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) override[m
[2m-    {[m
[2m-        return HandleLoadWallet(std::move(fn));[m
[2m-    }[m
     std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) override[m
     {[m
         return MakeHandler(::uiInterface.NotifyNumConnectionsChanged_connect(fn));[m
[33mdiff --git a/src/interfaces/node.h b/src/interfaces/node.h[m
[33mindex 753f3e6b13..5079be038e 100644[m
[33m--- a/src/interfaces/node.h[m
[33m+++ b/src/interfaces/node.h[m
[36m@@ -29,14 +29,13 @@[m [mclass RPCTimerInterface;[m
 class UniValue;[m
 class proxyType;[m
 enum class SynchronizationState;[m
[2m-enum class WalletCreationStatus;[m
 struct CNodeStateStats;[m
 struct NodeContext;[m
 struct bilingual_str;[m
 [m
 namespace interfaces {[m
 class Handler;[m
[31m-class Wallet;[m
[32m+[m[32mclass WalletClient;[m
 struct BlockTip;[m
 [m
 //! Block and header tip information[m
[36m@@ -55,41 +54,6 @@[m [mclass Node[m
 public:[m
     virtual ~Node() {}[m
 [m
[31m-    //! Send init error.[m
[31m-    virtual void initError(const bilingual_str& message) = 0;[m
[31m-[m
[31m-    //! Set command line arguments.[m
[31m-    virtual bool parseParameters(int argc, const char* const argv[], std::string& error) = 0;[m
[31m-[m
[31m-    //! Set a command line argument[m
[31m-    virtual void forceSetArg(const std::string& arg, const std::string& value) = 0;[m
[31m-[m
[31m-    //! Set a command line argument if it doesn't already have a value[m
[31m-    virtual bool softSetArg(const std::string& arg, const std::string& value) = 0;[m
[31m-[m
[31m-    //! Set a command line boolean argument if it doesn't already have a value[m
[31m-    virtual bool softSetBoolArg(const std::string& arg, bool value) = 0;[m
[31m-[m
[31m-    //! Load settings from configuration file.[m
[31m-    virtual bool readConfigFiles(std::string& error) = 0;[m
[31m-[m
[31m-    //! Choose network parameters.[m
[31m-    virtual void selectParams(const std::string& network) = 0;[m
[31m-[m
[31m-    //! Read and update <datadir>/settings.json file with saved settings. This[m
[31m-    //! needs to be called after selectParams() because the settings file[m
[31m-    //! location is network-specific.[m
[31m-    virtual bool initSettings(std::string& error) = 0;[m
[31m-[m
[31m-    //! Get the (assumed) blockchain size.[m
[31m-    virtual uint64_t getAssumedBlockchainSize() = 0;[m
[31m-[m
[31m-    //! Get the (assumed) chain state size.[m
[31m-    virtual uint64_t getAssumedChainStateSize() = 0;[m
[31m-[m
[31m-    //! Get network name.[m
[31m-    virtual std::string getNetwork() = 0;[m
[31m-[m
     //! Init logging.[m
     virtual void initLogging() = 0;[m
 [m
[36m@@ -117,9 +81,6 @@[m [mpublic:[m
     //! Return whether shutdown was requested.[m
     virtual bool shutdownRequested() = 0;[m
 [m
[31m-    //! Setup arguments[m
[31m-    virtual void setupServerArgs() = 0;[m
[31m-[m
     //! Map port.[m
     virtual void mapPort(bool use_upnp) = 0;[m
 [m
[36m@@ -211,22 +172,8 @@[m [mpublic:[m
     //! Get unspent outputs associated with a transaction.[m
     virtual bool getUnspentOutput(const COutPoint& output, Coin& coin) = 0;[m
 [m
[31m-    //! Return default wallet directory.[m
[31m-    virtual std::string getWalletDir() = 0;[m
[31m-[m
[31m-    //! Return available wallets in wallet directory.[m
[31m-    virtual std::vector<std::string> listWalletDir() = 0;[m
[31m-[m
[31m-    //! Return interfaces for accessing wallets (if any).[m
[31m-    virtual std::vector<std::unique_ptr<Wallet>> getWallets() = 0;[m
[31m-[m
[31m-    //! Attempts to load a wallet from file or directory.[m
[31m-    //! The loaded wallet is also notified to handlers previously registered[m
[31m-    //! with handleLoadWallet.[m
[31m-    virtual std::unique_ptr<Wallet> loadWallet(const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings) = 0;[m
[31m-[m
[31m-    //! Create a wallet from file[m
[31m-    virtual std::unique_ptr<Wallet> createWallet(const SecureString& passphrase, uint64_t wallet_creation_flags, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings, WalletCreationStatus& status) = 0;[m
[32m+[m[32m    //! Get wallet client.[m
[32m+[m[32m    virtual WalletClient& walletClient() = 0;[m
 [m
     //! Register handler for init messages.[m
     using InitMessageFn = std::function<void(const std::string& message)>;[m
[36m@@ -248,10 +195,6 @@[m [mpublic:[m
     using ShowProgressFn = std::function<void(const std::string& title, int progress, bool resume_possible)>;[m
     virtual std::unique_ptr<Handler> handleShowProgress(ShowProgressFn fn) = 0;[m
 [m
[31m-    //! Register handler for load wallet messages.[m
[31m-    using LoadWalletFn = std::function<void(std::unique_ptr<Wallet> wallet)>;[m
[31m-    virtual std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) = 0;[m
[31m-[m
     //! Register handler for number of connections changed messages.[m
     using NotifyNumConnectionsChangedFn = std::function<void(int new_num_connections)>;[m
     virtual std::unique_ptr<Handler> handleNotifyNumConnectionsChanged(NotifyNumConnectionsChangedFn fn) = 0;[m
[33mdiff --git a/src/interfaces/wallet.cpp b/src/interfaces/wallet.cpp[m
[33mindex 7fd24425cf..63c109658e 100644[m
[33m--- a/src/interfaces/wallet.cpp[m
[33m+++ b/src/interfaces/wallet.cpp[m
[36m@@ -37,6 +37,7 @@[m [mnamespace {[m
 //! Construct wallet tx struct.[m
 WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)[m
 {[m
[32m+[m[32m    LOCK(wallet.cs_wallet);[m
     WalletTx result;[m
     result.tx = wtx.tx;[m
     result.txin_is_mine.reserve(wtx.tx->vin.size());[m
[36m@@ -132,7 +133,11 @@[m [mpublic:[m
     {[m
         return m_wallet->SignMessage(message, pkhash, str_sig);[m
     }[m
[31m-    bool isSpendable(const CTxDestination& dest) override { return m_wallet->IsMine(dest) & ISMINE_SPENDABLE; }[m
[32m+[m[32m    bool isSpendable(const CTxDestination& dest) override[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(m_wallet->cs_wallet);[m
[32m+[m[32m        return m_wallet->IsMine(dest) & ISMINE_SPENDABLE;[m
[32m+[m[32m    }[m
     bool haveWatchOnly() override[m
     {[m
         auto spk_man = m_wallet->GetLegacyScriptPubKeyMan();[m
[36m@@ -480,7 +485,7 @@[m [mpublic:[m
     std::shared_ptr<CWallet> m_wallet;[m
 };[m
 [m
[31m-class WalletClientImpl : public ChainClient[m
[32m+[m[32mclass WalletClientImpl : public WalletClient[m
 {[m
 public:[m
     WalletClientImpl(Chain& chain, ArgsManager& args, std::vector<std::string> wallet_filenames)[m
[36m@@ -489,6 +494,9 @@[m [mpublic:[m
         m_context.chain = &chain;[m
         m_context.args = &args;[m
     }[m
[2m+[m[2m    ~WalletClientImpl() override { UnloadWallets(); }[m
[32m+[m
[32m+[m[32m    //! ChainClient methods[m
     void registerRpcs() override[m
     {[m
         for (const CRPCCommand& command : GetWalletRPCCommands()) {[m
[36m@@ -504,6 +512,30 @@[m [mpublic:[m
     void flush() override { return FlushWallets(); }[m
     void stop() override { return StopWallets(); }[m
     void setMockTime(int64_t time) override { return SetMockTime(time); }[m
[32m+[m
[32m+[m[32m    //! WalletClient methods[m
[32m+[m[32m    std::unique_ptr<Wallet> createWallet(const std::string& name, const SecureString& passphrase, uint64_t wallet_creation_flags, WalletCreationStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings) override[m
[2;3m+[m[2;3m    {[m
[2;3m+[m[2;3m        std::shared_ptr<CWallet> wallet;[m
[32m+[m[32m        status = CreateWallet(*m_context.chain, passphrase, wallet_creation_flags, name, error, warnings, wallet);[m
[32m+[m[32m        return MakeWallet(std::move(wallet));[m
[2m+[m[2m    }[m
[2m+[m[2m    std::unique_ptr<Wallet> loadWallet(const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings) override[m
[2m+[m[2m    {[m
[32m+[m[32m        return MakeWallet(LoadWallet(*m_context.chain, WalletLocation(name), error, warnings));[m
[32m+[m[32m    }[m
[2m+[m[2m    std::string getWalletDir() override[m
[2m+[m[2m    {[m
[2m+[m[2m        return GetWalletDir().string();[m
[2m+[m[2m    }[m
[2m+[m[2m    std::vector<std::string> listWalletDir() override[m
[2m+[m[2m    {[m
[2m+[m[2m        std::vector<std::string> paths;[m
[2m+[m[2m        for (auto& path : ListWalletDir()) {[m
[2m+[m[2m            paths.push_back(path.string());[m
[2m+[m[2m        }[m
[2m+[m[2m        return paths;[m
[2m+[m[2m    }[m
     std::vector<std::unique_ptr<Wallet>> getWallets() override[m
     {[m
         std::vector<std::unique_ptr<Wallet>> wallets;[m
[36m@@ -512,7 +544,10 @@[m [mpublic:[m
         }[m
         return wallets;[m
     }[m
[1;35m-    ~WalletClientImpl() override { UnloadWallets(); }[m
[1;33m+[m[1;33m    std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) override[m
[2;3m+[m[2;3m    {[m
[2;3m+[m[2;3m        return HandleLoadWallet(std::move(fn));[m
[2;3m+[m[2;3m    }[m
 [m
     WalletContext m_context;[m
     const std::vector<std::string> m_wallet_filenames;[m
[36m@@ -524,7 +559,7 @@[m [mpublic:[m
 [m
 std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return wallet ? MakeUnique<WalletImpl>(wallet) : nullptr; }[m
 [m
[31m-std::unique_ptr<ChainClient> MakeWalletClient(Chain& chain, ArgsManager& args, std::vector<std::string> wallet_filenames)[m
[32m+[m[32mstd::unique_ptr<WalletClient> MakeWalletClient(Chain& chain, ArgsManager& args, std::vector<std::string> wallet_filenames)[m
 {[m
     return MakeUnique<WalletClientImpl>(chain, args, std::move(wallet_filenames));[m
 }[m
[33mdiff --git a/src/interfaces/wallet.h b/src/interfaces/wallet.h[m
[33mindex 3cdadbc72e..186f5d81a5 100644[m
[33m--- a/src/interfaces/wallet.h[m
[33m+++ b/src/interfaces/wallet.h[m
[36m@@ -6,6 +6,7 @@[m
 #define BITCOIN_INTERFACES_WALLET_H[m
 [m
 #include <amount.h>                    // For CAmount[m
[32m+[m[32m#include <interfaces/chain.h>          // For ChainClient[m
 #include <pubkey.h>                    // For CKeyID and CScriptID (definitions needed in CTxDestination instantiation)[m
 #include <script/standard.h>           // For CTxDestination[m
 #include <support/allocators/secure.h> // For SecureString[m
[36m@@ -28,9 +29,11 @@[m [mclass CWallet;[m
 enum class FeeReason;[m
 enum class OutputType;[m
 enum class TransactionError;[m
[2m+[m[2menum class WalletCreationStatus;[m
 enum isminetype : unsigned int;[m
 struct CRecipient;[m
 struct PartiallySignedTransaction;[m
[32m+[m[32mstruct WalletContext;[m
 struct bilingual_str;[m
 typedef uint8_t isminefilter;[m
 [m
[36m@@ -301,6 +304,34 @@[m [mpublic:[m
     virtual CWallet* wallet() { return nullptr; }[m
 };[m
 [m
[32m+[m[32m//! Wallet chain client that in addition to having chain client methods for[m
[32m+[m[32m//! starting up, shutting down, and registering RPCs, also has additional[m
[32m+[m[32m//! methods (called by the GUI) to load and create wallets.[m
[32m+[m[32mclass WalletClient : public ChainClient[m
[32m+[m[32m{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    //! Create new wallet.[m
[32m+[m[32m    virtual std::unique_ptr<Wallet> createWallet(const std::string& name, const SecureString& passphrase, uint64_t wallet_creation_flags, WalletCreationStatus& status, bilingual_str& error, std::vector<bilingual_str>& warnings) = 0;[m
[32m+[m
[32m+[m[32m   //! Load existing wallet.[m
[32m+[m[32m   virtual std::unique_ptr<Wallet> loadWallet(const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings) = 0;[m
[32m+[m
[32m+[m[32m   //! Return default wallet directory.[m
[32m+[m[32m   virtual std::string getWalletDir() = 0;[m
[32m+[m
[32m+[m[32m   //! Return available wallets in wallet directory.[m
[32m+[m[32m   virtual std::vector<std::string> listWalletDir() = 0;[m
[32m+[m
[32m+[m[32m   //! Return interfaces for accessing wallets (if any).[m
[32m+[m[32m   virtual std::vector<std::unique_ptr<Wallet>> getWallets() = 0;[m
[32m+[m
[32m+[m[32m   //! Register handler for load wallet messages. This callback is triggered by[m
[32m+[m[32m   //! createWallet and loadWallet above, and also triggered when wallets are[m
[32m+[m[32m   //! loaded at startup or by RPC.[m
[32m+[m[32m   using LoadWalletFn = std::function<void(std::unique_ptr<Wallet> wallet)>;[m
[32m+[m[32m   virtual std::unique_ptr<Handler> handleLoadWallet(LoadWalletFn fn) = 0;[m
[32m+[m[32m};[m
[32m+[m
 //! Information about one wallet address.[m
 struct WalletAddress[m
 {[m
[36m@@ -379,6 +410,10 @@[m [mstruct WalletTxOut[m
 //! dummywallet.cpp and throws if the wallet component is not compiled.[m
 std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet);[m
 [m
[2m+[m[2m//! Return implementation of ChainClient interface for a wallet client. This[m
[2m+[m[2m//! function will be undefined in builds where ENABLE_WALLET is false.[m
[32m+[m[32mstd::unique_ptr<WalletClient> MakeWalletClient(Chain& chain, ArgsManager& args, std::vector<std::string> wallet_filenames);[m
[32m+[m
 } // namespace interfaces[m
 [m
 #endif // BITCOIN_INTERFACES_WALLET_H[m
[33mdiff --git a/src/key.cpp b/src/key.cpp[m
[33mindex 4ed74a39b1..868a8b9b0e 100644[m
[33m--- a/src/key.cpp[m
[33m+++ b/src/key.cpp[m
[36m@@ -31,7 +31,7 @@[m [mstatic secp256k1_context* secp256k1_context_sign = nullptr;[m
  *[m
  * out32 must point to an output buffer of length at least 32 bytes.[m
  */[m
[31m-static int ec_seckey_import_der(const secp256k1_context* ctx, unsigned char *out32, const unsigned char *seckey, size_t seckeylen) {[m
[32m+[m[32mint ec_seckey_import_der(const secp256k1_context* ctx, unsigned char *out32, const unsigned char *seckey, size_t seckeylen) {[m
     const unsigned char *end = seckey + seckeylen;[m
     memset(out32, 0, 32);[m
     /* sequence header */[m
[36m@@ -88,7 +88,7 @@[m [mstatic int ec_seckey_import_der(const secp256k1_context* ctx, unsigned char *out[m
  * will be set to the number of bytes used in the buffer.[m
  * key32 must point to a 32-byte raw private key.[m
  */[m
[31m-static int ec_seckey_export_der(const secp256k1_context *ctx, unsigned char *seckey, size_t *seckeylen, const unsigned char *key32, bool compressed) {[m
[32m+[m[32mint ec_seckey_export_der(const secp256k1_context *ctx, unsigned char *seckey, size_t *seckeylen, const unsigned char *key32, bool compressed) {[m
     assert(*seckeylen >= CKey::SIZE);[m
     secp256k1_pubkey pubkey;[m
     size_t pubkeylen = 0;[m
[33mdiff --git a/src/net_processing.cpp b/src/net_processing.cpp[m
[33mindex 60bdfbe9f5..e2efbd8804 100644[m
[33m--- a/src/net_processing.cpp[m
[33m+++ b/src/net_processing.cpp[m
[36m@@ -278,12 +278,6 @@[m [mstruct CNodeState {[m
     const CService address;[m
     //! Whether we have a fully established connection.[m
     bool fCurrentlyConnected;[m
[31m-    //! Accumulated misbehaviour score for this peer.[m
[31m-    int nMisbehavior;[m
[31m-    //! Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission).[m
[31m-    bool m_should_discourage;[m
[31m-    //! String name of this peer (debugging/logging purposes).[m
[31m-    const std::string name;[m
     //! The best known block we know this peer has announced.[m
     const CBlockIndex *pindexBestKnownBlock;[m
     //! The hash of the last unknown block this peer has announced.[m
[36m@@ -432,13 +426,10 @@[m [mstruct CNodeState {[m
     //! Whether this peer relays txs via wtxid[m
     bool m_wtxid_relay{false};[m
 [m
[31m-    CNodeState(CAddress addrIn, std::string addrNameIn, bool is_inbound, bool is_manual) :[m
[31m-        address(addrIn), name(std::move(addrNameIn)), m_is_inbound(is_inbound),[m
[31m-        m_is_manual_connection (is_manual)[m
[32m+[m[32m    CNodeState(CAddress addrIn, bool is_inbound, bool is_manual)[m
[32m+[m[32m        : address(addrIn), m_is_inbound(is_inbound), m_is_manual_connection(is_manual)[m
     {[m
         fCurrentlyConnected = false;[m
[31m-        nMisbehavior = 0;[m
[31m-        m_should_discourage = false;[m
         pindexBestKnownBlock = nullptr;[m
         hashLastUnknownBlock.SetNull();[m
         pindexLastCommonBlock = nullptr;[m
[36m@@ -476,6 +467,50 @@[m [mstatic CNodeState *State(NodeId pnode) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {[m
     return &it->second;[m
 }[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Data structure for an individual peer. This struct is not protected by[m
[32m+[m[32m * cs_main since it does not contain validation-critical data.[m
[32m+[m[32m *[m
[32m+[m[32m * Memory is owned by shared pointers and this object is destructed when[m
[32m+[m[32m * the refcount drops to zero.[m
[32m+[m[32m *[m
[32m+[m[32m * TODO: move most members from CNodeState to this structure.[m
[32m+[m[32m * TODO: move remaining application-layer data members from CNode to this structure.[m
[32m+[m[32m */[m
[32m+[m[32mstruct Peer {[m
[32m+[m[32m    /** Same id as the CNode object for this peer */[m
[32m+[m[32m    const NodeId m_id{0};[m
[32m+[m
[32m+[m[32m    /** Protects misbehavior data members */[m
[32m+[m[32m    Mutex m_misbehavior_mutex;[m
[32m+[m[32m    /** Accumulated misbehavior score for this peer */[m
[32m+[m[32m    int m_misbehavior_score GUARDED_BY(m_misbehavior_mutex){0};[m
[32m+[m[32m    /** Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission). */[m
[32m+[m[32m    bool m_should_discourage GUARDED_BY(m_misbehavior_mutex){false};[m
[32m+[m
[32m+[m[32m    Peer(NodeId id) : m_id(id) {}[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32musing PeerRef = std::shared_ptr<Peer>;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * Map of all Peer objects, keyed by peer id. This map is protected[m
[32m+[m[32m * by the global g_peer_mutex. Once a shared pointer reference is[m
[32m+[m[32m * taken, the lock may be released. Individual fields are protected by[m
[32m+[m[32m * their own locks.[m
[32m+[m[32m */[m
[32m+[m[32mMutex g_peer_mutex;[m
[32m+[m[32mstatic std::map<NodeId, PeerRef> g_peer_map GUARDED_BY(g_peer_mutex);[m
[32m+[m
[32m+[m[32m/** Get a shared pointer to the Peer object.[m
[32m+[m[32m *  May return nullptr if the Peer object can't be found. */[m
[32m+[m[32mstatic PeerRef GetPeerRef(NodeId id)[m
[32m+[m[32m{[m
[32m+[m[32m    LOCK(g_peer_mutex);[m
[32m+[m[32m    auto it = g_peer_map.find(id);[m
[32m+[m[32m    return it != g_peer_map.end() ? it->second : nullptr;[m
[32m+[m[32m}[m
[32m+[m
 static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
 {[m
     nPreferredDownload -= state->fPreferredDownload;[m
[36m@@ -628,13 +663,12 @@[m [mstatic void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma[m
             }[m
         }[m
         connman.ForNode(nodeid, [&connman](CNode* pfrom){[m
[31m-            AssertLockHeld(cs_main);[m
[32m+[m[32m            LockAssertion lock(::cs_main);[m
             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;[m
             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {[m
                 // As per BIP152, we only get 3 of our peers to announce[m
                 // blocks using compact encodings.[m
                 connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, nCMPCTBLOCKVersion](CNode* pnodeStop){[m
[31m-                    AssertLockHeld(cs_main);[m
                     connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetSendVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));[m
                     return true;[m
                 });[m
[36m@@ -841,7 +875,12 @@[m [mvoid PeerLogicValidation::InitializeNode(CNode *pnode) {[m
     NodeId nodeid = pnode->GetId();[m
     {[m
         LOCK(cs_main);[m
[31m-        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, std::move(addrName), pnode->IsInboundConn(), pnode->IsManualConn()));[m
[32m+[m[32m        mapNodeState.emplace_hint(mapNodeState.end(), std::piecewise_construct, std::forward_as_tuple(nodeid), std::forward_as_tuple(addr, pnode->IsInboundConn(), pnode->IsManualConn()));[m
[32m+[m[32m    }[m
[32m+[m[32m    {[m
[32m+[m[32m        PeerRef peer = std::make_shared<Peer>(nodeid);[m
[32m+[m[32m        LOCK(g_peer_mutex);[m
[32m+[m[32m        g_peer_map.emplace_hint(g_peer_map.end(), nodeid, std::move(peer));[m
     }[m
     if(!pnode->IsInboundConn())[m
         PushNodeVersion(*pnode, m_connman, GetTime());[m
[36m@@ -870,13 +909,21 @@[m [mvoid PeerLogicValidation::ReattemptInitialBroadcast(CScheduler& scheduler) const[m
 void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {[m
     fUpdateConnectionTime = false;[m
     LOCK(cs_main);[m
[32m+[m[32m    int misbehavior{0};[m
[32m+[m[32m    {[m
[32m+[m[32m        PeerRef peer = GetPeerRef(nodeid);[m
[32m+[m[32m        assert(peer != nullptr);[m
[32m+[m[32m        misbehavior = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);[m
[32m+[m[32m        LOCK(g_peer_mutex);[m
[32m+[m[32m        g_peer_map.erase(nodeid);[m
[32m+[m[32m    }[m
     CNodeState *state = State(nodeid);[m
     assert(state != nullptr);[m
 [m
     if (state->fSyncStarted)[m
         nSyncStarted--;[m
 [m
[31m-    if (state->nMisbehavior == 0 && state->fCurrentlyConnected) {[m
[32m+[m[32m    if (misbehavior == 0 && state->fCurrentlyConnected) {[m
         fUpdateConnectionTime = true;[m
     }[m
 [m
[36m@@ -906,17 +953,23 @@[m [mvoid PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim[m
 }[m
 [m
 bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {[m
[31m-    LOCK(cs_main);[m
[31m-    CNodeState *state = State(nodeid);[m
[31m-    if (state == nullptr)[m
[31m-        return false;[m
[31m-    stats.nMisbehavior = state->nMisbehavior;[m
[31m-    stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;[m
[31m-    stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;[m
[31m-    for (const QueuedBlock& queue : state->vBlocksInFlight) {[m
[31m-        if (queue.pindex)[m
[31m-            stats.vHeightInFlight.push_back(queue.pindex->nHeight);[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(cs_main);[m
[32m+[m[32m        CNodeState* state = State(nodeid);[m
[32m+[m[32m        if (state == nullptr)[m
[32m+[m[32m            return false;[m
[32m+[m[32m        stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;[m
[32m+[m[32m        stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;[m
[32m+[m[32m        for (const QueuedBlock& queue : state->vBlocksInFlight) {[m
[32m+[m[32m            if (queue.pindex)[m
[32m+[m[32m                stats.vHeightInFlight.push_back(queue.pindex->nHeight);[m
[32m+[m[32m        }[m
     }[m
[32m+[m
[32m+[m[32m    PeerRef peer = GetPeerRef(nodeid);[m
[32m+[m[32m    if (peer == nullptr) return false;[m
[32m+[m[32m    stats.m_misbehavior_score = WITH_LOCK(peer->m_misbehavior_mutex, return peer->m_misbehavior_score);[m
[32m+[m
     return true;[m
 }[m
 [m
[36m@@ -1060,21 +1113,21 @@[m [munsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)[m
  * Increment peer's misbehavior score. If the new value >= DISCOURAGEMENT_THRESHOLD, mark the node[m
  * to be discouraged, meaning the peer might be disconnected and added to the discouragement filter.[m
  */[m
[31m-void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
[32m+[m[32mvoid Misbehaving(const NodeId pnode, const int howmuch, const std::string& message)[m
 {[m
     assert(howmuch > 0);[m
 [m
[31m-    CNodeState* const state = State(pnode);[m
[31m-    if (state == nullptr) return;[m
[32m+[m[32m    PeerRef peer = GetPeerRef(pnode);[m
[32m+[m[32m    if (peer == nullptr) return;[m
 [m
[31m-    state->nMisbehavior += howmuch;[m
[32m+[m[32m    LOCK(peer->m_misbehavior_mutex);[m
[32m+[m[32m    peer->m_misbehavior_score += howmuch;[m
     const std::string message_prefixed = message.empty() ? "" : (": " + message);[m
[31m-    if (state->nMisbehavior >= DISCOURAGEMENT_THRESHOLD && state->nMisbehavior - howmuch < DISCOURAGEMENT_THRESHOLD)[m
[31m-    {[m
[31m-        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\n", pnode, state->nMisbehavior - howmuch, state->nMisbehavior, message_prefixed);[m
[31m-        state->m_should_discourage = true;[m
[32m+[m[32m    if (peer->m_misbehavior_score >= DISCOURAGEMENT_THRESHOLD && peer->m_misbehavior_score - howmuch < DISCOURAGEMENT_THRESHOLD) {[m
[32m+[m[32m        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d) DISCOURAGE THRESHOLD EXCEEDED%s\n", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);[m
[32m+[m[32m        peer->m_should_discourage = true;[m
     } else {[m
[31m-        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d)%s\n", pnode, state->nMisbehavior - howmuch, state->nMisbehavior, message_prefixed);[m
[32m+[m[32m        LogPrint(BCLog::NET, "Misbehaving: peer=%d (%d -> %d)%s\n", pnode, peer->m_misbehavior_score - howmuch, peer->m_misbehavior_score, message_prefixed);[m
     }[m
 }[m
 [m
[36m@@ -1096,7 +1149,6 @@[m [mstatic bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& s[m
     case BlockValidationResult::BLOCK_CONSENSUS:[m
     case BlockValidationResult::BLOCK_MUTATED:[m
         if (!via_compact_block) {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(nodeid, 100, message);[m
             return true;[m
         }[m
[36m@@ -1120,18 +1172,12 @@[m [mstatic bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& s[m
     case BlockValidationResult::BLOCK_INVALID_HEADER:[m
     case BlockValidationResult::BLOCK_CHECKPOINT:[m
     case BlockValidationResult::BLOCK_INVALID_PREV:[m
[31m-        {[m
[31m-            LOCK(cs_main);[m
[31m-            Misbehaving(nodeid, 100, message);[m
[31m-        }[m
[32m+[m[32m        Misbehaving(nodeid, 100, message);[m
         return true;[m
     // Conflicting (but not necessarily invalid) data or different policy:[m
     case BlockValidationResult::BLOCK_MISSING_PREV:[m
[31m-        {[m
[31m-            // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)[m
[31m-            LOCK(cs_main);[m
[31m-            Misbehaving(nodeid, 10, message);[m
[31m-        }[m
[32m+[m[32m        // TODO: Handle this much more gracefully (10 DoS points is super arbitrary)[m
[32m+[m[32m        Misbehaving(nodeid, 10, message);[m
         return true;[m
     case BlockValidationResult::BLOCK_RECENT_CONSENSUS_CHANGE:[m
     case BlockValidationResult::BLOCK_TIME_FUTURE:[m
[36m@@ -1155,11 +1201,8 @@[m [mstatic bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state,[m
         break;[m
     // The node is providing invalid data:[m
     case TxValidationResult::TX_CONSENSUS:[m
[31m-        {[m
[31m-            LOCK(cs_main);[m
[31m-            Misbehaving(nodeid, 100, message);[m
[31m-            return true;[m
[31m-        }[m
[32m+[m[32m        Misbehaving(nodeid, 100, message);[m
[32m+[m[32m        return true;[m
     // Conflicting (but not necessarily invalid) data or different policy:[m
     case TxValidationResult::TX_RECENT_CONSENSUS_CHANGE:[m
     case TxValidationResult::TX_INPUTS_NOT_STANDARD:[m
[36m@@ -1327,7 +1370,7 @@[m [mvoid PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:[m
     }[m
 [m
     m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {[m
[31m-        AssertLockHeld(cs_main);[m
[32m+[m[32m        LockAssertion lock(::cs_main);[m
 [m
         // TODO: Avoid the repeated-serialization here[m
         if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)[m
[36m@@ -1469,7 +1512,8 @@[m [mvoid RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman&[m
 {[m
     connman.ForEachNode([&txid, &wtxid](CNode* pnode)[m
     {[m
[31m-        AssertLockHeld(cs_main);[m
[32m+[m[32m        LockAssertion lock(::cs_main);[m
[32m+[m
         CNodeState &state = *State(pnode->GetId());[m
         if (state.m_wtxid_relay) {[m
             pnode->PushTxInventory(wtxid);[m
[36m@@ -1806,7 +1850,6 @@[m [minline void static SendBlockTransactions(const CBlock& block, const BlockTransac[m
     BlockTransactions resp(req);[m
     for (size_t i = 0; i < req.indexes.size(); i++) {[m
         if (req.indexes[i] >= block.vtx.size()) {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 100, "getblocktxn with out-of-bounds tx indices");[m
             return;[m
         }[m
[36m@@ -2318,7 +2361,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
         // Each connection can only send one version message[m
         if (pfrom.nVersion != 0)[m
         {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 1, "redundant version message");[m
             return;[m
         }[m
[36m@@ -2478,7 +2520,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
 [m
     if (pfrom.nVersion == 0) {[m
         // Must have a version message before anything else[m
[31m-        LOCK(cs_main);[m
         Misbehaving(pfrom.GetId(), 1, "non-version message before version handshake");[m
         return;[m
     }[m
[36m@@ -2545,7 +2586,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
 [m
     if (!pfrom.fSuccessfullyConnected) {[m
         // Must have a verack message before anything else[m
[31m-        LOCK(cs_main);[m
         Misbehaving(pfrom.GetId(), 1, "non-verack message before version handshake");[m
         return;[m
     }[m
[36m@@ -2559,7 +2599,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
         }[m
         if (vAddr.size() > MAX_ADDR_TO_SEND)[m
         {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 20, strprintf("addr message size = %u", vAddr.size()));[m
             return;[m
         }[m
[36m@@ -2638,7 +2677,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
         vRecv >> vInv;[m
         if (vInv.size() > MAX_INV_SZ)[m
         {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 20, strprintf("inv message size = %u", vInv.size()));[m
             return;[m
         }[m
[36m@@ -2714,7 +2752,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
         vRecv >> vInv;[m
         if (vInv.size() > MAX_INV_SZ)[m
         {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 20, strprintf("getdata message size = %u", vInv.size()));[m
             return;[m
         }[m
[36m@@ -3439,7 +3476,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
         // Bypass the normal CBlock deserialization, as we don't want to risk deserializing 2000 full blocks.[m
         unsigned int nCount = ReadCompactSize(vRecv);[m
         if (nCount > MAX_HEADERS_RESULTS) {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 20, strprintf("headers message size = %u", nCount));[m
             return;[m
         }[m
[36m@@ -3641,7 +3677,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
         if (!filter.IsWithinSizeConstraints())[m
         {[m
             // There is no excuse for sending a too-large filter[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 100, "too-large bloom filter");[m
         }[m
         else if (pfrom.m_tx_relay != nullptr)[m
[36m@@ -3675,7 +3710,6 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
             }[m
         }[m
         if (bad) {[m
[31m-            LOCK(cs_main);[m
             Misbehaving(pfrom.GetId(), 100, "bad filteradd message");[m
         }[m
         return;[m
[36m@@ -3761,15 +3795,17 @@[m [mvoid PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty[m
 bool PeerLogicValidation::MaybeDiscourageAndDisconnect(CNode& pnode)[m
 {[m
     const NodeId peer_id{pnode.GetId()};[m
[32m+[m[32m    PeerRef peer = GetPeerRef(peer_id);[m
[32m+[m[32m    if (peer == nullptr) return false;[m
[32m+[m
     {[m
[31m-        LOCK(cs_main);[m
[31m-        CNodeState& state = *State(peer_id);[m
[32m+[m[32m        LOCK(peer->m_misbehavior_mutex);[m
 [m
         // There's nothing to do if the m_should_discourage flag isn't set[m
[31m-        if (!state.m_should_discourage) return false;[m
[32m+[m[32m        if (!peer->m_should_discourage) return false;[m
 [m
[31m-        state.m_should_discourage = false;[m
[31m-    } // cs_main[m
[32m+[m[32m        peer->m_should_discourage = false;[m
[32m+[m[32m    } // peer.m_misbehavior_mutex[m
 [m
     if (pnode.HasPermission(PF_NOBAN)) {[m
         // We never disconnect or discourage peers for bad behavior if they have the NOBAN permission flag[m
[36m@@ -3957,7 +3993,7 @@[m [mvoid PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)[m
         int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();[m
 [m
         m_connman.ForEachNode([&](CNode* pnode) {[m
[31m-            AssertLockHeld(cs_main);[m
[32m+[m[32m            LockAssertion lock(::cs_main);[m
 [m
             // Ignore non-outbound peers, or nodes marked for disconnect already[m
             if (!pnode->IsOutboundOrBlockRelayConn() || pnode->fDisconnect) return;[m
[36m@@ -3974,7 +4010,7 @@[m [mvoid PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)[m
         });[m
         if (worst_peer != -1) {[m
             bool disconnected = m_connman.ForNode(worst_peer, [&](CNode *pnode) {[m
[31m-                AssertLockHeld(cs_main);[m
[32m+[m[32m                LockAssertion lock(::cs_main);[m
 [m
                 // Only disconnect a peer that has been connected to us for[m
                 // some reasonable fraction of our check-frequency, to give[m
[33mdiff --git a/src/net_processing.h b/src/net_processing.h[m
[33mindex 74d6603747..4f1c52fc17 100644[m
[33m--- a/src/net_processing.h[m
[33m+++ b/src/net_processing.h[m
[36m@@ -97,7 +97,7 @@[m [mprivate:[m
 };[m
 [m
 struct CNodeStateStats {[m
[31m-    int nMisbehavior = 0;[m
[32m+[m[32m    int m_misbehavior_score = 0;[m
     int nSyncHeight = -1;[m
     int nCommonHeight = -1;[m
     std::vector<int> vHeightInFlight;[m
[33mdiff --git a/src/netaddress.cpp b/src/netaddress.cpp[m
[33mindex d29aed6c8b..b50cf74069 100644[m
[33m--- a/src/netaddress.cpp[m
[33m+++ b/src/netaddress.cpp[m
[36m@@ -3,79 +3,91 @@[m
 // Distributed under the MIT software license, see the accompanying[m
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
 [m
[31m-#include <cstdint>[m
 #include <netaddress.h>[m
[32m+[m
 #include <hash.h>[m
[32m+[m[32m#include <tinyformat.h>[m
 #include <util/strencodings.h>[m
 #include <util/asmap.h>[m
[31m-#include <tinyformat.h>[m
 [m
[31m-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };[m
[31m-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};[m
[32m+[m[32m#include <algorithm>[m
[32m+[m[32m#include <array>[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <iterator>[m
[32m+[m[32m#include <tuple>[m
 [m
[31m-// 0xFD + sha256("bitcoin")[0:5][m
[31m-static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };[m
[32m+[m[32mconstexpr size_t CNetAddr::V1_SERIALIZATION_SIZE;[m
 [m
 /**[m
  * Construct an unspecified IPv6 network address (::/128).[m
  *[m
  * @note This address is considered invalid by CNetAddr::IsValid()[m
  */[m
[31m-CNetAddr::CNetAddr()[m
[31m-{[m
[31m-    memset(ip, 0, sizeof(ip));[m
[31m-}[m
[32m+[m[32mCNetAddr::CNetAddr() {}[m
 [m
 void CNetAddr::SetIP(const CNetAddr& ipIn)[m
 {[m
[32m+[m[32m    // Size check.[m
[32m+[m[32m    switch (ipIn.m_net) {[m
[32m+[m[32m    case NET_IPV4:[m
[32m+[m[32m        assert(ipIn.m_addr.size() == ADDR_IPV4_SIZE);[m
[32m+[m[32m        break;[m
[32m+[m[32m    case NET_IPV6:[m
[32m+[m[32m        assert(ipIn.m_addr.size() == ADDR_IPV6_SIZE);[m
[32m+[m[32m        break;[m
[32m+[m[32m    case NET_ONION:[m
[32m+[m[32m        assert(ipIn.m_addr.size() == ADDR_TORV2_SIZE);[m
[32m+[m[32m        break;[m
[32m+[m[32m    case NET_INTERNAL:[m
[32m+[m[32m        assert(ipIn.m_addr.size() == ADDR_INTERNAL_SIZE);[m
[32m+[m[32m        break;[m
[32m+[m[32m    case NET_UNROUTABLE:[m
[32m+[m[32m    case NET_MAX:[m
[32m+[m[32m        assert(false);[m
[32m+[m[32m    } // no default case, so the compiler can warn about missing cases[m
[32m+[m
     m_net = ipIn.m_net;[m
[31m-    memcpy(ip, ipIn.ip, sizeof(ip));[m
[32m+[m[32m    m_addr = ipIn.m_addr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mtemplate <typename T1, size_t PREFIX_LEN>[m
[32m+[m[32minline bool HasPrefix(const T1& obj, const std::array<uint8_t, PREFIX_LEN>& prefix)[m
[32m+[m[32m{[m
[32m+[m[32m    return obj.size() >= PREFIX_LEN &&[m
[32m+[m[32m           std::equal(std::begin(prefix), std::end(prefix), std::begin(obj));[m
 }[m
 [m
[31m-void CNetAddr::SetLegacyIPv6(const uint8_t ipv6[16])[m
[32m+[m[32mvoid CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)[m
 {[m
[31m-    if (memcmp(ipv6, pchIPv4, sizeof(pchIPv4)) == 0) {[m
[32m+[m[32m    assert(ipv6.size() == ADDR_IPV6_SIZE);[m
[32m+[m
[32m+[m[32m    size_t skip{0};[m
[32m+[m
[32m+[m[32m    if (HasPrefix(ipv6, IPV4_IN_IPV6_PREFIX)) {[m
[32m+[m[32m        // IPv4-in-IPv6[m
         m_net = NET_IPV4;[m
[31m-    } else if (memcmp(ipv6, pchOnionCat, sizeof(pchOnionCat)) == 0) {[m
[32m+[m[32m        skip = sizeof(IPV4_IN_IPV6_PREFIX);[m
[32m+[m[32m    } else if (HasPrefix(ipv6, TORV2_IN_IPV6_PREFIX)) {[m
[32m+[m[32m        // TORv2-in-IPv6[m
         m_net = NET_ONION;[m
[31m-    } else if (memcmp(ipv6, g_internal_prefix, sizeof(g_internal_prefix)) == 0) {[m
[32m+[m[32m        skip = sizeof(TORV2_IN_IPV6_PREFIX);[m
[32m+[m[32m    } else if (HasPrefix(ipv6, INTERNAL_IN_IPV6_PREFIX)) {[m
[32m+[m[32m        // Internal-in-IPv6[m
         m_net = NET_INTERNAL;[m
[32m+[m[32m        skip = sizeof(INTERNAL_IN_IPV6_PREFIX);[m
     } else {[m
[32m+[m[32m        // IPv6[m
         m_net = NET_IPV6;[m
     }[m
[31m-    memcpy(ip, ipv6, 16);[m
[31m-}[m
 [m
[31m-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)[m
[31m-{[m
[31m-    switch(network)[m
[31m-    {[m
[31m-        case NET_IPV4:[m
[31m-            m_net = NET_IPV4;[m
[31m-            memcpy(ip, pchIPv4, 12);[m
[31m-            memcpy(ip+12, ip_in, 4);[m
[31m-            break;[m
[31m-        case NET_IPV6:[m
[31m-            SetLegacyIPv6(ip_in);[m
[31m-            break;[m
[31m-        default:[m
[31m-            assert(!"invalid network");[m
[31m-    }[m
[32m+[m[32m    m_addr.assign(ipv6.begin() + skip, ipv6.end());[m
 }[m
 [m
 /**[m
[31m- * Try to make this a dummy address that maps the specified name into IPv6 like[m
[31m- * so: (0xFD + %sha256("bitcoin")[0:5]) + %sha256(name)[0:10]. Such dummy[m
[31m- * addresses have a prefix of fd6b:88c0:8724::/48 and are guaranteed to not be[m
[31m- * publicly routable as it falls under RFC4193's fc00::/7 subnet allocated to[m
[31m- * unique-local addresses.[m
[31m- *[m
[31m- * CAddrMan uses these fake addresses to keep track of which DNS seeds were[m
[31m- * used.[m
[31m- *[m
[32m+[m[32m * Create an "internal" address that represents a name or FQDN. CAddrMan uses[m
[32m+[m[32m * these fake addresses to keep track of which DNS seeds were used.[m
  * @returns Whether or not the operation was successful.[m
[31m- *[m
[31m- * @see CNetAddr::IsInternal(), CNetAddr::IsRFC4193()[m
[32m+[m[32m * @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX, CNetAddr::IsInternal(), CNetAddr::IsRFC4193()[m
  */[m
 bool CNetAddr::SetInternal(const std::string &name)[m
 {[m
[36m@@ -85,31 +97,26 @@[m [mbool CNetAddr::SetInternal(const std::string &name)[m
     m_net = NET_INTERNAL;[m
     unsigned char hash[32] = {};[m
     CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);[m
[31m-    memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));[m
[31m-    memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));[m
[32m+[m[32m    m_addr.assign(hash, hash + ADDR_INTERNAL_SIZE);[m
     return true;[m
 }[m
 [m
 /**[m
[31m- * Try to make this a dummy address that maps the specified onion address into[m
[31m- * IPv6 using OnionCat's range and encoding. Such dummy addresses have a prefix[m
[31m- * of fd87:d87e:eb43::/48 and are guaranteed to not be publicly routable as they[m
[31m- * fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.[m
[32m+[m[32m * Parse a TORv2 address and set this object to it.[m
  *[m
  * @returns Whether or not the operation was successful.[m
  *[m
[31m- * @see CNetAddr::IsTor(), CNetAddr::IsRFC4193()[m
[32m+[m[32m * @see CNetAddr::IsTor()[m
  */[m
 bool CNetAddr::SetSpecial(const std::string &strName)[m
 {[m
     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == ".onion") {[m
         std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());[m
[31m-        if (vchAddr.size() != 16-sizeof(pchOnionCat))[m
[32m+[m[32m        if (vchAddr.size() != ADDR_TORV2_SIZE) {[m
             return false;[m
[32m+[m[32m        }[m
         m_net = NET_ONION;[m
[31m-        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));[m
[31m-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)[m
[31m-            ip[i + sizeof(pchOnionCat)] = vchAddr[i];[m
[32m+[m[32m        m_addr.assign(vchAddr.begin(), vchAddr.end());[m
         return true;[m
     }[m
     return false;[m
[36m@@ -117,28 +124,23 @@[m [mbool CNetAddr::SetSpecial(const std::string &strName)[m
 [m
 CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)[m
 {[m
[31m-    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);[m
[32m+[m[32m    m_net = NET_IPV4;[m
[32m+[m[32m    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(&ipv4Addr);[m
[32m+[m[32m    m_addr.assign(ptr, ptr + ADDR_IPV4_SIZE);[m
 }[m
 [m
 CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)[m
 {[m
[31m-    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);[m
[32m+[m[32m    SetLegacyIPv6(Span<const uint8_t>(reinterpret_cast<const uint8_t*>(&ipv6Addr), sizeof(ipv6Addr)));[m
     scopeId = scope;[m
 }[m
 [m
[31m-unsigned int CNetAddr::GetByte(int n) const[m
[31m-{[m
[31m-    return ip[15-n];[m
[31m-}[m
[31m-[m
 bool CNetAddr::IsBindAny() const[m
 {[m
[31m-    const int cmplen = IsIPv4() ? 4 : 16;[m
[31m-    for (int i = 0; i < cmplen; ++i) {[m
[31m-        if (GetByte(i)) return false;[m
[32m+[m[32m    if (!IsIPv4() && !IsIPv6()) {[m
[32m+[m[32m        return false;[m
     }[m
[31m-[m
[31m-    return true;[m
[32m+[m[32m    return std::all_of(m_addr.begin(), m_addr.end(), [](uint8_t b) { return b == 0; });[m
 }[m
 [m
 bool CNetAddr::IsIPv4() const { return m_net == NET_IPV4; }[m
[36m@@ -148,88 +150,88 @@[m [mbool CNetAddr::IsIPv6() const { return m_net == NET_IPV6; }[m
 bool CNetAddr::IsRFC1918() const[m
 {[m
     return IsIPv4() && ([m
[31m-        GetByte(3) == 10 ||[m
[31m-        (GetByte(3) == 192 && GetByte(2) == 168) ||[m
[31m-        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));[m
[32m+[m[32m        m_addr[0] == 10 ||[m
[32m+[m[32m        (m_addr[0] == 192 && m_addr[1] == 168) ||[m
[32m+[m[32m        (m_addr[0] == 172 && m_addr[1] >= 16 && m_addr[1] <= 31));[m
 }[m
 [m
 bool CNetAddr::IsRFC2544() const[m
 {[m
[31m-    return IsIPv4() && GetByte(3) == 198 && (GetByte(2) == 18 || GetByte(2) == 19);[m
[32m+[m[32m    return IsIPv4() && m_addr[0] == 198 && (m_addr[1] == 18 || m_addr[1] == 19);[m
 }[m
 [m
 bool CNetAddr::IsRFC3927() const[m
 {[m
[31m-    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);[m
[32m+[m[32m    return IsIPv4() && HasPrefix(m_addr, std::array<uint8_t, 2>{169, 254});[m
 }[m
 [m
 bool CNetAddr::IsRFC6598() const[m
 {[m
[31m-    return IsIPv4() && GetByte(3) == 100 && GetByte(2) >= 64 && GetByte(2) <= 127;[m
[32m+[m[32m    return IsIPv4() && m_addr[0] == 100 && m_addr[1] >= 64 && m_addr[1] <= 127;[m
 }[m
 [m
 bool CNetAddr::IsRFC5737() const[m
 {[m
[31m-    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||[m
[31m-        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||[m
[31m-        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));[m
[32m+[m[32m    return IsIPv4() && (HasPrefix(m_addr, std::array<uint8_t, 3>{192, 0, 2}) ||[m
[32m+[m[32m                        HasPrefix(m_addr, std::array<uint8_t, 3>{198, 51, 100}) ||[m
[32m+[m[32m                        HasPrefix(m_addr, std::array<uint8_t, 3>{203, 0, 113}));[m
 }[m
 [m
 bool CNetAddr::IsRFC3849() const[m
 {[m
[31m-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&[m
[31m-           GetByte(13) == 0x0D && GetByte(12) == 0xB8;[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 4>{0x20, 0x01, 0x0D, 0xB8});[m
 }[m
 [m
 bool CNetAddr::IsRFC3964() const[m
 {[m
[31m-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x02;[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 2>{0x20, 0x02});[m
 }[m
 [m
 bool CNetAddr::IsRFC6052() const[m
 {[m
[31m-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};[m
[31m-    return IsIPv6() && memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0;[m
[32m+[m[32m    return IsIPv6() &&[m
[32m+[m[32m           HasPrefix(m_addr, std::array<uint8_t, 12>{0x00, 0x64, 0xFF, 0x9B, 0x00, 0x00,[m
[32m+[m[32m                                                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00});[m
 }[m
 [m
 bool CNetAddr::IsRFC4380() const[m
 {[m
[31m-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 &&[m
[31m-           GetByte(12) == 0;[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 4>{0x20, 0x01, 0x00, 0x00});[m
 }[m
 [m
 bool CNetAddr::IsRFC4862() const[m
 {[m
[31m-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};[m
[31m-    return IsIPv6() && memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0;[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 8>{0xFE, 0x80, 0x00, 0x00,[m
[32m+[m[32m                                                                0x00, 0x00, 0x00, 0x00});[m
 }[m
 [m
 bool CNetAddr::IsRFC4193() const[m
 {[m
[31m-    return IsIPv6() && (GetByte(15) & 0xFE) == 0xFC;[m
[32m+[m[32m    return IsIPv6() && (m_addr[0] & 0xFE) == 0xFC;[m
 }[m
 [m
 bool CNetAddr::IsRFC6145() const[m
 {[m
[31m-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};[m
[31m-    return IsIPv6() && memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0;[m
[32m+[m[32m    return IsIPv6() &&[m
[32m+[m[32m           HasPrefix(m_addr, std::array<uint8_t, 12>{0x00, 0x00, 0x00, 0x00, 0x00, 0x00,[m
[32m+[m[32m                                                     0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00});[m
 }[m
 [m
 bool CNetAddr::IsRFC4843() const[m
 {[m
[31m-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&[m
[31m-           GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10;[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 3>{0x20, 0x01, 0x00}) &&[m
[32m+[m[32m           (m_addr[3] & 0xF0) == 0x10;[m
 }[m
 [m
 bool CNetAddr::IsRFC7343() const[m
 {[m
[31m-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&[m
[31m-           GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x20;[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 3>{0x20, 0x01, 0x00}) &&[m
[32m+[m[32m           (m_addr[3] & 0xF0) == 0x20;[m
 }[m
 [m
 bool CNetAddr::IsHeNet() const[m
 {[m
[31m-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70);[m
[32m+[m[32m    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 4>{0x20, 0x01, 0x04, 0x70});[m
 }[m
 [m
 /**[m
[36m@@ -243,13 +245,15 @@[m [mbool CNetAddr::IsTor() const { return m_net == NET_ONION; }[m
 bool CNetAddr::IsLocal() const[m
 {[m
     // IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)[m
[31m-    if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))[m
[32m+[m[32m    if (IsIPv4() && (m_addr[0] == 127 || m_addr[0] == 0)) {[m
         return true;[m
[32m+[m[32m    }[m
 [m
     // IPv6 loopback (::1/128)[m
     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};[m
[31m-    if (IsIPv6() && memcmp(ip, pchLocal, 16) == 0)[m
[32m+[m[32m    if (IsIPv6() && memcmp(m_addr.data(), pchLocal, sizeof(pchLocal)) == 0) {[m
         return true;[m
[32m+[m[32m    }[m
 [m
     return false;[m
 }[m
[36m@@ -266,19 +270,11 @@[m [mbool CNetAddr::IsLocal() const[m
  */[m
 bool CNetAddr::IsValid() const[m
 {[m
[31m-    // Cleanup 3-byte shifted addresses caused by garbage in size field[m
[31m-    // of addr messages from versions before 0.2.9 checksum.[m
[31m-    // Two consecutive addr messages look like this:[m
[31m-    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...[m
[31m-    // so if the first length field is garbled, it reads the second batch[m
[31m-    // of addr misaligned by 3 bytes.[m
[31m-    if (IsIPv6() && memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)[m
[31m-        return false;[m
[31m-[m
     // unspecified IPv6 address (::/128)[m
     unsigned char ipNone6[16] = {};[m
[31m-    if (IsIPv6() && memcmp(ip, ipNone6, 16) == 0)[m
[32m+[m[32m    if (IsIPv6() && memcmp(m_addr.data(), ipNone6, sizeof(ipNone6)) == 0) {[m
         return false;[m
[32m+[m[32m    }[m
 [m
     // documentation IPv6 address[m
     if (IsRFC3849())[m
[36m@@ -287,17 +283,11 @@[m [mbool CNetAddr::IsValid() const[m
     if (IsInternal())[m
         return false;[m
 [m
[31m-    if (IsIPv4())[m
[31m-    {[m
[31m-        // INADDR_NONE[m
[31m-        uint32_t ipNone = INADDR_NONE;[m
[31m-        if (memcmp(ip+12, &ipNone, 4) == 0)[m
[31m-            return false;[m
[31m-[m
[31m-        // 0[m
[31m-        ipNone = 0;[m
[31m-        if (memcmp(ip+12, &ipNone, 4) == 0)[m
[32m+[m[32m    if (IsIPv4()) {[m
[32m+[m[32m        const uint32_t addr = ReadBE32(m_addr.data());[m
[32m+[m[32m        if (addr == INADDR_ANY || addr == INADDR_NONE) {[m
             return false;[m
[32m+[m[32m        }[m
     }[m
 [m
     return true;[m
[36m@@ -318,7 +308,7 @@[m [mbool CNetAddr::IsRoutable() const[m
 }[m
 [m
 /**[m
[31m- * @returns Whether or not this is a dummy address that maps a name into IPv6.[m
[32m+[m[32m * @returns Whether or not this is a dummy address that represents a name.[m
  *[m
  * @see CNetAddr::SetInternal(const std::string &)[m
  */[m
[36m@@ -341,9 +331,9 @@[m [menum Network CNetAddr::GetNetwork() const[m
 std::string CNetAddr::ToStringIP() const[m
 {[m
     if (IsTor())[m
[31m-        return EncodeBase32(&ip[6], 10) + ".onion";[m
[32m+[m[32m        return EncodeBase32(m_addr) + ".onion";[m
     if (IsInternal())[m
[31m-        return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + ".internal";[m
[32m+[m[32m        return EncodeBase32(m_addr) + ".internal";[m
     CService serv(*this, 0);[m
     struct sockaddr_storage sockaddr;[m
     socklen_t socklen = sizeof(sockaddr);[m
[36m@@ -353,13 +343,13 @@[m [mstd::string CNetAddr::ToStringIP() const[m
             return std::string(name);[m
     }[m
     if (IsIPv4())[m
[31m-        return strprintf("%u.%u.%u.%u", GetByte(3), GetByte(2), GetByte(1), GetByte(0));[m
[31m-    else[m
[31m-        return strprintf("%x:%x:%x:%x:%x:%x:%x:%x",[m
[31m-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),[m
[31m-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),[m
[31m-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),[m
[31m-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));[m
[32m+[m[32m        return strprintf("%u.%u.%u.%u", m_addr[0], m_addr[1], m_addr[2], m_addr[3]);[m
[32m+[m[32m    assert(IsIPv6());[m
[32m+[m[32m    return strprintf("%x:%x:%x:%x:%x:%x:%x:%x",[m
[32m+[m[32m                     m_addr[0] << 8 | m_addr[1], m_addr[2] << 8 | m_addr[3],[m
[32m+[m[32m                     m_addr[4] << 8 | m_addr[5], m_addr[6] << 8 | m_addr[7],[m
[32m+[m[32m                     m_addr[8] << 8 | m_addr[9], m_addr[10] << 8 | m_addr[11],[m
[32m+[m[32m                     m_addr[12] << 8 | m_addr[13], m_addr[14] << 8 | m_addr[15]);[m
 }[m
 [m
 std::string CNetAddr::ToString() const[m
[36m@@ -369,12 +359,12 @@[m [mstd::string CNetAddr::ToString() const[m
 [m
 bool operator==(const CNetAddr& a, const CNetAddr& b)[m
 {[m
[31m-    return a.m_net == b.m_net && memcmp(a.ip, b.ip, 16) == 0;[m
[32m+[m[32m    return a.m_net == b.m_net && a.m_addr == b.m_addr;[m
 }[m
 [m
 bool operator<(const CNetAddr& a, const CNetAddr& b)[m
 {[m
[31m-    return a.m_net < b.m_net || (a.m_net == b.m_net && memcmp(a.ip, b.ip, 16) < 0);[m
[32m+[m[32m    return std::tie(a.m_net, a.m_addr) < std::tie(b.m_net, b.m_addr);[m
 }[m
 [m
 /**[m
[36m@@ -391,7 +381,8 @@[m [mbool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const[m
 {[m
     if (!IsIPv4())[m
         return false;[m
[31m-    memcpy(pipv4Addr, ip+12, 4);[m
[32m+[m[32m    assert(sizeof(*pipv4Addr) == m_addr.size());[m
[32m+[m[32m    memcpy(pipv4Addr, m_addr.data(), m_addr.size());[m
     return true;[m
 }[m
 [m
[36m@@ -410,7 +401,8 @@[m [mbool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const[m
     if (!IsIPv6()) {[m
         return false;[m
     }[m
[31m-    memcpy(pipv6Addr, ip, 16);[m
[32m+[m[32m    assert(sizeof(*pipv6Addr) == m_addr.size());[m
[32m+[m[32m    memcpy(pipv6Addr, m_addr.data(), m_addr.size());[m
     return true;[m
 }[m
 [m
[36m@@ -421,15 +413,17 @@[m [mbool CNetAddr::HasLinkedIPv4() const[m
 [m
 uint32_t CNetAddr::GetLinkedIPv4() const[m
 {[m
[31m-    if (IsIPv4() || IsRFC6145() || IsRFC6052()) {[m
[31m-        // IPv4, mapped IPv4, SIIT translated IPv4: the IPv4 address is the last 4 bytes of the address[m
[31m-        return ReadBE32(ip + 12);[m
[32m+[m[32m    if (IsIPv4()) {[m
[32m+[m[32m        return ReadBE32(m_addr.data());[m
[32m+[m[32m    } else if (IsRFC6052() || IsRFC6145()) {[m
[32m+[m[32m        // mapped IPv4, SIIT translated IPv4: the IPv4 address is the last 4 bytes of the address[m
[32m+[m[32m        return ReadBE32(MakeSpan(m_addr).last(ADDR_IPV4_SIZE).data());[m
     } else if (IsRFC3964()) {[m
         // 6to4 tunneled IPv4: the IPv4 address is in bytes 2-6[m
[31m-        return ReadBE32(ip + 2);[m
[32m+[m[32m        return ReadBE32(MakeSpan(m_addr).subspan(2, ADDR_IPV4_SIZE).data());[m
     } else if (IsRFC4380()) {[m
         // Teredo tunneled IPv4: the IPv4 address is in the last 4 bytes of the address, but bitflipped[m
[31m-        return ~ReadBE32(ip + 12);[m
[32m+[m[32m        return ~ReadBE32(MakeSpan(m_addr).last(ADDR_IPV4_SIZE).data());[m
     }[m
     assert(false);[m
 }[m
[36m@@ -458,10 +452,10 @@[m [muint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {[m
     }[m
     std::vector<bool> ip_bits(128);[m
     if (HasLinkedIPv4()) {[m
[31m-        // For lookup, treat as if it was just an IPv4 address (pchIPv4 prefix + IPv4 bits)[m
[32m+[m[32m        // For lookup, treat as if it was just an IPv4 address (IPV4_IN_IPV6_PREFIX + IPv4 bits)[m
         for (int8_t byte_i = 0; byte_i < 12; ++byte_i) {[m
             for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {[m
[31m-                ip_bits[byte_i * 8 + bit_i] = (pchIPv4[byte_i] >> (7 - bit_i)) & 1;[m
[32m+[m[32m                ip_bits[byte_i * 8 + bit_i] = (IPV4_IN_IPV6_PREFIX[byte_i] >> (7 - bit_i)) & 1;[m
             }[m
         }[m
         uint32_t ipv4 = GetLinkedIPv4();[m
[36m@@ -470,8 +464,9 @@[m [muint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {[m
         }[m
     } else {[m
         // Use all 128 bits of the IPv6 address otherwise[m
[32m+[m[32m        assert(IsIPv6());[m
         for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {[m
[31m-            uint8_t cur_byte = GetByte(15 - byte_i);[m
[32m+[m[32m            uint8_t cur_byte = m_addr[byte_i];[m
             for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {[m
                 ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;[m
             }[m
[36m@@ -507,19 +502,15 @@[m [mstd::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co[m
     }[m
 [m
     vchRet.push_back(net_class);[m
[31m-    int nStartByte = 0;[m
[31m-    int nBits = 16;[m
[32m+[m[32m    int nBits{0};[m
 [m
     if (IsLocal()) {[m
         // all local addresses belong to the same group[m
[31m-        nBits = 0;[m
     } else if (IsInternal()) {[m
         // all internal-usage addresses get their own group[m
[31m-        nStartByte = sizeof(g_internal_prefix);[m
[31m-        nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;[m
[32m+[m[32m        nBits = ADDR_INTERNAL_SIZE * 8;[m
     } else if (!IsRoutable()) {[m
         // all other unroutable addresses belong to the same group[m
[31m-        nBits = 0;[m
     } else if (HasLinkedIPv4()) {[m
         // IPv4 addresses (and mapped IPv4 addresses) use /16 groups[m
         uint32_t ipv4 = GetLinkedIPv4();[m
[36m@@ -527,7 +518,6 @@[m [mstd::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co[m
         vchRet.push_back((ipv4 >> 16) & 0xFF);[m
         return vchRet;[m
     } else if (IsTor()) {[m
[31m-        nStartByte = 6;[m
         nBits = 4;[m
     } else if (IsHeNet()) {[m
         // for he.net, use /36 groups[m
[36m@@ -537,23 +527,29 @@[m [mstd::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co[m
         nBits = 32;[m
     }[m
 [m
[31m-    // push our ip onto vchRet byte by byte...[m
[31m-    while (nBits >= 8)[m
[31m-    {[m
[31m-        vchRet.push_back(GetByte(15 - nStartByte));[m
[31m-        nStartByte++;[m
[31m-        nBits -= 8;[m
[31m-    }[m
[32m+[m[32m    // Push our address onto vchRet.[m
[32m+[m[32m    const size_t num_bytes = nBits / 8;[m
[32m+[m[32m    vchRet.insert(vchRet.end(), m_addr.begin(), m_addr.begin() + num_bytes);[m
[32m+[m[32m    nBits %= 8;[m
     // ...for the last byte, push nBits and for the rest of the byte push 1's[m
[31m-    if (nBits > 0)[m
[31m-        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));[m
[32m+[m[32m    if (nBits > 0) {[m
[32m+[m[32m        assert(num_bytes < m_addr.size());[m
[32m+[m[32m        vchRet.push_back(m_addr[num_bytes] | ((1 << (8 - nBits)) - 1));[m
[32m+[m[32m    }[m
 [m
     return vchRet;[m
 }[m
 [m
[32m+[m[32mstd::vector<unsigned char> CNetAddr::GetAddrBytes() const[m
[32m+[m[32m{[m
[32m+[m[32m    uint8_t serialized[V1_SERIALIZATION_SIZE];[m
[32m+[m[32m    SerializeV1Array(serialized);[m
[32m+[m[32m    return {std::begin(serialized), std::end(serialized)};[m
[32m+[m[32m}[m
[32m+[m
 uint64_t CNetAddr::GetHash() const[m
 {[m
[31m-    uint256 hash = Hash(ip);[m
[32m+[m[32m    uint256 hash = Hash(m_addr);[m
     uint64_t nRet;[m
     memcpy(&nRet, &hash, sizeof(nRet));[m
     return nRet;[m
[36m@@ -764,53 +760,89 @@[m [mCSubNet::CSubNet():[m
     memset(netmask, 0, sizeof(netmask));[m
 }[m
 [m
[31m-CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)[m
[32m+[m[32mCSubNet::CSubNet(const CNetAddr& addr, uint8_t mask) : CSubNet()[m
 {[m
[31m-    valid = true;[m
[32m+[m[32m    valid = (addr.IsIPv4() && mask <= ADDR_IPV4_SIZE * 8) ||[m
[32m+[m[32m            (addr.IsIPv6() && mask <= ADDR_IPV6_SIZE * 8);[m
[32m+[m[32m    if (!valid) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    assert(mask <= sizeof(netmask) * 8);[m
[32m+[m
     network = addr;[m
[31m-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address[m
[31m-    memset(netmask, 255, sizeof(netmask));[m
[31m-[m
[31m-    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n[m
[31m-    const int astartofs = network.IsIPv4() ? 12 : 0;[m
[31m-[m
[31m-    int32_t n = mask;[m
[31m-    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address[m
[31m-    {[m
[31m-        n += astartofs*8;[m
[31m-        // Clear bits [n..127][m
[31m-        for (; n < 128; ++n)[m
[31m-            netmask[n>>3] &= ~(1<<(7-(n&7)));[m
[31m-    } else[m
[31m-        valid = false;[m
 [m
[31m-    // Normalize network according to netmask[m
[31m-    for(int x=0; x<16; ++x)[m
[31m-        network.ip[x] &= netmask[x];[m
[32m+[m[32m    uint8_t n = mask;[m
[32m+[m[32m    for (size_t i = 0; i < network.m_addr.size(); ++i) {[m
[32m+[m[32m        const uint8_t bits = n < 8 ? n : 8;[m
[32m+[m[32m        netmask[i] = (uint8_t)((uint8_t)0xFF << (8 - bits)); // Set first bits.[m
[32m+[m[32m        network.m_addr[i] &= netmask[i]; // Normalize network according to netmask.[m
[32m+[m[32m        n -= bits;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[2;3m+[m
[2;3m+[m[2;3m/**[m
[2;3m+[m[2;3m * @returns The number of 1-bits in the prefix of the specified subnet mask. If[m
[2;3m+[m[2;3m *          the specified subnet mask is not a valid one, -1.[m
[2;3m+[m[2;3m */[m
[2;3m+[m[2;3mstatic inline int NetmaskBits(uint8_t x)[m
[2;3m+[m[2;3m{[m
[2;3m+[m[2;3m    switch(x) {[m
[2;3m+[m[2;3m    case 0x00: return 0;[m
[2;3m+[m[2;3m    case 0x80: return 1;[m
[2;3m+[m[2;3m    case 0xc0: return 2;[m
[2;3m+[m[2;3m    case 0xe0: return 3;[m
[2;3m+[m[2;3m    case 0xf0: return 4;[m
[2;3m+[m[2;3m    case 0xf8: return 5;[m
[2;3m+[m[2;3m    case 0xfc: return 6;[m
[2;3m+[m[2;3m    case 0xfe: return 7;[m
[2;3m+[m[2;3m    case 0xff: return 8;[m
[2;3m+[m[2;3m    default: return -1;[m
[32m+[m[32m    }[m
 }[m
 [m
[31m-CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)[m
[32m+[m[32mCSubNet::CSubNet(const CNetAddr& addr, const CNetAddr& mask) : CSubNet()[m
 {[m
[31m-    valid = true;[m
[31m-    network = addr;[m
[31m-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address[m
[31m-    memset(netmask, 255, sizeof(netmask));[m
[32m+[m[32m    valid = (addr.IsIPv4() || addr.IsIPv6()) && addr.m_net == mask.m_net;[m
[32m+[m[32m    if (!valid) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    // Check if `mask` contains 1-bits after 0-bits (which is an invalid netmask).[m
[32m+[m[32m    bool zeros_found = false;[m
[32m+[m[32m    for (auto b : mask.m_addr) {[m
[32m+[m[32m        const int num_bits = NetmaskBits(b);[m
[32m+[m[32m        if (num_bits == -1 || (zeros_found && num_bits != 0)) {[m
[32m+[m[32m            valid = false;[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (num_bits < 8) {[m
[32m+[m[32m            zeros_found = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    assert(mask.m_addr.size() <= sizeof(netmask));[m
 [m
[31m-    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n[m
[31m-    const int astartofs = network.IsIPv4() ? 12 : 0;[m
[32m+[m[32m    memcpy(netmask, mask.m_addr.data(), mask.m_addr.size());[m
 [m
[31m-    for(int x=astartofs; x<16; ++x)[m
[31m-        netmask[x] = mask.ip[x];[m
[32m+[m[32m    network = addr;[m
 [m
     // Normalize network according to netmask[m
[31m-    for(int x=0; x<16; ++x)[m
[31m-        network.ip[x] &= netmask[x];[m
[32m+[m[32m    for (size_t x = 0; x < network.m_addr.size(); ++x) {[m
[32m+[m[32m        network.m_addr[x] &= netmask[x];[m
[32m+[m[32m    }[m
 }[m
 [m
[31m-CSubNet::CSubNet(const CNetAddr &addr):[m
[31m-    valid(addr.IsValid())[m
[32m+[m[32mCSubNet::CSubNet(const CNetAddr& addr) : CSubNet()[m
 {[m
[31m-    memset(netmask, 255, sizeof(netmask));[m
[32m+[m[32m    valid = addr.IsIPv4() || addr.IsIPv6();[m
[32m+[m[32m    if (!valid) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    assert(addr.m_addr.size() <= sizeof(netmask));[m
[32m+[m
[32m+[m[32m    memset(netmask, 0xFF, addr.m_addr.size());[m
[32m+[m
     network = addr;[m
 }[m
 [m
[36m@@ -822,68 +854,29 @@[m [mbool CSubNet::Match(const CNetAddr &addr) const[m
 {[m
     if (!valid || !addr.IsValid() || network.m_net != addr.m_net)[m
         return false;[m
[31m-    for(int x=0; x<16; ++x)[m
[31m-        if ((addr.ip[x] & netmask[x]) != network.ip[x])[m
[32m+[m[32m    assert(network.m_addr.size() == addr.m_addr.size());[m
[32m+[m[32m    for (size_t x = 0; x < addr.m_addr.size(); ++x) {[m
[32m+[m[32m        if ((addr.m_addr[x] & netmask[x]) != network.m_addr[x]) {[m
             return false;[m
[31m-    return true;[m
[31m-}[m
[31m-[m
[2;3m-/**[m
[2;3m- * @returns The number of 1-bits in the prefix of the specified subnet mask. If[m
[2;3m- *          the specified subnet mask is not a valid one, -1.[m
[2;3m- */[m
[2;3m-static inline int NetmaskBits(uint8_t x)[m
[2;3m-{[m
[2;3m-    switch(x) {[m
[2;3m-    case 0x00: return 0;[m
[2;3m-    case 0x80: return 1;[m
[2;3m-    case 0xc0: return 2;[m
[2;3m-    case 0xe0: return 3;[m
[2;3m-    case 0xf0: return 4;[m
[2;3m-    case 0xf8: return 5;[m
[2;3m-    case 0xfc: return 6;[m
[2;3m-    case 0xfe: return 7;[m
[2;3m-    case 0xff: return 8;[m
[2;3m-    default: return -1;[m
[32m+[m[32m        }[m
     }[m
[32m+[m[32m    return true;[m
 }[m
 [m
 std::string CSubNet::ToString() const[m
 {[m
[31m-    /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */[m
[31m-    int cidr = 0;[m
[31m-    bool valid_cidr = true;[m
[31m-    int n = network.IsIPv4() ? 12 : 0;[m
[31m-    for (; n < 16 && netmask[n] == 0xff; ++n)[m
[31m-        cidr += 8;[m
[31m-    if (n < 16) {[m
[31m-        int bits = NetmaskBits(netmask[n]);[m
[31m-        if (bits < 0)[m
[31m-            valid_cidr = false;[m
[31m-        else[m
[31m-            cidr += bits;[m
[31m-        ++n;[m
[31m-    }[m
[31m-    for (; n < 16 && valid_cidr; ++n)[m
[31m-        if (netmask[n] != 0x00)[m
[31m-            valid_cidr = false;[m
[31m-[m
[31m-    /* Format output */[m
[31m-    std::string strNetmask;[m
[31m-    if (valid_cidr) {[m
[31m-        strNetmask = strprintf("%u", cidr);[m
[31m-    } else {[m
[31m-        if (network.IsIPv4())[m
[31m-            strNetmask = strprintf("%u.%u.%u.%u", netmask[12], netmask[13], netmask[14], netmask[15]);[m
[31m-        else[m
[31m-            strNetmask = strprintf("%x:%x:%x:%x:%x:%x:%x:%x",[m
[31m-                             netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],[m
[31m-                             netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],[m
[31m-                             netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],[m
[31m-                             netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);[m
[32m+[m[32m    assert(network.m_addr.size() <= sizeof(netmask));[m
[32m+[m
[32m+[m[32m    uint8_t cidr = 0;[m
[32m+[m
[32m+[m[32m    for (size_t i = 0; i < network.m_addr.size(); ++i) {[m
[32m+[m[32m        if (netmask[i] == 0x00) {[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        cidr += NetmaskBits(netmask[i]);[m
     }[m
 [m
[31m-    return network.ToString() + "/" + strNetmask;[m
[32m+[m[32m    return network.ToString() + strprintf("/%u", cidr);[m
 }[m
 [m
 bool CSubNet::IsValid() const[m
[33mdiff --git a/src/netaddress.h b/src/netaddress.h[m
[33mindex 0365907d44..8cc24dd1a8 100644[m
[33m--- a/src/netaddress.h[m
[33m+++ b/src/netaddress.h[m
[36m@@ -9,9 +9,14 @@[m
 #include <config/bitcoin-config.h>[m
 #endif[m
 [m
[32m+[m[32m#include <attributes.h>[m
 #include <compat.h>[m
[32m+[m[32m#include <prevector.h>[m
[32m+[m[32m#include <crypto/siphash.h>[m
[32m+[m[32m#include <random.h>[m
 #include <serialize.h>[m
 [m
[32m+[m[32m#include <array>[m
 #include <cstdint>[m
 #include <string>[m
 #include <vector>[m
[36m@@ -39,28 +44,66 @@[m [menum Network[m
     /// TORv2[m
     NET_ONION,[m
 [m
[31m-    /// A set of dummy addresses that map a name to an IPv6 address. These[m
[31m-    /// addresses belong to RFC4193's fc00::/7 subnet (unique-local addresses).[m
[31m-    /// We use them to map a string or FQDN to an IPv6 address in CAddrMan to[m
[31m-    /// keep track of which DNS seeds were used.[m
[32m+[m[32m    /// A set of addresses that represent the hash of a string or FQDN. We use[m
[32m+[m[32m    /// them in CAddrMan to keep track of which DNS seeds were used.[m
     NET_INTERNAL,[m
 [m
     /// Dummy value to indicate the number of NET_* constants.[m
     NET_MAX,[m
 };[m
 [m
[32m+[m[32m/// Prefix of an IPv6 address when it contains an embedded IPv4 address.[m
[32m+[m[32m/// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).[m
[32m+[m[32mstatic const std::array<uint8_t, 12> IPV4_IN_IPV6_PREFIX{[m
[32m+[m[32m    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/// Prefix of an IPv6 address when it contains an embedded TORv2 address.[m
[32m+[m[32m/// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).[m
[32m+[m[32m/// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they[m
[32m+[m[32m/// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.[m
[32m+[m[32mstatic const std::array<uint8_t, 6> TORV2_IN_IPV6_PREFIX{[m
[32m+[m[32m    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/// Prefix of an IPv6 address when it contains an embedded "internal" address.[m
[32m+[m[32m/// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).[m
[32m+[m[32m/// The prefix comes from 0xFD + SHA256("bitcoin")[0:5].[m
[32m+[m[32m/// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they[m
[32m+[m[32m/// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.[m
[32m+[m[32mstatic const std::array<uint8_t, 6> INTERNAL_IN_IPV6_PREFIX{[m
[32m+[m[32m    0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 // 0xFD + sha256("bitcoin")[0:5].[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m/// Size of IPv4 address (in bytes).[m
[32m+[m[32mstatic constexpr size_t ADDR_IPV4_SIZE = 4;[m
[32m+[m
[32m+[m[32m/// Size of IPv6 address (in bytes).[m
[32m+[m[32mstatic constexpr size_t ADDR_IPV6_SIZE = 16;[m
[32m+[m
[32m+[m[32m/// Size of TORv2 address (in bytes).[m
[32m+[m[32mstatic constexpr size_t ADDR_TORV2_SIZE = 10;[m
[32m+[m
[32m+[m[32m/// Size of "internal" (NET_INTERNAL) address (in bytes).[m
[32m+[m[32mstatic constexpr size_t ADDR_INTERNAL_SIZE = 10;[m
[32m+[m
 /**[m
  * Network address.[m
  */[m
 class CNetAddr[m
 {[m
     protected:[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Raw representation of the network address.[m
[32m+[m[32m         * In network byte order (big endian) for IPv4 and IPv6.[m
[32m+[m[32m         */[m
[32m+[m[32m        prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};[m
[32m+[m
         /**[m
          * Network to which this address belongs.[m
          */[m
         Network m_net{NET_IPV6};[m
 [m
[31m-        unsigned char ip[16]; // in network byte order[m
         uint32_t scopeId{0}; // for scoped/link-local ipv6 addresses[m
 [m
     public:[m
[36m@@ -74,13 +117,7 @@[m [mclass CNetAddr[m
          * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy[m
          * `addr` encoding.[m
          */[m
[31m-        void SetLegacyIPv6(const uint8_t ipv6[16]);[m
[31m-[m
[31m-        /**[m
[31m-         * Set raw IPv4 or IPv6 address (in network byte order)[m
[31m-         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.[m
[31m-         */[m
[31m-        void SetRaw(Network network, const uint8_t *data);[m
[32m+[m[32m        void SetLegacyIPv6(Span<const uint8_t> ipv6);[m
 [m
         bool SetInternal(const std::string& name);[m
 [m
[36m@@ -111,7 +148,6 @@[m [mclass CNetAddr[m
         enum Network GetNetwork() const;[m
         std::string ToString() const;[m
         std::string ToStringIP() const;[m
[31m-        unsigned int GetByte(int n) const;[m
         uint64_t GetHash() const;[m
         bool GetInAddr(struct in_addr* pipv4Addr) const;[m
         uint32_t GetNetClass() const;[m
[36m@@ -127,7 +163,7 @@[m [mclass CNetAddr[m
         uint32_t GetMappedAS(const std::vector<bool> &asmap) const;[m
 [m
         std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;[m
[31m-        std::vector<unsigned char> GetAddrBytes() const { return {std::begin(ip), std::end(ip)}; }[m
[32m+[m[32m        std::vector<unsigned char> GetAddrBytes() const;[m
         int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;[m
 [m
         explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);[m
[36m@@ -143,7 +179,7 @@[m [mclass CNetAddr[m
         template <typename Stream>[m
         void Serialize(Stream& s) const[m
         {[m
[31m-            s << ip;[m
[32m+[m[32m            SerializeV1Stream(s);[m
         }[m
 [m
         /**[m
[36m@@ -152,14 +188,108 @@[m [mclass CNetAddr[m
         template <typename Stream>[m
         void Unserialize(Stream& s)[m
         {[m
[31m-            unsigned char ip_temp[sizeof(ip)];[m
[31m-            s >> ip_temp;[m
[32m+[m[32m            UnserializeV1Stream(s);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        friend class CSubNet;[m
[32m+[m[32m        friend class CNetAddrHash;[m
[32m+[m
[32m+[m[32m    private:[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).[m
[32m+[m[32m         */[m
[32m+[m[32m        static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;[m
[32m+[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Serialize in pre-ADDRv2/BIP155 format to an array.[m
[32m+[m[32m         * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.[m
[32m+[m[32m         */[m
[32m+[m[32m        void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const[m
[32m+[m[32m        {[m
[32m+[m[32m            size_t prefix_size;[m
[32m+[m
[32m+[m[32m            switch (m_net) {[m
[32m+[m[32m            case NET_IPV6:[m
[32m+[m[32m                assert(m_addr.size() == sizeof(arr));[m
[32m+[m[32m                memcpy(arr, m_addr.data(), m_addr.size());[m
[32m+[m[32m                return;[m
[32m+[m[32m            case NET_IPV4:[m
[32m+[m[32m                prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);[m
[32m+[m[32m                assert(prefix_size + m_addr.size() == sizeof(arr));[m
[32m+[m[32m                memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);[m
[32m+[m[32m                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());[m
[32m+[m[32m                return;[m
[32m+[m[32m            case NET_ONION:[m
[32m+[m[32m                prefix_size = sizeof(TORV2_IN_IPV6_PREFIX);[m
[32m+[m[32m                assert(prefix_size + m_addr.size() == sizeof(arr));[m
[32m+[m[32m                memcpy(arr, TORV2_IN_IPV6_PREFIX.data(), prefix_size);[m
[32m+[m[32m                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());[m
[32m+[m[32m                return;[m
[32m+[m[32m            case NET_INTERNAL:[m
[32m+[m[32m                prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);[m
[32m+[m[32m                assert(prefix_size + m_addr.size() == sizeof(arr));[m
[32m+[m[32m                memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);[m
[32m+[m[32m                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());[m
[32m+[m[32m                return;[m
[32m+[m[32m            case NET_UNROUTABLE:[m
[32m+[m[32m            case NET_MAX:[m
[32m+[m[32m                assert(false);[m
[32m+[m[32m            } // no default case, so the compiler can warn about missing cases[m
[32m+[m
[32m+[m[32m            assert(false);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Serialize in pre-ADDRv2/BIP155 format to a stream.[m
[32m+[m[32m         * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.[m
[32m+[m[32m         */[m
[32m+[m[32m        template <typename Stream>[m
[32m+[m[32m        void SerializeV1Stream(Stream& s) const[m
[32m+[m[32m        {[m
[32m+[m[32m            uint8_t serialized[V1_SERIALIZATION_SIZE];[m
[32m+[m
[32m+[m[32m            SerializeV1Array(serialized);[m
[32m+[m
[32m+[m[32m            s << serialized;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Unserialize from a pre-ADDRv2/BIP155 format from an array.[m
[32m+[m[32m         */[m
[32m+[m[32m        void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])[m
[32m+[m[32m        {[m
             // Use SetLegacyIPv6() so that m_net is set correctly. For example[m
             // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).[m
[31m-            SetLegacyIPv6(ip_temp);[m
[32m+[m[32m            SetLegacyIPv6(arr);[m
         }[m
 [m
[31m-        friend class CSubNet;[m
[32m+[m[32m        /**[m
[32m+[m[32m         * Unserialize from a pre-ADDRv2/BIP155 format from a stream.[m
[32m+[m[32m         */[m
[32m+[m[32m        template <typename Stream>[m
[32m+[m[32m        void UnserializeV1Stream(Stream& s)[m
[32m+[m[32m        {[m
[32m+[m[32m            uint8_t serialized[V1_SERIALIZATION_SIZE];[m
[32m+[m
[32m+[m[32m            s >> serialized;[m
[32m+[m
[32m+[m[32m            UnserializeV1Array(serialized);[m
[32m+[m[32m        }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mclass CNetAddrHash[m
[32m+[m[32m{[m
[32m+[m[32mpublic:[m
[32m+[m[32m    size_t operator()(const CNetAddr& a) const noexcept[m
[32m+[m[32m    {[m
[32m+[m[32m        CSipHasher hasher(m_salt_k0, m_salt_k1);[m
[32m+[m[32m        hasher.Write(a.m_addr.data(), a.m_addr.size());[m
[32m+[m[32m        return (size_t)hasher.Finalize();[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32mprivate:[m
[32m+[m[32m    const uint64_t m_salt_k0 = GetRand(std::numeric_limits<uint64_t>::max());[m
[32m+[m[32m    const uint64_t m_salt_k1 = GetRand(std::numeric_limits<uint64_t>::max());[m
 };[m
 [m
 class CSubNet[m
[36m@@ -174,11 +304,11 @@[m [mclass CSubNet[m
 [m
     public:[m
         CSubNet();[m
[31m-        CSubNet(const CNetAddr &addr, int32_t mask);[m
[31m-        CSubNet(const CNetAddr &addr, const CNetAddr &mask);[m
[32m+[m[32m        CSubNet(const CNetAddr& addr, uint8_t mask);[m
[32m+[m[32m        CSubNet(const CNetAddr& addr, const CNetAddr& mask);[m
 [m
         //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)[m
[31m-        explicit CSubNet(const CNetAddr &addr);[m
[32m+[m[32m        explicit CSubNet(const CNetAddr& addr);[m
 [m
         bool Match(const CNetAddr &addr) const;[m
 [m
[33mdiff --git a/src/netbase.cpp b/src/netbase.cpp[m
[33mindex 3a3b5f3e66..0273839017 100644[m
[33m--- a/src/netbase.cpp[m
[33m+++ b/src/netbase.cpp[m
[36m@@ -13,6 +13,7 @@[m
 [m
 #include <atomic>[m
 #include <cstdint>[m
[32m+[m[32m#include <limits>[m
 [m
 #ifndef WIN32[m
 #include <fcntl.h>[m
[36m@@ -838,8 +839,8 @@[m [mbool LookupSubNet(const std::string& strSubnet, CSubNet& ret)[m
         if (slash != strSubnet.npos)[m
         {[m
             std::string strNetmask = strSubnet.substr(slash + 1);[m
[31m-            int32_t n;[m
[31m-            if (ParseInt32(strNetmask, &n)) {[m
[32m+[m[32m            uint8_t n;[m
[32m+[m[32m            if (ParseUInt8(strNetmask, &n)) {[m
                 // If valid number, assume CIDR variable-length subnet masking[m
                 ret = CSubNet(network, n);[m
                 return ret.IsValid();[m
[33mdiff --git a/src/node/context.h b/src/node/context.h[m
[33mindex be568cba36..793c9dfc34 100644[m
[33m--- a/src/node/context.h[m
[33m+++ b/src/node/context.h[m
[36m@@ -20,6 +20,7 @@[m [mclass PeerLogicValidation;[m
 namespace interfaces {[m
 class Chain;[m
 class ChainClient;[m
[32m+[m[32mclass WalletClient;[m
 } // namespace interfaces[m
 [m
 //! NodeContext struct containing references to chain state and connection[m
[36m@@ -40,7 +41,11 @@[m [mstruct NodeContext {[m
     std::unique_ptr<BanMan> banman;[m
     ArgsManager* args{nullptr}; // Currently a raw pointer because the memory is not managed by this struct[m
     std::unique_ptr<interfaces::Chain> chain;[m
[32m+[m[32m    //! List of all chain clients (wallet processes or other client) connected to node.[m
     std::vector<std::unique_ptr<interfaces::ChainClient>> chain_clients;[m
[32m+[m[32m    //! Reference to chain client that should used to load or create wallets[m
[32m+[m[32m    //! opened by the gui.[m
[32m+[m[32m    interfaces::WalletClient* wallet_client{nullptr};[m
     std::unique_ptr<CScheduler> scheduler;[m
     std::function<void()> rpc_interruption_point = [] {};[m
 [m
[33mdiff --git a/src/pubkey.cpp b/src/pubkey.cpp[m
[33mindex ef42aa5bc7..fc14f41a0c 100644[m
[33m--- a/src/pubkey.cpp[m
[33m+++ b/src/pubkey.cpp[m
[36m@@ -24,7 +24,7 @@[m [msecp256k1_context* secp256k1_context_verify = nullptr;[m
  *  strict DER before being passed to this module, and we know it supports all[m
  *  violations present in the blockchain before that point.[m
  */[m
[31m-static int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {[m
[32m+[m[32mint ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char *input, size_t inputlen) {[m
     size_t rpos, rlen, spos, slen;[m
     size_t pos = 0;[m
     size_t lenbyte;[m
[33mdiff --git a/src/qt/bitcoin.cpp b/src/qt/bitcoin.cpp[m
[33mindex f53fcc41f3..eaaaaeb904 100644[m
[33m--- a/src/qt/bitcoin.cpp[m
[33m+++ b/src/qt/bitcoin.cpp[m
[36m@@ -27,9 +27,11 @@[m
 #include <qt/walletmodel.h>[m
 #endif // ENABLE_WALLET[m
 [m
[32m+[m[32m#include <init.h>[m
 #include <interfaces/handler.h>[m
 #include <interfaces/node.h>[m
 #include <node/context.h>[m
[32m+[m[32m#include <node/ui_interface.h>[m
 #include <noui.h>[m
 #include <uint256.h>[m
 #include <util/system.h>[m
[36m@@ -37,6 +39,7 @@[m
 #include <util/translation.h>[m
 #include <validation.h>[m
 [m
[32m+[m[32m#include <boost/signals2/connection.hpp>[m
 #include <memory>[m
 [m
 #include <QApplication>[m
[36m@@ -193,10 +196,9 @@[m [mvoid BitcoinCore::shutdown()[m
 static int qt_argc = 1;[m
 static const char* qt_argv = "bitcoin-qt";[m
 [m
[31m-BitcoinApplication::BitcoinApplication(interfaces::Node& node):[m
[32m+[m[32mBitcoinApplication::BitcoinApplication():[m
     QApplication(qt_argc, const_cast<char **>(&qt_argv)),[m
     coreThread(nullptr),[m
[31m-    m_node(node),[m
     optionsModel(nullptr),[m
     clientModel(nullptr),[m
     window(nullptr),[m
[36m@@ -204,6 +206,7 @@[m [mBitcoinApplication::BitcoinApplication(interfaces::Node& node):[m
     returnValue(0),[m
     platformStyle(nullptr)[m
 {[m
[32m+[m[32m    // Qt runs setlocale(LC_ALL, "") on initialization.[m
     RegisterMetaTypes();[m
     setQuitOnLastWindowClosed(false);[m
 }[m
[36m@@ -246,12 +249,12 @@[m [mvoid BitcoinApplication::createPaymentServer()[m
 [m
 void BitcoinApplication::createOptionsModel(bool resetSettings)[m
 {[m
[31m-    optionsModel = new OptionsModel(m_node, this, resetSettings);[m
[32m+[m[32m    optionsModel = new OptionsModel(this, resetSettings);[m
 }[m
 [m
 void BitcoinApplication::createWindow(const NetworkStyle *networkStyle)[m
 {[m
[31m-    window = new BitcoinGUI(m_node, platformStyle, networkStyle, nullptr);[m
[32m+[m[32m    window = new BitcoinGUI(node(), platformStyle, networkStyle, nullptr);[m
 [m
     pollShutdownTimer = new QTimer(window);[m
     connect(pollShutdownTimer, &QTimer::timeout, window, &BitcoinGUI::detectShutdown);[m
[36m@@ -259,17 +262,27 @@[m [mvoid BitcoinApplication::createWindow(const NetworkStyle *networkStyle)[m
 [m
 void BitcoinApplication::createSplashScreen(const NetworkStyle *networkStyle)[m
 {[m
[31m-    SplashScreen *splash = new SplashScreen(m_node, nullptr, networkStyle);[m
[32m+[m[32m    assert(!m_splash);[m
[32m+[m[32m    m_splash = new SplashScreen(nullptr, networkStyle);[m
     // We don't hold a direct pointer to the splash screen after creation, but the splash[m
     // screen will take care of deleting itself when finish() happens.[m
[31m-    splash->show();[m
[31m-    connect(this, &BitcoinApplication::splashFinished, splash, &SplashScreen::finish);[m
[31m-    connect(this, &BitcoinApplication::requestedShutdown, splash, &QWidget::close);[m
[32m+[m[32m    m_splash->show();[m
[32m+[m[32m    connect(this, &BitcoinApplication::requestedInitialize, m_splash, &SplashScreen::handleLoadWallet);[m
[32m+[m[32m    connect(this, &BitcoinApplication::splashFinished, m_splash, &SplashScreen::finish);[m
[32m+[m[32m    connect(this, &BitcoinApplication::requestedShutdown, m_splash, &QWidget::close);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid BitcoinApplication::setNode(interfaces::Node& node)[m
[32m+[m[32m{[m
[32m+[m[32m    assert(!m_node);[m
[32m+[m[32m    m_node = &node;[m
[32m+[m[32m    if (optionsModel) optionsModel->setNode(*m_node);[m
[32m+[m[32m    if (m_splash) m_splash->setNode(*m_node);[m
 }[m
 [m
 bool BitcoinApplication::baseInitialize()[m
 {[m
[31m-    return m_node.baseInitialize();[m
[32m+[m[32m    return node().baseInitialize();[m
 }[m
 [m
 void BitcoinApplication::startThread()[m
[36m@@ -277,7 +290,7 @@[m [mvoid BitcoinApplication::startThread()[m
     if(coreThread)[m
         return;[m
     coreThread = new QThread(this);[m
[31m-    BitcoinCore *executor = new BitcoinCore(m_node);[m
[32m+[m[32m    BitcoinCore *executor = new BitcoinCore(node());[m
     executor->moveToThread(coreThread);[m
 [m
     /*  communication to and from thread */[m
[36m@@ -298,8 +311,8 @@[m [mvoid BitcoinApplication::parameterSetup()[m
     // print to the console unnecessarily.[m
     gArgs.SoftSetBoolArg("-printtoconsole", false);[m
 [m
[31m-    m_node.initLogging();[m
[31m-    m_node.initParameterInteraction();[m
[32m+[m[32m    InitLogging(gArgs);[m
[32m+[m[32m    InitParameterInteraction(gArgs);[m
 }[m
 [m
 void BitcoinApplication::InitializePruneSetting(bool prune)[m
[36m@@ -331,7 +344,7 @@[m [mvoid BitcoinApplication::requestShutdown()[m
     window->unsubscribeFromCoreSignals();[m
     // Request node shutdown, which can interrupt long operations, like[m
     // rescanning a wallet.[m
[31m-    m_node.startShutdown();[m
[32m+[m[32m    node().startShutdown();[m
     // Unsetting the client model can cause the current thread to wait for node[m
     // to complete an operation, like wait for a RPC execution to complete.[m
     window->setClientModel(nullptr);[m
[36m@@ -353,7 +366,7 @@[m [mvoid BitcoinApplication::initializeResult(bool success, interfaces::BlockAndHead[m
     {[m
         // Log this only after AppInitMain finishes, as then logging setup is guaranteed complete[m
         qInfo() << "Platform customization:" << platformStyle->getName();[m
[31m-        clientModel = new ClientModel(m_node, optionsModel);[m
[32m+[m[32m        clientModel = new ClientModel(node(), optionsModel);[m
         window->setClientModel(clientModel, &tip_info);[m
 #ifdef ENABLE_WALLET[m
         if (WalletModel::isWalletEnabled()) {[m
[36m@@ -437,9 +450,9 @@[m [mint GuiMain(int argc, char* argv[])[m
     std::unique_ptr<interfaces::Node> node = interfaces::MakeNode(&node_context);[m
 [m
     // Subscribe to global signals from core[m
[31m-    std::unique_ptr<interfaces::Handler> handler_message_box = node->handleMessageBox(noui_ThreadSafeMessageBox);[m
[31m-    std::unique_ptr<interfaces::Handler> handler_question = node->handleQuestion(noui_ThreadSafeQuestion);[m
[31m-    std::unique_ptr<interfaces::Handler> handler_init_message = node->handleInitMessage(noui_InitMessage);[m
[32m+[m[32m    boost::signals2::scoped_connection handler_message_box = ::uiInterface.ThreadSafeMessageBox_connect(noui_ThreadSafeMessageBox);[m
[32m+[m[32m    boost::signals2::scoped_connection handler_question = ::uiInterface.ThreadSafeQuestion_connect(noui_ThreadSafeQuestion);[m
[32m+[m[32m    boost::signals2::scoped_connection handler_init_message = ::uiInterface.InitMessage_connect(noui_InitMessage);[m
 [m
     // Do not refer to data directory yet, this can be overridden by Intro::pickDataDirectory[m
 [m
[36m@@ -453,15 +466,15 @@[m [mint GuiMain(int argc, char* argv[])[m
     QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);[m
 #endif[m
 [m
[31m-    BitcoinApplication app(*node);[m
[32m+[m[32m    BitcoinApplication app;[m
 [m
     /// 2. Parse command-line options. We do this after qt in order to show an error if there are problems parsing these[m
     // Command-line options take precedence:[m
[31m-    node->setupServerArgs();[m
[32m+[m[32m    SetupServerArgs(node_context);[m
     SetupUIArgs(gArgs);[m
     std::string error;[m
[31m-    if (!node->parseParameters(argc, argv, error)) {[m
[31m-        node->initError(strprintf(Untranslated("Error parsing command line arguments: %s\n"), error));[m
[2m+[m[2m    if (!gArgs.ParseParameters(argc, argv, error)) {[m
[32m+[m[32m        InitError(strprintf(Untranslated("Error parsing command line arguments: %s\n"), error));[m
         // Create a message box, because the gui has neither been created nor has subscribed to core signals[m
         QMessageBox::critical(nullptr, PACKAGE_NAME,[m
             // message can not be translated because translations have not been initialized[m
[36m@@ -487,7 +500,7 @@[m [mint GuiMain(int argc, char* argv[])[m
     // Show help message immediately after parsing command-line options (for "-lang") and setting locale,[m
     // but before showing splash screen.[m
     if (HelpRequested(gArgs) || gArgs.IsArgSet("-version")) {[m
[31m-        HelpMessageDialog help(*node, nullptr, gArgs.IsArgSet("-version"));[m
[32m+[m[32m        HelpMessageDialog help(nullptr, gArgs.IsArgSet("-version"));[m
         help.showOrPrint();[m
         return EXIT_SUCCESS;[m
     }[m
[36m@@ -497,18 +510,18 @@[m [mint GuiMain(int argc, char* argv[])[m
     bool did_show_intro = false;[m
     bool prune = false; // Intro dialog prune check box[m
     // Gracefully exit if the user cancels[m
[31m-    if (!Intro::showIfNeeded(*node, did_show_intro, prune)) return EXIT_SUCCESS;[m
[32m+[m[32m    if (!Intro::showIfNeeded(did_show_intro, prune)) return EXIT_SUCCESS;[m
 [m
     /// 6. Determine availability of data directory and parse bitcoin.conf[m
     /// - Do not call GetDataDir(true) before this step finishes[m
     if (!CheckDataDirOption()) {[m
[31m-        node->initError(strprintf(Untranslated("Specified data directory \"%s\" does not exist.\n"), gArgs.GetArg("-datadir", "")));[m
[32m+[m[32m        InitError(strprintf(Untranslated("Specified data directory \"%s\" does not exist.\n"), gArgs.GetArg("-datadir", "")));[m
         QMessageBox::critical(nullptr, PACKAGE_NAME,[m
             QObject::tr("Error: Specified data directory \"%1\" does not exist.").arg(QString::fromStdString(gArgs.GetArg("-datadir", ""))));[m
         return EXIT_FAILURE;[m
     }[m
[31m-    if (!node->readConfigFiles(error)) {[m
[31m-        node->initError(strprintf(Untranslated("Error reading configuration file: %s\n"), error));[m
[32m+[m[32m    if (!gArgs.ReadConfigFiles(error, true)) {[m
[32m+[m[32m        InitError(strprintf(Untranslated("Error reading configuration file: %s\n"), error));[m
         QMessageBox::critical(nullptr, PACKAGE_NAME,[m
             QObject::tr("Error: Cannot parse configuration file: %1.").arg(QString::fromStdString(error)));[m
         return EXIT_FAILURE;[m
[36m@@ -522,18 +535,18 @@[m [mint GuiMain(int argc, char* argv[])[m
 [m
     // Check for -chain, -testnet or -regtest parameter (Params() calls are only valid after this clause)[m
     try {[m
[31m-        node->selectParams(gArgs.GetChainName());[m
[32m+[m[32m        SelectParams(gArgs.GetChainName());[m
     } catch(std::exception &e) {[m
[31m-        node->initError(Untranslated(strprintf("%s\n", e.what())));[m
[32m+[m[32m        InitError(Untranslated(strprintf("%s\n", e.what())));[m
         QMessageBox::critical(nullptr, PACKAGE_NAME, QObject::tr("Error: %1").arg(e.what()));[m
         return EXIT_FAILURE;[m
     }[m
 #ifdef ENABLE_WALLET[m
     // Parse URIs on command line -- this can affect Params()[m
[31m-    PaymentServer::ipcParseCommandLine(*node, argc, argv);[m
[32m+[m[32m    PaymentServer::ipcParseCommandLine(argc, argv);[m
 #endif[m
[31m-    if (!node->initSettings(error)) {[m
[31m-        node->initError(Untranslated(error));[m
[32m+[m[32m    if (!gArgs.InitSettings(error)) {[m
[32m+[m[32m        InitError(Untranslated(error));[m
         QMessageBox::critical(nullptr, PACKAGE_NAME, QObject::tr("Error initializing settings: %1").arg(QString::fromStdString(error)));[m
         return EXIT_FAILURE;[m
     }[m
[36m@@ -587,6 +600,8 @@[m [mint GuiMain(int argc, char* argv[])[m
     if (gArgs.GetBoolArg("-splash", DEFAULT_SPLASHSCREEN) && !gArgs.GetBoolArg("-min", false))[m
         app.createSplashScreen(networkStyle.data());[m
 [m
[32m+[m[32m    app.setNode(*node);[m
[32m+[m
     int rv = EXIT_SUCCESS;[m
     try[m
     {[m
[36m@@ -609,10 +624,10 @@[m [mint GuiMain(int argc, char* argv[])[m
         }[m
     } catch (const std::exception& e) {[m
         PrintExceptionContinue(&e, "Runaway exception");[m
[31m-        app.handleRunawayException(QString::fromStdString(node->getWarnings().translated));[m
[32m+[m[32m        app.handleRunawayException(QString::fromStdString(app.node().getWarnings().translated));[m
     } catch (...) {[m
         PrintExceptionContinue(nullptr, "Runaway exception");[m
[31m-        app.handleRunawayException(QString::fromStdString(node->getWarnings().translated));[m
[32m+[m[32m        app.handleRunawayException(QString::fromStdString(app.node().getWarnings().translated));[m
     }[m
     return rv;[m
 }[m
[33mdiff --git a/src/qt/bitcoin.h b/src/qt/bitcoin.h[m
[33mindex 20c6dfc047..69e0a5921e 100644[m
[33m--- a/src/qt/bitcoin.h[m
[33m+++ b/src/qt/bitcoin.h[m
[36m@@ -10,6 +10,7 @@[m
 #endif[m
 [m
 #include <QApplication>[m
[32m+[m[32m#include <assert.h>[m
 #include <memory>[m
 [m
 #include <interfaces/node.h>[m
[36m@@ -20,6 +21,7 @@[m [mclass NetworkStyle;[m
 class OptionsModel;[m
 class PaymentServer;[m
 class PlatformStyle;[m
[32m+[m[32mclass SplashScreen;[m
 class WalletController;[m
 class WalletModel;[m
 [m
[36m@@ -54,7 +56,7 @@[m [mclass BitcoinApplication: public QApplication[m
 {[m
     Q_OBJECT[m
 public:[m
[31m-    explicit BitcoinApplication(interfaces::Node& node);[m
[32m+[m[32m    explicit BitcoinApplication();[m
     ~BitcoinApplication();[m
 [m
 #ifdef ENABLE_WALLET[m
[36m@@ -88,6 +90,9 @@[m [mpublic:[m
     /// Setup platform style[m
     void setupPlatformStyle();[m
 [m
[32m+[m[32m    interfaces::Node& node() const { assert(m_node); return *m_node; }[m
[32m+[m[32m    void setNode(interfaces::Node& node);[m
[32m+[m
 public Q_SLOTS:[m
     void initializeResult(bool success, interfaces::BlockAndHeaderTipInfo tip_info);[m
     void shutdownResult();[m
[36m@@ -102,7 +107,6 @@[m [mQ_SIGNALS:[m
 [m
 private:[m
     QThread *coreThread;[m
[31m-    interfaces::Node& m_node;[m
     OptionsModel *optionsModel;[m
     ClientModel *clientModel;[m
     BitcoinGUI *window;[m
[36m@@ -114,6 +118,8 @@[m [mprivate:[m
     int returnValue;[m
     const PlatformStyle *platformStyle;[m
     std::unique_ptr<QWidget> shutdownWindow;[m
[32m+[m[32m    SplashScreen* m_splash = nullptr;[m
[32m+[m[32m    interfaces::Node* m_node = nullptr;[m
 [m
     void startThread();[m
 };[m
[33mdiff --git a/src/qt/bitcoingui.cpp b/src/qt/bitcoingui.cpp[m
[33mindex 56adbf249a..aa58c0b10e 100644[m
[33m--- a/src/qt/bitcoingui.cpp[m
[33m+++ b/src/qt/bitcoingui.cpp[m
[36m@@ -95,7 +95,7 @@[m [mBitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty[m
     updateWindowTitle();[m
 [m
     rpcConsole = new RPCConsole(node, _platformStyle, nullptr);[m
[31m-    helpMessageDialog = new HelpMessageDialog(node, this, false);[m
[32m+[m[32m    helpMessageDialog = new HelpMessageDialog(this, false);[m
 #ifdef ENABLE_WALLET[m
     if(enableWallet)[m
     {[m
[36m@@ -821,7 +821,7 @@[m [mvoid BitcoinGUI::aboutClicked()[m
     if(!clientModel)[m
         return;[m
 [m
[31m-    HelpMessageDialog dlg(m_node, this, true);[m
[32m+[m[32m    HelpMessageDialog dlg(this, true);[m
     dlg.exec();[m
 }[m
 [m
[36m@@ -1189,7 +1189,7 @@[m [mvoid BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmoun[m
     // On new transaction, make an info balloon[m
     QString msg = tr("Date: %1\n").arg(date) +[m
                   tr("Amount: %1\n").arg(BitcoinUnits::formatWithUnit(unit, amount, true));[m
[31m-    if (m_node.getWallets().size() > 1 && !walletName.isEmpty()) {[m
[32m+[m[32m    if (m_node.walletClient().getWallets().size() > 1 && !walletName.isEmpty()) {[m
         msg += tr("Wallet: %1\n").arg(walletName);[m
     }[m
     msg += tr("Type: %1\n").arg(type);[m
[33mdiff --git a/src/qt/forms/debugwindow.ui b/src/qt/forms/debugwindow.ui[m
[33mindex 93840b4169..d210faec03 100644[m
[33m--- a/src/qt/forms/debugwindow.ui[m
[33m+++ b/src/qt/forms/debugwindow.ui[m
[36m@@ -290,7 +290,7 @@[m
        <item row="11" column="0">[m
         <widget class="QLabel" name="label_3">[m
          <property name="text">[m
[31m-          <string>Current number of blocks</string>[m
[32m+[m[32m          <string>Current block height</string>[m
          </property>[m
         </widget>[m
        </item>[m
[33mdiff --git a/src/qt/forms/receivecoinsdialog.ui b/src/qt/forms/receivecoinsdialog.ui[m
[33mindex 7dbee6d689..06d39426c9 100644[m
[33m--- a/src/qt/forms/receivecoinsdialog.ui[m
[33m+++ b/src/qt/forms/receivecoinsdialog.ui[m
[36m@@ -114,6 +114,12 @@[m
              <iconset resource="../bitcoin.qrc">[m
               <normaloff>:/icons/receiving_addresses</normaloff>:/icons/receiving_addresses</iconset>[m
             </property>[m
[32m+[m[32m            <property name="autoDefault">[m
[32m+[m[32m             <bool>false</bool>[m
[32m+[m[32m            </property>[m
[32m+[m[32m            <property name="default">[m
[32m+[m[32m             <bool>true</bool>[m
[32m+[m[32m            </property>[m
            </widget>[m
           </item>[m
           <item>[m
[33mdiff --git a/src/qt/guiutil.cpp b/src/qt/guiutil.cpp[m
[33mindex 6e34aca0eb..bab17562a6 100644[m
[33m--- a/src/qt/guiutil.cpp[m
[33m+++ b/src/qt/guiutil.cpp[m
[36m@@ -21,11 +21,6 @@[m
 #include <util/system.h>[m
 [m
 #ifdef WIN32[m
[31m-#ifdef _WIN32_IE[m
[31m-#undef _WIN32_IE[m
[31m-#endif[m
[31m-#define _WIN32_IE 0x0501[m
[31m-#define WIN32_LEAN_AND_MEAN 1[m
 #ifndef NOMINMAX[m
 #define NOMINMAX[m
 #endif[m
[33mdiff --git a/src/qt/intro.cpp b/src/qt/intro.cpp[m
[33mindex ad21dfc3ef..235722d091 100644[m
[33m--- a/src/qt/intro.cpp[m
[33m+++ b/src/qt/intro.cpp[m
[36m@@ -6,6 +6,7 @@[m
 #include <config/bitcoin-config.h>[m
 #endif[m
 [m
[32m+[m[32m#include <chainparams.h>[m
 #include <fs.h>[m
 #include <qt/intro.h>[m
 #include <qt/forms/ui_intro.h>[m
[36m@@ -181,7 +182,7 @@[m [mvoid Intro::setDataDirectory(const QString &dataDir)[m
     }[m
 }[m
 [m
[31m-bool Intro::showIfNeeded(interfaces::Node& node, bool& did_show_intro, bool& prune)[m
[32m+[m[32mbool Intro::showIfNeeded(bool& did_show_intro, bool& prune)[m
 {[m
     did_show_intro = false;[m
 [m
[36m@@ -199,13 +200,13 @@[m [mbool Intro::showIfNeeded(interfaces::Node& node, bool& did_show_intro, bool& pru[m
     {[m
         /* Use selectParams here to guarantee Params() can be used by node interface */[m
         try {[m
[31m-            node.selectParams(gArgs.GetChainName());[m
[2m+[m[2m            SelectParams(gArgs.GetChainName());[m
         } catch (const std::exception&) {[m
             return false;[m
         }[m
 [m
         /* If current default data directory does not exist, let the user choose one */[m
[31m-        Intro intro(0, node.getAssumedBlockchainSize(), node.getAssumedChainStateSize());[m
[32m+[m[32m        Intro intro(0, Params().AssumedBlockchainSize(), Params().AssumedChainStateSize());[m
         intro.setDataDirectory(dataDir);[m
         intro.setWindowIcon(QIcon(":icons/bitcoin"));[m
         did_show_intro = true;[m
[36m@@ -242,7 +243,7 @@[m [mbool Intro::showIfNeeded(interfaces::Node& node, bool& did_show_intro, bool& pru[m
      * (to be consistent with bitcoind behavior)[m
      */[m
     if(dataDir != GUIUtil::getDefaultDataDirectory()) {[m
[31m-        node.softSetArg("-datadir", GUIUtil::qstringToBoostPath(dataDir).string()); // use OS locale for path setting[m
[32m+[m[32m        gArgs.SoftSetArg("-datadir", GUIUtil::qstringToBoostPath(dataDir).string()); // use OS locale for path setting[m
     }[m
     return true;[m
 }[m
[33mdiff --git a/src/qt/intro.h b/src/qt/intro.h[m
[33mindex 732393246e..51f42de7ac 100644[m
[33m--- a/src/qt/intro.h[m
[33m+++ b/src/qt/intro.h[m
[36m@@ -47,7 +47,7 @@[m [mpublic:[m
      * @note do NOT call global GetDataDir() before calling this function, this[m
      * will cause the wrong path to be cached.[m
      */[m
[31m-    static bool showIfNeeded(interfaces::Node& node, bool& did_show_intro, bool& prune);[m
[32m+[m[32m    static bool showIfNeeded(bool& did_show_intro, bool& prune);[m
 [m
 Q_SIGNALS:[m
     void requestCheck();[m
[33mdiff --git a/src/qt/optionsmodel.cpp b/src/qt/optionsmodel.cpp[m
[33mindex 58a7591c95..7e089b4f95 100644[m
[33m--- a/src/qt/optionsmodel.cpp[m
[33m+++ b/src/qt/optionsmodel.cpp[m
[36m@@ -27,8 +27,8 @@[m [mconst char *DEFAULT_GUI_PROXY_HOST = "127.0.0.1";[m
 [m
 static const QString GetDefaultProxyAddress();[m
 [m
[31m-OptionsModel::OptionsModel(interfaces::Node& node, QObject *parent, bool resetSettings) :[m
[31m-    QAbstractListModel(parent), m_node(node)[m
[32m+[m[32mOptionsModel::OptionsModel(QObject *parent, bool resetSettings) :[m
[32m+[m[32m    QAbstractListModel(parent)[m
 {[m
     Init(resetSettings);[m
 }[m
[36m@@ -97,12 +97,12 @@[m [mvoid OptionsModel::Init(bool resetSettings)[m
 [m
     if (!settings.contains("nDatabaseCache"))[m
         settings.setValue("nDatabaseCache", (qint64)nDefaultDbCache);[m
[31m-    if (!m_node.softSetArg("-dbcache", settings.value("nDatabaseCache").toString().toStdString()))[m
[32m+[m[32m    if (!gArgs.SoftSetArg("-dbcache", settings.value("nDatabaseCache").toString().toStdString()))[m
         addOverriddenOption("-dbcache");[m
 [m
     if (!settings.contains("nThreadsScriptVerif"))[m
         settings.setValue("nThreadsScriptVerif", DEFAULT_SCRIPTCHECK_THREADS);[m
[31m-    if (!m_node.softSetArg("-par", settings.value("nThreadsScriptVerif").toString().toStdString()))[m
[32m+[m[32m    if (!gArgs.SoftSetArg("-par", settings.value("nThreadsScriptVerif").toString().toStdString()))[m
         addOverriddenOption("-par");[m
 [m
     if (!settings.contains("strDataDir"))[m
[36m@@ -112,19 +112,19 @@[m [mvoid OptionsModel::Init(bool resetSettings)[m
 #ifdef ENABLE_WALLET[m
     if (!settings.contains("bSpendZeroConfChange"))[m
         settings.setValue("bSpendZeroConfChange", true);[m
[31m-    if (!m_node.softSetBoolArg("-spendzeroconfchange", settings.value("bSpendZeroConfChange").toBool()))[m
[32m+[m[32m    if (!gArgs.SoftSetBoolArg("-spendzeroconfchange", settings.value("bSpendZeroConfChange").toBool()))[m
         addOverriddenOption("-spendzeroconfchange");[m
 #endif[m
 [m
     // Network[m
     if (!settings.contains("fUseUPnP"))[m
         settings.setValue("fUseUPnP", DEFAULT_UPNP);[m
[31m-    if (!m_node.softSetBoolArg("-upnp", settings.value("fUseUPnP").toBool()))[m
[32m+[m[32m    if (!gArgs.SoftSetBoolArg("-upnp", settings.value("fUseUPnP").toBool()))[m
         addOverriddenOption("-upnp");[m
 [m
     if (!settings.contains("fListen"))[m
         settings.setValue("fListen", DEFAULT_LISTEN);[m
[31m-    if (!m_node.softSetBoolArg("-listen", settings.value("fListen").toBool()))[m
[32m+[m[32m    if (!gArgs.SoftSetBoolArg("-listen", settings.value("fListen").toBool()))[m
         addOverriddenOption("-listen");[m
 [m
     if (!settings.contains("fUseProxy"))[m
[36m@@ -132,7 +132,7 @@[m [mvoid OptionsModel::Init(bool resetSettings)[m
     if (!settings.contains("addrProxy"))[m
         settings.setValue("addrProxy", GetDefaultProxyAddress());[m
     // Only try to set -proxy, if user has enabled fUseProxy[m
[31m-    if (settings.value("fUseProxy").toBool() && !m_node.softSetArg("-proxy", settings.value("addrProxy").toString().toStdString()))[m
[32m+[m[32m    if ((settings.value("fUseProxy").toBool() && !gArgs.SoftSetArg("-proxy", settings.value("addrProxy").toString().toStdString())))[m
         addOverriddenOption("-proxy");[m
     else if(!settings.value("fUseProxy").toBool() && !gArgs.GetArg("-proxy", "").empty())[m
         addOverriddenOption("-proxy");[m
[36m@@ -142,7 +142,7 @@[m [mvoid OptionsModel::Init(bool resetSettings)[m
     if (!settings.contains("addrSeparateProxyTor"))[m
         settings.setValue("addrSeparateProxyTor", GetDefaultProxyAddress());[m
     // Only try to set -onion, if user has enabled fUseSeparateProxyTor[m
[31m-    if (settings.value("fUseSeparateProxyTor").toBool() && !m_node.softSetArg("-onion", settings.value("addrSeparateProxyTor").toString().toStdString()))[m
[32m+[m[32m    if ((settings.value("fUseSeparateProxyTor").toBool() && !gArgs.SoftSetArg("-onion", settings.value("addrSeparateProxyTor").toString().toStdString())))[m
         addOverriddenOption("-onion");[m
     else if(!settings.value("fUseSeparateProxyTor").toBool() && !gArgs.GetArg("-onion", "").empty())[m
         addOverriddenOption("-onion");[m
[36m@@ -150,7 +150,7 @@[m [mvoid OptionsModel::Init(bool resetSettings)[m
     // Display[m
     if (!settings.contains("language"))[m
         settings.setValue("language", "");[m
[31m-    if (!m_node.softSetArg("-lang", settings.value("language").toString().toStdString()))[m
[32m+[m[32m    if (!gArgs.SoftSetArg("-lang", settings.value("language").toString().toStdString()))[m
         addOverriddenOption("-lang");[m
 [m
     language = settings.value("language").toString();[m
[36m@@ -244,10 +244,10 @@[m [mvoid OptionsModel::SetPruneEnabled(bool prune, bool force)[m
     const int64_t prune_target_mib = PruneGBtoMiB(settings.value("nPruneSize").toInt());[m
     std::string prune_val = prune ? ToString(prune_target_mib) : "0";[m
     if (force) {[m
[31m-        m_node.forceSetArg("-prune", prune_val);[m
[32m+[m[32m        gArgs.ForceSetArg("-prune", prune_val);[m
         return;[m
     }[m
[31m-    if (!m_node.softSetArg("-prune", prune_val)) {[m
[32m+[m[32m    if (!gArgs.SoftSetArg("-prune", prune_val)) {[m
         addOverriddenOption("-prune");[m
     }[m
 }[m
[36m@@ -353,7 +353,7 @@[m [mbool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in[m
             break;[m
         case MapPortUPnP: // core option - can be changed on-the-fly[m
             settings.setValue("fUseUPnP", value.toBool());[m
[31m-            m_node.mapPort(value.toBool());[m
[32m+[m[32m            node().mapPort(value.toBool());[m
             break;[m
         case MinimizeOnClose:[m
             fMinimizeOnClose = value.toBool();[m
[33mdiff --git a/src/qt/optionsmodel.h b/src/qt/optionsmodel.h[m
[33mindex 14fdf9046e..3d9e7bbb80 100644[m
[33m--- a/src/qt/optionsmodel.h[m
[33m+++ b/src/qt/optionsmodel.h[m
[36m@@ -11,6 +11,8 @@[m
 [m
 #include <QAbstractListModel>[m
 [m
[32m+[m[32m#include <assert.h>[m
[32m+[m
 namespace interfaces {[m
 class Node;[m
 }[m
[36m@@ -39,7 +41,7 @@[m [mclass OptionsModel : public QAbstractListModel[m
     Q_OBJECT[m
 [m
 public:[m
[31m-    explicit OptionsModel(interfaces::Node& node, QObject *parent = nullptr, bool resetSettings = false);[m
[32m+[m[32m    explicit OptionsModel(QObject *parent = nullptr, bool resetSettings = false);[m
 [m
     enum OptionID {[m
         StartAtStartup,         // bool[m
[36m@@ -92,10 +94,11 @@[m [mpublic:[m
     void setRestartRequired(bool fRequired);[m
     bool isRestartRequired() const;[m
 [m
[31m-    interfaces::Node& node() const { return m_node; }[m
[32m+[m[32m    interfaces::Node& node() const { assert(m_node); return *m_node; }[m
[32m+[m[32m    void setNode(interfaces::Node& node) { assert(!m_node); m_node = &node; }[m
 [m
 private:[m
[31m-    interfaces::Node& m_node;[m
[32m+[m[32m    interfaces::Node* m_node = nullptr;[m
     /* Qt-only settings */[m
     bool fHideTrayIcon;[m
     bool fMinimizeToTray;[m
[33mdiff --git a/src/qt/paymentserver.cpp b/src/qt/paymentserver.cpp[m
[33mindex a1da85bda7..8679ced685 100644[m
[33m--- a/src/qt/paymentserver.cpp[m
[33m+++ b/src/qt/paymentserver.cpp[m
[36m@@ -74,7 +74,7 @@[m [mstatic QSet<QString> savedPaymentRequests;[m
 // Warning: ipcSendCommandLine() is called early in init,[m
 // so don't use "Q_EMIT message()", but "QMessageBox::"![m
 //[m
[31m-void PaymentServer::ipcParseCommandLine(interfaces::Node& node, int argc, char* argv[])[m
[32m+[m[32mvoid PaymentServer::ipcParseCommandLine(int argc, char* argv[])[m
 {[m
     for (int i = 1; i < argc; i++)[m
     {[m
[36m@@ -97,11 +97,11 @@[m [mvoid PaymentServer::ipcParseCommandLine(interfaces::Node& node, int argc, char*[m
                 auto tempChainParams = CreateChainParams(CBaseChainParams::MAIN);[m
 [m
                 if (IsValidDestinationString(r.address.toStdString(), *tempChainParams)) {[m
[31m-                    node.selectParams(CBaseChainParams::MAIN);[m
[32m+[m[32m                    SelectParams(CBaseChainParams::MAIN);[m
                 } else {[m
                     tempChainParams = CreateChainParams(CBaseChainParams::TESTNET);[m
                     if (IsValidDestinationString(r.address.toStdString(), *tempChainParams)) {[m
[31m-                        node.selectParams(CBaseChainParams::TESTNET);[m
[32m+[m[32m                        SelectParams(CBaseChainParams::TESTNET);[m
                     }[m
                 }[m
             }[m
[33mdiff --git a/src/qt/paymentserver.h b/src/qt/paymentserver.h[m
[33mindex 154f4a7ea6..eaf2bafe59 100644[m
[33m--- a/src/qt/paymentserver.h[m
[33m+++ b/src/qt/paymentserver.h[m
[36m@@ -61,7 +61,7 @@[m [mclass PaymentServer : public QObject[m
 public:[m
     // Parse URIs on command line[m
     // Returns false on error[m
[31m-    static void ipcParseCommandLine(interfaces::Node& node, int argc, char *argv[]);[m
[32m+[m[32m    static void ipcParseCommandLine(int argc, char *argv[]);[m
 [m
     // Returns true if there were URIs on the command line[m
     // which were successfully sent to an already-running[m
[33mdiff --git a/src/qt/receivecoinsdialog.cpp b/src/qt/receivecoinsdialog.cpp[m
[33mindex 5debded4ea..d374d610ee 100644[m
[33m--- a/src/qt/receivecoinsdialog.cpp[m
[33m+++ b/src/qt/receivecoinsdialog.cpp[m
[36m@@ -242,22 +242,6 @@[m [mvoid ReceiveCoinsDialog::resizeEvent(QResizeEvent *event)[m
     columnResizingFixer->stretchColumnWidth(RecentRequestsTableModel::Message);[m
 }[m
 [m
[31m-void ReceiveCoinsDialog::keyPressEvent(QKeyEvent *event)[m
[31m-{[m
[31m-    if (event->key() == Qt::Key_Return)[m
[31m-    {[m
[31m-        // press return -> submit form[m
[31m-        if (ui->reqLabel->hasFocus() || ui->reqAmount->hasFocus() || ui->reqMessage->hasFocus())[m
[31m-        {[m
[31m-            event->ignore();[m
[31m-            on_receiveButton_clicked();[m
[31m-            return;[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    this->QDialog::keyPressEvent(event);[m
[31m-}[m
[31m-[m
 QModelIndex ReceiveCoinsDialog::selectedRow()[m
 {[m
     if(!model || !model->getRecentRequestsTableModel() || !ui->recentRequestsView->selectionModel())[m
[33mdiff --git a/src/qt/receivecoinsdialog.h b/src/qt/receivecoinsdialog.h[m
[33mindex 2f48cd58f0..27455e2906 100644[m
[33m--- a/src/qt/receivecoinsdialog.h[m
[33m+++ b/src/qt/receivecoinsdialog.h[m
[36m@@ -49,9 +49,6 @@[m [mpublic Q_SLOTS:[m
     void reject() override;[m
     void accept() override;[m
 [m
[31m-protected:[m
[31m-    virtual void keyPressEvent(QKeyEvent *event) override;[m
[31m-[m
 private:[m
     Ui::ReceiveCoinsDialog *ui;[m
     GUIUtil::TableViewLastColumnResizingFixer *columnResizingFixer;[m
[33mdiff --git a/src/qt/splashscreen.cpp b/src/qt/splashscreen.cpp[m
[33mindex 6e6b2b8466..8e381861a0 100644[m
[33m--- a/src/qt/splashscreen.cpp[m
[33m+++ b/src/qt/splashscreen.cpp[m
[36m@@ -24,8 +24,8 @@[m
 #include <QScreen>[m
 [m
 [m
[31m-SplashScreen::SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const NetworkStyle *networkStyle) :[m
[31m-    QWidget(nullptr, f), curAlignment(0), m_node(node)[m
[32m+[m[32mSplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle) :[m
[32m+[m[32m    QWidget(nullptr, f), curAlignment(0)[m
 {[m
     // set reference point, paddings[m
     int paddingRight            = 50;[m
[36m@@ -124,7 +124,6 @@[m [mSplashScreen::SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const Netw[m
     setFixedSize(r.size());[m
     move(QGuiApplication::primaryScreen()->geometry().center() - r.center());[m
 [m
[2m-    subscribeToCoreSignals();[m
     installEventFilter(this);[m
 [m
     GUIUtil::handleCloseWindowShortcut(this);[m
[36m@@ -132,14 +131,28 @@[m [mSplashScreen::SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const Netw[m
 [m
 SplashScreen::~SplashScreen()[m
 {[m
[31m-    unsubscribeFromCoreSignals();[m
[32m+[m[32m    if (m_node) unsubscribeFromCoreSignals();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid SplashScreen::setNode(interfaces::Node& node)[m
[32m+[m[32m{[m
[32m+[m[32m    assert(!m_node);[m
[32m+[m[32m    m_node = &node;[m
[2m+[m[2m    subscribeToCoreSignals();[m
[32m+[m[32m    if (m_shutdown) m_node->startShutdown();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid SplashScreen::shutdown()[m
[32m+[m[32m{[m
[32m+[m[32m    m_shutdown = true;[m
[32m+[m[32m    if (m_node) m_node->startShutdown();[m
 }[m
 [m
 bool SplashScreen::eventFilter(QObject * obj, QEvent * ev) {[m
     if (ev->type() == QEvent::KeyPress) {[m
         QKeyEvent *keyEvent = static_cast<QKeyEvent *>(ev);[m
         if (keyEvent->key() == Qt::Key_Q) {[m
[31m-            m_node.startShutdown();[m
[32m+[m[32m            shutdown();[m
         }[m
     }[m
     return QObject::eventFilter(obj, ev);[m
[36m@@ -172,21 +185,21 @@[m [mstatic void ShowProgress(SplashScreen *splash, const std::string &title, int nPr[m
                                 : _("press q to shutdown").translated) +[m
             strprintf("\n%d", nProgress) + "%");[m
 }[m
[31m-#ifdef ENABLE_WALLET[m
[31m-void SplashScreen::ConnectWallet(std::unique_ptr<interfaces::Wallet> wallet)[m
[31m-{[m
[31m-    m_connected_wallet_handlers.emplace_back(wallet->handleShowProgress(std::bind(ShowProgress, this, std::placeholders::_1, std::placeholders::_2, false)));[m
[31m-    m_connected_wallets.emplace_back(std::move(wallet));[m
[31m-}[m
[31m-#endif[m
 [m
 void SplashScreen::subscribeToCoreSignals()[m
 {[m
     // Connect signals to client[m
[31m-    m_handler_init_message = m_node.handleInitMessage(std::bind(InitMessage, this, std::placeholders::_1));[m
[31m-    m_handler_show_progress = m_node.handleShowProgress(std::bind(ShowProgress, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));[m
[32m+[m[32m    m_handler_init_message = m_node->handleInitMessage(std::bind(InitMessage, this, std::placeholders::_1));[m
[32m+[m[32m    m_handler_show_progress = m_node->handleShowProgress(std::bind(ShowProgress, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid SplashScreen::handleLoadWallet()[m
[32m+[m[32m{[m
 #ifdef ENABLE_WALLET[m
[31m-    m_handler_load_wallet = m_node.handleLoadWallet([this](std::unique_ptr<interfaces::Wallet> wallet) { ConnectWallet(std::move(wallet)); });[m
[32m+[m[32m    m_handler_load_wallet = m_node->walletClient().handleLoadWallet([this](std::unique_ptr<interfaces::Wallet> wallet) {[m
[32m+[m[32m        m_connected_wallet_handlers.emplace_back(wallet->handleShowProgress(std::bind(ShowProgress, this, std::placeholders::_1, std::placeholders::_2, false)));[m
[32m+[m[32m        m_connected_wallets.emplace_back(std::move(wallet));[m
[32m+[m[32m    });[m
 #endif[m
 }[m
 [m
[36m@@ -221,6 +234,6 @@[m [mvoid SplashScreen::paintEvent(QPaintEvent *event)[m
 [m
 void SplashScreen::closeEvent(QCloseEvent *event)[m
 {[m
[31m-    m_node.startShutdown(); // allows an "emergency" shutdown during startup[m
[32m+[m[32m    shutdown(); // allows an "emergency" shutdown during startup[m
     event->ignore();[m
 }[m
[33mdiff --git a/src/qt/splashscreen.h b/src/qt/splashscreen.h[m
[33mindex 3158524117..a0cd677d3d 100644[m
[33m--- a/src/qt/splashscreen.h[m
[33m+++ b/src/qt/splashscreen.h[m
[36m@@ -28,8 +28,9 @@[m [mclass SplashScreen : public QWidget[m
     Q_OBJECT[m
 [m
 public:[m
[31m-    explicit SplashScreen(interfaces::Node& node, Qt::WindowFlags f, const NetworkStyle *networkStyle);[m
[32m+[m[32m    explicit SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle);[m
     ~SplashScreen();[m
[32m+[m[32m    void setNode(interfaces::Node& node);[m
 [m
 protected:[m
     void paintEvent(QPaintEvent *event) override;[m
[36m@@ -42,6 +43,9 @@[m [mpublic Q_SLOTS:[m
     /** Show message and progress */[m
     void showMessage(const QString &message, int alignment, const QColor &color);[m
 [m
[32m+[m[32m    /** Handle wallet load notifications. */[m
[32m+[m[32m    void handleLoadWallet();[m
[32m+[m
 protected:[m
     bool eventFilter(QObject * obj, QEvent * ev) override;[m
 [m
[36m@@ -50,15 +54,16 @@[m [mprivate:[m
     void subscribeToCoreSignals();[m
     /** Disconnect core signals to splash screen */[m
     void unsubscribeFromCoreSignals();[m
[31m-    /** Connect wallet signals to splash screen */[m
[31m-    void ConnectWallet(std::unique_ptr<interfaces::Wallet> wallet);[m
[32m+[m[32m    /** Initiate shutdown */[m
[32m+[m[32m    void shutdown();[m
 [m
     QPixmap pixmap;[m
     QString curMessage;[m
     QColor curColor;[m
     int curAlignment;[m
 [m
[31m-    interfaces::Node& m_node;[m
[32m+[m[32m    interfaces::Node* m_node = nullptr;[m
[32m+[m[32m    bool m_shutdown = false;[m
     std::unique_ptr<interfaces::Handler> m_handler_init_message;[m
     std::unique_ptr<interfaces::Handler> m_handler_show_progress;[m
     std::unique_ptr<interfaces::Handler> m_handler_load_wallet;[m
[33mdiff --git a/src/qt/test/addressbooktests.cpp b/src/qt/test/addressbooktests.cpp[m
[33mindex 035c8196bc..84f981dff3 100644[m
[33m--- a/src/qt/test/addressbooktests.cpp[m
[33m+++ b/src/qt/test/addressbooktests.cpp[m
[36m@@ -108,7 +108,7 @@[m [mvoid TestAddAddressesToSendBook(interfaces::Node& node)[m
 [m
     // Initialize relevant QT models.[m
     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate("other"));[m
[31m-    OptionsModel optionsModel(node);[m
[32m+[m[32m    OptionsModel optionsModel;[m
     ClientModel clientModel(node, &optionsModel);[m
     AddWallet(wallet);[m
     WalletModel walletModel(interfaces::MakeWallet(wallet), clientModel, platformStyle.get());[m
[33mdiff --git a/src/qt/test/test_main.cpp b/src/qt/test/test_main.cpp[m
[33mindex 031913bd02..86356b43c8 100644[m
[33m--- a/src/qt/test/test_main.cpp[m
[33m+++ b/src/qt/test/test_main.cpp[m
[36m@@ -68,11 +68,11 @@[m [mint main(int argc, char* argv[])[m
 [m
     // Don't remove this, it's needed to access[m
     // QApplication:: and QCoreApplication:: in the tests[m
[31m-    BitcoinApplication app(*node);[m
[32m+[m[32m    BitcoinApplication app;[m
[32m+[m[32m    app.setNode(*node);[m
     app.setApplicationName("Bitcoin-Qt-test");[m
 [m
[31m-    node->setupServerArgs();            // Make gArgs available in the NodeContext[m
[31m-    node->context()->args->ClearArgs(); // Clear added args again[m
[32m+[m[32m    app.node().context()->args = &gArgs;     // Make gArgs available in the NodeContext[m
     AppTests app_tests(app);[m
     if (QTest::qExec(&app_tests) != 0) {[m
         fInvalid = true;[m
[36m@@ -81,7 +81,7 @@[m [mint main(int argc, char* argv[])[m
     if (QTest::qExec(&test1) != 0) {[m
         fInvalid = true;[m
     }[m
[31m-    RPCNestedTests test3(*node);[m
[32m+[m[32m    RPCNestedTests test3(app.node());[m
     if (QTest::qExec(&test3) != 0) {[m
         fInvalid = true;[m
     }[m
[36m@@ -90,11 +90,11 @@[m [mint main(int argc, char* argv[])[m
         fInvalid = true;[m
     }[m
 #ifdef ENABLE_WALLET[m
[31m-    WalletTests test5(*node);[m
[32m+[m[32m    WalletTests test5(app.node());[m
     if (QTest::qExec(&test5) != 0) {[m
         fInvalid = true;[m
     }[m
[31m-    AddressBookTests test6(*node);[m
[32m+[m[32m    AddressBookTests test6(app.node());[m
     if (QTest::qExec(&test6) != 0) {[m
         fInvalid = true;[m
     }[m
[33mdiff --git a/src/qt/test/wallettests.cpp b/src/qt/test/wallettests.cpp[m
[33mindex 475fd589af..adcfe0d25c 100644[m
[33m--- a/src/qt/test/wallettests.cpp[m
[33m+++ b/src/qt/test/wallettests.cpp[m
[36m@@ -163,7 +163,7 @@[m [mvoid TestGUI(interfaces::Node& node)[m
     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate("other"));[m
     SendCoinsDialog sendCoinsDialog(platformStyle.get());[m
     TransactionView transactionView(platformStyle.get());[m
[31m-    OptionsModel optionsModel(node);[m
[32m+[m[32m    OptionsModel optionsModel;[m
     ClientModel clientModel(node, &optionsModel);[m
     AddWallet(wallet);[m
     WalletModel walletModel(interfaces::MakeWallet(wallet), clientModel, platformStyle.get());[m
[33mdiff --git a/src/qt/utilitydialog.cpp b/src/qt/utilitydialog.cpp[m
[33mindex 01922cf996..b7f85446f4 100644[m
[33m--- a/src/qt/utilitydialog.cpp[m
[33m+++ b/src/qt/utilitydialog.cpp[m
[36m@@ -28,7 +28,7 @@[m
 #include <QVBoxLayout>[m
 [m
 /** "Help message" or "About" dialog box */[m
[31m-HelpMessageDialog::HelpMessageDialog(interfaces::Node& node, QWidget *parent, bool about) :[m
[32m+[m[32mHelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :[m
     QDialog(parent),[m
     ui(new Ui::HelpMessageDialog)[m
 {[m
[33mdiff --git a/src/qt/utilitydialog.h b/src/qt/utilitydialog.h[m
[33mindex 425b468f40..d2a5d5f67f 100644[m
[33m--- a/src/qt/utilitydialog.h[m
[33m+++ b/src/qt/utilitydialog.h[m
[36m@@ -12,10 +12,6 @@[m [mQT_BEGIN_NAMESPACE[m
 class QMainWindow;[m
 QT_END_NAMESPACE[m
 [m
[31m-namespace interfaces {[m
[31m-    class Node;[m
[31m-}[m
[31m-[m
 namespace Ui {[m
     class HelpMessageDialog;[m
 }[m
[36m@@ -26,7 +22,7 @@[m [mclass HelpMessageDialog : public QDialog[m
     Q_OBJECT[m
 [m
 public:[m
[31m-    explicit HelpMessageDialog(interfaces::Node& node, QWidget *parent, bool about);[m
[32m+[m[32m    explicit HelpMessageDialog(QWidget *parent, bool about);[m
     ~HelpMessageDialog();[m
 [m
     void printToConsole();[m
[33mdiff --git a/src/qt/walletcontroller.cpp b/src/qt/walletcontroller.cpp[m
[33mindex 3aed98e0e8..828f84ffcc 100644[m
[33m--- a/src/qt/walletcontroller.cpp[m
[33m+++ b/src/qt/walletcontroller.cpp[m
[36m@@ -35,11 +35,11 @@[m [mWalletController::WalletController(ClientModel& client_model, const PlatformStyl[m
     , m_platform_style(platform_style)[m
     , m_options_model(client_model.getOptionsModel())[m
 {[m
[31m-    m_handler_load_wallet = m_node.handleLoadWallet([this](std::unique_ptr<interfaces::Wallet> wallet) {[m
[32m+[m[32m    m_handler_load_wallet = m_node.walletClient().handleLoadWallet([this](std::unique_ptr<interfaces::Wallet> wallet) {[m
         getOrCreateWallet(std::move(wallet));[m
     });[m
 [m
[31m-    for (std::unique_ptr<interfaces::Wallet>& wallet : m_node.getWallets()) {[m
[32m+[m[32m    for (std::unique_ptr<interfaces::Wallet>& wallet : m_node.walletClient().getWallets()) {[m
         getOrCreateWallet(std::move(wallet));[m
     }[m
 [m
[36m@@ -66,7 +66,7 @@[m [mstd::map<std::string, bool> WalletController::listWalletDir() const[m
 {[m
     QMutexLocker locker(&m_mutex);[m
     std::map<std::string, bool> wallets;[m
[31m-    for (const std::string& name : m_node.listWalletDir()) {[m
[32m+[m[32m    for (const std::string& name : m_node.walletClient().listWalletDir()) {[m
         wallets[name] = false;[m
     }[m
     for (WalletModel* wallet_model : m_wallets) {[m
[36m@@ -250,7 +250,7 @@[m [mvoid CreateWalletActivity::createWallet()[m
 [m
     QTimer::singleShot(500, worker(), [this, name, flags] {[m
         WalletCreationStatus status;[m
[31m-        std::unique_ptr<interfaces::Wallet> wallet = node().createWallet(m_passphrase, flags, name, m_error_message, m_warning_message, status);[m
[32m+[m[32m        std::unique_ptr<interfaces::Wallet> wallet = node().walletClient().createWallet(name, m_passphrase, flags, status, m_error_message, m_warning_message);[m
 [m
         if (status == WalletCreationStatus::SUCCESS) m_wallet_model = m_wallet_controller->getOrCreateWallet(std::move(wallet));[m
 [m
[36m@@ -321,7 +321,7 @@[m [mvoid OpenWalletActivity::open(const std::string& path)[m
     showProgressDialog(tr("Opening Wallet <b>%1</b>...").arg(name.toHtmlEscaped()));[m
 [m
     QTimer::singleShot(0, worker(), [this, path] {[m
[31m-        std::unique_ptr<interfaces::Wallet> wallet = node().loadWallet(path, m_error_message, m_warning_message);[m
[32m+[m[32m        std::unique_ptr<interfaces::Wallet> wallet = node().walletClient().loadWallet(path, m_error_message, m_warning_message);[m
 [m
         if (wallet) m_wallet_model = m_wallet_controller->getOrCreateWallet(std::move(wallet));[m
 [m
[33mdiff --git a/src/qt/walletmodel.cpp b/src/qt/walletmodel.cpp[m
[33mindex e374dd191c..0556895948 100644[m
[33m--- a/src/qt/walletmodel.cpp[m
[33m+++ b/src/qt/walletmodel.cpp[m
[36m@@ -581,7 +581,7 @@[m [mQString WalletModel::getDisplayName() const[m
 [m
 bool WalletModel::isMultiwallet()[m
 {[m
[31m-    return m_node.getWallets().size() > 1;[m
[32m+[m[32m    return m_node.walletClient().getWallets().size() > 1;[m
 }[m
 [m
 void WalletModel::refresh(bool pk_hash_only)[m
[33mdiff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp[m
[33mindex 76aa9dbfc1..b04e106b2d 100644[m
[33m--- a/src/rpc/mining.cpp[m
[33m+++ b/src/rpc/mining.cpp[m
[36m@@ -81,9 +81,9 @@[m [mstatic UniValue GetNetworkHashPS(int lookup, int height) {[m
     return workDiff.getdouble() / timeDiff;[m
 }[m
 [m
[31m-static UniValue getnetworkhashps(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan getnetworkhashps()[m
 {[m
[31m-            RPCHelpMan{"getnetworkhashps",[m
[32m+[m[32m    return RPCHelpMan{"getnetworkhashps",[m
                 "\nReturns the estimated network hashes per second based on the last n blocks.\n"[m
                 "Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\n"[m
                 "Pass in [height] to estimate the network speed at the time when a certain block was found.\n",[m
[36m@@ -97,10 +97,12 @@[m [mstatic UniValue getnetworkhashps(const JSONRPCRequest& request)[m
                     HelpExampleCli("getnetworkhashps", "")[m
             + HelpExampleRpc("getnetworkhashps", "")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     LOCK(cs_main);[m
     return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 static bool GenerateBlock(ChainstateManager& chainman, CBlock& block, uint64_t& max_tries, unsigned int& extra_nonce, uint256& block_hash)[m
[36m@@ -200,9 +202,9 @@[m [mstatic bool getScriptFromDescriptor(const std::string& descriptor, CScript& scri[m
     }[m
 }[m
 [m
[31m-static UniValue generatetodescriptor(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan generatetodescriptor()[m
 {[m
[31m-    RPCHelpMan{[m
[32m+[m[32m    return RPCHelpMan{[m
         "generatetodescriptor",[m
         "\nMine blocks immediately to a specified descriptor (before the RPC call returns)\n",[m
         {[m
[36m@@ -218,9 +220,8 @@[m [mstatic UniValue generatetodescriptor(const JSONRPCRequest& request)[m
         },[m
         RPCExamples{[m
             "\nGenerate 11 blocks to mydesc\n" + HelpExampleCli("generatetodescriptor", "11 \"mydesc\"")},[m
[31m-    }[m
[31m-        .Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     const int num_blocks{request.params[0].get_int()};[m
     const uint64_t max_tries{request.params[2].isNull() ? DEFAULT_MAX_TRIES : request.params[2].get_int()};[m
 [m
[36m@@ -234,22 +235,25 @@[m [mstatic UniValue generatetodescriptor(const JSONRPCRequest& request)[m
     ChainstateManager& chainman = EnsureChainman(request.context);[m
 [m
     return generateBlocks(chainman, mempool, coinbase_script, num_blocks, max_tries);[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-static UniValue generate(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan generate()[m
 {[m
[31m-    const std::string help_str{"generate ( nblocks maxtries ) has been replaced by the -generate cli option. Refer to -help for more information."};[m
[32m+[m[32m    return RPCHelpMan{"generate", "has been replaced by the -generate cli option. Refer to -help for more information.", {}, {}, RPCExamples{""}, [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {[m
 [m
     if (request.fHelp) {[m
[31m-        throw std::runtime_error(help_str);[m
[32m+[m[32m        throw std::runtime_error(self.ToString());[m
     } else {[m
[31m-        throw JSONRPCError(RPC_METHOD_NOT_FOUND, help_str);[m
[32m+[m[32m        throw JSONRPCError(RPC_METHOD_NOT_FOUND, self.ToString());[m
     }[m
[32m+[m[32m    }};[m
 }[m
 [m
[31m-static UniValue generatetoaddress(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan generatetoaddress()[m
 {[m
[31m-            RPCHelpMan{"generatetoaddress",[m
[32m+[m[32m    return RPCHelpMan{"generatetoaddress",[m
                 "\nMine blocks immediately to a specified address (before the RPC call returns)\n",[m
                 {[m
                     {"nblocks", RPCArg::Type::NUM, RPCArg::Optional::NO, "How many blocks are generated immediately."},[m
[36m@@ -267,8 +271,8 @@[m [mstatic UniValue generatetoaddress(const JSONRPCRequest& request)[m
             + "If you are using the " PACKAGE_NAME " wallet, you can get a new address to send the newly generated bitcoin to with:\n"[m
             + HelpExampleCli("getnewaddress", "")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     const int num_blocks{request.params[0].get_int()};[m
     const uint64_t max_tries{request.params[2].isNull() ? DEFAULT_MAX_TRIES : request.params[2].get_int()};[m
 [m
[36m@@ -283,11 +287,13 @@[m [mstatic UniValue generatetoaddress(const JSONRPCRequest& request)[m
     CScript coinbase_script = GetScriptForDestination(destination);[m
 [m
     return generateBlocks(chainman, mempool, coinbase_script, num_blocks, max_tries);[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-static UniValue generateblock(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan generateblock()[m
 {[m
[31m-    RPCHelpMan{"generateblock",[m
[32m+[m[32m    return RPCHelpMan{"generateblock",[m
         "\nMine a block with a set of ordered transactions immediately to a specified address or descriptor (before the RPC call returns)\n",[m
         {[m
             {"output", RPCArg::Type::STR, RPCArg::Optional::NO, "The address or descriptor to send the newly generated bitcoin to."},[m
[36m@@ -309,8 +315,8 @@[m [mstatic UniValue generateblock(const JSONRPCRequest& request)[m
             "\nGenerate a block to myaddress, with txs rawtx and mempool_txid\n"[m
             + HelpExampleCli("generateblock", R"("myaddress" '["rawtx", "mempool_txid"]')")[m
         },[m
[31m-    }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     const auto address_or_descriptor = request.params[0].get_str();[m
     CScript coinbase_script;[m
     std::string error;[m
[36m@@ -390,11 +396,13 @@[m [mstatic UniValue generateblock(const JSONRPCRequest& request)[m
     UniValue obj(UniValue::VOBJ);[m
     obj.pushKV("hash", block_hash.GetHex());[m
     return obj;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-static UniValue getmininginfo(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan getmininginfo()[m
 {[m
[31m-            RPCHelpMan{"getmininginfo",[m
[32m+[m[32m    return RPCHelpMan{"getmininginfo",[m
                 "\nReturns a json object containing mining-related information.",[m
                 {},[m
                 RPCResult{[m
[36m@@ -413,8 +421,8 @@[m [mstatic UniValue getmininginfo(const JSONRPCRequest& request)[m
                     HelpExampleCli("getmininginfo", "")[m
             + HelpExampleRpc("getmininginfo", "")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     LOCK(cs_main);[m
     const CTxMemPool& mempool = EnsureMemPool(request.context);[m
 [m
[36m@@ -423,18 +431,20 @@[m [mstatic UniValue getmininginfo(const JSONRPCRequest& request)[m
     if (BlockAssembler::m_last_block_weight) obj.pushKV("currentblockweight", *BlockAssembler::m_last_block_weight);[m
     if (BlockAssembler::m_last_block_num_txs) obj.pushKV("currentblocktx", *BlockAssembler::m_last_block_num_txs);[m
     obj.pushKV("difficulty",       (double)GetDifficulty(::ChainActive().Tip()));[m
[31m-    obj.pushKV("networkhashps",    getnetworkhashps(request));[m
[32m+[m[32m    obj.pushKV("networkhashps",    getnetworkhashps().HandleRequest(request));[m
     obj.pushKV("pooledtx",         (uint64_t)mempool.size());[m
     obj.pushKV("chain",            Params().NetworkIDString());[m
     obj.pushKV("warnings",         GetWarnings(false).original);[m
     return obj;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 [m
 // NOTE: Unlike wallet RPC (which use BTC values), mining RPCs follow GBT (BIP 22) in using satoshi amounts[m
[31m-static UniValue prioritisetransaction(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan prioritisetransaction()[m
 {[m
[31m-            RPCHelpMan{"prioritisetransaction",[m
[32m+[m[32m    return RPCHelpMan{"prioritisetransaction",[m
                 "Accepts the transaction into mined blocks at a higher (or lower) priority\n",[m
                 {[m
                     {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The transaction id."},[m
[36m@@ -451,8 +461,8 @@[m [mstatic UniValue prioritisetransaction(const JSONRPCRequest& request)[m
                     HelpExampleCli("prioritisetransaction", "\"txid\" 0.0 10000")[m
             + HelpExampleRpc("prioritisetransaction", "\"txid\", 0.0, 10000")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     LOCK(cs_main);[m
 [m
     uint256 hash(ParseHashV(request.params[0], "txid"));[m
[36m@@ -464,6 +474,8 @@[m [mstatic UniValue prioritisetransaction(const JSONRPCRequest& request)[m
 [m
     EnsureMemPool(request.context).PrioritiseTransaction(hash, nAmount);[m
     return true;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 [m
[36m@@ -495,9 +507,9 @@[m [mstatic std::string gbt_vb_name(const Consensus::DeploymentPos pos) {[m
     return s;[m
 }[m
 [m
[31m-static UniValue getblocktemplate(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan getblocktemplate()[m
 {[m
[31m-            RPCHelpMan{"getblocktemplate",[m
[32m+[m[32m    return RPCHelpMan{"getblocktemplate",[m
                 "\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\n"[m
                 "It returns data needed to construct a block to work on.\n"[m
                 "For full specification, see BIPs 22, 23, 9, and 145:\n"[m
[36m@@ -511,12 +523,13 @@[m [mstatic UniValue getblocktemplate(const JSONRPCRequest& request)[m
                             {"mode", RPCArg::Type::STR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, "This must be set to \"template\", \"proposal\" (see BIP 23), or omitted"},[m
                             {"capabilities", RPCArg::Type::ARR, /* treat as named arg */ RPCArg::Optional::OMITTED_NAMED_ARG, "A list of strings",[m
                                 {[m
[31m-                                    {"support", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'"},[m
[32m+[m[32m                                    {"str", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "client side supported feature, 'longpoll', 'coinbasevalue', 'proposal', 'serverlist', 'workid'"},[m
                                 },[m
                                 },[m
                             {"rules", RPCArg::Type::ARR, RPCArg::Optional::NO, "A list of strings",[m
                                 {[m
[31m-                                    {"support", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "client side supported softfork deployment"},[m
[32m+[m[32m                                    {"segwit", RPCArg::Type::STR, RPCArg::Optional::NO, "(literal) indicates client side segwit support"},[m
[32m+[m[32m                                    {"str", RPCArg::Type::STR, RPCArg::Optional::OMITTED, "other client side supported softfork deployment"},[m
                                 },[m
                                 },[m
                         },[m
[36m@@ -528,7 +541,7 @@[m [mstatic UniValue getblocktemplate(const JSONRPCRequest& request)[m
                         {RPCResult::Type::NUM, "version", "The preferred block version"},[m
                         {RPCResult::Type::ARR, "rules", "specific block rules that are to be enforced",[m
                             {[m
[31m-                                {RPCResult::Type::STR, "", "rulename"},[m
[32m+[m[32m                                {RPCResult::Type::STR, "", "name of a rule the client must understand to some extent; see BIP 9 for format"},[m
                             }},[m
                         {RPCResult::Type::OBJ_DYN, "vbavailable", "set of pending, supported versionbit (BIP 9) softfork deployments",[m
                             {[m
[36m@@ -536,7 +549,7 @@[m [mstatic UniValue getblocktemplate(const JSONRPCRequest& request)[m
                             }},[m
                         {RPCResult::Type::NUM, "vbrequired", "bit mask of versionbits the server requires set in submissions"},[m
                         {RPCResult::Type::STR, "previousblockhash", "The hash of current highest block"},[m
[31m-                        {RPCResult::Type::ARR, "", "contents of non-coinbase transactions that should be included in the next block",[m
[32m+[m[32m                        {RPCResult::Type::ARR, "transactions", "contents of non-coinbase transactions that should be included in the next block",[m
                             {[m
                                 {RPCResult::Type::OBJ, "", "",[m
                                     {[m
[36m@@ -552,15 +565,12 @@[m [mstatic UniValue getblocktemplate(const JSONRPCRequest& request)[m
                                         {RPCResult::Type::NUM, "weight", "total transaction weight, as counted for purposes of block limits"},[m
                                     }},[m
                             }},[m
[31m-                        {RPCResult::Type::OBJ, "coinbaseaux", "data that should be included in the coinbase's scriptSig content",[m
[32m+[m[32m                        {RPCResult::Type::OBJ_DYN, "coinbaseaux", "data that should be included in the coinbase's scriptSig content",[m
                         {[m
[31m-                            {RPCResult::Type::ELISION, "", ""},[m
[32m+[m[32m                            {RPCResult::Type::STR_HEX, "key", "values must be in the coinbase (keys may be ignored)"},[m
                         }},[m
                         {RPCResult::Type::NUM, "coinbasevalue", "maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)"},[m
[31m-                        {RPCResult::Type::OBJ, "coinbasetxn", "information for coinbase transaction",[m
[31m-                        {[m
[31m-                            {RPCResult::Type::ELISION, "", ""},[m
[31m-                        }},[m
[32m+[m[32m                        {RPCResult::Type::STR, "longpollid", "an id to include with a request to longpoll on an update to this template"},[m
                         {RPCResult::Type::STR, "target", "The hash target"},[m
                         {RPCResult::Type::NUM_TIME, "mintime", "The minimum timestamp appropriate for the next block time, expressed in " + UNIX_EPOCH_TIME},[m
                         {RPCResult::Type::ARR, "mutable", "list of ways the block template may be changed",[m
[36m@@ -574,13 +584,14 @@[m [mstatic UniValue getblocktemplate(const JSONRPCRequest& request)[m
                         {RPCResult::Type::NUM_TIME, "curtime", "current timestamp in " + UNIX_EPOCH_TIME},[m
                         {RPCResult::Type::STR, "bits", "compressed target of next block"},[m
                         {RPCResult::Type::NUM, "height", "The height of the next block"},[m
[32m+[m[32m                        {RPCResult::Type::STR, "default_witness_commitment", /* optional */ true, "a valid witness commitment for the unmodified block template"}[m
                     }},[m
                 RPCExamples{[m
                     HelpExampleCli("getblocktemplate", "'{\"rules\": [\"segwit\"]}'")[m
             + HelpExampleRpc("getblocktemplate", "{\"rules\": [\"segwit\"]}")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     LOCK(cs_main);[m
 [m
     std::string strMode = "template";[m
[36m@@ -888,6 +899,8 @@[m [mstatic UniValue getblocktemplate(const JSONRPCRequest& request)[m
     }[m
 [m
     return result;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 class submitblock_StateCatcher final : public CValidationInterface[m
[36m@@ -908,10 +921,10 @@[m [mprotected:[m
     }[m
 };[m
 [m
[31m-static UniValue submitblock(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan submitblock()[m
 {[m
     // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.[m
[31m-            RPCHelpMan{"submitblock",[m
[32m+[m[32m    return RPCHelpMan{"submitblock",[m
                 "\nAttempts to submit new block to network.\n"[m
                 "See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\n",[m
                 {[m
[36m@@ -923,8 +936,8 @@[m [mstatic UniValue submitblock(const JSONRPCRequest& request)[m
                     HelpExampleCli("submitblock", "\"mydata\"")[m
             + HelpExampleRpc("submitblock", "\"mydata\"")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CBlock> blockptr = std::make_shared<CBlock>();[m
     CBlock& block = *blockptr;[m
     if (!DecodeHexBlk(block, request.params[0].get_str())) {[m
[36m@@ -969,11 +982,13 @@[m [mstatic UniValue submitblock(const JSONRPCRequest& request)[m
         return "inconclusive";[m
     }[m
     return BIP22ValidationResult(sc->state);[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-static UniValue submitheader(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan submitheader()[m
 {[m
[31m-            RPCHelpMan{"submitheader",[m
[32m+[m[32m    return RPCHelpMan{"submitheader",[m
                 "\nDecode the given hexdata as a header and submit it as a candidate chain tip if valid."[m
                 "\nThrows when the header is invalid.\n",[m
                 {[m
[36m@@ -985,8 +1000,8 @@[m [mstatic UniValue submitheader(const JSONRPCRequest& request)[m
                     HelpExampleCli("submitheader", "\"aabbcc\"") +[m
                     HelpExampleRpc("submitheader", "\"aabbcc\"")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     CBlockHeader h;[m
     if (!DecodeHexBlockHeader(h, request.params[0].get_str())) {[m
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block header decode failed");[m
[36m@@ -1005,11 +1020,13 @@[m [mstatic UniValue submitheader(const JSONRPCRequest& request)[m
         throw JSONRPCError(RPC_VERIFY_ERROR, state.ToString());[m
     }[m
     throw JSONRPCError(RPC_VERIFY_ERROR, state.GetRejectReason());[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-static UniValue estimatesmartfee(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan estimatesmartfee()[m
 {[m
[31m-            RPCHelpMan{"estimatesmartfee",[m
[32m+[m[32m    return RPCHelpMan{"estimatesmartfee",[m
                 "\nEstimates the approximate fee per kilobyte needed for a transaction to begin\n"[m
                 "confirmation within conf_target blocks if possible and return the number of blocks\n"[m
                 "for which the estimate is valid. Uses virtual transaction size as defined\n"[m
[36m@@ -1043,8 +1060,8 @@[m [mstatic UniValue estimatesmartfee(const JSONRPCRequest& request)[m
                 RPCExamples{[m
                     HelpExampleCli("estimatesmartfee", "6")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VSTR});[m
     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);[m
     unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);[m
[36m@@ -1070,11 +1087,13 @@[m [mstatic UniValue estimatesmartfee(const JSONRPCRequest& request)[m
     }[m
     result.pushKV("blocks", feeCalc.returnedTarget);[m
     return result;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-static UniValue estimaterawfee(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan estimaterawfee()[m
 {[m
[31m-            RPCHelpMan{"estimaterawfee",[m
[32m+[m[32m    return RPCHelpMan{"estimaterawfee",[m
                 "\nWARNING: This interface is unstable and may disappear or change!\n"[m
                 "\nWARNING: This is an advanced API call that is tightly coupled to the specific\n"[m
                 "         implementation of fee estimation. The parameters it can be called with\n"[m
[36m@@ -1126,8 +1145,8 @@[m [mstatic UniValue estimaterawfee(const JSONRPCRequest& request)[m
                 RPCExamples{[m
                     HelpExampleCli("estimaterawfee", "6 0.9")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM}, true);[m
     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);[m
     unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);[m
[36m@@ -1186,6 +1205,8 @@[m [mstatic UniValue estimaterawfee(const JSONRPCRequest& request)[m
         result.pushKV(StringForFeeEstimateHorizon(horizon), horizon_result);[m
     }[m
     return result;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 void RegisterMiningRPCCommands(CRPCTable &t)[m
[33mdiff --git a/src/rpc/net.cpp b/src/rpc/net.cpp[m
[33mindex e9343b3348..7e2052c7cb 100644[m
[33m--- a/src/rpc/net.cpp[m
[33m+++ b/src/rpc/net.cpp[m
[36m@@ -197,7 +197,7 @@[m [mstatic UniValue getpeerinfo(const JSONRPCRequest& request)[m
         if (fStateStats) {[m
             if (IsDeprecatedRPCEnabled("banscore")) {[m
                 // banscore is deprecated in v0.21 for removal in v0.22[m
[31m-                obj.pushKV("banscore", statestats.nMisbehavior);[m
[32m+[m[32m                obj.pushKV("banscore", statestats.m_misbehavior_score);[m
             }[m
             obj.pushKV("synced_headers", statestats.nSyncHeight);[m
             obj.pushKV("synced_blocks", statestats.nCommonHeight);[m
[33mdiff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp[m
[33mindex abc8168c55..d6988ee3ac 100644[m
[33m--- a/src/rpc/rawtransaction.cpp[m
[33m+++ b/src/rpc/rawtransaction.cpp[m
[36m@@ -1300,7 +1300,7 @@[m [mUniValue combinepsbt(const JSONRPCRequest& request)[m
 [m
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);[m
     ssTx << merged_psbt;[m
[31m-    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());[m
[32m+[m[32m    return EncodeBase64(MakeUCharSpan(ssTx));[m
 }[m
 [m
 UniValue finalizepsbt(const JSONRPCRequest& request)[m
[36m@@ -1435,7 +1435,7 @@[m [mUniValue createpsbt(const JSONRPCRequest& request)[m
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);[m
     ssTx << psbtx;[m
 [m
[31m-    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());[m
[32m+[m[32m    return EncodeBase64(MakeUCharSpan(ssTx));[m
 }[m
 [m
 UniValue converttopsbt(const JSONRPCRequest& request)[m
[36m@@ -1502,7 +1502,7 @@[m [mUniValue converttopsbt(const JSONRPCRequest& request)[m
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);[m
     ssTx << psbtx;[m
 [m
[31m-    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());[m
[32m+[m[32m    return EncodeBase64(MakeUCharSpan(ssTx));[m
 }[m
 [m
 UniValue utxoupdatepsbt(const JSONRPCRequest& request)[m
[36m@@ -1590,7 +1590,7 @@[m [mUniValue utxoupdatepsbt(const JSONRPCRequest& request)[m
 [m
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);[m
     ssTx << psbtx;[m
[31m-    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());[m
[32m+[m[32m    return EncodeBase64(MakeUCharSpan(ssTx));[m
 }[m
 [m
 UniValue joinpsbts(const JSONRPCRequest& request)[m
[36m@@ -1683,7 +1683,7 @@[m [mUniValue joinpsbts(const JSONRPCRequest& request)[m
 [m
     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);[m
     ssTx << shuffled_psbt;[m
[31m-    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());[m
[32m+[m[32m    return EncodeBase64(MakeUCharSpan(ssTx));[m
 }[m
 [m
 UniValue analyzepsbt(const JSONRPCRequest& request)[m
[33mdiff --git a/src/rpc/server.cpp b/src/rpc/server.cpp[m
[33mindex 9c8e7fe04a..f32d9abac6 100644[m
[33m--- a/src/rpc/server.cpp[m
[33m+++ b/src/rpc/server.cpp[m
[36m@@ -261,13 +261,11 @@[m [mCRPCTable::CRPCTable()[m
     }[m
 }[m
 [m
[31m-bool CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)[m
[32m+[m[32mvoid CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)[m
 {[m
[31m-    if (IsRPCRunning())[m
[31m-        return false;[m
[32m+[m[32m    CHECK_NONFATAL(!IsRPCRunning()); // Only add commands before rpc is running[m
 [m
     mapCommands[name].push_back(pcmd);[m
[31m-    return true;[m
 }[m
 [m
 bool CRPCTable::removeCommand(const std::string& name, const CRPCCommand* pcmd)[m
[33mdiff --git a/src/rpc/server.h b/src/rpc/server.h[m
[33mindex 6da3e94ea2..b2358ac5b2 100644[m
[33m--- a/src/rpc/server.h[m
[33m+++ b/src/rpc/server.h[m
[36m@@ -160,7 +160,7 @@[m [mpublic:[m
     /**[m
      * Appends a CRPCCommand to the dispatch table.[m
      *[m
[31m-     * Returns false if RPC server is already running (dump concurrency protection).[m
[32m+[m[32m     * Precondition: RPC server is not running[m
      *[m
      * Commands with different method names but the same unique_id will[m
      * be considered aliases, and only the first registered method name will[m
[36m@@ -169,7 +169,7 @@[m [mpublic:[m
      * between calls based on method name, and aliased commands can also[m
      * register different names, types, and numbers of parameters.[m
      */[m
[31m-    bool appendCommand(const std::string& name, const CRPCCommand* pcmd);[m
[32m+[m[32m    void appendCommand(const std::string& name, const CRPCCommand* pcmd);[m
     bool removeCommand(const std::string& name, const CRPCCommand* pcmd);[m
 };[m
 [m
[33mdiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp[m
[33mindex 39feb4ccc9..7b2457a5e3 100644[m
[33m--- a/src/script/interpreter.cpp[m
[33m+++ b/src/script/interpreter.cpp[m
[36m@@ -1258,34 +1258,37 @@[m [mpublic:[m
     }[m
 };[m
 [m
[32m+[m[32m/** Compute the (single) SHA256 of the concatenation of all prevouts of a tx. */[m
 template <class T>[m
[31m-uint256 GetPrevoutHash(const T& txTo)[m
[32m+[m[32muint256 GetPrevoutsSHA256(const T& txTo)[m
 {[m
     CHashWriter ss(SER_GETHASH, 0);[m
     for (const auto& txin : txTo.vin) {[m
         ss << txin.prevout;[m
     }[m
[31m-    return ss.GetHash();[m
[32m+[m[32m    return ss.GetSHA256();[m
 }[m
 [m
[32m+[m[32m/** Compute the (single) SHA256 of the concatenation of all nSequences of a tx. */[m
 template <class T>[m
[31m-uint256 GetSequenceHash(const T& txTo)[m
[32m+[m[32muint256 GetSequencesSHA256(const T& txTo)[m
 {[m
     CHashWriter ss(SER_GETHASH, 0);[m
     for (const auto& txin : txTo.vin) {[m
         ss << txin.nSequence;[m
     }[m
[31m-    return ss.GetHash();[m
[32m+[m[32m    return ss.GetSHA256();[m
 }[m
 [m
[32m+[m[32m/** Compute the (single) SHA256 of the concatenation of all txouts of a tx. */[m
 template <class T>[m
[31m-uint256 GetOutputsHash(const T& txTo)[m
[32m+[m[32muint256 GetOutputsSHA256(const T& txTo)[m
 {[m
     CHashWriter ss(SER_GETHASH, 0);[m
     for (const auto& txout : txTo.vout) {[m
         ss << txout;[m
     }[m
[31m-    return ss.GetHash();[m
[32m+[m[32m    return ss.GetSHA256();[m
 }[m
 [m
 } // namespace[m
[36m@@ -1297,9 +1300,9 @@[m [mvoid PrecomputedTransactionData::Init(const T& txTo)[m
 [m
     // Cache is calculated only for transactions with witness[m
     if (txTo.HasWitness()) {[m
[31m-        hashPrevouts = GetPrevoutHash(txTo);[m
[31m-        hashSequence = GetSequenceHash(txTo);[m
[31m-        hashOutputs = GetOutputsHash(txTo);[m
[32m+[m[32m        hashPrevouts = SHA256Uint256(GetPrevoutsSHA256(txTo));[m
[32m+[m[32m        hashSequence = SHA256Uint256(GetSequencesSHA256(txTo));[m
[32m+[m[32m        hashOutputs = SHA256Uint256(GetOutputsSHA256(txTo));[m
     }[m
 [m
     m_ready = true;[m
[36m@@ -1329,16 +1332,16 @@[m [muint256 SignatureHash(const CScript& scriptCode, const T& txTo, unsigned int nIn[m
         const bool cacheready = cache && cache->m_ready;[m
 [m
         if (!(nHashType & SIGHASH_ANYONECANPAY)) {[m
[31m-            hashPrevouts = cacheready ? cache->hashPrevouts : GetPrevoutHash(txTo);[m
[32m+[m[32m            hashPrevouts = cacheready ? cache->hashPrevouts : SHA256Uint256(GetPrevoutsSHA256(txTo));[m
         }[m
 [m
         if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {[m
[31m-            hashSequence = cacheready ? cache->hashSequence : GetSequenceHash(txTo);[m
[32m+[m[32m            hashSequence = cacheready ? cache->hashSequence : SHA256Uint256(GetSequencesSHA256(txTo));[m
         }[m
 [m
 [m
         if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {[m
[31m-            hashOutputs = cacheready ? cache->hashOutputs : GetOutputsHash(txTo);[m
[32m+[m[32m            hashOutputs = cacheready ? cache->hashOutputs : SHA256Uint256(GetOutputsSHA256(txTo));[m
         } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {[m
             CHashWriter ss(SER_GETHASH, 0);[m
             ss << txTo.vout[nIn];[m
[33mdiff --git a/src/support/lockedpool.cpp b/src/support/lockedpool.cpp[m
[33mindex b4f392116c..26de780f29 100644[m
[33m--- a/src/support/lockedpool.cpp[m
[33m+++ b/src/support/lockedpool.cpp[m
[36m@@ -10,7 +10,6 @@[m
 #endif[m
 [m
 #ifdef WIN32[m
[31m-#define WIN32_LEAN_AND_MEAN 1[m
 #ifndef NOMINMAX[m
 #define NOMINMAX[m
 #endif[m
[33mdiff --git a/src/sync.cpp b/src/sync.cpp[m
[33mindex 4be13a3c48..322198a852 100644[m
[33m--- a/src/sync.cpp[m
[33m+++ b/src/sync.cpp[m
[36m@@ -238,12 +238,15 @@[m [mvoid AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine,[m
 template void AssertLockHeldInternal(const char*, const char*, int, Mutex*);[m
 template void AssertLockHeldInternal(const char*, const char*, int, RecursiveMutex*);[m
 [m
[31m-void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs)[m
[32m+[m[32mtemplate <typename MutexType>[m
[32m+[m[32mvoid AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs)[m
 {[m
     if (!LockHeld(cs)) return;[m
     tfm::format(std::cerr, "Assertion failed: lock %s held in %s:%i; locks held:\n%s", pszName, pszFile, nLine, LocksHeld());[m
     abort();[m
 }[m
[32m+[m[32mtemplate void AssertLockNotHeldInternal(const char*, const char*, int, Mutex*);[m
[32m+[m[32mtemplate void AssertLockNotHeldInternal(const char*, const char*, int, RecursiveMutex*);[m
 [m
 void DeleteLock(void* cs)[m
 {[m
[33mdiff --git a/src/sync.h b/src/sync.h[m
[33mindex 05ff2ee8a9..7b397a8003 100644[m
[33m--- a/src/sync.h[m
[33m+++ b/src/sync.h[m
[36m@@ -53,8 +53,9 @@[m [mvoid LeaveCritical();[m
 void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line);[m
 std::string LocksHeld();[m
 template <typename MutexType>[m
[31m-void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) ASSERT_EXCLUSIVE_LOCK(cs);[m
[31m-void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);[m
[32m+[m[32mvoid AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs);[m
[32m+[m[32mtemplate <typename MutexType>[m
[32m+[m[32mvoid AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs);[m
 void DeleteLock(void* cs);[m
 bool LockStackEmpty();[m
 [m
[36m@@ -69,8 +70,9 @@[m [minline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v[m
 inline void LeaveCritical() {}[m
 inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}[m
 template <typename MutexType>[m
[31m-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) ASSERT_EXCLUSIVE_LOCK(cs) {}[m
[31m-inline void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}[m
[32m+[m[32minline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}[m
[32m+[m[32mtemplate <typename MutexType>[m
[32m+[m[32mvoid AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}[m
 inline void DeleteLock(void* cs) {}[m
 inline bool LockStackEmpty() { return true; }[m
 #endif[m
[33mdiff --git a/src/test/denialofservice_tests.cpp b/src/test/denialofservice_tests.cpp[m
[33mindex c0a2fca9ca..93bfa88024 100644[m
[33m--- a/src/test/denialofservice_tests.cpp[m
[33m+++ b/src/test/denialofservice_tests.cpp[m
[36m@@ -232,10 +232,7 @@[m [mBOOST_AUTO_TEST_CASE(peer_discouragement)[m
     peerLogic->InitializeNode(&dummyNode1);[m
     dummyNode1.nVersion = 1;[m
     dummyNode1.fSuccessfullyConnected = true;[m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        Misbehaving(dummyNode1.GetId(), DISCOURAGEMENT_THRESHOLD); // Should be discouraged[m
[31m-    }[m
[32m+[m[32m    Misbehaving(dummyNode1.GetId(), DISCOURAGEMENT_THRESHOLD); // Should be discouraged[m
     {[m
         LOCK(dummyNode1.cs_sendProcessing);[m
         BOOST_CHECK(peerLogic->SendMessages(&dummyNode1));[m
[36m@@ -249,20 +246,14 @@[m [mBOOST_AUTO_TEST_CASE(peer_discouragement)[m
     peerLogic->InitializeNode(&dummyNode2);[m
     dummyNode2.nVersion = 1;[m
     dummyNode2.fSuccessfullyConnected = true;[m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        Misbehaving(dummyNode2.GetId(), DISCOURAGEMENT_THRESHOLD - 1);[m
[31m-    }[m
[32m+[m[32m    Misbehaving(dummyNode2.GetId(), DISCOURAGEMENT_THRESHOLD - 1);[m
     {[m
         LOCK(dummyNode2.cs_sendProcessing);[m
         BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));[m
     }[m
     BOOST_CHECK(!banman->IsDiscouraged(addr2)); // 2 not discouraged yet...[m
     BOOST_CHECK(banman->IsDiscouraged(addr1));  // ... but 1 still should be[m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        Misbehaving(dummyNode2.GetId(), 1); // 2 reaches discouragement threshold[m
[31m-    }[m
[32m+[m[32m    Misbehaving(dummyNode2.GetId(), 1);         // 2 reaches discouragement threshold[m
     {[m
         LOCK(dummyNode2.cs_sendProcessing);[m
         BOOST_CHECK(peerLogic->SendMessages(&dummyNode2));[m
[36m@@ -292,10 +283,7 @@[m [mBOOST_AUTO_TEST_CASE(DoS_bantime)[m
     dummyNode.nVersion = 1;[m
     dummyNode.fSuccessfullyConnected = true;[m
 [m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        Misbehaving(dummyNode.GetId(), DISCOURAGEMENT_THRESHOLD);[m
[31m-    }[m
[32m+[m[32m    Misbehaving(dummyNode.GetId(), DISCOURAGEMENT_THRESHOLD);[m
     {[m
         LOCK(dummyNode.cs_sendProcessing);[m
         BOOST_CHECK(peerLogic->SendMessages(&dummyNode));[m
[33mdiff --git a/src/test/fuzz/asmap.cpp b/src/test/fuzz/asmap.cpp[m
[33mindex 40ca01bd9f..e3aefa18a3 100644[m
[33m--- a/src/test/fuzz/asmap.cpp[m
[33m+++ b/src/test/fuzz/asmap.cpp[m
[36m@@ -33,7 +33,7 @@[m [mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
     if (buffer.size() < 1 + 3 + 4) return;[m
     int asmap_size = 3 + (buffer[0] & 127);[m
     bool ipv6 = buffer[0] & 128;[m
[31m-    int addr_size = ipv6 ? 16 : 4;[m
[32m+[m[32m    const size_t addr_size = ipv6 ? ADDR_IPV6_SIZE : ADDR_IPV4_SIZE;[m
     if (buffer.size() < size_t(1 + asmap_size + addr_size)) return;[m
     std::vector<bool> asmap = ipv6 ? IPV6_PREFIX_ASMAP : IPV4_PREFIX_ASMAP;[m
     asmap.reserve(asmap.size() + 8 * asmap_size);[m
[36m@@ -43,7 +43,17 @@[m [mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
         }[m
     }[m
     if (!SanityCheckASMap(asmap)) return;[m
[32m+[m
[32m+[m[32m    const uint8_t* addr_data = buffer.data() + 1 + asmap_size;[m
     CNetAddr net_addr;[m
[31m-    net_addr.SetRaw(ipv6 ? NET_IPV6 : NET_IPV4, buffer.data() + 1 + asmap_size);[m
[32m+[m[32m    if (ipv6) {[m
[32m+[m[32m        assert(addr_size == ADDR_IPV6_SIZE);[m
[32m+[m[32m        net_addr.SetLegacyIPv6(Span<const uint8_t>(addr_data, addr_size));[m
[32m+[m[32m    } else {[m
[32m+[m[32m        assert(addr_size == ADDR_IPV4_SIZE);[m
[32m+[m[32m        in_addr ipv4;[m
[32m+[m[32m        memcpy(&ipv4, addr_data, addr_size);[m
[32m+[m[32m        net_addr.SetIP(CNetAddr{ipv4});[m
[32m+[m[32m    }[m
     (void)net_addr.GetMappedAS(asmap);[m
 }[m
[33mdiff --git a/src/test/fuzz/net.cpp b/src/test/fuzz/net.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..1ff9d6b286[m
[33m--- /dev/null[m
[33m+++ b/src/test/fuzz/net.cpp[m
[36m@@ -0,0 +1,156 @@[m
[32m+[m[32m// Copyright (c) 2020 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <chainparams.h>[m
[32m+[m[32m#include <chainparamsbase.h>[m
[32m+[m[32m#include <net.h>[m
[32m+[m[32m#include <net_permissions.h>[m
[32m+[m[32m#include <netaddress.h>[m
[32m+[m[32m#include <optional.h>[m
[32m+[m[32m#include <protocol.h>[m
[32m+[m[32m#include <random.h>[m
[32m+[m[32m#include <test/fuzz/FuzzedDataProvider.h>[m
[32m+[m[32m#include <test/fuzz/fuzz.h>[m
[32m+[m[32m#include <test/fuzz/util.h>[m
[32m+[m[32m#include <test/util/setup_common.h>[m
[32m+[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32mvoid initialize()[m
[32m+[m[32m{[m
[32m+[m[32m    static const BasicTestingSetup basic_testing_setup;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
[32m+[m[32m{[m
[32m+[m[32m    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());[m
[32m+[m
[32m+[m[32m    const std::optional<CAddress> address = ConsumeDeserializable<CAddress>(fuzzed_data_provider);[m
[32m+[m[32m    if (!address) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    const std::optional<CAddress> address_bind = ConsumeDeserializable<CAddress>(fuzzed_data_provider);[m
[32m+[m[32m    if (!address_bind) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    CNode node{fuzzed_data_provider.ConsumeIntegral<NodeId>(),[m
[32m+[m[32m               static_cast<ServiceFlags>(fuzzed_data_provider.ConsumeIntegral<uint64_t>()),[m
[32m+[m[32m               fuzzed_data_provider.ConsumeIntegral<int>(),[m
[32m+[m[32m               INVALID_SOCKET,[m
[32m+[m[32m               *address,[m
[32m+[m[32m               fuzzed_data_provider.ConsumeIntegral<uint64_t>(),[m
[32m+[m[32m               fuzzed_data_provider.ConsumeIntegral<uint64_t>(),[m
[32m+[m[32m               *address_bind,[m
[32m+[m[32m               fuzzed_data_provider.ConsumeRandomLengthString(32),[m
[32m+[m[32m               fuzzed_data_provider.PickValueInArray({ConnectionType::INBOUND, ConnectionType::OUTBOUND, ConnectionType::MANUAL, ConnectionType::FEELER, ConnectionType::BLOCK_RELAY, ConnectionType::ADDR_FETCH})};[m
[32m+[m[32m    while (fuzzed_data_provider.ConsumeBool()) {[m
[32m+[m[32m        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 12)) {[m
[32m+[m[32m        case 0: {[m
[32m+[m[32m            node.CloseSocketDisconnect();[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 1: {[m
[32m+[m[32m            node.MaybeSetAddrName(fuzzed_data_provider.ConsumeRandomLengthString(32));[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 2: {[m
[32m+[m[32m            node.SetSendVersion(fuzzed_data_provider.ConsumeIntegral<int>());[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 3: {[m
[32m+[m[32m            const std::vector<bool> asmap = ConsumeRandomLengthIntegralVector<bool>(fuzzed_data_provider, 128);[m
[32m+[m[32m            if (!SanityCheckASMap(asmap)) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            CNodeStats stats;[m
[32m+[m[32m            node.copyStats(stats, asmap);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 4: {[m
[32m+[m[32m            node.SetRecvVersion(fuzzed_data_provider.ConsumeIntegral<int>());[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 5: {[m
[32m+[m[32m            const CNode* add_ref_node = node.AddRef();[m
[32m+[m[32m            assert(add_ref_node == &node);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 6: {[m
[32m+[m[32m            if (node.GetRefCount() > 0) {[m
[32m+[m[32m                node.Release();[m
[32m+[m[32m            }[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 7: {[m
[32m+[m[32m            if (node.m_addr_known == nullptr) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);[m
[32m+[m[32m            if (!addr_opt) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            node.AddAddressKnown(*addr_opt);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 8: {[m
[32m+[m[32m            if (node.m_addr_known == nullptr) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            const std::optional<CAddress> addr_opt = ConsumeDeserializable<CAddress>(fuzzed_data_provider);[m
[32m+[m[32m            if (!addr_opt) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            FastRandomContext fast_random_context{ConsumeUInt256(fuzzed_data_provider)};[m
[32m+[m[32m            node.PushAddress(*addr_opt, fast_random_context);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 9: {[m
[32m+[m[32m            const std::optional<CInv> inv_opt = ConsumeDeserializable<CInv>(fuzzed_data_provider);[m
[32m+[m[32m            if (!inv_opt) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            node.AddKnownTx(inv_opt->hash);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 10: {[m
[32m+[m[32m            node.PushTxInventory(ConsumeUInt256(fuzzed_data_provider));[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 11: {[m
[32m+[m[32m            const std::optional<CService> service_opt = ConsumeDeserializable<CService>(fuzzed_data_provider);[m
[32m+[m[32m            if (!service_opt) {[m
[32m+[m[32m                break;[m
[32m+[m[32m            }[m
[32m+[m[32m            node.SetAddrLocal(*service_opt);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        case 12: {[m
[32m+[m[32m            const std::vector<uint8_t> b = ConsumeRandomLengthByteVector(fuzzed_data_provider);[m
[32m+[m[32m            bool complete;[m
[32m+[m[32m            node.ReceiveMsgBytes((const char*)b.data(), b.size(), complete);[m
[32m+[m[32m            break;[m
[32m+[m[32m        }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    (void)node.GetAddrLocal();[m
[32m+[m[32m    (void)node.GetAddrName();[m
[32m+[m[32m    (void)node.GetId();[m
[32m+[m[32m    (void)node.GetLocalNonce();[m
[32m+[m[32m    (void)node.GetLocalServices();[m
[32m+[m[32m    (void)node.GetMyStartingHeight();[m
[32m+[m[32m    (void)node.GetRecvVersion();[m
[32m+[m[32m    const int ref_count = node.GetRefCount();[m
[32m+[m[32m    assert(ref_count >= 0);[m
[32m+[m[32m    (void)node.GetSendVersion();[m
[32m+[m[32m    (void)node.IsAddrRelayPeer();[m
[32m+[m
[32m+[m[32m    const NetPermissionFlags net_permission_flags = fuzzed_data_provider.ConsumeBool() ?[m
[32m+[m[32m                                                        fuzzed_data_provider.PickValueInArray<NetPermissionFlags>({NetPermissionFlags::PF_NONE, NetPermissionFlags::PF_BLOOMFILTER, NetPermissionFlags::PF_RELAY, NetPermissionFlags::PF_FORCERELAY, NetPermissionFlags::PF_NOBAN, NetPermissionFlags::PF_MEMPOOL, NetPermissionFlags::PF_ISIMPLICIT, NetPermissionFlags::PF_ALL}) :[m
[32m+[m[32m                                                        static_cast<NetPermissionFlags>(fuzzed_data_provider.ConsumeIntegral<uint32_t>());[m
[32m+[m[32m    (void)node.HasPermission(net_permission_flags);[m
[32m+[m[32m}[m
[33mdiff --git a/src/test/fuzz/netaddress.cpp b/src/test/fuzz/netaddress.cpp[m
[33mindex 2901c704f6..8252f38726 100644[m
[33m--- a/src/test/fuzz/netaddress.cpp[m
[33m+++ b/src/test/fuzz/netaddress.cpp[m
[36m@@ -17,9 +17,6 @@[m [mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());[m
 [m
     const CNetAddr net_addr = ConsumeNetAddr(fuzzed_data_provider);[m
[31m-    for (int i = 0; i < 15; ++i) {[m
[31m-        (void)net_addr.GetByte(i);[m
[31m-    }[m
     (void)net_addr.GetHash();[m
     (void)net_addr.GetNetClass();[m
     if (net_addr.GetNetwork() == Network::NET_IPV4) {[m
[36m@@ -78,7 +75,7 @@[m [mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
     (void)net_addr.ToString();[m
     (void)net_addr.ToStringIP();[m
 [m
[31m-    const CSubNet sub_net{net_addr, fuzzed_data_provider.ConsumeIntegral<int32_t>()};[m
[32m+[m[32m    const CSubNet sub_net{net_addr, fuzzed_data_provider.ConsumeIntegral<uint8_t>()};[m
     (void)sub_net.IsValid();[m
     (void)sub_net.ToString();[m
 [m
[33mdiff --git a/src/test/fuzz/secp256k1_ec_seckey_import_export_der.cpp b/src/test/fuzz/secp256k1_ec_seckey_import_export_der.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..d4f302a8d3[m
[33m--- /dev/null[m
[33m+++ b/src/test/fuzz/secp256k1_ec_seckey_import_export_der.cpp[m
[36m@@ -0,0 +1,38 @@[m
[32m+[m[32m// Copyright (c) 2020 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <key.h>[m
[32m+[m[32m#include <secp256k1.h>[m
[32m+[m[32m#include <test/fuzz/FuzzedDataProvider.h>[m
[32m+[m[32m#include <test/fuzz/fuzz.h>[m
[32m+[m[32m#include <test/fuzz/util.h>[m
[32m+[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32mint ec_seckey_import_der(const secp256k1_context* ctx, unsigned char* out32, const unsigned char* seckey, size_t seckeylen);[m
[32m+[m[32mint ec_seckey_export_der(const secp256k1_context* ctx, unsigned char* seckey, size_t* seckeylen, const unsigned char* key32, bool compressed);[m
[32m+[m
[32m+[m[32mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
[32m+[m[32m{[m
[32m+[m[32m    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};[m
[32m+[m[32m    secp256k1_context* secp256k1_context_sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);[m
[32m+[m[32m    {[m
[32m+[m[32m        std::vector<uint8_t> out32(32);[m
[32m+[m[32m        (void)ec_seckey_import_der(secp256k1_context_sign, out32.data(), ConsumeFixedLengthByteVector(fuzzed_data_provider, CKey::SIZE).data(), CKey::SIZE);[m
[32m+[m[32m    }[m
[32m+[m[32m    {[m
[32m+[m[32m        std::vector<uint8_t> seckey(CKey::SIZE);[m
[32m+[m[32m        const std::vector<uint8_t> key32 = ConsumeFixedLengthByteVector(fuzzed_data_provider, 32);[m
[32m+[m[32m        size_t seckeylen = CKey::SIZE;[m
[32m+[m[32m        const bool compressed = fuzzed_data_provider.ConsumeBool();[m
[32m+[m[32m        const bool exported = ec_seckey_export_der(secp256k1_context_sign, seckey.data(), &seckeylen, key32.data(), compressed);[m
[32m+[m[32m        if (exported) {[m
[32m+[m[32m            std::vector<uint8_t> out32(32);[m
[32m+[m[32m            const bool imported = ec_seckey_import_der(secp256k1_context_sign, out32.data(), seckey.data(), seckey.size()) == 1;[m
[32m+[m[32m            assert(imported && key32 == out32);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    secp256k1_context_destroy(secp256k1_context_sign);[m
[32m+[m[32m}[m
[33mdiff --git a/src/test/fuzz/secp256k1_ecdsa_signature_parse_der_lax.cpp b/src/test/fuzz/secp256k1_ecdsa_signature_parse_der_lax.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..ed8c7aba89[m
[33m--- /dev/null[m
[33m+++ b/src/test/fuzz/secp256k1_ecdsa_signature_parse_der_lax.cpp[m
[36m@@ -0,0 +1,33 @@[m
[32m+[m[32m// Copyright (c) 2020 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <key.h>[m
[32m+[m[32m#include <secp256k1.h>[m
[32m+[m[32m#include <test/fuzz/FuzzedDataProvider.h>[m
[32m+[m[32m#include <test/fuzz/fuzz.h>[m
[32m+[m[32m#include <test/fuzz/util.h>[m
[32m+[m
[32m+[m[32m#include <cstdint>[m
[32m+[m[32m#include <vector>[m
[32m+[m
[32m+[m[32mbool SigHasLowR(const secp256k1_ecdsa_signature* sig);[m
[32m+[m[32mint ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_signature* sig, const unsigned char* input, size_t inputlen);[m
[32m+[m
[32m+[m[32mvoid test_one_input(const std::vector<uint8_t>& buffer)[m
[32m+[m[32m{[m
[32m+[m[32m    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};[m
[32m+[m[32m    const std::vector<uint8_t> signature_bytes = ConsumeRandomLengthByteVector(fuzzed_data_provider);[m
[32m+[m[32m    if (signature_bytes.data() == nullptr) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m[32m    secp256k1_context* secp256k1_context_verify = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);[m
[32m+[m[32m    secp256k1_ecdsa_signature sig_der_lax;[m
[32m+[m[32m    const bool parsed_der_lax = ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig_der_lax, signature_bytes.data(), signature_bytes.size()) == 1;[m
[32m+[m[32m    if (parsed_der_lax) {[m
[32m+[m[32m        ECC_Start();[m
[32m+[m[32m        (void)SigHasLowR(&sig_der_lax);[m
[32m+[m[32m        ECC_Stop();[m
[32m+[m[32m    }[m
[32m+[m[32m    secp256k1_context_destroy(secp256k1_context_verify);[m
[32m+[m[32m}[m
[33mdiff --git a/src/test/fuzz/util.h b/src/test/fuzz/util.h[m
[33mindex 9f9552edb9..ed6093a8a8 100644[m
[33m--- a/src/test/fuzz/util.h[m
[33m+++ b/src/test/fuzz/util.h[m
[36m@@ -257,7 +257,7 @@[m [mCNetAddr ConsumeNetAddr(FuzzedDataProvider& fuzzed_data_provider) noexcept[m
 [m
 CSubNet ConsumeSubNet(FuzzedDataProvider& fuzzed_data_provider) noexcept[m
 {[m
[31m-    return {ConsumeNetAddr(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int32_t>()};[m
[32m+[m[32m    return {ConsumeNetAddr(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<uint8_t>()};[m
 }[m
 [m
 void InitializeFuzzingContext(const std::string& chain_name = CBaseChainParams::REGTEST)[m
[33mdiff --git a/src/test/net_tests.cpp b/src/test/net_tests.cpp[m
[33mindex 317000c771..917ae571f5 100644[m
[33m--- a/src/test/net_tests.cpp[m
[33m+++ b/src/test/net_tests.cpp[m
[36m@@ -13,8 +13,10 @@[m
 #include <streams.h>[m
 #include <test/util/setup_common.h>[m
 #include <util/memory.h>[m
[32m+[m[32m#include <util/strencodings.h>[m
 #include <util/string.h>[m
 #include <util/system.h>[m
[32m+[m[32m#include <version.h>[m
 [m
 #include <boost/test/unit_test.hpp>[m
 [m
[36m@@ -188,6 +190,78 @@[m [mBOOST_AUTO_TEST_CASE(cnode_simple_test)[m
     BOOST_CHECK(pnode2->IsInboundConn() == true);[m
 }[m
 [m
[32m+[m[32mBOOST_AUTO_TEST_CASE(cnetaddr_basic)[m
[32m+[m[32m{[m
[32m+[m[32m    CNetAddr addr;[m
[32m+[m
[32m+[m[32m    // IPv4, INADDR_ANY[m
[32m+[m[32m    BOOST_REQUIRE(LookupHost("0.0.0.0", addr, false));[m
[32m+[m[32m    BOOST_REQUIRE(!addr.IsValid());[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsIPv4());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "0.0.0.0");[m
[32m+[m
[32m+[m[32m    // IPv4, INADDR_NONE[m
[32m+[m[32m    BOOST_REQUIRE(LookupHost("255.255.255.255", addr, false));[m
[32m+[m[32m    BOOST_REQUIRE(!addr.IsValid());[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsIPv4());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(!addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "255.255.255.255");[m
[32m+[m
[32m+[m[32m    // IPv4, casual[m
[32m+[m[32m    BOOST_REQUIRE(LookupHost("12.34.56.78", addr, false));[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsValid());[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsIPv4());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(!addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "12.34.56.78");[m
[32m+[m
[32m+[m[32m    // IPv6, in6addr_any[m
[32m+[m[32m    BOOST_REQUIRE(LookupHost("::", addr, false));[m
[32m+[m[32m    BOOST_REQUIRE(!addr.IsValid());[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsIPv6());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "::");[m
[32m+[m
[32m+[m[32m    // IPv6, casual[m
[32m+[m[32m    BOOST_REQUIRE(LookupHost("1122:3344:5566:7788:9900:aabb:ccdd:eeff", addr, false));[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsValid());[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsIPv6());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(!addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "1122:3344:5566:7788:9900:aabb:ccdd:eeff");[m
[32m+[m
[32m+[m[32m    // TORv2[m
[32m+[m[32m    addr.SetSpecial("6hzph5hv6337r6p2.onion");[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsValid());[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsTor());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(!addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "6hzph5hv6337r6p2.onion");[m
[32m+[m
[32m+[m[32m    // Internal[m
[32m+[m[32m    addr.SetInternal("esffpp");[m
[32m+[m[32m    BOOST_REQUIRE(!addr.IsValid()); // "internal" is considered invalid[m
[32m+[m[32m    BOOST_REQUIRE(addr.IsInternal());[m
[32m+[m
[32m+[m[32m    BOOST_CHECK(!addr.IsBindAny());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(addr.ToString(), "esffpvrt3wpeaygy.internal");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mBOOST_AUTO_TEST_CASE(cnetaddr_serialize)[m
[32m+[m[32m{[m
[32m+[m[32m    CNetAddr addr;[m
[32m+[m[32m    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);[m
[32m+[m
[32m+[m[32m    addr.SetInternal("a");[m
[32m+[m[32m    s << addr;[m
[32m+[m[32m    BOOST_CHECK_EQUAL(HexStr(s), "fd6b88c08724ca978112ca1bbdcafac2");[m
[32m+[m[32m    s.clear();[m
[32m+[m[32m}[m
[32m+[m
 // prior to PR #14728, this test triggers an undefined behavior[m
 BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)[m
 {[m
[33mdiff --git a/src/test/netbase_tests.cpp b/src/test/netbase_tests.cpp[m
[33mindex 49073ea657..6681c92bb5 100644[m
[33m--- a/src/test/netbase_tests.cpp[m
[33m+++ b/src/test/netbase_tests.cpp[m
[36m@@ -185,6 +185,7 @@[m [mBOOST_AUTO_TEST_CASE(subnet_test)[m
     BOOST_CHECK(!ResolveSubNet("1.2.3.0/-1").IsValid());[m
     BOOST_CHECK(ResolveSubNet("1.2.3.0/32").IsValid());[m
     BOOST_CHECK(!ResolveSubNet("1.2.3.0/33").IsValid());[m
[32m+[m[32m    BOOST_CHECK(!ResolveSubNet("1.2.3.0/300").IsValid());[m
     BOOST_CHECK(ResolveSubNet("1:2:3:4:5:6:7:8/0").IsValid());[m
     BOOST_CHECK(ResolveSubNet("1:2:3:4:5:6:7:8/33").IsValid());[m
     BOOST_CHECK(!ResolveSubNet("1:2:3:4:5:6:7:8/-1").IsValid());[m
[36m@@ -216,6 +217,11 @@[m [mBOOST_AUTO_TEST_CASE(subnet_test)[m
     BOOST_CHECK(CSubNet(ResolveIP("1:2:3:4:5:6:7:8")).Match(ResolveIP("1:2:3:4:5:6:7:8")));[m
     BOOST_CHECK(!CSubNet(ResolveIP("1:2:3:4:5:6:7:8")).Match(ResolveIP("1:2:3:4:5:6:7:9")));[m
     BOOST_CHECK(CSubNet(ResolveIP("1:2:3:4:5:6:7:8")).ToString() == "1:2:3:4:5:6:7:8/128");[m
[32m+[m[32m    // IPv4 address with IPv6 netmask or the other way around.[m
[32m+[m[32m    BOOST_CHECK(!CSubNet(ResolveIP("1.1.1.1"), ResolveIP("ffff::")).IsValid());[m
[32m+[m[32m    BOOST_CHECK(!CSubNet(ResolveIP("::1"), ResolveIP("255.0.0.0")).IsValid());[m
[32m+[m[32m    // Can't subnet TOR (or any other non-IPv4 and non-IPv6 network).[m
[32m+[m[32m    BOOST_CHECK(!CSubNet(ResolveIP("5wyqrzbvrdsumnok.onion"), ResolveIP("255.0.0.0")).IsValid());[m
 [m
     subnet = ResolveSubNet("1.2.3.4/255.255.255.255");[m
     BOOST_CHECK_EQUAL(subnet.ToString(), "1.2.3.4/32");[m
[36m@@ -290,11 +296,13 @@[m [mBOOST_AUTO_TEST_CASE(subnet_test)[m
     BOOST_CHECK_EQUAL(subnet.ToString(), "1::/16");[m
     subnet = ResolveSubNet("1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000");[m
     BOOST_CHECK_EQUAL(subnet.ToString(), "::/0");[m
[32m+[m[32m    // Invalid netmasks (with 1-bits after 0-bits)[m
     subnet = ResolveSubNet("1.2.3.4/255.255.232.0");[m
[31m-    BOOST_CHECK_EQUAL(subnet.ToString(), "1.2.0.0/255.255.232.0");[m
[32m+[m[32m    BOOST_CHECK(!subnet.IsValid());[m
[32m+[m[32m    subnet = ResolveSubNet("1.2.3.4/255.0.255.255");[m
[32m+[m[32m    BOOST_CHECK(!subnet.IsValid());[m
     subnet = ResolveSubNet("1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f");[m
[31m-    BOOST_CHECK_EQUAL(subnet.ToString(), "1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f");[m
[31m-[m
[32m+[m[32m    BOOST_CHECK(!subnet.IsValid());[m
 }[m
 [m
 BOOST_AUTO_TEST_CASE(netbase_getgroup)[m
[36m@@ -428,7 +436,8 @@[m [mBOOST_AUTO_TEST_CASE(netbase_dont_resolve_strings_with_embedded_nul_characters)[m
     BOOST_CHECK(!LookupSubNet(std::string("1.2.3.0/24\0", 11), ret));[m
     BOOST_CHECK(!LookupSubNet(std::string("1.2.3.0/24\0example.com", 22), ret));[m
     BOOST_CHECK(!LookupSubNet(std::string("1.2.3.0/24\0example.com\0", 23), ret));[m
[31m-    BOOST_CHECK(LookupSubNet(std::string("5wyqrzbvrdsumnok.onion", 22), ret));[m
[32m+[m[32m    // We only do subnetting for IPv4 and IPv6[m
[32m+[m[32m    BOOST_CHECK(!LookupSubNet(std::string("5wyqrzbvrdsumnok.onion", 22), ret));[m
     BOOST_CHECK(!LookupSubNet(std::string("5wyqrzbvrdsumnok.onion\0", 23), ret));[m
     BOOST_CHECK(!LookupSubNet(std::string("5wyqrzbvrdsumnok.onion\0example.com", 34), ret));[m
     BOOST_CHECK(!LookupSubNet(std::string("5wyqrzbvrdsumnok.onion\0example.com\0", 35), ret));[m
[33mdiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp[m
[33mindex 9d63aad672..8a88e75892 100644[m
[33m--- a/src/test/util/setup_common.cpp[m
[33m+++ b/src/test/util/setup_common.cpp[m
[36m@@ -97,8 +97,8 @@[m [mBasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::ve[m
     SelectParams(chainName);[m
     SeedInsecureRand();[m
     if (G_TEST_LOG_FUN) LogInstance().PushBackCallback(G_TEST_LOG_FUN);[m
[31m-    InitLogging();[m
[31m-    AppInitParameterInteraction();[m
[32m+[m[32m    InitLogging(*m_node.args);[m
[32m+[m[32m    AppInitParameterInteraction(*m_node.args);[m
     LogInstance().StartLogging();[m
     SHA256AutoDetect();[m
     ECC_Start();[m
[36m@@ -141,8 +141,11 @@[m [mTestingSetup::TestingSetup(const std::string& chainName, const std::vector<const[m
 [m
     pblocktree.reset(new CBlockTreeDB(1 << 20, true));[m
 [m
[2m+[m[2m    m_node.mempool = &::mempool;[m
[2m+[m[2m    m_node.mempool->setSanityCheck(1.0);[m
[32m+[m
     m_node.chainman = &::g_chainman;[m
[31m-    m_node.chainman->InitializeChainstate();[m
[32m+[m[32m    m_node.chainman->InitializeChainstate(*m_node.mempool);[m
     ::ChainstateActive().InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
     assert(!::ChainstateActive().CanFlushToDisk());[m
[36m@@ -164,8 +167,6 @@[m [mTestingSetup::TestingSetup(const std::string& chainName, const std::vector<const[m
     }[m
     g_parallel_script_checks = true;[m
 [m
[2m-    m_node.mempool = &::mempool;[m
[2m-    m_node.mempool->setSanityCheck(1.0);[m
     m_node.banman = MakeUnique<BanMan>(GetDataDir() / "banlist.dat", nullptr, DEFAULT_MISBEHAVING_BANTIME);[m
     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.[m
     m_node.peer_logic = MakeUnique<PeerLogicValidation>(*m_node.connman, m_node.banman.get(), *m_node.scheduler, *m_node.chainman, *m_node.mempool);[m
[36m@@ -196,49 +197,34 @@[m [mTestingSetup::~TestingSetup()[m
 [m
 TestChain100Setup::TestChain100Setup()[m
 {[m
[31m-    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.[m
[31m-    // TODO: fix the code to support SegWit blocks.[m
[31m-    gArgs.ForceSetArg("-segwitheight", "432");[m
[31m-    // Need to recreate chainparams[m
[31m-    SelectParams(CBaseChainParams::REGTEST);[m
[31m-[m
     // Generate a 100-block chain:[m
     coinbaseKey.MakeNewKey(true);[m
[31m-    CScript scriptPubKey = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;[m
[31m-    for (int i = 0; i < COINBASE_MATURITY; i++)[m
[31m-    {[m
[32m+[m[32m    CScript scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;[m
[32m+[m[32m    for (int i = 0; i < COINBASE_MATURITY; i++) {[m
         std::vector<CMutableTransaction> noTxns;[m
         CBlock b = CreateAndProcessBlock(noTxns, scriptPubKey);[m
         m_coinbase_txns.push_back(b.vtx[0]);[m
     }[m
 }[m
 [m
[31m-// Create a new block with just given transactions, coinbase paying to[m
[31m-// scriptPubKey, and try to add it to the current chain.[m
 CBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>& txns, const CScript& scriptPubKey)[m
 {[m
     const CChainParams& chainparams = Params();[m
[31m-    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(scriptPubKey);[m
[31m-    CBlock& block = pblocktemplate->block;[m
[32m+[m[32m    CTxMemPool empty_pool;[m
[32m+[m[32m    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(scriptPubKey)->block;[m
 [m
[31m-    // Replace mempool-selected txns with just coinbase plus passed-in txns:[m
[31m-    block.vtx.resize(1);[m
[31m-    for (const CMutableTransaction& tx : txns)[m
[32m+[m[32m    Assert(block.vtx.size() == 1);[m
[32m+[m[32m    for (const CMutableTransaction& tx : txns) {[m
         block.vtx.push_back(MakeTransactionRef(tx));[m
[31m-    // IncrementExtraNonce creates a valid coinbase and merkleRoot[m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        unsigned int extraNonce = 0;[m
[31m-        IncrementExtraNonce(&block, ::ChainActive().Tip(), extraNonce);[m
     }[m
[32m+[m[32m    RegenerateCommitments(block);[m
 [m
     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;[m
 [m
     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);[m
     Assert(m_node.chainman)->ProcessNewBlock(chainparams, shared_pblock, true, nullptr);[m
 [m
[31m-    CBlock result = block;[m
[31m-    return result;[m
[32m+[m[32m    return block;[m
 }[m
 [m
 TestChain100Setup::~TestChain100Setup()[m
[36m@@ -246,8 +232,8 @@[m [mTestChain100Setup::~TestChain100Setup()[m
     gArgs.ForceSetArg("-segwitheight", "0");[m
 }[m
 [m
[31m-[m
[31m-CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction &tx) {[m
[32m+[m[32mCTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction& tx)[m
[32m+[m[32m{[m
     return FromTx(MakeTransactionRef(tx));[m
 }[m
 [m
[33mdiff --git a/src/test/util/setup_common.h b/src/test/util/setup_common.h[m
[33mindex 78b279e42a..22f5d6d936 100644[m
[33m--- a/src/test/util/setup_common.h[m
[33m+++ b/src/test/util/setup_common.h[m
[36m@@ -102,15 +102,16 @@[m [mclass CBlock;[m
 struct CMutableTransaction;[m
 class CScript;[m
 [m
[31m-//[m
[31m-// Testing fixture that pre-creates a[m
[31m-// 100-block REGTEST-mode block chain[m
[31m-//[m
[32m+[m[32m/**[m
[32m+[m[32m * Testing fixture that pre-creates a 100-block REGTEST-mode block chain[m
[32m+[m[32m */[m
 struct TestChain100Setup : public RegTestingSetup {[m
     TestChain100Setup();[m
 [m
[31m-    // Create a new block with just given transactions, coinbase paying to[m
[31m-    // scriptPubKey, and try to add it to the current chain.[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Create a new block with just given transactions, coinbase paying to[m
[32m+[m[32m     * scriptPubKey, and try to add it to the current chain.[m
[32m+[m[32m     */[m
     CBlock CreateAndProcessBlock(const std::vector<CMutableTransaction>& txns,[m
                                  const CScript& scriptPubKey);[m
 [m
[33mdiff --git a/src/test/validation_chainstate_tests.cpp b/src/test/validation_chainstate_tests.cpp[m
[33mindex 2076a1096a..c8a375275f 100644[m
[33m--- a/src/test/validation_chainstate_tests.cpp[m
[33m+++ b/src/test/validation_chainstate_tests.cpp[m
[36m@@ -20,6 +20,7 @@[m [mBOOST_FIXTURE_TEST_SUITE(validation_chainstate_tests, TestingSetup)[m
 BOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)[m
 {[m
     ChainstateManager manager;[m
[32m+[m[32m    CTxMemPool mempool;[m
 [m
     //! Create and add a Coin with DynamicMemoryUsage of 80 bytes to the given view.[m
     auto add_coin = [](CCoinsViewCache& coins_view) -> COutPoint {[m
[36m@@ -34,7 +35,7 @@[m [mBOOST_AUTO_TEST_CASE(validation_chainstate_resize_caches)[m
         return outp;[m
     };[m
 [m
[31m-    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate());[m
[32m+[m[32m    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(mempool));[m
     c1.InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));[m
[33mdiff --git a/src/test/validation_chainstatemanager_tests.cpp b/src/test/validation_chainstatemanager_tests.cpp[m
[33mindex 887a48124f..36badafc4e 100644[m
[33m--- a/src/test/validation_chainstatemanager_tests.cpp[m
[33m+++ b/src/test/validation_chainstatemanager_tests.cpp[m
[36m@@ -23,12 +23,13 @@[m [mBOOST_FIXTURE_TEST_SUITE(validation_chainstatemanager_tests, TestingSetup)[m
 BOOST_AUTO_TEST_CASE(chainstatemanager)[m
 {[m
     ChainstateManager manager;[m
[32m+[m[32m    CTxMemPool mempool;[m
     std::vector<CChainState*> chainstates;[m
     const CChainParams& chainparams = Params();[m
 [m
     // Create a legacy (IBD) chainstate.[m
     //[m
[31m-    CChainState& c1 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate());[m
[32m+[m[32m    CChainState& c1 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate(mempool));[m
     chainstates.push_back(&c1);[m
     c1.InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
[36m@@ -54,7 +55,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
 [m
     // Create a snapshot-based chainstate.[m
     //[m
[31m-    CChainState& c2 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate(GetRandHash()));[m
[32m+[m[32m    CChainState& c2 = *WITH_LOCK(::cs_main, return &manager.InitializeChainstate(mempool, GetRandHash()));[m
     chainstates.push_back(&c2);[m
     c2.InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
[36m@@ -104,6 +105,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
 BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
 {[m
     ChainstateManager manager;[m
[32m+[m[32m    CTxMemPool mempool;[m
     size_t max_cache = 10000;[m
     manager.m_total_coinsdb_cache = max_cache;[m
     manager.m_total_coinstip_cache = max_cache;[m
[36m@@ -112,7 +114,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
 [m
     // Create a legacy (IBD) chainstate.[m
     //[m
[31m-    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate());[m
[32m+[m[32m    CChainState& c1 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(mempool));[m
     chainstates.push_back(&c1);[m
     c1.InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
[36m@@ -129,7 +131,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
 [m
     // Create a snapshot-based chainstate.[m
     //[m
[31m-    CChainState& c2 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(GetRandHash()));[m
[32m+[m[32m    CChainState& c2 = *WITH_LOCK(cs_main, return &manager.InitializeChainstate(mempool, GetRandHash()));[m
     chainstates.push_back(&c2);[m
     c2.InitCoinsDB([m
         /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
[36m@@ -147,7 +149,6 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
     BOOST_CHECK_CLOSE(c1.m_coinsdb_cache_size_bytes, max_cache * 0.05, 1);[m
     BOOST_CHECK_CLOSE(c2.m_coinstip_cache_size_bytes, max_cache * 0.95, 1);[m
     BOOST_CHECK_CLOSE(c2.m_coinsdb_cache_size_bytes, max_cache * 0.95, 1);[m
[31m-[m
 }[m
 [m
 BOOST_AUTO_TEST_SUITE_END()[m
[33mdiff --git a/src/test/validation_flush_tests.cpp b/src/test/validation_flush_tests.cpp[m
[33mindex 8bac914f05..a3b344d2c9 100644[m
[33m--- a/src/test/validation_flush_tests.cpp[m
[33m+++ b/src/test/validation_flush_tests.cpp[m
[36m@@ -18,8 +18,9 @@[m [mBOOST_FIXTURE_TEST_SUITE(validation_flush_tests, BasicTestingSetup)[m
 //![m
 BOOST_AUTO_TEST_CASE(getcoinscachesizestate)[m
 {[m
[32m+[m[32m    CTxMemPool mempool;[m
     BlockManager blockman{};[m
[31m-    CChainState chainstate{blockman};[m
[32m+[m[32m    CChainState chainstate{mempool, blockman};[m
     chainstate.InitCoinsDB(/*cache_size_bytes*/ 1 << 10, /*in_memory*/ true, /*should_wipe*/ false);[m
     WITH_LOCK(::cs_main, chainstate.InitCoinsCache(1 << 10));[m
     CTxMemPool tx_pool{};[m
[33mdiff --git a/src/threadsafety.h b/src/threadsafety.h[m
[33mindex 5f2c40bac6..52bf83b676 100644[m
[33m--- a/src/threadsafety.h[m
[33m+++ b/src/threadsafety.h[m
[36m@@ -18,9 +18,7 @@[m
 #define LOCKABLE __attribute__((lockable))[m
 #define SCOPED_LOCKABLE __attribute__((scoped_lockable))[m
 #define GUARDED_BY(x) __attribute__((guarded_by(x)))[m
[31m-#define GUARDED_VAR __attribute__((guarded_var))[m
 #define PT_GUARDED_BY(x) __attribute__((pt_guarded_by(x)))[m
[31m-#define PT_GUARDED_VAR __attribute__((pt_guarded_var))[m
 #define ACQUIRED_AFTER(...) __attribute__((acquired_after(__VA_ARGS__)))[m
 #define ACQUIRED_BEFORE(...) __attribute__((acquired_before(__VA_ARGS__)))[m
 #define EXCLUSIVE_LOCK_FUNCTION(...) __attribute__((exclusive_lock_function(__VA_ARGS__)))[m
[36m@@ -33,14 +31,12 @@[m
 #define EXCLUSIVE_LOCKS_REQUIRED(...) __attribute__((exclusive_locks_required(__VA_ARGS__)))[m
 #define SHARED_LOCKS_REQUIRED(...) __attribute__((shared_locks_required(__VA_ARGS__)))[m
 #define NO_THREAD_SAFETY_ANALYSIS __attribute__((no_thread_safety_analysis))[m
[31m-#define ASSERT_EXCLUSIVE_LOCK(...) __attribute((assert_exclusive_lock(__VA_ARGS__)))[m
[32m+[m[32m#define ASSERT_EXCLUSIVE_LOCK(...) __attribute__((assert_exclusive_lock(__VA_ARGS__)))[m
 #else[m
 #define LOCKABLE[m
 #define SCOPED_LOCKABLE[m
 #define GUARDED_BY(x)[m
[31m-#define GUARDED_VAR[m
 #define PT_GUARDED_BY(x)[m
[31m-#define PT_GUARDED_VAR[m
 #define ACQUIRED_AFTER(...)[m
 #define ACQUIRED_BEFORE(...)[m
 #define EXCLUSIVE_LOCK_FUNCTION(...)[m
[33mdiff --git a/src/util/message.cpp b/src/util/message.cpp[m
[33mindex 1e7128d225..e1d5cff48c 100644[m
[33m--- a/src/util/message.cpp[m
[33m+++ b/src/util/message.cpp[m
[36m@@ -64,7 +64,7 @@[m [mbool MessageSign([m
         return false;[m
     }[m
 [m
[31m-    signature = EncodeBase64(signature_bytes.data(), signature_bytes.size());[m
[32m+[m[32m    signature = EncodeBase64(signature_bytes);[m
 [m
     return true;[m
 }[m
[33mdiff --git a/src/util/strencodings.cpp b/src/util/strencodings.cpp[m
[33mindex 4d51b9045e..079a4529a3 100644[m
[33m--- a/src/util/strencodings.cpp[m
[33m+++ b/src/util/strencodings.cpp[m
[36m@@ -126,20 +126,20 @@[m [mvoid SplitHostPort(std::string in, int &portOut, std::string &hostOut) {[m
         hostOut = in;[m
 }[m
 [m
[31m-std::string EncodeBase64(const unsigned char* pch, size_t len)[m
[32m+[m[32mstd::string EncodeBase64(Span<const unsigned char> input)[m
 {[m
     static const char *pbase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";[m
 [m
     std::string str;[m
[31m-    str.reserve(((len + 2) / 3) * 4);[m
[31m-    ConvertBits<8, 6, true>([&](int v) { str += pbase64[v]; }, pch, pch + len);[m
[32m+[m[32m    str.reserve(((input.size() + 2) / 3) * 4);[m
[32m+[m[32m    ConvertBits<8, 6, true>([&](int v) { str += pbase64[v]; }, input.begin(), input.end());[m
     while (str.size() % 4) str += '=';[m
     return str;[m
 }[m
 [m
 std::string EncodeBase64(const std::string& str)[m
 {[m
[31m-    return EncodeBase64((const unsigned char*)str.data(), str.size());[m
[32m+[m[32m    return EncodeBase64(MakeUCharSpan(str));[m
 }[m
 [m
 std::vector<unsigned char> DecodeBase64(const char* p, bool* pf_invalid)[m
[36m@@ -201,20 +201,20 @@[m [mstd::string DecodeBase64(const std::string& str, bool* pf_invalid)[m
     return std::string((const char*)vchRet.data(), vchRet.size());[m
 }[m
 [m
[31m-std::string EncodeBase32(const unsigned char* pch, size_t len)[m
[32m+[m[32mstd::string EncodeBase32(Span<const unsigned char> input)[m
 {[m
     static const char *pbase32 = "abcdefghijklmnopqrstuvwxyz234567";[m
 [m
     std::string str;[m
[31m-    str.reserve(((len + 4) / 5) * 8);[m
[31m-    ConvertBits<8, 5, true>([&](int v) { str += pbase32[v]; }, pch, pch + len);[m
[32m+[m[32m    str.reserve(((input.size() + 4) / 5) * 8);[m
[32m+[m[32m    ConvertBits<8, 5, true>([&](int v) { str += pbase32[v]; }, input.begin(), input.end());[m
     while (str.size() % 8) str += '=';[m
     return str;[m
 }[m
 [m
 std::string EncodeBase32(const std::string& str)[m
 {[m
[31m-    return EncodeBase32((const unsigned char*)str.data(), str.size());[m
[32m+[m[32m    return EncodeBase32(MakeUCharSpan(str));[m
 }[m
 [m
 std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)[m
[36m@@ -318,6 +318,18 @@[m [mbool ParseInt64(const std::string& str, int64_t *out)[m
         n <= std::numeric_limits<int64_t>::max();[m
 }[m
 [m
[32m+[m[32mbool ParseUInt8(const std::string& str, uint8_t *out)[m
[32m+[m[32m{[m
[32m+[m[32m    uint32_t u32;[m
[32m+[m[32m    if (!ParseUInt32(str, &u32) || u32 > std::numeric_limits<uint8_t>::max()) {[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m    if (out != nullptr) {[m
[32m+[m[32m        *out = static_cast<uint8_t>(u32);[m
[32m+[m[32m    }[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
 bool ParseUInt32(const std::string& str, uint32_t *out)[m
 {[m
     if (!ParsePrechecks(str))[m
[33mdiff --git a/src/util/strencodings.h b/src/util/strencodings.h[m
[33mindex b4bbaeebf6..1519214140 100644[m
[33m--- a/src/util/strencodings.h[m
[33m+++ b/src/util/strencodings.h[m
[36m@@ -48,11 +48,11 @@[m [mbool IsHex(const std::string& str);[m
 bool IsHexNumber(const std::string& str);[m
 std::vector<unsigned char> DecodeBase64(const char* p, bool* pf_invalid = nullptr);[m
 std::string DecodeBase64(const std::string& str, bool* pf_invalid = nullptr);[m
[31m-std::string EncodeBase64(const unsigned char* pch, size_t len);[m
[32m+[m[32mstd::string EncodeBase64(Span<const unsigned char> input);[m
 std::string EncodeBase64(const std::string& str);[m
 std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid = nullptr);[m
 std::string DecodeBase32(const std::string& str, bool* pf_invalid = nullptr);[m
[31m-std::string EncodeBase32(const unsigned char* pch, size_t len);[m
[32m+[m[32mstd::string EncodeBase32(Span<const unsigned char> input);[m
 std::string EncodeBase32(const std::string& str);[m
 [m
 void SplitHostPort(std::string in, int& portOut, std::string& hostOut);[m
[36m@@ -98,6 +98,13 @@[m [mNODISCARD bool ParseInt32(const std::string& str, int32_t *out);[m
  */[m
 NODISCARD bool ParseInt64(const std::string& str, int64_t *out);[m
 [m
[32m+[m[32m/**[m
[32m+[m[32m * Convert decimal string to unsigned 8-bit integer with strict parse error feedback.[m
[32m+[m[32m * @returns true if the entire string could be parsed as valid integer,[m
[32m+[m[32m *   false if not the entire string could be parsed or when overflow or underflow occurred.[m
[32m+[m[32m */[m
[32m+[m[32mNODISCARD bool ParseUInt8(const std::string& str, uint8_t *out);[m
[32m+[m
 /**[m
  * Convert decimal string to unsigned 32-bit integer with strict parse error feedback.[m
  * @returns true if the entire string could be parsed as valid integer,[m
[33mdiff --git a/src/util/system.cpp b/src/util/system.cpp[m
[33mindex 7b74789b32..999937d906 100644[m
[33m--- a/src/util/system.cpp[m
[33m+++ b/src/util/system.cpp[m
[36m@@ -48,12 +48,6 @@[m
 #pragma warning(disable:4717)[m
 #endif[m
 [m
[31m-#ifdef _WIN32_IE[m
[31m-#undef _WIN32_IE[m
[31m-#endif[m
[31m-#define _WIN32_IE 0x0501[m
[31m-[m
[31m-#define WIN32_LEAN_AND_MEAN 1[m
 #ifndef NOMINMAX[m
 #define NOMINMAX[m
 #endif[m
[36m@@ -1025,7 +1019,7 @@[m [mbool FileCommit(FILE *file)[m
         return false;[m
     }[m
 #else[m
[31m-    #if defined(HAVE_FDATASYNC)[m
[32m+[m[32m    #if HAVE_FDATASYNC[m
     if (fdatasync(fileno(file)) != 0 && errno != EINVAL) { // Ignore EINVAL for filesystems that don't support sync[m
         LogPrintf("%s: fdatasync failed: %d\n", __func__, errno);[m
         return false;[m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex cf2f9dde62..58af8744d9 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -370,9 +370,10 @@[m [mstatic bool IsCurrentForFeeEstimation() EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
  * and instead just erase from the mempool as needed.[m
  */[m
 [m
[31m-static void UpdateMempoolForReorg(DisconnectedBlockTransactions& disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs)[m
[32m+[m[32mstatic void UpdateMempoolForReorg(CTxMemPool& mempool, DisconnectedBlockTransactions& disconnectpool, bool fAddToMempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, mempool.cs)[m
 {[m
     AssertLockHeld(cs_main);[m
[32m+[m[32m    AssertLockHeld(mempool.cs);[m
     std::vector<uint256> vHashUpdate;[m
     // disconnectpool's insertion_order index sorts the entries from[m
     // oldest to newest, but the oldest entry will be the last tx from the[m
[36m@@ -1254,8 +1255,9 @@[m [mvoid CoinsViews::InitCache()[m
     m_cacheview = MakeUnique<CCoinsViewCache>(&m_catcherview);[m
 }[m
 [m
[31m-CChainState::CChainState(BlockManager& blockman, uint256 from_snapshot_blockhash)[m
[32m+[m[32mCChainState::CChainState(CTxMemPool& mempool, BlockManager& blockman, uint256 from_snapshot_blockhash)[m
     : m_blockman(blockman),[m
[32m+[m[32m      m_mempool(mempool),[m
       m_from_snapshot_blockhash(from_snapshot_blockhash) {}[m
 [m
 void CChainState::InitCoinsDB([m
[36m@@ -2280,7 +2282,7 @@[m [mbool CChainState::FlushStateToDisk([m
     {[m
         bool fFlushForPrune = false;[m
         bool fDoFullFlush = false;[m
[31m-        CoinsCacheSizeState cache_state = GetCoinsCacheSizeState(&::mempool);[m
[32m+[m[32m        CoinsCacheSizeState cache_state = GetCoinsCacheSizeState(&m_mempool);[m
         LOCK(cs_LastBlockFile);[m
         if (fPruneMode && (fCheckForPruning || nManualPruneHeight > 0) && !fReindex) {[m
             if (nManualPruneHeight > 0) {[m
[36m@@ -2426,7 +2428,7 @@[m [mstatic void AppendWarning(bilingual_str& res, const bilingual_str& warn)[m
 }[m
 [m
 /** Check warning conditions and do some notifications on new chain tip set. */[m
[31m-void static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainParams)[m
[32m+[m[32mstatic void UpdateTip(CTxMemPool& mempool, const CBlockIndex* pindexNew, const CChainParams& chainParams)[m
     EXCLUSIVE_LOCKS_REQUIRED(::cs_main)[m
 {[m
     // New best block[m
[36m@@ -2472,7 +2474,6 @@[m [mvoid static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainPar[m
       FormatISO8601DateTime(pindexNew->GetBlockTime()),[m
       GuessVerificationProgress(chainParams.TxData(), pindexNew), ::ChainstateActive().CoinsTip().DynamicMemoryUsage() * (1.0 / (1<<20)), ::ChainstateActive().CoinsTip().GetCacheSize(),[m
       !warning_messages.empty() ? strprintf(" warning='%s'", warning_messages.original) : "");[m
[31m-[m
 }[m
 [m
 /** Disconnect m_chain's tip.[m
[36m@@ -2485,8 +2486,11 @@[m [mvoid static UpdateTip(const CBlockIndex* pindexNew, const CChainParams& chainPar[m
   * disconnectpool (note that the caller is responsible for mempool consistency[m
   * in any case).[m
   */[m
[31m-bool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)[m
[32m+[m[32mbool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool)[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_main);[m
[32m+[m[32m    AssertLockHeld(m_mempool.cs);[m
[32m+[m
     CBlockIndex *pindexDelete = m_chain.Tip();[m
     assert(pindexDelete);[m
     // Read block from disk.[m
[36m@@ -2517,14 +2521,14 @@[m [mbool CChainState::DisconnectTip(BlockValidationState& state, const CChainParams&[m
         while (disconnectpool->DynamicMemoryUsage() > MAX_DISCONNECTED_TX_POOL_SIZE * 1000) {[m
             // Drop the earliest entry, and remove its children from the mempool.[m
             auto it = disconnectpool->queuedTx.get<insertion_order>().begin();[m
[31m-            mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);[m
[32m+[m[32m            m_mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);[m
             disconnectpool->removeEntry(it);[m
         }[m
     }[m
 [m
     m_chain.SetTip(pindexDelete->pprev);[m
 [m
[31m-    UpdateTip(pindexDelete->pprev, chainparams);[m
[32m+[m[32m    UpdateTip(m_mempool, pindexDelete->pprev, chainparams);[m
     // Let wallets know transactions went from 1-confirmed to[m
     // 0-confirmed or conflicted:[m
     GetMainSignals().BlockDisconnected(pblock, pindexDelete);[m
[36m@@ -2585,6 +2589,9 @@[m [mpublic:[m
  */[m
 bool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_main);[m
[32m+[m[32m    AssertLockHeld(m_mempool.cs);[m
[32m+[m
     assert(pindexNew->pprev == m_chain.Tip());[m
     // Read block from disk.[m
     int64_t nTime1 = GetTimeMicros();[m
[36m@@ -2625,11 +2632,11 @@[m [mbool CChainState::ConnectTip(BlockValidationState& state, const CChainParams& ch[m
     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;[m
     LogPrint(BCLog::BENCH, "  - Writing chainstate: %.2fms [%.2fs (%.2fms/blk)]\n", (nTime5 - nTime4) * MILLI, nTimeChainState * MICRO, nTimeChainState * MILLI / nBlocksTotal);[m
     // Remove conflicting transactions from the mempool.;[m
[31m-    mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);[m
[32m+[m[32m    m_mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);[m
     disconnectpool.removeForBlock(blockConnecting.vtx);[m
     // Update m_chain & related variables.[m
     m_chain.SetTip(pindexNew);[m
[31m-    UpdateTip(pindexNew, chainparams);[m
[32m+[m[32m    UpdateTip(m_mempool, pindexNew, chainparams);[m
 [m
     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;[m
     LogPrint(BCLog::BENCH, "  - Connect postprocess: %.2fms [%.2fs (%.2fms/blk)]\n", (nTime6 - nTime5) * MILLI, nTimePostConnect * MICRO, nTimePostConnect * MILLI / nBlocksTotal);[m
[36m@@ -2719,6 +2726,7 @@[m [mvoid CChainState::PruneBlockIndexCandidates() {[m
 bool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace)[m
 {[m
     AssertLockHeld(cs_main);[m
[32m+[m[32m    AssertLockHeld(m_mempool.cs);[m
 [m
     const CBlockIndex *pindexOldTip = m_chain.Tip();[m
     const CBlockIndex *pindexFork = m_chain.FindFork(pindexMostWork);[m
[36m@@ -2730,7 +2738,7 @@[m [mbool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai[m
         if (!DisconnectTip(state, chainparams, &disconnectpool)) {[m
             // This is likely a fatal error, but keep the mempool consistent,[m
             // just in case. Only remove from the mempool in this case.[m
[31m-            UpdateMempoolForReorg(disconnectpool, false);[m
[32m+[m[32m            UpdateMempoolForReorg(m_mempool, disconnectpool, false);[m
 [m
             // If we're unable to disconnect a block during normal operation,[m
             // then that is a failure of our local system -- we should abort[m
[36m@@ -2774,7 +2782,7 @@[m [mbool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai[m
                     // A system error occurred (disk space, database error, ...).[m
                     // Make the mempool consistent with the current tip, just in case[m
                     // any observers try to use it before shutdown.[m
[31m-                    UpdateMempoolForReorg(disconnectpool, false);[m
[32m+[m[32m                    UpdateMempoolForReorg(m_mempool, disconnectpool, false);[m
                     return false;[m
                 }[m
             } else {[m
[36m@@ -2791,9 +2799,9 @@[m [mbool CChainState::ActivateBestChainStep(BlockValidationState& state, const CChai[m
     if (fBlocksDisconnected) {[m
         // If any blocks were disconnected, disconnectpool may be non empty.  Add[m
         // any disconnected transactions back to the mempool.[m
[31m-        UpdateMempoolForReorg(disconnectpool, true);[m
[32m+[m[32m        UpdateMempoolForReorg(m_mempool, disconnectpool, true);[m
     }[m
[31m-    mempool.check(&CoinsTip());[m
[32m+[m[32m    m_mempool.check(&CoinsTip());[m
 [m
     // Callbacks/notifications for a new best chain.[m
     if (fInvalidFound)[m
[36m@@ -2867,7 +2875,8 @@[m [mbool CChainState::ActivateBestChain(BlockValidationState &state, const CChainPar[m
         LimitValidationInterfaceQueue();[m
 [m
         {[m
[31m-            LOCK2(cs_main, ::mempool.cs); // Lock transaction pool for at least as long as it takes for connectTrace to be consumed[m
[32m+[m[32m            LOCK(cs_main);[m
[32m+[m[32m            LOCK(m_mempool.cs); // Lock transaction pool for at least as long as it takes for connectTrace to be consumed[m
             CBlockIndex* starting_tip = m_chain.Tip();[m
             bool blocks_connected = false;[m
             do {[m
[36m@@ -3020,7 +3029,7 @@[m [mbool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam[m
         LimitValidationInterfaceQueue();[m
 [m
         LOCK(cs_main);[m
[31m-        LOCK(::mempool.cs); // Lock for as long as disconnectpool is in scope to make sure UpdateMempoolForReorg is called after DisconnectTip without unlocking in between[m
[32m+[m[32m        LOCK(m_mempool.cs); // Lock for as long as disconnectpool is in scope to make sure UpdateMempoolForReorg is called after DisconnectTip without unlocking in between[m
         if (!m_chain.Contains(pindex)) break;[m
         pindex_was_in_chain = true;[m
         CBlockIndex *invalid_walk_tip = m_chain.Tip();[m
[36m@@ -3034,7 +3043,7 @@[m [mbool CChainState::InvalidateBlock(BlockValidationState& state, const CChainParam[m
         // transactions back to the mempool if disconnecting was successful,[m
         // and we're not doing a very deep invalidation (in which case[m
         // keeping the mempool up to date is probably futile anyway).[m
[31m-        UpdateMempoolForReorg(disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);[m
[32m+[m[32m        UpdateMempoolForReorg(m_mempool, disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);[m
         if (!ret) return false;[m
         assert(invalid_walk_tip->pprev == m_chain.Tip());[m
 [m
[36m@@ -4517,7 +4526,8 @@[m [mbool CChainState::RewindBlockIndex(const CChainParams& params)[m
     // Loop until the tip is below nHeight, or we reach a pruned block.[m
     while (!ShutdownRequested()) {[m
         {[m
[31m-            LOCK2(cs_main, ::mempool.cs);[m
[32m+[m[32m            LOCK(cs_main);[m
[32m+[m[32m            LOCK(m_mempool.cs);[m
             // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)[m
             assert(tip == m_chain.Tip());[m
             if (tip == nullptr || tip->nHeight < nHeight) break;[m
[36m@@ -5246,7 +5256,7 @@[m [mstd::vector<CChainState*> ChainstateManager::GetAll()[m
     return out;[m
 }[m
 [m
[31m-CChainState& ChainstateManager::InitializeChainstate(const uint256& snapshot_blockhash)[m
[32m+[m[32mCChainState& ChainstateManager::InitializeChainstate(CTxMemPool& mempool, const uint256& snapshot_blockhash)[m
 {[m
     bool is_snapshot = !snapshot_blockhash.IsNull();[m
     std::unique_ptr<CChainState>& to_modify =[m
[36m@@ -5255,8 +5265,7 @@[m [mCChainState& ChainstateManager::InitializeChainstate(const uint256& snapshot_blo[m
     if (to_modify) {[m
         throw std::logic_error("should not be overwriting a chainstate");[m
     }[m
[31m-[m
[31m-    to_modify.reset(new CChainState(m_blockman, snapshot_blockhash));[m
[32m+[m[32m    to_modify.reset(new CChainState(mempool, m_blockman, snapshot_blockhash));[m
 [m
     // Snapshot chainstates and initial IBD chaintates always become active.[m
     if (is_snapshot || (!is_snapshot && !m_active_chainstate)) {[m
[33mdiff --git a/src/validation.h b/src/validation.h[m
[33mindex 534162d64a..cac9473c7a 100644[m
[33m--- a/src/validation.h[m
[33m+++ b/src/validation.h[m
[36m@@ -245,7 +245,7 @@[m [mbool TestLockPointValidity(const LockPoints* lp) EXCLUSIVE_LOCKS_REQUIRED(cs_mai[m
  *[m
  * See consensus/consensus.h for flag definitions.[m
  */[m
[31m-bool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m[32mbool CheckSequenceLocks(const CTxMemPool& pool, const CTransaction& tx, int flags, LockPoints* lp = nullptr, bool useExistingLockPoints = false) EXCLUSIVE_LOCKS_REQUIRED(::cs_main, pool.cs);[m
 [m
 /**[m
  * Closure representing one script verification[m
[36m@@ -511,11 +511,14 @@[m [mprivate:[m
     //! easily as opposed to referencing a global.[m
     BlockManager& m_blockman;[m
 [m
[32m+[m[32m    //! mempool that is kept in sync with the chain[m
[32m+[m[32m    CTxMemPool& m_mempool;[m
[32m+[m
     //! Manages the UTXO set, which is a reflection of the contents of `m_chain`.[m
     std::unique_ptr<CoinsViews> m_coins_views;[m
 [m
 public:[m
[31m-    explicit CChainState(BlockManager& blockman, uint256 from_snapshot_blockhash = uint256());[m
[32m+[m[32m    explicit CChainState(CTxMemPool& mempool, BlockManager& blockman, uint256 from_snapshot_blockhash = uint256());[m
 [m
     /**[m
      * Initialize the CoinsViews UTXO set database management data structures. The in-memory[m
[36m@@ -642,7 +645,7 @@[m [mpublic:[m
                       CCoinsViewCache& view, const CChainParams& chainparams, bool fJustCheck = false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
     // Apply the effects of a block disconnection on the UTXO set.[m
[31m-    bool DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);[m
[32m+[m[32m    bool DisconnectTip(BlockValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions* disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);[m
 [m
     // Manual block validity manipulation:[m
     bool PreciousBlock(BlockValidationState& state, const CChainParams& params, CBlockIndex* pindex) LOCKS_EXCLUDED(cs_main);[m
[36m@@ -685,8 +688,8 @@[m [mpublic:[m
     std::string ToString() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
 [m
 private:[m
[31m-    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);[m
[31m-    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, ::mempool.cs);[m
[32m+[m[32m    bool ActivateBestChainStep(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);[m
[32m+[m[32m    bool ConnectTip(BlockValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions& disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_mempool.cs);[m
 [m
     void InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[36m@@ -818,9 +821,11 @@[m [mpublic:[m
     //! Instantiate a new chainstate and assign it based upon whether it is[m
     //! from a snapshot.[m
     //![m
[32m+[m[32m    //! @param[in] mempool              The mempool to pass to the chainstate[m
[32m+[m[32m    //                                  constructor[m
     //! @param[in] snapshot_blockhash   If given, signify that this chainstate[m
     //!                                 is based on a snapshot.[m
[31m-    CChainState& InitializeChainstate(const uint256& snapshot_blockhash = uint256())[m
[32m+[m[32m    CChainState& InitializeChainstate(CTxMemPool& mempool, const uint256& snapshot_blockhash = uint256())[m
         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
 [m
     //! Get all chainstates currently being used.[m
[33mdiff --git a/src/wallet/init.cpp b/src/wallet/init.cpp[m
[33mindex bf05ef844a..3910599ca7 100644[m
[33m--- a/src/wallet/init.cpp[m
[33m+++ b/src/wallet/init.cpp[m
[36m@@ -5,6 +5,7 @@[m
 [m
 #include <init.h>[m
 #include <interfaces/chain.h>[m
[32m+[m[32m#include <interfaces/wallet.h>[m
 #include <net.h>[m
 #include <node/context.h>[m
 #include <node/ui_interface.h>[m
[36m@@ -66,13 +67,13 @@[m [mvoid WalletInit::AddWalletOptions(ArgsManager& argsman) const[m
     argsman.AddArg("-walletnotify=<cmd>", "Execute command when a wallet transaction changes. %s in cmd is replaced by TxID and %w is replaced by wallet name. %w is not currently implemented on windows. On systems where %w is supported, it should NOT be quoted because this would break shell escaping used to invoke the command.", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);[m
 #endif[m
     argsman.AddArg("-walletrbf", strprintf("Send transactions with full-RBF opt-in enabled (RPC only, default: %u)", DEFAULT_WALLET_RBF), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);[m
[31m-    argsman.AddArg("-zapwallettxes=<mode>", "Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup"[m
[31m-                               " (1 = keep tx meta data e.g. payment request information, 2 = drop tx meta data)", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);[m
 [m
     argsman.AddArg("-dblogsize=<n>", strprintf("Flush wallet database activity from memory to disk log every <n> megabytes (default: %u)", DEFAULT_WALLET_DBLOGSIZE), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::WALLET_DEBUG_TEST);[m
     argsman.AddArg("-flushwallet", strprintf("Run a thread to flush wallet periodically (default: %u)", DEFAULT_FLUSHWALLET), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::WALLET_DEBUG_TEST);[m
     argsman.AddArg("-privdb", strprintf("Sets the DB_PRIVATE flag in the wallet db environment (default: %u)", DEFAULT_WALLET_PRIVDB), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::WALLET_DEBUG_TEST);[m
     argsman.AddArg("-walletrejectlongchains", strprintf("Wallet will not create transactions that violate mempool chain limits (default: %u)", DEFAULT_WALLET_REJECT_LONG_CHAINS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::WALLET_DEBUG_TEST);[m
[32m+[m
[32m+[m[32m    argsman.AddHiddenArgs({"-zapwallettxes"});[m
 }[m
 [m
 bool WalletInit::ParameterInteraction() const[m
[36m@@ -85,26 +86,12 @@[m [mbool WalletInit::ParameterInteraction() const[m
         return true;[m
     }[m
 [m
[31m-    const bool is_multiwallet = gArgs.GetArgs("-wallet").size() > 1;[m
[31m-[m
     if (gArgs.GetBoolArg("-blocksonly", DEFAULT_BLOCKSONLY) && gArgs.SoftSetBoolArg("-walletbroadcast", false)) {[m
         LogPrintf("%s: parameter interaction: -blocksonly=1 -> setting -walletbroadcast=0\n", __func__);[m
     }[m
 [m
[31m-    bool zapwallettxes = gArgs.GetBoolArg("-zapwallettxes", false);[m
[31m-    // -zapwallettxes implies dropping the mempool on startup[m
[31m-    if (zapwallettxes && gArgs.SoftSetBoolArg("-persistmempool", false)) {[m
[31m-        LogPrintf("%s: parameter interaction: -zapwallettxes enabled -> setting -persistmempool=0\n", __func__);[m
[31m-    }[m
[31m-[m
[31m-    // -zapwallettxes implies a rescan[m
[31m-    if (zapwallettxes) {[m
[31m-        if (is_multiwallet) {[m
[31m-            return InitError(strprintf(Untranslated("%s is only allowed with a single wallet file"), "-zapwallettxes"));[m
[31m-        }[m
[31m-        if (gArgs.SoftSetBoolArg("-rescan", true)) {[m
[31m-            LogPrintf("%s: parameter interaction: -zapwallettxes enabled -> setting -rescan=1\n", __func__);[m
[31m-        }[m
[32m+[m[32m    if (gArgs.IsArgSet("-zapwallettxes")) {[m
[32m+[m[32m        return InitError(Untranslated("-zapwallettxes has been removed. If you are attempting to remove a stuck transaction from your wallet, please use abandontransaction instead."));[m
     }[m
 [m
     if (gArgs.GetBoolArg("-sysperms", false))[m
[36m@@ -129,5 +116,7 @@[m [mvoid WalletInit::Construct(NodeContext& node) const[m
             settings.rw_settings["wallet"] = wallets;[m
         });[m
     }[m
[31m-    node.chain_clients.emplace_back(interfaces::MakeWalletClient(*node.chain, args, args.GetArgs("-wallet")));[m
[32m+[m[32m    auto wallet_client = interfaces::MakeWalletClient(*node.chain, args, args.GetArgs("-wallet"));[m
[32m+[m[32m    node.wallet_client = wallet_client.get();[m
[32m+[m[32m    node.chain_clients.emplace_back(std::move(wallet_client));[m
 }[m
[33mdiff --git a/src/wallet/rpcdump.cpp b/src/wallet/rpcdump.cpp[m
[33mindex e0c3a1287a..9e36a09780 100644[m
[33m--- a/src/wallet/rpcdump.cpp[m
[33m+++ b/src/wallet/rpcdump.cpp[m
[36m@@ -90,9 +90,9 @@[m [mstatic void RescanWallet(CWallet& wallet, const WalletRescanReserver& reserver,[m
     }[m
 }[m
 [m
[31m-UniValue importprivkey(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan importprivkey()[m
 {[m
[31m-            RPCHelpMan{"importprivkey",[m
[32m+[m[32m    return RPCHelpMan{"importprivkey",[m
                 "\nAdds a private key (as returned by dumpprivkey) to your wallet. Requires a new wallet backup.\n"[m
                 "Hint: use importmulti to import more than one private key.\n"[m
             "\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"[m
[36m@@ -116,8 +116,8 @@[m [mUniValue importprivkey(const JSONRPCRequest& request)[m
             "\nAs a JSON-RPC call\n"[m
             + HelpExampleRpc("importprivkey", "\"mykey\", \"testing\", false")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -189,11 +189,13 @@[m [mUniValue importprivkey(const JSONRPCRequest& request)[m
     }[m
 [m
     return NullUniValue;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-UniValue abortrescan(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan abortrescan()[m
 {[m
[31m-            RPCHelpMan{"abortrescan",[m
[32m+[m[32m    return RPCHelpMan{"abortrescan",[m
                 "\nStops current wallet rescan triggered by an RPC call, e.g. by an importprivkey call.\n"[m
                 "Note: Use \"getwalletinfo\" to query the scanning progress.\n",[m
                 {},[m
[36m@@ -206,8 +208,8 @@[m [mUniValue abortrescan(const JSONRPCRequest& request)[m
             "\nAs a JSON-RPC call\n"[m
             + HelpExampleRpc("abortrescan", "")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -215,11 +217,13 @@[m [mUniValue abortrescan(const JSONRPCRequest& request)[m
     if (!pwallet->IsScanning() || pwallet->IsAbortingRescan()) return false;[m
     pwallet->AbortRescan();[m
     return true;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-UniValue importaddress(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan importaddress()[m
 {[m
[31m-            RPCHelpMan{"importaddress",[m
[32m+[m[32m    return RPCHelpMan{"importaddress",[m
                 "\nAdds an address or script (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\n"[m
             "\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"[m
             "may report that the imported address exists but related transactions are still missing, leading to temporarily incorrect/bogus balances and unspent outputs until rescan completes.\n"[m
[36m@@ -243,8 +247,8 @@[m [mUniValue importaddress(const JSONRPCRequest& request)[m
             "\nAs a JSON-RPC call\n"[m
             + HelpExampleRpc("importaddress", "\"myaddress\", \"testing\", false")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -315,11 +319,13 @@[m [mUniValue importaddress(const JSONRPCRequest& request)[m
     }[m
 [m
     return NullUniValue;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-UniValue importprunedfunds(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan importprunedfunds()[m
 {[m
[31m-            RPCHelpMan{"importprunedfunds",[m
[32m+[m[32m    return RPCHelpMan{"importprunedfunds",[m
                 "\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\n",[m
                 {[m
                     {"rawtransaction", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "A raw transaction in hex funding an already-existing address in wallet"},[m
[36m@@ -327,8 +333,8 @@[m [mUniValue importprunedfunds(const JSONRPCRequest& request)[m
                 },[m
                 RPCResult{RPCResult::Type::NONE, "", ""},[m
                 RPCExamples{""},[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -371,11 +377,13 @@[m [mUniValue importprunedfunds(const JSONRPCRequest& request)[m
     }[m
 [m
     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No addresses in wallet correspond to included transaction");[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-UniValue removeprunedfunds(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan removeprunedfunds()[m
 {[m
[31m-            RPCHelpMan{"removeprunedfunds",[m
[32m+[m[32m    return RPCHelpMan{"removeprunedfunds",[m
                 "\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.\n",[m
                 {[m
                     {"txid", RPCArg::Type::STR_HEX, RPCArg::Optional::NO, "The hex-encoded id of the transaction you are deleting"},[m
[36m@@ -386,8 +394,8 @@[m [mUniValue removeprunedfunds(const JSONRPCRequest& request)[m
             "\nAs a JSON-RPC call\n"[m
             + HelpExampleRpc("removeprunedfunds", "\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\"")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -408,11 +416,13 @@[m [mUniValue removeprunedfunds(const JSONRPCRequest& request)[m
     }[m
 [m
     return NullUniValue;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-UniValue importpubkey(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan importpubkey()[m
 {[m
[31m-            RPCHelpMan{"importpubkey",[m
[32m+[m[32m    return RPCHelpMan{"importpubkey",[m
                 "\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend. Requires a new wallet backup.\n"[m
                 "Hint: use importmulti to import more than one public key.\n"[m
             "\nNote: This call can take over an hour to complete if rescan is true, during that time, other rpc calls\n"[m
[36m@@ -432,8 +442,8 @@[m [mUniValue importpubkey(const JSONRPCRequest& request)[m
             "\nAs a JSON-RPC call\n"[m
             + HelpExampleRpc("importpubkey", "\"mypubkey\", \"testing\", false")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -492,12 +502,14 @@[m [mUniValue importpubkey(const JSONRPCRequest& request)[m
     }[m
 [m
     return NullUniValue;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 [m
[31m-UniValue importwallet(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan importwallet()[m
 {[m
[31m-            RPCHelpMan{"importwallet",[m
[32m+[m[32m    return RPCHelpMan{"importwallet",[m
                 "\nImports keys from a wallet dump file (see dumpwallet). Requires a new wallet backup to include imported keys.\n"[m
                 "Note: Use \"getwalletinfo\" to query the scanning progress.\n",[m
                 {[m
[36m@@ -512,8 +524,8 @@[m [mUniValue importwallet(const JSONRPCRequest& request)[m
             "\nImport using the json rpc call\n"[m
             + HelpExampleRpc("importwallet", "\"test\"")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -649,11 +661,13 @@[m [mUniValue importwallet(const JSONRPCRequest& request)[m
         throw JSONRPCError(RPC_WALLET_ERROR, "Error adding some keys/scripts to wallet");[m
 [m
     return NullUniValue;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
[31m-UniValue dumpprivkey(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan dumpprivkey()[m
 {[m
[31m-            RPCHelpMan{"dumpprivkey",[m
[32m+[m[32m    return RPCHelpMan{"dumpprivkey",[m
                 "\nReveals the private key corresponding to 'address'.\n"[m
                 "Then the importprivkey can be used with this output\n",[m
                 {[m
[36m@@ -667,8 +681,8 @@[m [mUniValue dumpprivkey(const JSONRPCRequest& request)[m
             + HelpExampleCli("importprivkey", "\"mykey\"")[m
             + HelpExampleRpc("dumpprivkey", "\"myaddress\"")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);[m
     if (!wallet) return NullUniValue;[m
     const CWallet* const pwallet = wallet.get();[m
[36m@@ -693,12 +707,14 @@[m [mUniValue dumpprivkey(const JSONRPCRequest& request)[m
         throw JSONRPCError(RPC_WALLET_ERROR, "Private key for address " + strAddress + " is not known");[m
     }[m
     return EncodeSecret(vchSecret);[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 [m
[31m-UniValue dumpwallet(const JSONRPCRequest& request)[m
[32m+[m[32mRPCHelpMan dumpwallet()[m
 {[m
[31m-            RPCHelpMan{"dumpwallet",[m
[32m+[m[32m    return RPCHelpMan{"dumpwallet",[m
                 "\nDumps all wallet keys in a human-readable format to a server-side file. This does not allow overwriting existing files.\n"[m
                 "Imported scripts are included in the dumpfile, but corresponding BIP173 addresses, etc. may not be added automatically by importwallet.\n"[m
                 "Note that if your wallet contains keys which are not derived from your HD seed (e.g. imported keys), these are not covered by\n"[m
[36m@@ -716,8 +732,8 @@[m [mUniValue dumpwallet(const JSONRPCRequest& request)[m
                     HelpExampleCli("dumpwallet", "\"test\"")[m
             + HelpExampleRpc("dumpwallet", "\"test\"")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const pwallet = GetWalletForJSONRPCRequest(request);[m
     if (!pwallet) return NullUniValue;[m
 [m
[36m@@ -829,6 +845,8 @@[m [mUniValue dumpwallet(const JSONRPCRequest& request)[m
     reply.pushKV("filename", filepath.string());[m
 [m
     return reply;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 struct ImportData[m
[36m@@ -1239,9 +1257,9 @@[m [mstatic int64_t GetImportTimestamp(const UniValue& data, int64_t now)[m
     throw JSONRPCError(RPC_TYPE_ERROR, "Missing required timestamp field for key");[m
 }[m
 [m
[31m-UniValue importmulti(const JSONRPCRequest& mainRequest)[m
[32m+[m[32mRPCHelpMan importmulti()[m
 {[m
[31m-            RPCHelpMan{"importmulti",[m
[32m+[m[32m    return RPCHelpMan{"importmulti",[m
                 "\nImport addresses/scripts (with private or public keys, redeem script (P2SH)), optionally rescanning the blockchain from the earliest creation time of the imported scripts. Requires a new wallet backup.\n"[m
                 "If an address/script is imported without all of the private keys required to spend from that address, it will be watchonly. The 'watchonly' option must be set to true in this case or a warning will be returned.\n"[m
                 "Conversely, if all the private keys are provided and the address/script is spendable, the watchonly option must be set to false, or a warning will be returned.\n"[m
[36m@@ -1314,8 +1332,8 @@[m [mUniValue importmulti(const JSONRPCRequest& mainRequest)[m
                                           "{ \"scriptPubKey\": { \"address\": \"<my 2nd address>\" }, \"label\": \"example 2\", \"timestamp\": 1455191480 }]'") +[m
                     HelpExampleCli("importmulti", "'[{ \"scriptPubKey\": { \"address\": \"<my address>\" }, \"timestamp\":1455191478 }]' '{ \"rescan\": false}'")[m
                 },[m
[31m-            }.Check(mainRequest);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& mainRequest) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(mainRequest);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -1423,6 +1441,8 @@[m [mUniValue importmulti(const JSONRPCRequest& mainRequest)[m
     }[m
 [m
     return response;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 static UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)[m
[36m@@ -1564,9 +1584,9 @@[m [mstatic UniValue ProcessDescriptorImport(CWallet * const pwallet, const UniValue&[m
     return result;[m
 }[m
 [m
[31m-UniValue importdescriptors(const JSONRPCRequest& main_request)[m
[32m+[m[32mRPCHelpMan importdescriptors()[m
 {[m
[31m-            RPCHelpMan{"importdescriptors",[m
[32m+[m[32m    return RPCHelpMan{"importdescriptors",[m
                 "\nImport descriptors. This will trigger a rescan of the blockchain based on the earliest timestamp of all descriptors being imported. Requires a new wallet backup.\n"[m
             "\nNote: This call can take over an hour to complete if using an early timestamp; during that time, other rpc calls\n"[m
             "may report that the imported keys, addresses or scripts exist but related transactions are still missing.\n",[m
[36m@@ -1615,8 +1635,8 @@[m [mUniValue importdescriptors(const JSONRPCRequest& main_request)[m
                                           "{ \"desc\": \"<my desccriptor 2>\", \"label\": \"example 2\", \"timestamp\": 1455191480 }]'") +[m
                     HelpExampleCli("importdescriptors", "'[{ \"desc\": \"<my descriptor>\", \"timestamp\":1455191478, \"active\": true, \"range\": [0,100], \"label\": \"<my bech32 wallet>\" }]'")[m
                 },[m
[31m-            }.Check(main_request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& main_request) -> UniValue[m
[32m+[m[32m{[m
     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(main_request);[m
     if (!wallet) return NullUniValue;[m
     CWallet* const pwallet = wallet.get();[m
[36m@@ -1713,4 +1733,6 @@[m [mUniValue importdescriptors(const JSONRPCRequest& main_request)[m
     }[m
 [m
     return response;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
[33mdiff --git a/src/wallet/rpcwallet.cpp b/src/wallet/rpcwallet.cpp[m
[33mindex 7a03c4f544..7ef0b2129b 100644[m
[33m--- a/src/wallet/rpcwallet.cpp[m
[33m+++ b/src/wallet/rpcwallet.cpp[m
[36m@@ -2061,6 +2061,7 @@[m [mstatic UniValue lockunspent(const JSONRPCRequest& request)[m
                 "Temporarily lock (unlock=false) or unlock (unlock=true) specified transaction outputs.\n"[m
                 "If no transaction outputs are specified when unlocking then all current locked transaction outputs are unlocked.\n"[m
                 "A locked transaction output will not be chosen by automatic coin selection, when spending bitcoins.\n"[m
[32m+[m[32m                "Manually selected coins are automatically unlocked.\n"[m
                 "Locks are stored in memory only. Nodes start with zero locked outputs, and the locked output list\n"[m
                 "is always cleared (by virtue of process exit) when a node stops or fails.\n"[m
                 "Also see the listunspent call\n",[m
[36m@@ -2494,7 +2495,7 @@[m [mstatic UniValue loadwallet(const JSONRPCRequest& request)[m
             RPCHelpMan{"loadwallet",[m
                 "\nLoads a wallet from a wallet file or directory."[m
                 "\nNote that all wallet command-line options used when starting bitcoind will be"[m
[31m-                "\napplied to the new wallet (eg -zapwallettxes, rescan, etc).\n",[m
[32m+[m[32m                "\napplied to the new wallet (eg -rescan, etc).\n",[m
                 {[m
                     {"filename", RPCArg::Type::STR, RPCArg::Optional::NO, "The wallet directory or .dat file."},[m
                     {"load_on_startup", RPCArg::Type::BOOL, /* default */ "null", "Save wallet name to persistent settings and load on startup. True to add wallet to startup list, false to remove, null to leave unchanged."},[m
[36m@@ -2836,6 +2837,15 @@[m [mstatic UniValue listunspent(const JSONRPCRequest& request)[m
     if (!request.params[4].isNull()) {[m
         const UniValue& options = request.params[4].get_obj();[m
 [m
[32m+[m[32m        RPCTypeCheckObj(options,[m
[32m+[m[32m            {[m
[32m+[m[32m                {"minimumAmount", UniValueType()},[m
[32m+[m[32m                {"maximumAmount", UniValueType()},[m
[32m+[m[32m                {"minimumSumAmount", UniValueType()},[m
[32m+[m[32m                {"maximumCount", UniValueType(UniValue::VNUM)},[m
[32m+[m[32m            },[m
[32m+[m[32m            true, true);[m
[32m+[m
         if (options.exists("minimumAmount"))[m
             nMinimumAmount = AmountFromValue(options["minimumAmount"]);[m
 [m
[36m@@ -4161,17 +4171,17 @@[m [mstatic UniValue upgradewallet(const JSONRPCRequest& request)[m
     return error.original;[m
 }[m
 [m
[31m-UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp[m
[31m-UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp[m
[31m-UniValue importprivkey(const JSONRPCRequest& request);[m
[31m-UniValue importaddress(const JSONRPCRequest& request);[m
[31m-UniValue importpubkey(const JSONRPCRequest& request);[m
[31m-UniValue dumpwallet(const JSONRPCRequest& request);[m
[31m-UniValue importwallet(const JSONRPCRequest& request);[m
[31m-UniValue importprunedfunds(const JSONRPCRequest& request);[m
[31m-UniValue removeprunedfunds(const JSONRPCRequest& request);[m
[31m-UniValue importmulti(const JSONRPCRequest& request);[m
[31m-UniValue importdescriptors(const JSONRPCRequest& request);[m
[32m+[m[32mRPCHelpMan abortrescan();[m
[32m+[m[32mRPCHelpMan dumpprivkey();[m
[32m+[m[32mRPCHelpMan importprivkey();[m
[32m+[m[32mRPCHelpMan importaddress();[m
[32m+[m[32mRPCHelpMan importpubkey();[m
[32m+[m[32mRPCHelpMan dumpwallet();[m
[32m+[m[32mRPCHelpMan importwallet();[m
[32m+[m[32mRPCHelpMan importprunedfunds();[m
[32m+[m[32mRPCHelpMan removeprunedfunds();[m
[32m+[m[32mRPCHelpMan importmulti();[m
[32m+[m[32mRPCHelpMan importdescriptors();[m
 [m
 Span<const CRPCCommand> GetWalletRPCCommands()[m
 {[m
[33mdiff --git a/src/wallet/scriptpubkeyman.h b/src/wallet/scriptpubkeyman.h[m
[33mindex a96d971734..14fb1fa89f 100644[m
[33m--- a/src/wallet/scriptpubkeyman.h[m
[33m+++ b/src/wallet/scriptpubkeyman.h[m
[36m@@ -535,7 +535,7 @@[m [mprivate:[m
     //! keeps track of whether Unlock has run a thorough check before[m
     bool m_decryption_thoroughly_checked = false;[m
 [m
[31m-    bool AddDescriptorKeyWithDB(WalletBatch& batch, const CKey& key, const CPubKey &pubkey);[m
[32m+[m[32m    bool AddDescriptorKeyWithDB(WalletBatch& batch, const CKey& key, const CPubKey &pubkey) EXCLUSIVE_LOCKS_REQUIRED(cs_desc_man);[m
 [m
     KeyMap GetKeys() const EXCLUSIVE_LOCKS_REQUIRED(cs_desc_man);[m
 [m
[33mdiff --git a/src/wallet/test/init_test_fixture.cpp b/src/wallet/test/init_test_fixture.cpp[m
[33mindex 35bd965673..c23dea1338 100644[m
[33m--- a/src/wallet/test/init_test_fixture.cpp[m
[33m+++ b/src/wallet/test/init_test_fixture.cpp[m
[36m@@ -10,7 +10,7 @@[m
 [m
 InitWalletDirTestingSetup::InitWalletDirTestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)[m
 {[m
[31m-    m_chain_client = MakeWalletClient(*m_chain, *Assert(m_node.args), {});[m
[32m+[m[32m    m_wallet_client = MakeWalletClient(*m_chain, *Assert(m_node.args), {});[m
 [m
     std::string sep;[m
     sep += fs::path::preferred_separator;[m
[33mdiff --git a/src/wallet/test/init_test_fixture.h b/src/wallet/test/init_test_fixture.h[m
[33mindex c95b4f1f6e..f5bade77df 100644[m
[33m--- a/src/wallet/test/init_test_fixture.h[m
[33m+++ b/src/wallet/test/init_test_fixture.h[m
[36m@@ -6,6 +6,7 @@[m
 #define BITCOIN_WALLET_TEST_INIT_TEST_FIXTURE_H[m
 [m
 #include <interfaces/chain.h>[m
[32m+[m[32m#include <interfaces/wallet.h>[m
 #include <node/context.h>[m
 #include <test/util/setup_common.h>[m
 [m
[36m@@ -19,7 +20,7 @@[m [mstruct InitWalletDirTestingSetup: public BasicTestingSetup {[m
     fs::path m_cwd;[m
     std::map<std::string, fs::path> m_walletdir_path_cases;[m
     std::unique_ptr<interfaces::Chain> m_chain = interfaces::MakeChain(m_node);[m
[31m-    std::unique_ptr<interfaces::ChainClient> m_chain_client;[m
[32m+[m[32m    std::unique_ptr<interfaces::WalletClient> m_wallet_client;[m
 };[m
 [m
 #endif // BITCOIN_WALLET_TEST_INIT_TEST_FIXTURE_H[m
[33mdiff --git a/src/wallet/test/init_tests.cpp b/src/wallet/test/init_tests.cpp[m
[33mindex c228e06009..9b905569fc 100644[m
[33m--- a/src/wallet/test/init_tests.cpp[m
[33m+++ b/src/wallet/test/init_tests.cpp[m
[36m@@ -15,7 +15,7 @@[m [mBOOST_FIXTURE_TEST_SUITE(init_tests, InitWalletDirTestingSetup)[m
 BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_default)[m
 {[m
     SetWalletDir(m_walletdir_path_cases["default"]);[m
[31m-    bool result = m_chain_client->verify();[m
[32m+[m[32m    bool result = m_wallet_client->verify();[m
     BOOST_CHECK(result == true);[m
     fs::path walletdir = gArgs.GetArg("-walletdir", "");[m
     fs::path expected_path = fs::canonical(m_walletdir_path_cases["default"]);[m
[36m@@ -25,7 +25,7 @@[m [mBOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_default)[m
 BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_custom)[m
 {[m
     SetWalletDir(m_walletdir_path_cases["custom"]);[m
[31m-    bool result = m_chain_client->verify();[m
[32m+[m[32m    bool result = m_wallet_client->verify();[m
     BOOST_CHECK(result == true);[m
     fs::path walletdir = gArgs.GetArg("-walletdir", "");[m
     fs::path expected_path = fs::canonical(m_walletdir_path_cases["custom"]);[m
[36m@@ -37,7 +37,7 @@[m [mBOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_does_not_exist)[m
     SetWalletDir(m_walletdir_path_cases["nonexistent"]);[m
     {[m
         ASSERT_DEBUG_LOG("does not exist");[m
[31m-        bool result = m_chain_client->verify();[m
[32m+[m[32m        bool result = m_wallet_client->verify();[m
         BOOST_CHECK(result == false);[m
     }[m
 }[m
[36m@@ -47,7 +47,7 @@[m [mBOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_is_not_directory)[m
     SetWalletDir(m_walletdir_path_cases["file"]);[m
     {[m
         ASSERT_DEBUG_LOG("is not a directory");[m
[31m-        bool result = m_chain_client->verify();[m
[32m+[m[32m        bool result = m_wallet_client->verify();[m
         BOOST_CHECK(result == false);[m
     }[m
 }[m
[36m@@ -57,7 +57,7 @@[m [mBOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_is_not_relative)[m
     SetWalletDir(m_walletdir_path_cases["relative"]);[m
     {[m
         ASSERT_DEBUG_LOG("is a relative path");[m
[31m-        bool result = m_chain_client->verify();[m
[32m+[m[32m        bool result = m_wallet_client->verify();[m
         BOOST_CHECK(result == false);[m
     }[m
 }[m
[36m@@ -65,7 +65,7 @@[m [mBOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_is_not_relative)[m
 BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing)[m
 {[m
     SetWalletDir(m_walletdir_path_cases["trailing"]);[m
[31m-    bool result = m_chain_client->verify();[m
[32m+[m[32m    bool result = m_wallet_client->verify();[m
     BOOST_CHECK(result == true);[m
     fs::path walletdir = gArgs.GetArg("-walletdir", "");[m
     fs::path expected_path = fs::canonical(m_walletdir_path_cases["default"]);[m
[36m@@ -75,7 +75,7 @@[m [mBOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing)[m
 BOOST_AUTO_TEST_CASE(walletinit_verify_walletdir_no_trailing2)[m
 {[m
     SetWalletDir(m_walletdir_path_cases["trailing2"]);[m
[31m-    bool result = m_chain_client->verify();[m
[32m+[m[32m    bool result = m_wallet_client->verify();[m
     BOOST_CHECK(result == true);[m
     fs::path walletdir = gArgs.GetArg("-walletdir", "");[m
     fs::path expected_path = fs::canonical(m_walletdir_path_cases["default"]);[m
[33mdiff --git a/src/wallet/test/wallet_test_fixture.cpp b/src/wallet/test/wallet_test_fixture.cpp[m
[33mindex 44f9eb5ddd..9241470745 100644[m
[33m--- a/src/wallet/test/wallet_test_fixture.cpp[m
[33m+++ b/src/wallet/test/wallet_test_fixture.cpp[m
[36m@@ -11,5 +11,5 @@[m [mWalletTestingSetup::WalletTestingSetup(const std::string& chainName)[m
     bool fFirstRun;[m
     m_wallet.LoadWallet(fFirstRun);[m
     m_chain_notifications_handler = m_chain->handleNotifications({ &m_wallet, [](CWallet*) {} });[m
[31m-    m_chain_client->registerRpcs();[m
[32m+[m[32m    m_wallet_client->registerRpcs();[m
 }[m
[33mdiff --git a/src/wallet/test/wallet_test_fixture.h b/src/wallet/test/wallet_test_fixture.h[m
[33mindex 99d7cfe921..12ad13b49b 100644[m
[33m--- a/src/wallet/test/wallet_test_fixture.h[m
[33m+++ b/src/wallet/test/wallet_test_fixture.h[m
[36m@@ -21,7 +21,7 @@[m [mstruct WalletTestingSetup : public TestingSetup {[m
     explicit WalletTestingSetup(const std::string& chainName = CBaseChainParams::MAIN);[m
 [m
     std::unique_ptr<interfaces::Chain> m_chain = interfaces::MakeChain(m_node);[m
[31m-    std::unique_ptr<interfaces::ChainClient> m_chain_client = interfaces::MakeWalletClient(*m_chain, *Assert(m_node.args), {});[m
[32m+[m[32m    std::unique_ptr<interfaces::WalletClient> m_wallet_client = interfaces::MakeWalletClient(*m_chain, *Assert(m_node.args), {});[m
     CWallet m_wallet;[m
     std::unique_ptr<interfaces::Handler> m_chain_notifications_handler;[m
 };[m
[33mdiff --git a/src/wallet/test/wallet_tests.cpp b/src/wallet/test/wallet_tests.cpp[m
[33mindex 7ef06663b5..c46e90d64b 100644[m
[33m--- a/src/wallet/test/wallet_tests.cpp[m
[33m+++ b/src/wallet/test/wallet_tests.cpp[m
[36m@@ -24,9 +24,9 @@[m
 #include <boost/test/unit_test.hpp>[m
 #include <univalue.h>[m
 [m
[31m-extern UniValue importmulti(const JSONRPCRequest& request);[m
[31m-extern UniValue dumpwallet(const JSONRPCRequest& request);[m
[31m-extern UniValue importwallet(const JSONRPCRequest& request);[m
[32m+[m[32mRPCHelpMan importmulti();[m
[32m+[m[32mRPCHelpMan dumpwallet();[m
[32m+[m[32mRPCHelpMan importwallet();[m
 [m
 // Ensure that fee levels defined in the wallet are at least as high[m
 // as the default levels for node policy.[m
[36m@@ -219,7 +219,7 @@[m [mBOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)[m
         request.params.setArray();[m
         request.params.push_back(keys);[m
 [m
[31m-        UniValue response = importmulti(request);[m
[32m+[m[32m        UniValue response = importmulti().HandleRequest(request);[m
         BOOST_CHECK_EQUAL(response.write(),[m
             strprintf("[{\"success\":false,\"error\":{\"code\":-1,\"message\":\"Rescan failed for key with creation "[m
                       "timestamp %d. There was an error reading a block from time %d, which is after or within %d "[m
[36m@@ -274,7 +274,7 @@[m [mBOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)[m
         request.params.setArray();[m
         request.params.push_back(backup_file);[m
 [m
[31m-        ::dumpwallet(request);[m
[32m+[m[32m        ::dumpwallet().HandleRequest(request);[m
         RemoveWallet(wallet);[m
     }[m
 [m
[36m@@ -291,7 +291,7 @@[m [mBOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)[m
         request.params.push_back(backup_file);[m
         AddWallet(wallet);[m
         wallet->SetLastBlockProcessed(::ChainActive().Height(), ::ChainActive().Tip()->GetBlockHash());[m
[31m-        ::importwallet(request);[m
[32m+[m[32m        ::importwallet().HandleRequest(request);[m
         RemoveWallet(wallet);[m
 [m
         BOOST_CHECK_EQUAL(wallet->mapWallet.size(), 3U);[m
[33mdiff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp[m
[33mindex c132a4be42..839e74a2be 100644[m
[33m--- a/src/wallet/wallet.cpp[m
[33m+++ b/src/wallet/wallet.cpp[m
[36m@@ -183,11 +183,6 @@[m [mstd::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const WalletLocati[m
     return wallet;[m
 }[m
 [m
[31m-std::shared_ptr<CWallet> LoadWallet(interfaces::Chain& chain, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings)[m
[31m-{[m
[31m-    return LoadWallet(chain, WalletLocation(name), error, warnings);[m
[31m-}[m
[31m-[m
 WalletCreationStatus CreateWallet(interfaces::Chain& chain, const SecureString& passphrase, uint64_t wallet_creation_flags, const std::string& name, bilingual_str& error, std::vector<bilingual_str>& warnings, std::shared_ptr<CWallet>& result)[m
 {[m
     // Indicate that the wallet is actually supposed to be blank and not just blank to make it encrypted[m
[36m@@ -276,7 +271,7 @@[m [mstd::string COutput::ToString() const[m
 [m
 const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const[m
 {[m
[31m-    LOCK(cs_wallet);[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(hash);[m
     if (it == mapWallet.end())[m
         return nullptr;[m
[36m@@ -1210,15 +1205,13 @@[m [mvoid CWallet::BlockUntilSyncedToCurrentChain() const {[m
 [m
 isminetype CWallet::IsMine(const CTxIn &txin) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
[32m+[m[32m    std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);[m
[32m+[m[32m    if (mi != mapWallet.end())[m
     {[m
[31m-        LOCK(cs_wallet);[m
[31m-        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);[m
[31m-        if (mi != mapWallet.end())[m
[31m-        {[m
[31m-            const CWalletTx& prev = (*mi).second;[m
[31m-            if (txin.prevout.n < prev.tx->vout.size())[m
[31m-                return IsMine(prev.tx->vout[txin.prevout.n]);[m
[31m-        }[m
[32m+[m[32m        const CWalletTx& prev = (*mi).second;[m
[32m+[m[32m        if (txin.prevout.n < prev.tx->vout.size())[m
[32m+[m[32m            return IsMine(prev.tx->vout[txin.prevout.n]);[m
     }[m
     return ISMINE_NO;[m
 }[m
[36m@@ -1243,16 +1236,19 @@[m [mCAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const[m
 [m
 isminetype CWallet::IsMine(const CTxOut& txout) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     return IsMine(txout.scriptPubKey);[m
 }[m
 [m
 isminetype CWallet::IsMine(const CTxDestination& dest) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     return IsMine(GetScriptForDestination(dest));[m
 }[m
 [m
 isminetype CWallet::IsMine(const CScript& script) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     isminetype result = ISMINE_NO;[m
     for (const auto& spk_man_pair : m_spk_managers) {[m
         result = std::max(result, spk_man_pair.second->IsMine(script));[m
[36m@@ -1264,6 +1260,7 @@[m [mCAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) cons[m
 {[m
     if (!MoneyRange(txout.nValue))[m
         throw std::runtime_error(std::string(__func__) + ": value out of range");[m
[32m+[m[32m    LOCK(cs_wallet);[m
     return ((IsMine(txout) & filter) ? txout.nValue : 0);[m
 }[m
 [m
[36m@@ -1281,13 +1278,12 @@[m [mbool CWallet::IsChange(const CScript& script) const[m
     // a better way of identifying which outputs are 'the send' and which are[m
     // 'the change' will need to be implemented (maybe extend CWalletTx to remember[m
     // which output, if any, was change).[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     if (IsMine(script))[m
     {[m
         CTxDestination address;[m
         if (!ExtractDestination(script, address))[m
             return true;[m
[31m-[m
[31m-        LOCK(cs_wallet);[m
         if (!FindAddressBookEntry(address)) {[m
             return true;[m
         }[m
[36m@@ -1297,6 +1293,7 @@[m [mbool CWallet::IsChange(const CScript& script) const[m
 [m
 CAmount CWallet::GetChange(const CTxOut& txout) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     if (!MoneyRange(txout.nValue))[m
         throw std::runtime_error(std::string(__func__) + ": value out of range");[m
     return (IsChange(txout) ? txout.nValue : 0);[m
[36m@@ -1304,6 +1301,7 @@[m [mCAmount CWallet::GetChange(const CTxOut& txout) const[m
 [m
 bool CWallet::IsMine(const CTransaction& tx) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     for (const CTxOut& txout : tx.vout)[m
         if (IsMine(txout))[m
             return true;[m
[36m@@ -1362,6 +1360,7 @@[m [mCAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) c[m
 [m
 CAmount CWallet::GetChange(const CTransaction& tx) const[m
 {[m
[32m+[m[32m    LOCK(cs_wallet);[m
     CAmount nChange = 0;[m
     for (const CTxOut& txout : tx.vout)[m
     {[m
[36m@@ -1597,6 +1596,7 @@[m [mvoid CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,[m
         nFee = nDebit - nValueOut;[m
     }[m
 [m
[32m+[m[32m    LOCK(pwallet->cs_wallet);[m
     // Sent/received.[m
     for (unsigned int i = 0; i < tx->vout.size(); ++i)[m
     {[m
[36m@@ -1965,36 +1965,38 @@[m [mbool CWalletTx::InMempool() const[m
 [m
 bool CWalletTx::IsTrusted() const[m
 {[m
[31m-    std::set<uint256> s;[m
[31m-    return IsTrusted(s);[m
[32m+[m[32m    std::set<uint256> trusted_parents;[m
[32m+[m[32m    LOCK(pwallet->cs_wallet);[m
[32m+[m[32m    return pwallet->IsTrusted(*this, trusted_parents);[m
 }[m
 [m
[31m-bool CWalletTx::IsTrusted(std::set<uint256>& trusted_parents) const[m
[32m+[m[32mbool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const[m
 {[m
[32m+[m[32m    AssertLockHeld(cs_wallet);[m
     // Quick answer in most cases[m
[31m-    if (!pwallet->chain().checkFinalTx(*tx)) return false;[m
[31m-    int nDepth = GetDepthInMainChain();[m
[32m+[m[32m    if (!chain().checkFinalTx(*wtx.tx)) return false;[m
[32m+[m[32m    int nDepth = wtx.GetDepthInMainChain();[m
     if (nDepth >= 1) return true;[m
     if (nDepth < 0) return false;[m
     // using wtx's cached debit[m
[31m-    if (!pwallet->m_spend_zero_conf_change || !IsFromMe(ISMINE_ALL)) return false;[m
[32m+[m[32m    if (!m_spend_zero_conf_change || !wtx.IsFromMe(ISMINE_ALL)) return false;[m
 [m
     // Don't trust unconfirmed transactions from us unless they are in the mempool.[m
[31m-    if (!InMempool()) return false;[m
[32m+[m[32m    if (!wtx.InMempool()) return false;[m
 [m
     // Trusted if all inputs are from us and are in the mempool:[m
[31m-    for (const CTxIn& txin : tx->vin)[m
[32m+[m[32m    for (const CTxIn& txin : wtx.tx->vin)[m
     {[m
         // Transactions not sent by us: not trusted[m
[31m-        const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);[m
[32m+[m[32m        const CWalletTx* parent = GetWalletTx(txin.prevout.hash);[m
         if (parent == nullptr) return false;[m
         const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];[m
         // Check that this specific input being spent is trusted[m
[31m-        if (pwallet->IsMine(parentOut) != ISMINE_SPENDABLE) return false;[m
[32m+[m[32m        if (IsMine(parentOut) != ISMINE_SPENDABLE) return false;[m
         // If we've already trusted this parent, continue[m
         if (trusted_parents.count(parent->GetHash())) continue;[m
         // Recurse to check that the parent is also trusted[m
[31m-        if (!parent->IsTrusted(trusted_parents)) return false;[m
[32m+[m[32m        if (!IsTrusted(*parent, trusted_parents)) return false;[m
         trusted_parents.insert(parent->GetHash());[m
     }[m
     return true;[m
[36m@@ -2080,7 +2082,7 @@[m [mCWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) cons[m
         for (const auto& entry : mapWallet)[m
         {[m
             const CWalletTx& wtx = entry.second;[m
[31m-            const bool is_trusted{wtx.IsTrusted(trusted_parents)};[m
[32m+[m[32m            const bool is_trusted{IsTrusted(wtx, trusted_parents)};[m
             const int tx_depth{wtx.GetDepthInMainChain()};[m
             const CAmount tx_credit_mine{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};[m
             const CAmount tx_credit_watchonly{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};[m
[36m@@ -2148,7 +2150,7 @@[m [mvoid CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlySafe, const[m
         if (nDepth == 0 && !wtx.InMempool())[m
             continue;[m
 [m
[31m-        bool safeTx = wtx.IsTrusted(trusted_parents);[m
[32m+[m[32m        bool safeTx = IsTrusted(wtx, trusted_parents);[m
 [m
         // We should not consider coins from transactions that are replacing[m
         // other transactions.[m
[36m@@ -2580,10 +2582,11 @@[m [mbool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC[m
         if (!coinControl.IsSelected(txin.prevout)) {[m
             tx.vin.push_back(txin);[m
 [m
[31m-            if (lockUnspents) {[m
[31m-                LockCoin(txin.prevout);[m
[31m-            }[m
         }[m
[32m+[m[32m        if (lockUnspents) {[m
[32m+[m[32m            LockCoin(txin.prevout);[m
[32m+[m[32m        }[m
[32m+[m
     }[m
 [m
     return true;[m
[36m@@ -3172,28 +3175,10 @@[m [mDBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256[m
     return DBErrors::LOAD_OK;[m
 }[m
 [m
[31m-DBErrors CWallet::ZapWalletTx(std::list<CWalletTx>& vWtx)[m
[31m-{[m
[31m-    DBErrors nZapWalletTxRet = WalletBatch(*database,"cr+").ZapWalletTx(vWtx);[m
[31m-    if (nZapWalletTxRet == DBErrors::NEED_REWRITE)[m
[31m-    {[m
[31m-        if (database->Rewrite("\x04pool"))[m
[31m-        {[m
[31m-            for (const auto& spk_man_pair : m_spk_managers) {[m
[31m-                spk_man_pair.second->RewriteDB();[m
[31m-            }[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    if (nZapWalletTxRet != DBErrors::LOAD_OK)[m
[31m-        return nZapWalletTxRet;[m
[31m-[m
[31m-    return DBErrors::LOAD_OK;[m
[31m-}[m
[31m-[m
 bool CWallet::SetAddressBookWithDB(WalletBatch& batch, const CTxDestination& address, const std::string& strName, const std::string& strPurpose)[m
 {[m
     bool fUpdated = false;[m
[32m+[m[32m    bool is_mine;[m
     {[m
         LOCK(cs_wallet);[m
         std::map<CTxDestination, CAddressBookData>::iterator mi = m_address_book.find(address);[m
[36m@@ -3201,8 +3186,9 @@[m [mbool CWallet::SetAddressBookWithDB(WalletBatch& batch, const CTxDestination& add[m
         m_address_book[address].SetLabel(strName);[m
         if (!strPurpose.empty()) /* update purpose only if requested */[m
             m_address_book[address].purpose = strPurpose;[m
[32m+[m[32m        is_mine = IsMine(address) != ISMINE_NO;[m
     }[m
[31m-    NotifyAddressBookChanged(this, address, strName, IsMine(address) != ISMINE_NO,[m
[32m+[m[32m    NotifyAddressBookChanged(this, address, strName, is_mine,[m
                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );[m
     if (!strPurpose.empty() && !batch.WritePurpose(EncodeDestination(address), strPurpose))[m
         return false;[m
[36m@@ -3217,17 +3203,16 @@[m [mbool CWallet::SetAddressBook(const CTxDestination& address, const std::string& s[m
 [m
 bool CWallet::DelAddressBook(const CTxDestination& address)[m
 {[m
[31m-    // If we want to delete receiving addresses, we need to take care that DestData "used" (and possibly newer DestData) gets preserved (and the "deleted" address transformed into a change entry instead of actually being deleted)[m
[31m-    // NOTE: This isn't a problem for sending addresses because they never have any DestData yet![m
[31m-    // When adding new DestData, it should be considered here whether to retain or delete it (or move it?).[m
[31m-    if (IsMine(address)) {[m
[31m-        WalletLogPrintf("%s called with IsMine address, NOT SUPPORTED. Please report this bug! %s\n", __func__, PACKAGE_BUGREPORT);[m
[31m-        return false;[m
[31m-    }[m
[31m-[m
[32m+[m[32m    bool is_mine;[m
     {[m
         LOCK(cs_wallet);[m
[31m-[m
[32m+[m[32m        // If we want to delete receiving addresses, we need to take care that DestData "used" (and possibly newer DestData) gets preserved (and the "deleted" address transformed into a change entry instead of actually being deleted)[m
[32m+[m[32m        // NOTE: This isn't a problem for sending addresses because they never have any DestData yet![m
[32m+[m[32m        // When adding new DestData, it should be considered here whether to retain or delete it (or move it?).[m
[32m+[m[32m        if (IsMine(address)) {[m
[32m+[m[32m            WalletLogPrintf("%s called with IsMine address, NOT SUPPORTED. Please report this bug! %s\n", __func__, PACKAGE_BUGREPORT);[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
         // Delete destdata tuples associated with address[m
         std::string strAddress = EncodeDestination(address);[m
         for (const std::pair<const std::string, std::string> &item : m_address_book[address].destdata)[m
[36m@@ -3235,9 +3220,10 @@[m [mbool CWallet::DelAddressBook(const CTxDestination& address)[m
             WalletBatch(*database).EraseDestData(strAddress, item.first);[m
         }[m
         m_address_book.erase(address);[m
[32m+[m[32m        is_mine = IsMine(address) != ISMINE_NO;[m
     }[m
 [m
[31m-    NotifyAddressBookChanged(this, address, "", IsMine(address) != ISMINE_NO, "", CT_DELETED);[m
[32m+[m[32m    NotifyAddressBookChanged(this, address, "", is_mine, "", CT_DELETED);[m
 [m
     WalletBatch(*database).ErasePurpose(EncodeDestination(address));[m
     return WalletBatch(*database).EraseName(EncodeDestination(address));[m
[36m@@ -3345,7 +3331,7 @@[m [mstd::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const[m
         {[m
             const CWalletTx& wtx = walletEntry.second;[m
 [m
[31m-            if (!wtx.IsTrusted(trusted_parents))[m
[32m+[m[32m            if (!IsTrusted(wtx, trusted_parents))[m
                 continue;[m
 [m
             if (wtx.IsImmatureCoinBase())[m
[36m@@ -3364,9 +3350,6 @@[m [mstd::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const[m
                     continue;[m
 [m
                 CAmount n = IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;[m
[31m-[m
[31m-                if (!balances.count(addr))[m
[31m-                    balances[addr] = 0;[m
                 balances[addr] += n;[m
             }[m
         }[m
[36m@@ -3770,20 +3753,6 @@[m [mstd::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,[m
 {[m
     const std::string walletFile = WalletDataFilePath(location.GetPath()).string();[m
 [m
[31m-    // needed to restore wallet transaction meta data after -zapwallettxes[m
[31m-    std::list<CWalletTx> vWtx;[m
[31m-[m
[31m-    if (gArgs.GetBoolArg("-zapwallettxes", false)) {[m
[31m-        chain.initMessage(_("Zapping all transactions from wallet...").translated);[m
[31m-[m
[31m-        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(&chain, location, CreateWalletDatabase(location.GetPath()));[m
[31m-        DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);[m
[31m-        if (nZapWalletRet != DBErrors::LOAD_OK) {[m
[31m-            error = strprintf(_("Error loading %s: Wallet corrupted"), walletFile);[m
[31m-            return nullptr;[m
[31m-        }[m
[31m-    }[m
[31m-[m
     chain.initMessage(_("Loading wallet...").translated);[m
 [m
     int64_t nStart = GetTimeMillis();[m
[36m@@ -4060,30 +4029,6 @@[m [mstd::shared_ptr<CWallet> CWallet::CreateWalletFromFile(interfaces::Chain& chain,[m
         }[m
         walletInstance->chainStateFlushed(chain.getTipLocator());[m
         walletInstance->database->IncrementUpdateCounter();[m
[31m-[m
[31m-        // Restore wallet transaction metadata after -zapwallettxes=1[m
[31m-        if (gArgs.GetBoolArg("-zapwallettxes", false) && gArgs.GetArg("-zapwallettxes", "1") != "2")[m
[31m-        {[m
[31m-            WalletBatch batch(*walletInstance->database);[m
[31m-[m
[31m-            for (const CWalletTx& wtxOld : vWtx)[m
[31m-            {[m
[31m-                uint256 hash = wtxOld.GetHash();[m
[31m-                std::map<uint256, CWalletTx>::iterator mi = walletInstance->mapWallet.find(hash);[m
[31m-                if (mi != walletInstance->mapWallet.end())[m
[31m-                {[m
[31m-                    const CWalletTx* copyFrom = &wtxOld;[m
[31m-                    CWalletTx* copyTo = &mi->second;[m
[31m-                    copyTo->mapValue = copyFrom->mapValue;[m
[31m-                    copyTo->vOrderForm = copyFrom->vOrderForm;[m
[31m-                    copyTo->nTimeReceived = copyFrom->nTimeReceived;[m
[31m-                    copyTo->nTimeSmart = copyFrom->nTimeSmart;[m
[31m-                    copyTo->fFromMe = copyFrom->fFromMe;[m
[31m-                    copyTo->nOrderPos = copyFrom->nOrderPos;[m
[31m-                    batch.WriteTx(*copyTo);[m
[31m-                }[m
[31m-            }[m
[31m-        }[m
     }[m
 [m
     {[m
[33mdiff --git a/src/wallet/wallet.h b/src/wallet/wallet.h[m
[33mindex 2f9d301000..42622c9312 100644[m
[33m--- a/src/wallet/wallet.h[m
[33m+++ b/src/wallet/wallet.h[m
[36m@@ -275,7 +275,7 @@[m [mint CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet,[m
 class CWalletTx[m
 {[m
 private:[m
[31m-    const CWallet* pwallet;[m
[32m+[m[32m    const CWallet* const pwallet;[m
 [m
     /** Constant used in hashBlock to indicate tx has been abandoned, only used at[m
      * serialization/deserialization to avoid ambiguity with conflicted.[m
[36m@@ -502,7 +502,6 @@[m [mpublic:[m
 [m
     bool InMempool() const;[m
     bool IsTrusted() const;[m
[31m-    bool IsTrusted(std::set<uint256>& trusted_parents) const;[m
 [m
     int64_t GetTxTime() const;[m
 [m
[36m@@ -805,7 +804,8 @@[m [mpublic:[m
     /** Interface for accessing chain state. */[m
     interfaces::Chain& chain() const { assert(m_chain); return *m_chain; }[m
 [m
[31m-    const CWalletTx* GetWalletTx(const uint256& hash) const;[m
[32m+[m[32m    const CWalletTx* GetWalletTx(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
[32m+[m[32m    bool IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
 [m
     //! check whether we are allowed to upgrade (or already support) to the named feature[m
     bool CanSupportFeature(enum WalletFeature wf) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return nWalletMaxVersion >= wf; }[m
[36m@@ -1051,20 +1051,20 @@[m [mpublic:[m
     bool GetNewDestination(const OutputType type, const std::string label, CTxDestination& dest, std::string& error);[m
     bool GetNewChangeDestination(const OutputType type, CTxDestination& dest, std::string& error);[m
 [m
[31m-    isminetype IsMine(const CTxDestination& dest) const;[m
[31m-    isminetype IsMine(const CScript& script) const;[m
[31m-    isminetype IsMine(const CTxIn& txin) const;[m
[32m+[m[32m    isminetype IsMine(const CTxDestination& dest) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
[32m+[m[32m    isminetype IsMine(const CScript& script) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
[32m+[m[32m    isminetype IsMine(const CTxIn& txin) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
     /**[m
      * Returns amount of debit if the input matches the[m
      * filter, otherwise returns 0[m
      */[m
     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;[m
[31m-    isminetype IsMine(const CTxOut& txout) const;[m
[32m+[m[32m    isminetype IsMine(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
     CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;[m
[31m-    bool IsChange(const CTxOut& txout) const;[m
[31m-    bool IsChange(const CScript& script) const;[m
[31m-    CAmount GetChange(const CTxOut& txout) const;[m
[31m-    bool IsMine(const CTransaction& tx) const;[m
[32m+[m[32m    bool IsChange(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
[32m+[m[32m    bool IsChange(const CScript& script) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
[32m+[m[32m    CAmount GetChange(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
[32m+[m[32m    bool IsMine(const CTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
     /** should probably be renamed to IsRelevantToMe */[m
     bool IsFromMe(const CTransaction& tx) const;[m
     CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;[m
[36m@@ -1075,7 +1075,6 @@[m [mpublic:[m
     void chainStateFlushed(const CBlockLocator& loc) override;[m
 [m
     DBErrors LoadWallet(bool& fFirstRunRet);[m
[31m-    DBErrors ZapWalletTx(std::list<CWalletTx>& vWtx);[m
     DBErrors ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
 [m
     bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);[m
[36m@@ -1179,7 +1178,7 @@[m [mpublic:[m
      * Obviously holding cs_main/cs_wallet when going into this call may cause[m
      * deadlock[m
      */[m
[31m-    void BlockUntilSyncedToCurrentChain() const LOCKS_EXCLUDED(cs_main, cs_wallet);[m
[32m+[m[32m    void BlockUntilSyncedToCurrentChain() const EXCLUSIVE_LOCKS_REQUIRED(!::cs_main, !cs_wallet);[m
 [m
     /** set a single wallet flag */[m
     void SetWalletFlag(uint64_t flags);[m
[36m@@ -1285,7 +1284,7 @@[m [mpublic:[m
     void LoadActiveScriptPubKeyMan(uint256 id, OutputType type, bool internal);[m
 [m
     //! Create new DescriptorScriptPubKeyMans and add them to the wallet[m
[31m-    void SetupDescriptorScriptPubKeyMans();[m
[32m+[m[32m    void SetupDescriptorScriptPubKeyMans() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
 [m
     //! Return the DescriptorScriptPubKeyMan for a WalletDescriptor if it is already in the wallet[m
     DescriptorScriptPubKeyMan* GetDescriptorScriptPubKeyMan(const WalletDescriptor& desc) const;[m
[33mdiff --git a/src/wallet/walletdb.cpp b/src/wallet/walletdb.cpp[m
[33mindex fa6814d0d3..f25acee1e9 100644[m
[33m--- a/src/wallet/walletdb.cpp[m
[33m+++ b/src/wallet/walletdb.cpp[m
[36m@@ -926,23 +926,6 @@[m [mDBErrors WalletBatch::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<u[m
     return DBErrors::LOAD_OK;[m
 }[m
 [m
[31m-DBErrors WalletBatch::ZapWalletTx(std::list<CWalletTx>& vWtx)[m
[31m-{[m
[31m-    // build list of wallet TXs[m
[31m-    std::vector<uint256> vTxHash;[m
[31m-    DBErrors err = FindWalletTx(vTxHash, vWtx);[m
[31m-    if (err != DBErrors::LOAD_OK)[m
[31m-        return err;[m
[31m-[m
[31m-    // erase each wallet TX[m
[31m-    for (const uint256& hash : vTxHash) {[m
[31m-        if (!EraseTx(hash))[m
[31m-            return DBErrors::CORRUPT;[m
[31m-    }[m
[31m-[m
[31m-    return DBErrors::LOAD_OK;[m
[31m-}[m
[31m-[m
 void MaybeCompactWalletDB()[m
 {[m
     static std::atomic<bool> fOneThread(false);[m
[33mdiff --git a/src/wallet/walletdb.h b/src/wallet/walletdb.h[m
[33mindex 64d60b1f44..c13de01319 100644[m
[33m--- a/src/wallet/walletdb.h[m
[33m+++ b/src/wallet/walletdb.h[m
[36m@@ -257,7 +257,6 @@[m [mpublic:[m
 [m
     DBErrors LoadWallet(CWallet* pwallet);[m
     DBErrors FindWalletTx(std::vector<uint256>& vTxHash, std::list<CWalletTx>& vWtx);[m
[31m-    DBErrors ZapWalletTx(std::list<CWalletTx>& vWtx);[m
     DBErrors ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut);[m
     /* Function to determine if a certain KV/key-type is a key (cryptographical key) type */[m
     static bool IsKeyType(const std::string& strType);[m
[33mdiff --git a/src/zmq/zmqrpc.cpp b/src/zmq/zmqrpc.cpp[m
[33mindex cce6210129..1dd751b493 100644[m
[33m--- a/src/zmq/zmqrpc.cpp[m
[33m+++ b/src/zmq/zmqrpc.cpp[m
[36m@@ -13,9 +13,9 @@[m
 [m
 namespace {[m
 [m
[31m-UniValue getzmqnotifications(const JSONRPCRequest& request)[m
[32m+[m[32mstatic RPCHelpMan getzmqnotifications()[m
 {[m
[31m-            RPCHelpMan{"getzmqnotifications",[m
[32m+[m[32m    return RPCHelpMan{"getzmqnotifications",[m
                 "\nReturns information about the active ZeroMQ notifications.\n",[m
                 {},[m
                 RPCResult{[m
[36m@@ -33,8 +33,8 @@[m [mUniValue getzmqnotifications(const JSONRPCRequest& request)[m
                     HelpExampleCli("getzmqnotifications", "")[m
             + HelpExampleRpc("getzmqnotifications", "")[m
                 },[m
[31m-            }.Check(request);[m
[31m-[m
[32m+[m[32m        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
[32m+[m[32m{[m
     UniValue result(UniValue::VARR);[m
     if (g_zmq_notification_interface != nullptr) {[m
         for (const auto* n : g_zmq_notification_interface->GetActiveNotifiers()) {[m
[36m@@ -47,6 +47,8 @@[m [mUniValue getzmqnotifications(const JSONRPCRequest& request)[m
     }[m
 [m
     return result;[m
[32m+[m[32m},[m
[32m+[m[32m    };[m
 }[m
 [m
 const CRPCCommand commands[] =[m
[33mdiff --git a/test/functional/README.md b/test/functional/README.md[m
[33mindex aff5f714f2..0d85a74074 100644[m
[33m--- a/test/functional/README.md[m
[33m+++ b/test/functional/README.md[m
[36m@@ -127,8 +127,8 @@[m [mBase class for functional tests.[m
 #### [util.py](test_framework/util.py)[m
 Generally useful functions.[m
 [m
[31m-#### [mininode.py](test_framework/mininode.py)[m
[31m-Basic code to support P2P connectivity to a bitcoind.[m
[32m+[m[32m#### [p2p.py](test_framework/p2p.py)[m
[32m+[m[32mTest objects for interacting with a bitcoind node over the p2p interface.[m
 [m
 #### [script.py](test_framework/script.py)[m
 Utilities for manipulating transaction scripts (originally from python-bitcoinlib)[m
[33mdiff --git a/test/functional/example_test.py b/test/functional/example_test.py[m
[33mindex 34e4999329..1832043989 100755[m
[33m--- a/test/functional/example_test.py[m
[33m+++ b/test/functional/example_test.py[m
[36m@@ -16,17 +16,16 @@[m [mfrom collections import defaultdict[m
 # Avoid wildcard * imports[m
 from test_framework.blocktools import (create_block, create_coinbase)[m
 from test_framework.messages import CInv, MSG_BLOCK[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PInterface,[m
[31m-    mininode_lock,[m
     msg_block,[m
     msg_getdata,[m
[32m+[m[32m    p2p_lock,[m
 )[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
     connect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 # P2PInterface is a class containing callbacks to be executed when a P2P[m
[36m@@ -167,7 +166,7 @@[m [mclass ExampleTest(BitcoinTestFramework):[m
         height = self.nodes[0].getblockcount()[m
 [m
         for _ in range(10):[m
[31m-            # Use the mininode and blocktools functionality to manually build a block[m
[32m+[m[32m            # Use the blocktools functionality to manually build a block.[m
             # Calling the generate() rpc is easier, but this allows us to exactly[m
             # control the blocks and transactions.[m
             block = create_block(self.tip, create_coinbase(height+1), self.block_time)[m
[36m@@ -203,13 +202,13 @@[m [mclass ExampleTest(BitcoinTestFramework):[m
 [m
         # wait_until() will loop until a predicate condition is met. Use it to test properties of the[m
         # P2PInterface objects.[m
[31m-        wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)[m
[32m+[m[32m        self.nodes[2].p2p.wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5)[m
 [m
         self.log.info("Check that each block was received only once")[m
         # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving[m
         # messages. The test thread should acquire the global lock before accessing any P2PConnection data to avoid locking[m
         # and synchronization issues. Note wait_until() acquires this global lock when testing the predicate.[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             for block in self.nodes[2].p2p.block_receive_map.values():[m
                 assert_equal(block, 1)[m
 [m
[33mdiff --git a/test/functional/feature_abortnode.py b/test/functional/feature_abortnode.py[m
[33mindex 75267de80b..17fbf50cc8 100755[m
[33m--- a/test/functional/feature_abortnode.py[m
[33m+++ b/test/functional/feature_abortnode.py[m
[36m@@ -11,7 +11,7 @@[m
 """[m
 [m
 from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.util import wait_until, get_datadir_path, connect_nodes[m
[32m+[m[32mfrom test_framework.util import get_datadir_path, connect_nodes[m
 import os[m
 [m
 [m
[36m@@ -41,7 +41,7 @@[m [mclass AbortNodeTest(BitcoinTestFramework):[m
 [m
             # Check that node0 aborted[m
             self.log.info("Waiting for crash")[m
[31m-            wait_until(lambda: self.nodes[0].is_node_stopped(), timeout=200)[m
[32m+[m[32m            self.nodes[0].wait_until_stopped(timeout=200)[m
         self.log.info("Node crashed - now verifying restart fails")[m
         self.nodes[0].assert_start_raises_init_error()[m
 [m
[33mdiff --git a/test/functional/feature_assumevalid.py b/test/functional/feature_assumevalid.py[m
[33mindex f19ee12f95..603d7f5d3b 100755[m
[33m--- a/test/functional/feature_assumevalid.py[m
[33m+++ b/test/functional/feature_assumevalid.py[m
[36m@@ -42,7 +42,7 @@[m [mfrom test_framework.messages import ([m
     msg_block,[m
     msg_headers,[m
 )[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.script import (CScript, OP_TRUE)[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
[33mdiff --git a/test/functional/feature_backwards_compatibility.py b/test/functional/feature_backwards_compatibility.py[m
[33mindex 07dd0f8f82..126c9fe929 100755[m
[33m--- a/test/functional/feature_backwards_compatibility.py[m
[33m+++ b/test/functional/feature_backwards_compatibility.py[m
[36m@@ -6,7 +6,7 @@[m
 [m
 Test various backwards compatibility scenarios. Download the previous node binaries:[m
 [m
[31m-contrib/devtools/previous_release.py -b v0.19.1 v0.18.1 v0.17.1 v0.16.3 v0.15.2[m
[32m+[m[32mtest/get_previous_releases.py -b v0.19.1 v0.18.1 v0.17.1 v0.16.3 v0.15.2[m
 [m
 v0.15.2 is not required by this test, but it is used in wallet_upgradewallet.py.[m
 Due to a hardfork in regtest, it can't be used to sync nodes.[m
[33mdiff --git a/test/functional/feature_block.py b/test/functional/feature_block.py[m
[33mindex c74761869b..efafcfaec3 100755[m
[33m--- a/test/functional/feature_block.py[m
[33m+++ b/test/functional/feature_block.py[m
[36m@@ -26,7 +26,7 @@[m [mfrom test_framework.messages import ([m
     uint256_from_compact,[m
     uint256_from_str,[m
 )[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.script import ([m
     CScript,[m
     MAX_SCRIPT_ELEMENT_SIZE,[m
[36m@@ -53,7 +53,7 @@[m [mfrom test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
 from data import invalid_txs[m
 [m
[31m-#  Use this class for tests that require behavior other than normal "mininode" behavior.[m
[32m+[m[32m#  Use this class for tests that require behavior other than normal p2p behavior.[m
 #  For now, it is used to serialize a bloated varint (b64).[m
 class CBrokenBlock(CBlock):[m
     def initialize(self, base_block):[m
[33mdiff --git a/test/functional/feature_cltv.py b/test/functional/feature_cltv.py[m
[33mindex fd0330924d..2919b0ea0b 100755[m
[33m--- a/test/functional/feature_cltv.py[m
[33m+++ b/test/functional/feature_cltv.py[m
[36m@@ -10,7 +10,7 @@[m [mTest that the CHECKLOCKTIMEVERIFY soft-fork activates at (regtest) block height[m
 [m
 from test_framework.blocktools import create_coinbase, create_block, create_transaction[m
 from test_framework.messages import CTransaction, msg_block, ToHex[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.script import CScript, OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP, CScriptNum[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
[33mdiff --git a/test/functional/feature_csv_activation.py b/test/functional/feature_csv_activation.py[m
[33mindex dfb3683143..38e95f00e9 100755[m
[33m--- a/test/functional/feature_csv_activation.py[m
[33m+++ b/test/functional/feature_csv_activation.py[m
[36m@@ -44,7 +44,7 @@[m [mimport time[m
 [m
 from test_framework.blocktools import create_coinbase, create_block, create_transaction[m
 from test_framework.messages import ToHex, CTransaction[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.script import ([m
     CScript,[m
     OP_CHECKSEQUENCEVERIFY,[m
[33mdiff --git a/test/functional/feature_dersig.py b/test/functional/feature_dersig.py[m
[33mindex 05fdacd451..f263c93c8a 100755[m
[33m--- a/test/functional/feature_dersig.py[m
[33m+++ b/test/functional/feature_dersig.py[m
[36m@@ -9,7 +9,7 @@[m [mTest that the DERSIG soft-fork activates at (regtest) height 1251.[m
 [m
 from test_framework.blocktools import create_coinbase, create_block, create_transaction[m
 from test_framework.messages import msg_block[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.script import CScript[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
[33mdiff --git a/test/functional/feature_maxuploadtarget.py b/test/functional/feature_maxuploadtarget.py[m
[33mindex 0dc2839191..e5c62d1ea7 100755[m
[33m--- a/test/functional/feature_maxuploadtarget.py[m
[33m+++ b/test/functional/feature_maxuploadtarget.py[m
[36m@@ -14,7 +14,7 @@[m [mfrom collections import defaultdict[m
 import time[m
 [m
 from test_framework.messages import CInv, MSG_BLOCK, msg_getdata[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal, mine_large_block[m
 [m
[33mdiff --git a/test/functional/feature_notifications.py b/test/functional/feature_notifications.py[m
[33mindex dd4c318cee..3497b49a19 100755[m
[33m--- a/test/functional/feature_notifications.py[m
[33m+++ b/test/functional/feature_notifications.py[m
[36m@@ -9,7 +9,6 @@[m [mfrom test_framework.address import ADDRESS_BCRT1_UNSPENDABLE, keyhash_to_p2pkh[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[31m-    wait_until,[m
     connect_nodes,[m
     disconnect_nodes,[m
     hex_str_to_bytes,[m
[36m@@ -56,7 +55,7 @@[m [mclass NotificationsTest(BitcoinTestFramework):[m
         blocks = self.nodes[1].generatetoaddress(block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)[m
 [m
         # wait at most 10 seconds for expected number of files before reading the content[m
[31m-        wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)[m
[32m+[m[32m        self.wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)[m
 [m
         # directory content should equal the generated blocks hashes[m
         assert_equal(sorted(blocks), sorted(os.listdir(self.blocknotify_dir)))[m
[36m@@ -64,7 +63,7 @@[m [mclass NotificationsTest(BitcoinTestFramework):[m
         if self.is_wallet_compiled():[m
             self.log.info("test -walletnotify")[m
             # wait at most 10 seconds for expected number of files before reading the content[m
[31m-            wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)[m
[32m+[m[32m            self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)[m
 [m
             # directory content should equal the generated transaction hashes[m
             txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions("*", block_count)))[m
[36m@@ -78,7 +77,7 @@[m [mclass NotificationsTest(BitcoinTestFramework):[m
             self.start_node(1)[m
             connect_nodes(self.nodes[0], 1)[m
 [m
[31m-            wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)[m
[32m+[m[32m            self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)[m
 [m
             # directory content should equal the generated transaction hashes[m
             txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions("*", block_count)))[m
[36m@@ -140,7 +139,7 @@[m [mclass NotificationsTest(BitcoinTestFramework):[m
         # TODO: add test for `-alertnotify` large fork notifications[m
 [m
     def expect_wallet_notify(self, tx_ids):[m
[31m-        wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)[m
[32m+[m[32m        self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)[m
         assert_equal(sorted(notify_outputname(self.wallet, tx_id) for tx_id in tx_ids), sorted(os.listdir(self.walletnotify_dir)))[m
         for tx_file in os.listdir(self.walletnotify_dir):[m
             os.remove(os.path.join(self.walletnotify_dir, tx_file))[m
[33mdiff --git a/test/functional/feature_pruning.py b/test/functional/feature_pruning.py[m
[33mindex 02fa88f7c8..db408ab67a 100755[m
[33m--- a/test/functional/feature_pruning.py[m
[33m+++ b/test/functional/feature_pruning.py[m
[36m@@ -20,7 +20,6 @@[m [mfrom test_framework.util import ([m
     assert_raises_rpc_error,[m
     connect_nodes,[m
     disconnect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 # Rescans start at the earliest block up to 2 hours before a key timestamp, so[m
[36m@@ -136,7 +135,7 @@[m [mclass PruneTest(BitcoinTestFramework):[m
         mine_large_blocks(self.nodes[0], 25)[m
 [m
         # Wait for blk00000.dat to be pruned[m
[31m-        wait_until(lambda: not os.path.isfile(os.path.join(self.prunedir, "blk00000.dat")), timeout=30)[m
[32m+[m[32m        self.wait_until(lambda: not os.path.isfile(os.path.join(self.prunedir, "blk00000.dat")), timeout=30)[m
 [m
         self.log.info("Success")[m
         usage = calc_usage(self.prunedir)[m
[36m@@ -250,7 +249,7 @@[m [mclass PruneTest(BitcoinTestFramework):[m
 [m
         self.log.info("Verify node 2 reorged back to the main chain, some blocks of which it had to redownload")[m
         # Wait for Node 2 to reorg to proper height[m
[31m-        wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)[m
         assert_equal(self.nodes[2].getbestblockhash(), goalbesthash)[m
         # Verify we can now have the data for a block previously pruned[m
         assert_equal(self.nodes[2].getblock(self.forkhash)["height"], self.forkheight)[m
[33mdiff --git a/test/functional/feature_shutdown.py b/test/functional/feature_shutdown.py[m
[33mindex d782d3b1d8..a76e0f1b50 100755[m
[33m--- a/test/functional/feature_shutdown.py[m
[33m+++ b/test/functional/feature_shutdown.py[m
[36m@@ -5,7 +5,7 @@[m
 """Test bitcoind shutdown."""[m
 [m
 from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.util import assert_equal, get_rpc_proxy, wait_until[m
[32m+[m[32mfrom test_framework.util import assert_equal, get_rpc_proxy[m
 from threading import Thread[m
 [m
 def test_long_call(node):[m
[36m@@ -25,7 +25,7 @@[m [mclass ShutdownTest(BitcoinTestFramework):[m
         node.getblockcount()[m
         Thread(target=test_long_call, args=(node,)).start()[m
         # Wait until the server is executing the above `waitfornewblock`.[m
[31m-        wait_until(lambda: len(self.nodes[0].getrpcinfo()['active_commands']) == 2)[m
[32m+[m[32m        self.wait_until(lambda: len(self.nodes[0].getrpcinfo()['active_commands']) == 2)[m
         # Wait 1 second after requesting shutdown but not before the `stop` call[m
         # finishes. This is to ensure event loop waits for current connections[m
         # to close.[m
[33mdiff --git a/test/functional/feature_versionbits_warning.py b/test/functional/feature_versionbits_warning.py[m
[33mindex 0713925141..e045adac32 100755[m
[33m--- a/test/functional/feature_versionbits_warning.py[m
[33m+++ b/test/functional/feature_versionbits_warning.py[m
[36m@@ -12,9 +12,8 @@[m [mimport re[m
 [m
 from test_framework.blocktools import create_block, create_coinbase[m
 from test_framework.messages import msg_block[m
[31m-from test_framework.mininode import P2PInterface, mininode_lock[m
[32m+[m[32mfrom test_framework.p2p import p2p_lock, P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.util import wait_until[m
 [m
 VB_PERIOD = 144           # versionbits period length for regtest[m
 VB_THRESHOLD = 108        # versionbits activation threshold for regtest[m
[36m@@ -91,14 +90,14 @@[m [mclass VersionBitsWarningTest(BitcoinTestFramework):[m
 [m
         # Generating one block guarantees that we'll get out of IBD[m
         node.generatetoaddress(1, node_deterministic_address)[m
[31m-        wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'], timeout=10, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'], timeout=10, lock=p2p_lock)[m
         # Generating one more block will be enough to generate an error.[m
         node.generatetoaddress(1, node_deterministic_address)[m
         # Check that get*info() shows the versionbits unknown rules warning[m
         assert WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()["warnings"][m
         assert WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()["warnings"][m
         # Check that the alert file shows the versionbits unknown rules warning[m
[31m-        wait_until(lambda: self.versionbits_in_alert_file(), timeout=60)[m
[32m+[m[32m        self.wait_until(lambda: self.versionbits_in_alert_file())[m
 [m
 if __name__ == '__main__':[m
     VersionBitsWarningTest().main()[m
[33mdiff --git a/test/functional/interface_zmq.py b/test/functional/interface_zmq.py[m
[33mindex 89c55f31f3..ef4780cacb 100755[m
[33m--- a/test/functional/interface_zmq.py[m
[33m+++ b/test/functional/interface_zmq.py[m
[36m@@ -54,28 +54,31 @@[m [mclass ZMQTest (BitcoinTestFramework):[m
             self.ctx.destroy(linger=None)[m
 [m
     def test_basic(self):[m
[31m-        # All messages are received in the same socket which means[m
[31m-        # that this test fails if the publishing order changes.[m
[31m-        # Note that the publishing order is not defined in the documentation and[m
[31m-        # is subject to change.[m
         import zmq[m
 [m
         # Invalid zmq arguments don't take down the node, see #17185.[m
         self.restart_node(0, ["-zmqpubrawtx=foo", "-zmqpubhashtx=bar"])[m
 [m
         address = 'tcp://127.0.0.1:28332'[m
[31m-        socket = self.ctx.socket(zmq.SUB)[m
[31m-        socket.set(zmq.RCVTIMEO, 60000)[m
[32m+[m[32m        sockets = [][m
[32m+[m[32m        subs = [][m
[32m+[m[32m        services = [b"hashblock", b"hashtx", b"rawblock", b"rawtx"][m
[32m+[m[32m        for service in services:[m
[32m+[m[32m            sockets.append(self.ctx.socket(zmq.SUB))[m
[32m+[m[32m            sockets[-1].set(zmq.RCVTIMEO, 60000)[m
[32m+[m[32m            subs.append(ZMQSubscriber(sockets[-1], service))[m
 [m
         # Subscribe to all available topics.[m
[31m-        hashblock = ZMQSubscriber(socket, b"hashblock")[m
[31m-        hashtx = ZMQSubscriber(socket, b"hashtx")[m
[31m-        rawblock = ZMQSubscriber(socket, b"rawblock")[m
[31m-        rawtx = ZMQSubscriber(socket, b"rawtx")[m
[32m+[m[32m        hashblock = subs[0][m
[32m+[m[32m        hashtx = subs[1][m
[32m+[m[32m        rawblock = subs[2][m
[32m+[m[32m        rawtx = subs[3][m
 [m
         self.restart_node(0, ["-zmqpub%s=%s" % (sub.topic.decode(), address) for sub in [hashblock, hashtx, rawblock, rawtx]])[m
         connect_nodes(self.nodes[0], 1)[m
[31m-        socket.connect(address)[m
[32m+[m[32m        for socket in sockets:[m
[32m+[m[32m            socket.connect(address)[m
[32m+[m
         # Relax so that the subscriber is ready before publishing zmq messages[m
         sleep(0.2)[m
 [m
[36m@@ -96,15 +99,16 @@[m [mclass ZMQTest (BitcoinTestFramework):[m
             tx.calc_sha256()[m
             assert_equal(tx.hash, txid.hex())[m
 [m
[2m+[m[2m            # Should receive the generated raw block.[m
[2m+[m[2m            block = rawblock.receive()[m
[2m+[m[2m            assert_equal(genhashes[x], hash256_reversed(block[:80]).hex())[m
[32m+[m
             # Should receive the generated block hash.[m
             hash = hashblock.receive().hex()[m
             assert_equal(genhashes[x], hash)[m
             # The block should only have the coinbase txid.[m
             assert_equal([txid.hex()], self.nodes[1].getblock(hash)["tx"])[m
 [m
[2m-            # Should receive the generated raw block.[m
[2m-            block = rawblock.receive()[m
[2m-            assert_equal(genhashes[x], hash256_reversed(block[:80]).hex())[m
 [m
         if self.is_wallet_compiled():[m
             self.log.info("Wait for tx from second node")[m
[36m@@ -119,6 +123,13 @@[m [mclass ZMQTest (BitcoinTestFramework):[m
             hex = rawtx.receive()[m
             assert_equal(payment_txid, hash256_reversed(hex).hex())[m
 [m
[32m+[m[32m            # Mining the block with this tx should result in second notification[m
[32m+[m[32m            # after coinbase tx notification[m
[32m+[m[32m            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[m
[32m+[m[32m            hashtx.receive()[m
[32m+[m[32m            txid = hashtx.receive()[m
[32m+[m[32m            assert_equal(payment_txid, txid.hex())[m
[32m+[m
 [m
         self.log.info("Test the getzmqnotifications RPC")[m
         assert_equal(self.nodes[0].getzmqnotifications(), [[m
[36m@@ -131,30 +142,67 @@[m [mclass ZMQTest (BitcoinTestFramework):[m
         assert_equal(self.nodes[1].getzmqnotifications(), [])[m
 [m
     def test_reorg(self):[m
[32m+[m[32m        if not self.is_wallet_compiled():[m
[32m+[m[32m            self.log.info("Skipping reorg test because wallet is disabled")[m
[32m+[m[32m            return[m
[32m+[m
         import zmq[m
         address = 'tcp://127.0.0.1:28333'[m
[31m-        socket = self.ctx.socket(zmq.SUB)[m
[31m-        socket.set(zmq.RCVTIMEO, 60000)[m
[31m-        hashblock = ZMQSubscriber(socket, b'hashblock')[m
[32m+[m
[32m+[m[32m        services = [b"hashblock", b"hashtx"][m
[32m+[m[32m        sockets = [][m
[32m+[m[32m        subs = [][m
[32m+[m[32m        for service in services:[m
[32m+[m[32m            sockets.append(self.ctx.socket(zmq.SUB))[m
[32m+[m[32m            # 2 second timeout to check end of notifications[m
[32m+[m[32m            sockets[-1].set(zmq.RCVTIMEO, 2000)[m
[32m+[m[32m            subs.append(ZMQSubscriber(sockets[-1], service))[m
[32m+[m
[32m+[m[32m        # Subscribe to all available topics.[m
[32m+[m[32m        hashblock = subs[0][m
[32m+[m[32m        hashtx = subs[1][m
 [m
         # Should only notify the tip if a reorg occurs[m
[31m-        self.restart_node(0, ['-zmqpub%s=%s' % (hashblock.topic.decode(), address)])[m
[31m-        socket.connect(address)[m
[32m+[m[32m        self.restart_node(0, ["-zmqpub%s=%s" % (sub.topic.decode(), address) for sub in [hashblock, hashtx]])[m
[32m+[m[32m        for socket in sockets:[m
[32m+[m[32m            socket.connect(address)[m
         # Relax so that the subscriber is ready before publishing zmq messages[m
         sleep(0.2)[m
 [m
[31m-        # Generate 1 block in nodes[0] and receive all notifications[m
[31m-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[m
[32m+[m[32m        # Generate 1 block in nodes[0] with 1 mempool tx and receive all notifications[m
[32m+[m[32m        payment_txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)[m
[32m+[m[32m        disconnect_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0][m
[32m+[m[32m        disconnect_cb = self.nodes[0].getblock(disconnect_block)["tx"][0][m
         assert_equal(self.nodes[0].getbestblockhash(), hashblock.receive().hex())[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), payment_txid)[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), disconnect_cb)[m
 [m
         # Generate 2 blocks in nodes[1][m
[31m-        self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_UNSPENDABLE)[m
[32m+[m[32m        connect_blocks = self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_UNSPENDABLE)[m
 [m
         # nodes[0] will reorg chain after connecting back nodes[1][m
         connect_nodes(self.nodes[0], 1)[m
[32m+[m[32m        self.sync_blocks() # tx in mempool valid but not advertised[m
 [m
         # Should receive nodes[1] tip[m
         assert_equal(self.nodes[1].getbestblockhash(), hashblock.receive().hex())[m
 [m
[32m+[m[32m        # During reorg:[m
[32m+[m[32m        # Get old payment transaction notification from disconnect and disconnected cb[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), payment_txid)[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), disconnect_cb)[m
[32m+[m[32m        # And the payment transaction again due to mempool entry[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), payment_txid)[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), payment_txid)[m
[32m+[m[32m        # And the new connected coinbases[m
[32m+[m[32m        for i in [0, 1]:[m
[32m+[m[32m            assert_equal(hashtx.receive().hex(), self.nodes[1].getblock(connect_blocks[i])["tx"][0])[m
[32m+[m
[32m+[m[32m        # If we do a simple invalidate we announce the disconnected coinbase[m
[32m+[m[32m        self.nodes[0].invalidateblock(connect_blocks[1])[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), self.nodes[1].getblock(connect_blocks[1])["tx"][0])[m
[32m+[m[32m        # And the current tip[m
[32m+[m[32m        assert_equal(hashtx.receive().hex(), self.nodes[1].getblock(connect_blocks[0])["tx"][0])[m
[32m+[m
 if __name__ == '__main__':[m
     ZMQTest().main()[m
[33mdiff --git a/test/functional/mempool_compatibility.py b/test/functional/mempool_compatibility.py[m
[33mindex 31fb751904..75ca8d3236 100755[m
[33m--- a/test/functional/mempool_compatibility.py[m
[33m+++ b/test/functional/mempool_compatibility.py[m
[36m@@ -8,7 +8,7 @@[m [mNOTE: The test is designed to prevent cases when compatibility is broken acciden[m
 In case we need to break mempool compatibility we can continue to use the test by just bumping the version number.[m
 [m
 Download node binaries:[m
[31m-contrib/devtools/previous_release.py -b v0.19.1 v0.18.1 v0.17.1 v0.16.3 v0.15.2[m
[32m+[m[32mtest/get_previous_releases.py -b v0.19.1 v0.18.1 v0.17.1 v0.16.3 v0.15.2[m
 [m
 Only v0.15.2 is required by this test. The rest is used in other backwards compatibility tests.[m
 """[m
[33mdiff --git a/test/functional/mempool_packages.py b/test/functional/mempool_packages.py[m
[33mindex 98dac30ace..e74ef8cf16 100755[m
[33m--- a/test/functional/mempool_packages.py[m
[33m+++ b/test/functional/mempool_packages.py[m
[36m@@ -7,13 +7,12 @@[m
 from decimal import Decimal[m
 [m
 from test_framework.messages import COIN[m
[31m-from test_framework.mininode import P2PTxInvStore[m
[32m+[m[32mfrom test_framework.p2p import P2PTxInvStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
     assert_raises_rpc_error,[m
     satoshi_round,[m
[31m-    wait_until,[m
 )[m
 [m
 # default limits[m
[36m@@ -269,8 +268,8 @@[m [mclass MempoolPackagesTest(BitcoinTestFramework):[m
         # - txs from previous ancestor test (-> custom ancestor limit)[m
         # - parent tx for descendant test[m
         # - txs chained off parent tx (-> custom descendant limit)[m
[31m-        wait_until(lambda: len(self.nodes[1].getrawmempool(False)) ==[m
[31m-                           MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=10)[m
[32m+[m[32m        self.wait_until(lambda: len(self.nodes[1].getrawmempool(False)) ==[m
[32m+[m[32m                                MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=10)[m
         mempool0 = self.nodes[0].getrawmempool(False)[m
         mempool1 = self.nodes[1].getrawmempool(False)[m
         assert set(mempool1).issubset(set(mempool0))[m
[33mdiff --git a/test/functional/mempool_persist.py b/test/functional/mempool_persist.py[m
[33mindex 85c4d6d570..f73f1a02a2 100755[m
[33m--- a/test/functional/mempool_persist.py[m
[33m+++ b/test/functional/mempool_persist.py[m
[36m@@ -39,15 +39,14 @@[m [mfrom decimal import Decimal[m
 import os[m
 import time[m
 [m
[32m+[m[32mfrom test_framework.p2p import P2PTxInvStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.mininode import P2PTxInvStore[m
 from test_framework.util import ([m
     assert_equal,[m
     assert_greater_than_or_equal,[m
     assert_raises_rpc_error,[m
     connect_nodes,[m
     disconnect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 [m
[36m@@ -172,7 +171,7 @@[m [mclass MempoolPersistTest(BitcoinTestFramework):[m
         # check that txn gets broadcast due to unbroadcast logic[m
         conn = node0.add_p2p_connection(P2PTxInvStore())[m
         node0.mockscheduler(16*60) # 15 min + 1 for buffer[m
[31m-        wait_until(lambda: len(conn.get_invs()) == 1)[m
[32m+[m[32m        self.wait_until(lambda: len(conn.get_invs()) == 1)[m
 [m
 if __name__ == '__main__':[m
     MempoolPersistTest().main()[m
[33mdiff --git a/test/functional/mempool_unbroadcast.py b/test/functional/mempool_unbroadcast.py[m
[33mindex 365d011157..abd5a03d95 100755[m
[33m--- a/test/functional/mempool_unbroadcast.py[m
[33m+++ b/test/functional/mempool_unbroadcast.py[m
[36m@@ -7,7 +7,7 @@[m [mto peers until a GETDATA is received."""[m
 [m
 import time[m
 [m
[31m-from test_framework.mininode import P2PTxInvStore[m
[32m+[m[32mfrom test_framework.p2p import P2PTxInvStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[33mdiff --git a/test/functional/mining_basic.py b/test/functional/mining_basic.py[m
[33mindex 63d1ccfb36..b13740750f 100755[m
[33m--- a/test/functional/mining_basic.py[m
[33m+++ b/test/functional/mining_basic.py[m
[36m@@ -20,7 +20,7 @@[m [mfrom test_framework.messages import ([m
     CBlockHeader,[m
     BLOCK_HEADER_SIZE,[m
 )[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[33mdiff --git a/test/functional/p2p_addr_relay.py b/test/functional/p2p_addr_relay.py[m
[33mindex 5c7e27a3a8..80f262d0d3 100755[m
[33m--- a/test/functional/p2p_addr_relay.py[m
[33m+++ b/test/functional/p2p_addr_relay.py[m
[36m@@ -12,9 +12,7 @@[m [mfrom test_framework.messages import ([m
     NODE_WITNESS,[m
     msg_addr,[m
 )[m
[31m-from test_framework.mininode import ([m
[31m-    P2PInterface,[m
[31m-)[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[33mdiff --git a/test/functional/p2p_blockfilters.py b/test/functional/p2p_blockfilters.py[m
[33mindex a9e86bd2fc..84178d0dd7 100755[m
[33m--- a/test/functional/p2p_blockfilters.py[m
[33m+++ b/test/functional/p2p_blockfilters.py[m
[36m@@ -18,13 +18,12 @@[m [mfrom test_framework.messages import ([m
     ser_uint256,[m
     uint256_from_str,[m
 )[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
     connect_nodes,[m
     disconnect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 class CFiltersClient(P2PInterface):[m
[36m@@ -65,11 +64,11 @@[m [mclass CompactFiltersTest(BitcoinTestFramework):[m
         disconnect_nodes(self.nodes[0], 1)[m
 [m
         self.nodes[0].generate(1)[m
[31m-        wait_until(lambda: self.nodes[0].getblockcount() == 1000)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[0].getblockcount() == 1000)[m
         stale_block_hash = self.nodes[0].getblockhash(1000)[m
 [m
         self.nodes[1].generate(1001)[m
[31m-        wait_until(lambda: self.nodes[1].getblockcount() == 2000)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[1].getblockcount() == 2000)[m
 [m
         # Check that nodes have signalled NODE_COMPACT_FILTERS correctly.[m
         assert node0.nServices & NODE_COMPACT_FILTERS != 0[m
[33mdiff --git a/test/functional/p2p_blocksonly.py b/test/functional/p2p_blocksonly.py[m
[33mindex 27e6b669f6..65259f1869 100755[m
[33m--- a/test/functional/p2p_blocksonly.py[m
[33m+++ b/test/functional/p2p_blocksonly.py[m
[36m@@ -5,7 +5,7 @@[m
 """Test p2p blocksonly"""[m
 [m
 from test_framework.messages import msg_tx, CTransaction, FromHex[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
 [m
[33mdiff --git a/test/functional/p2p_compactblocks.py b/test/functional/p2p_compactblocks.py[m
[33mindex 225d393e1b..fdae7fb68b 100755[m
[33m--- a/test/functional/p2p_compactblocks.py[m
[33m+++ b/test/functional/p2p_compactblocks.py[m
[36m@@ -11,10 +11,10 @@[m [mimport random[m
 [m
 from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment[m
 from test_framework.messages import BlockTransactions, BlockTransactionsRequest, calculate_shortid, CBlock, CBlockHeader, CInv, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, HeaderAndShortIDs, msg_no_witness_block, msg_no_witness_blocktxn, msg_cmpctblock, msg_getblocktxn, msg_getdata, msg_getheaders, msg_headers, msg_inv, msg_sendcmpct, msg_sendheaders, msg_tx, msg_block, msg_blocktxn, MSG_BLOCK, MSG_CMPCT_BLOCK, MSG_WITNESS_FLAG, NODE_NETWORK, P2PHeaderAndShortIDs, PrefilledTransaction, ser_uint256, ToHex[m
[31m-from test_framework.mininode import mininode_lock, P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import p2p_lock, P2PInterface[m
 from test_framework.script import CScript, OP_TRUE, OP_DROP[m
 from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.util import assert_equal, wait_until, softfork_active[m
[32m+[m[32mfrom test_framework.util import assert_equal, softfork_active[m
 [m
 # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.[m
 class TestP2PConn(P2PInterface):[m
[36m@@ -48,12 +48,12 @@[m [mclass TestP2PConn(P2PInterface):[m
                 self.block_announced = True[m
                 self.announced_blockhashes.add(x.hash)[m
 [m
[31m-    # Requires caller to hold mininode_lock[m
[32m+[m[32m    # Requires caller to hold p2p_lock[m
     def received_block_announcement(self):[m
         return self.block_announced[m
 [m
     def clear_block_announcement(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.block_announced = False[m
             self.last_message.pop("inv", None)[m
             self.last_message.pop("headers", None)[m
[36m@@ -73,7 +73,7 @@[m [mclass TestP2PConn(P2PInterface):[m
     def request_headers_and_sync(self, locator, hashstop=0):[m
         self.clear_block_announcement()[m
         self.get_headers(locator, hashstop)[m
[31m-        wait_until(self.received_block_announcement, timeout=30, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(self.received_block_announcement, timeout=30)[m
         self.clear_block_announcement()[m
 [m
     # Block until a block announcement for a particular block hash is[m
[36m@@ -81,7 +81,7 @@[m [mclass TestP2PConn(P2PInterface):[m
     def wait_for_block_announcement(self, block_hash, timeout=30):[m
         def received_hash():[m
             return (block_hash in self.announced_blockhashes)[m
[31m-        wait_until(received_hash, timeout=timeout, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(received_hash, timeout=timeout)[m
 [m
     def send_await_disconnect(self, message, timeout=30):[m
         """Sends a message to the node and wait for disconnect.[m
[36m@@ -89,7 +89,7 @@[m [mclass TestP2PConn(P2PInterface):[m
         This is used when we want to send a message into the node that we expect[m
         will get us disconnected, eg an invalid block."""[m
         self.send_message(message)[m
[31m-        wait_until(lambda: not self.is_connected, timeout=timeout, lock=mininode_lock)[m
[32m+[m[32m        self.wait_for_disconnect(timeout)[m
 [m
 class CompactBlocksTest(BitcoinTestFramework):[m
     def set_test_params(self):[m
[36m@@ -154,8 +154,8 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         # Make sure we get a SENDCMPCT message from our peer[m
         def received_sendcmpct():[m
             return (len(test_node.last_sendcmpct) > 0)[m
[31m-        wait_until(received_sendcmpct, timeout=30, lock=mininode_lock)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        test_node.wait_until(received_sendcmpct, timeout=30)[m
[32m+[m[32m        with p2p_lock:[m
             # Check that the first version received is the preferred one[m
             assert_equal(test_node.last_sendcmpct[0].version, preferred_version)[m
             # And that we receive versions down to 1.[m
[36m@@ -170,7 +170,7 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
             peer.wait_for_block_announcement(block_hash, timeout=30)[m
             assert peer.block_announced[m
 [m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 assert predicate(peer), ([m
                     "block_hash={!r}, cmpctblock={!r}, inv={!r}".format([m
                         block_hash, peer.last_message.get("cmpctblock", None), peer.last_message.get("inv", None)))[m
[36m@@ -294,11 +294,11 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         block.rehash()[m
 [m
         # Wait until the block was announced (via compact blocks)[m
[31m-        wait_until(lambda: "cmpctblock" in test_node.last_message, timeout=30, lock=mininode_lock)[m
[32m+[m[32m        test_node.wait_until(lambda: "cmpctblock" in test_node.last_message, timeout=30)[m
 [m
         # Now fetch and check the compact block[m
         header_and_shortids = None[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             # Convert the on-the-wire representation to absolute indexes[m
             header_and_shortids = HeaderAndShortIDs(test_node.last_message["cmpctblock"].header_and_shortids)[m
         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)[m
[36m@@ -308,11 +308,11 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         inv = CInv(MSG_CMPCT_BLOCK, block_hash)[m
         test_node.send_message(msg_getdata([inv]))[m
 [m
[31m-        wait_until(lambda: "cmpctblock" in test_node.last_message, timeout=30, lock=mininode_lock)[m
[32m+[m[32m        test_node.wait_until(lambda: "cmpctblock" in test_node.last_message, timeout=30)[m
 [m
         # Now fetch and check the compact block[m
         header_and_shortids = None[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             # Convert the on-the-wire representation to absolute indexes[m
             header_and_shortids = HeaderAndShortIDs(test_node.last_message["cmpctblock"].header_and_shortids)[m
         self.check_compactblock_construction_from_block(version, header_and_shortids, block_hash, block)[m
[36m@@ -378,7 +378,7 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
 [m
             if announce == "inv":[m
                 test_node.send_message(msg_inv([CInv(MSG_BLOCK, block.sha256)]))[m
[31m-                wait_until(lambda: "getheaders" in test_node.last_message, timeout=30, lock=mininode_lock)[m
[32m+[m[32m                test_node.wait_until(lambda: "getheaders" in test_node.last_message, timeout=30)[m
                 test_node.send_header_for_blocks([block])[m
             else:[m
                 test_node.send_header_for_blocks([block])[m
[36m@@ -397,7 +397,7 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
             test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))[m
             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)[m
             # Expect a getblocktxn message.[m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 assert "getblocktxn" in test_node.last_message[m
                 absolute_indexes = test_node.last_message["getblocktxn"].block_txn_request.to_absolute()[m
             assert_equal(absolute_indexes, [0])  # should be a coinbase request[m
[36m@@ -439,7 +439,7 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         def test_getblocktxn_response(compact_block, peer, expected_result):[m
             msg = msg_cmpctblock(compact_block.to_p2p())[m
             peer.send_and_ping(msg)[m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 assert "getblocktxn" in peer.last_message[m
                 absolute_indexes = peer.last_message["getblocktxn"].block_txn_request.to_absolute()[m
             assert_equal(absolute_indexes, expected_result)[m
[36m@@ -504,13 +504,13 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
             assert tx.hash in mempool[m
 [m
         # Clear out last request.[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             test_node.last_message.pop("getblocktxn", None)[m
 [m
         # Send compact block[m
         comp_block.initialize_from_block(block, prefill_list=[0], use_witness=with_witness)[m
         test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             # Shouldn't have gotten a request for any transaction[m
             assert "getblocktxn" not in test_node.last_message[m
 [m
[36m@@ -537,7 +537,7 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         comp_block.initialize_from_block(block, prefill_list=[0], use_witness=(version == 2))[m
         test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))[m
         absolute_indexes = [][m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             assert "getblocktxn" in test_node.last_message[m
             absolute_indexes = test_node.last_message["getblocktxn"].block_txn_request.to_absolute()[m
         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])[m
[36m@@ -588,10 +588,10 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
             num_to_request = random.randint(1, len(block.vtx))[m
             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))[m
             test_node.send_message(msg)[m
[31m-            wait_until(lambda: "blocktxn" in test_node.last_message, timeout=10, lock=mininode_lock)[m
[32m+[m[32m            test_node.wait_until(lambda: "blocktxn" in test_node.last_message, timeout=10)[m
 [m
             [tx.calc_sha256() for tx in block.vtx][m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 assert_equal(test_node.last_message["blocktxn"].block_transactions.blockhash, int(block_hash, 16))[m
                 all_indices = msg.block_txn_request.to_absolute()[m
                 for index in all_indices:[m
[36m@@ -611,11 +611,11 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         # allowed depth for a blocktxn response.[m
         block_hash = node.getblockhash(current_height)[m
         msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             test_node.last_message.pop("block", None)[m
             test_node.last_message.pop("blocktxn", None)[m
         test_node.send_and_ping(msg)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             test_node.last_message["block"].block.calc_sha256()[m
             assert_equal(test_node.last_message["block"].block.sha256, int(block_hash, 16))[m
             assert "blocktxn" not in test_node.last_message[m
[36m@@ -628,21 +628,21 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         for _ in range(MAX_CMPCTBLOCK_DEPTH + 1):[m
             test_node.clear_block_announcement()[m
             new_blocks.append(node.generate(1)[0])[m
[31m-            wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)[m
[32m+[m[32m            test_node.wait_until(test_node.received_block_announcement, timeout=30)[m
 [m
         test_node.clear_block_announcement()[m
         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))[m
[31m-        wait_until(lambda: "cmpctblock" in test_node.last_message, timeout=30, lock=mininode_lock)[m
[32m+[m[32m        test_node.wait_until(lambda: "cmpctblock" in test_node.last_message, timeout=30)[m
 [m
         test_node.clear_block_announcement()[m
         node.generate(1)[m
[31m-        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)[m
[32m+[m[32m        test_node.wait_until(test_node.received_block_announcement, timeout=30)[m
         test_node.clear_block_announcement()[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             test_node.last_message.pop("block", None)[m
         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))[m
[31m-        wait_until(lambda: "block" in test_node.last_message, timeout=30, lock=mininode_lock)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        test_node.wait_until(lambda: "block" in test_node.last_message, timeout=30)[m
[32m+[m[32m        with p2p_lock:[m
             test_node.last_message["block"].block.calc_sha256()[m
             assert_equal(test_node.last_message["block"].block.sha256, int(new_blocks[0], 16))[m
 [m
[36m@@ -670,10 +670,10 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         # (to avoid fingerprinting attacks).[m
         msg = msg_getblocktxn()[m
         msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             test_node.last_message.pop("blocktxn", None)[m
         test_node.send_and_ping(msg)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             assert "blocktxn" not in test_node.last_message[m
 [m
     def test_end_to_end_block_relay(self, listeners):[m
[36m@@ -689,8 +689,8 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
         node.submitblock(ToHex(block))[m
 [m
         for l in listeners:[m
[31m-            wait_until(lambda: "cmpctblock" in l.last_message, timeout=30, lock=mininode_lock)[m
[31m-        with mininode_lock:[m
[32m+[m[32m            l.wait_until(lambda: "cmpctblock" in l.last_message, timeout=30)[m
[32m+[m[32m        with p2p_lock:[m
             for l in listeners:[m
                 l.last_message["cmpctblock"].header_and_shortids.header.calc_sha256()[m
                 assert_equal(l.last_message["cmpctblock"].header_and_shortids.header.sha256, block.sha256)[m
[36m@@ -747,7 +747,7 @@[m [mclass CompactBlocksTest(BitcoinTestFramework):[m
             cmpct_block.initialize_from_block(block)[m
             msg = msg_cmpctblock(cmpct_block.to_p2p())[m
             peer.send_and_ping(msg)[m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 assert "getblocktxn" in peer.last_message[m
             return block, cmpct_block[m
 [m
[33mdiff --git a/test/functional/p2p_disconnect_ban.py b/test/functional/p2p_disconnect_ban.py[m
[33mindex 09b9ebeb2d..b7c2a306eb 100755[m
[33m--- a/test/functional/p2p_disconnect_ban.py[m
[33m+++ b/test/functional/p2p_disconnect_ban.py[m
[36m@@ -10,7 +10,6 @@[m [mfrom test_framework.util import ([m
     assert_equal,[m
     assert_raises_rpc_error,[m
     connect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 class DisconnectBanTest(BitcoinTestFramework):[m
[36m@@ -28,7 +27,7 @@[m [mclass DisconnectBanTest(BitcoinTestFramework):[m
         self.log.info("setban: successfully ban single IP address")[m
         assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point[m
         self.nodes[1].setban(subnet="127.0.0.1", command="add")[m
[31m-        wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)[m
[32m+[m[32m        self.wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)[m
         assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point[m
         assert_equal(len(self.nodes[1].listbanned()), 1)[m
 [m
[36m@@ -95,7 +94,7 @@[m [mclass DisconnectBanTest(BitcoinTestFramework):[m
         self.log.info("disconnectnode: successfully disconnect node by address")[m
         address1 = self.nodes[0].getpeerinfo()[0]['addr'][m
         self.nodes[0].disconnectnode(address=address1)[m
[31m-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)[m
[32m+[m[32m        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)[m
         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1][m
 [m
         self.log.info("disconnectnode: successfully reconnect node")[m
[36m@@ -106,7 +105,7 @@[m [mclass DisconnectBanTest(BitcoinTestFramework):[m
         self.log.info("disconnectnode: successfully disconnect node by node id")[m
         id1 = self.nodes[0].getpeerinfo()[0]['id'][m
         self.nodes[0].disconnectnode(nodeid=id1)[m
[31m-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)[m
[32m+[m[32m        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)[m
         assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1][m
 [m
 if __name__ == '__main__':[m
[33mdiff --git a/test/functional/p2p_dos_header_tree.py b/test/functional/p2p_dos_header_tree.py[m
[33mindex f8552cf53d..7dd8c3146b 100755[m
[33m--- a/test/functional/p2p_dos_header_tree.py[m
[33m+++ b/test/functional/p2p_dos_header_tree.py[m
[36m@@ -8,7 +8,7 @@[m [mfrom test_framework.messages import ([m
     CBlockHeader,[m
     FromHex,[m
 )[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PInterface,[m
     msg_headers,[m
 )[m
[33mdiff --git a/test/functional/p2p_eviction.py b/test/functional/p2p_eviction.py[m
[33mindex b2b3a89aab..72a255991c 100755[m
[33m--- a/test/functional/p2p_eviction.py[m
[33m+++ b/test/functional/p2p_eviction.py[m
[36m@@ -15,11 +15,11 @@[m [mTherefore, this test is limited to the remaining protection criteria.[m
 [m
 import time[m
 [m
[2m-from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.mininode import P2PInterface, P2PDataStore[m
[31m-from test_framework.util import assert_equal, wait_until[m
 from test_framework.blocktools import create_block, create_coinbase[m
 from test_framework.messages import CTransaction, FromHex, msg_pong, msg_tx[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore, P2PInterface[m
[2m+[m[2mfrom test_framework.test_framework import BitcoinTestFramework[m
[32m+[m[32mfrom test_framework.util import assert_equal[m
 [m
 [m
 class SlowP2PDataStore(P2PDataStore):[m
[36m@@ -92,7 +92,7 @@[m [mclass P2PEvict(BitcoinTestFramework):[m
         for _ in range(8):[m
             fastpeer = node.add_p2p_connection(P2PInterface())[m
             current_peer += 1[m
[31m-            wait_until(lambda: "ping" in fastpeer.last_message, timeout=10)[m
[32m+[m[32m            self.wait_until(lambda: "ping" in fastpeer.last_message, timeout=10)[m
 [m
         # Make sure by asking the node what the actual min pings are[m
         peerinfo = node.getpeerinfo()[m
[33mdiff --git a/test/functional/p2p_feefilter.py b/test/functional/p2p_feefilter.py[m
[33mindex 3a9b8dfbd7..0c07b56a69 100755[m
[33m--- a/test/functional/p2p_feefilter.py[m
[33m+++ b/test/functional/p2p_feefilter.py[m
[36m@@ -7,7 +7,7 @@[m
 from decimal import Decimal[m
 [m
 from test_framework.messages import MSG_TX, MSG_WTX, msg_feefilter[m
[31m-from test_framework.mininode import mininode_lock, P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface, p2p_lock[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
 [m
[36m@@ -23,7 +23,7 @@[m [mclass FeefilterConn(P2PInterface):[m
         self.feefilter_received = True[m
 [m
     def assert_feefilter_received(self, recv: bool):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             assert_equal(self.feefilter_received, recv)[m
 [m
 [m
[36m@@ -39,10 +39,10 @@[m [mclass TestP2PConn(P2PInterface):[m
 [m
     def wait_for_invs_to_match(self, invs_expected):[m
         invs_expected.sort()[m
[31m-        self.wait_until(lambda: invs_expected == sorted(self.txinvs), timeout=60)[m
[32m+[m[32m        self.wait_until(lambda: invs_expected == sorted(self.txinvs))[m
 [m
     def clear_invs(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.txinvs = [][m
 [m
 [m
[33mdiff --git a/test/functional/p2p_filter.py b/test/functional/p2p_filter.py[m
[33mindex ce3856fc95..613d96eaad 100755[m
[33m--- a/test/functional/p2p_filter.py[m
[33m+++ b/test/functional/p2p_filter.py[m
[36m@@ -19,7 +19,7 @@[m [mfrom test_framework.messages import ([m
     msg_mempool,[m
     msg_version,[m
 )[m
[31m-from test_framework.mininode import P2PInterface, mininode_lock[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface, p2p_lock[m
 from test_framework.script import MAX_SCRIPT_ELEMENT_SIZE[m
 from test_framework.test_framework import BitcoinTestFramework[m
 [m
[36m@@ -60,22 +60,22 @@[m [mclass P2PBloomFilter(P2PInterface):[m
 [m
     @property[m
     def tx_received(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             return self._tx_received[m
 [m
     @tx_received.setter[m
     def tx_received(self, value):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self._tx_received = value[m
 [m
     @property[m
     def merkleblock_received(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             return self._merkleblock_received[m
 [m
     @merkleblock_received.setter[m
     def merkleblock_received(self, value):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self._merkleblock_received = value[m
 [m
 [m
[33mdiff --git a/test/functional/p2p_fingerprint.py b/test/functional/p2p_fingerprint.py[m
[33mindex d743abe681..aaf862e6c8 100755[m
[33m--- a/test/functional/p2p_fingerprint.py[m
[33m+++ b/test/functional/p2p_fingerprint.py[m
[36m@@ -12,7 +12,7 @@[m [mimport time[m
 [m
 from test_framework.blocktools import (create_block, create_coinbase)[m
 from test_framework.messages import CInv, MSG_BLOCK[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PInterface,[m
     msg_headers,[m
     msg_block,[m
[36m@@ -22,9 +22,9 @@[m [mfrom test_framework.mininode import ([m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[31m-    wait_until,[m
 )[m
 [m
[32m+[m
 class P2PFingerprintTest(BitcoinTestFramework):[m
     def set_test_params(self):[m
         self.setup_clean_chain = True[m
[36m@@ -102,12 +102,12 @@[m [mclass P2PFingerprintTest(BitcoinTestFramework):[m
         # Check that getdata request for stale block succeeds[m
         self.send_block_request(stale_hash, node0)[m
         test_function = lambda: self.last_block_equals(stale_hash, node0)[m
[31m-        wait_until(test_function, timeout=3)[m
[32m+[m[32m        self.wait_until(test_function, timeout=3)[m
 [m
         # Check that getheader request for stale block header succeeds[m
         self.send_header_request(stale_hash, node0)[m
         test_function = lambda: self.last_header_equals(stale_hash, node0)[m
[31m-        wait_until(test_function, timeout=3)[m
[32m+[m[32m        self.wait_until(test_function, timeout=3)[m
 [m
         # Longest chain is extended so stale is much older than chain tip[m
         self.nodes[0].setmocktime(0)[m
[36m@@ -138,11 +138,11 @@[m [mclass P2PFingerprintTest(BitcoinTestFramework):[m
 [m
         self.send_block_request(block_hash, node0)[m
         test_function = lambda: self.last_block_equals(block_hash, node0)[m
[31m-        wait_until(test_function, timeout=3)[m
[32m+[m[32m        self.wait_until(test_function, timeout=3)[m
 [m
         self.send_header_request(block_hash, node0)[m
         test_function = lambda: self.last_header_equals(block_hash, node0)[m
[31m-        wait_until(test_function, timeout=3)[m
[32m+[m[32m        self.wait_until(test_function, timeout=3)[m
 [m
 if __name__ == '__main__':[m
     P2PFingerprintTest().main()[m
[33mdiff --git a/test/functional/p2p_getaddr_caching.py b/test/functional/p2p_getaddr_caching.py[m
[33mindex c9278eab92..6622ea9ec2 100755[m
[33m--- a/test/functional/p2p_getaddr_caching.py[m
[33m+++ b/test/functional/p2p_getaddr_caching.py[m
[36m@@ -12,9 +12,9 @@[m [mfrom test_framework.messages import ([m
     msg_addr,[m
     msg_getaddr,[m
 )[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PInterface,[m
[31m-    mininode_lock[m
[32m+[m[32m    p2p_lock[m
 )[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
[36m@@ -44,7 +44,7 @@[m [mclass AddrReceiver(P2PInterface):[m
         self.received_addrs = None[m
 [m
     def get_received_addrs(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             return self.received_addrs[m
 [m
     def on_addr(self, message):[m
[33mdiff --git a/test/functional/p2p_getdata.py b/test/functional/p2p_getdata.py[m
[33mindex d1b11c2c61..51921a8ab5 100755[m
[33m--- a/test/functional/p2p_getdata.py[m
[33m+++ b/test/functional/p2p_getdata.py[m
[36m@@ -9,7 +9,7 @@[m [mfrom test_framework.messages import ([m
     CInv,[m
     msg_getdata,[m
 )[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 [m
 [m
[33mdiff --git a/test/functional/p2p_invalid_block.py b/test/functional/p2p_invalid_block.py[m
[33mindex e280a62997..b2c3c5d45f 100755[m
[33m--- a/test/functional/p2p_invalid_block.py[m
[33m+++ b/test/functional/p2p_invalid_block.py[m
[36m@@ -14,7 +14,7 @@[m [mimport copy[m
 [m
 from test_framework.blocktools import create_block, create_coinbase, create_tx_with_script[m
 from test_framework.messages import COIN[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
 [m
[33mdiff --git a/test/functional/p2p_invalid_locator.py b/test/functional/p2p_invalid_locator.py[m
[33mindex 0155eb21f0..24328c2919 100755[m
[33m--- a/test/functional/p2p_invalid_locator.py[m
[33m+++ b/test/functional/p2p_invalid_locator.py[m
[36m@@ -6,7 +6,7 @@[m
 """[m
 [m
 from test_framework.messages import msg_getheaders, msg_getblocks, MAX_LOCATOR_SZ[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 [m
 [m
[33mdiff --git a/test/functional/p2p_invalid_messages.py b/test/functional/p2p_invalid_messages.py[m
[33mindex d9a9ae5188..fe57057a83 100755[m
[33m--- a/test/functional/p2p_invalid_messages.py[m
[33m+++ b/test/functional/p2p_invalid_messages.py[m
[36m@@ -17,14 +17,13 @@[m [mfrom test_framework.messages import ([m
     MSG_TX,[m
     ser_string,[m
 )[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PDataStore,[m
     P2PInterface,[m
 )[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[31m-    wait_until,[m
 )[m
 [m
 VALID_DATA_LIMIT = MAX_PROTOCOL_MESSAGE_LENGTH - 5  # Account for the 5-byte length prefix[m
[36m@@ -70,7 +69,7 @@[m [mclass InvalidMessagesTest(BitcoinTestFramework):[m
         before = int(self.nodes[0].getnettotals()['totalbytesrecv'])[m
         conn.send_raw_message(msg[:cut_pos])[m
         # Wait until node has processed the first half of the message[m
[31m-        wait_until(lambda: int(self.nodes[0].getnettotals()['totalbytesrecv']) != before)[m
[32m+[m[32m        self.wait_until(lambda: int(self.nodes[0].getnettotals()['totalbytesrecv']) != before)[m
         middle = int(self.nodes[0].getnettotals()['totalbytesrecv'])[m
         # If this assert fails, we've hit an unlikely race[m
         # where the test framework sent a message in between the two halves[m
[33mdiff --git a/test/functional/p2p_invalid_tx.py b/test/functional/p2p_invalid_tx.py[m
[33mindex c70a892463..a0ef6c9d6e 100755[m
[33m--- a/test/functional/p2p_invalid_tx.py[m
[33m+++ b/test/functional/p2p_invalid_tx.py[m
[36m@@ -13,11 +13,10 @@[m [mfrom test_framework.messages import ([m
     CTxIn,[m
     CTxOut,[m
 )[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[31m-    wait_until,[m
 )[m
 from data import invalid_txs[m
 [m
[36m@@ -146,7 +145,7 @@[m [mclass InvalidTxRequestTest(BitcoinTestFramework):[m
         # tx_orphan_no_fee, because it has too low fee (p2ps[0] is not disconnected for relaying that tx)[m
         # tx_orphan_invaid, because it has negative fee (p2ps[1] is disconnected for relaying that tx)[m
 [m
[31m-        wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected[m
[32m+[m[32m        self.wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected[m
         assert_equal(expected_mempool, set(node.getrawmempool()))[m
 [m
         self.log.info('Test orphan pool overflow')[m
[33mdiff --git a/test/functional/p2p_leak.py b/test/functional/p2p_leak.py[m
[33mindex 79bf7b2e7c..4978aa3845 100755[m
[33m--- a/test/functional/p2p_leak.py[m
[33m+++ b/test/functional/p2p_leak.py[m
[36m@@ -17,12 +17,11 @@[m [mfrom test_framework.messages import ([m
     msg_ping,[m
     msg_version,[m
 )[m
[31m-from test_framework.mininode import mininode_lock, P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import p2p_lock, P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
     assert_greater_than_or_equal,[m
[31m-    wait_until,[m
 )[m
 [m
 DISCOURAGEMENT_THRESHOLD = 100[m
[36m@@ -114,9 +113,9 @@[m [mclass P2PLeakTest(BitcoinTestFramework):[m
         # verack, since we never sent one[m
         no_verack_idle_peer.wait_for_verack()[m
 [m
[31m-        wait_until(lambda: no_version_disconnect_peer.ever_connected, timeout=10, lock=mininode_lock)[m
[31m-        wait_until(lambda: no_version_idle_peer.ever_connected, timeout=10, lock=mininode_lock)[m
[31m-        wait_until(lambda: no_verack_idle_peer.version_received, timeout=10, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(lambda: no_version_disconnect_peer.ever_connected, timeout=10, lock=p2p_lock)[m
[32m+[m[32m        self.wait_until(lambda: no_version_idle_peer.ever_connected, timeout=10, lock=p2p_lock)[m
[32m+[m[32m        self.wait_until(lambda: no_verack_idle_peer.version_received, timeout=10, lock=p2p_lock)[m
 [m
         # Mine a block and make sure that it's not sent to the connected peers[m
         self.nodes[0].generate(nblocks=1)[m
[33mdiff --git a/test/functional/p2p_leak_tx.py b/test/functional/p2p_leak_tx.py[m
[33mindex da30ad5977..9e761db03f 100755[m
[33m--- a/test/functional/p2p_leak_tx.py[m
[33m+++ b/test/functional/p2p_leak_tx.py[m
[36m@@ -5,7 +5,7 @@[m
 """Test that we don't leak txs to inbound peers that we haven't yet announced to"""[m
 [m
 from test_framework.messages import msg_getdata, CInv, MSG_TX[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[33mdiff --git a/test/functional/p2p_nobloomfilter_messages.py b/test/functional/p2p_nobloomfilter_messages.py[m
[33mindex accc5dc23c..c2311cb197 100755[m
[33m--- a/test/functional/p2p_nobloomfilter_messages.py[m
[33m+++ b/test/functional/p2p_nobloomfilter_messages.py[m
[36m@@ -12,7 +12,7 @@[m [mTest that, when bloom filters are not enabled, peers are disconnected if:[m
 """[m
 [m
 from test_framework.messages import msg_mempool, msg_filteradd, msg_filterload, msg_filterclear[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
 [m
[33mdiff --git a/test/functional/p2p_node_network_limited.py b/test/functional/p2p_node_network_limited.py[m
[33mindex a2f6ea538c..2c9cbea5e4 100755[m
[33m--- a/test/functional/p2p_node_network_limited.py[m
[33m+++ b/test/functional/p2p_node_network_limited.py[m
[36m@@ -9,13 +9,12 @@[m [mand that it responds to getdata requests for blocks correctly:[m
     - send a block within 288 + 2 of the tip[m
     - disconnect peers who request blocks older than that."""[m
 from test_framework.messages import CInv, MSG_BLOCK, msg_getdata, msg_verack, NODE_NETWORK_LIMITED, NODE_WITNESS[m
[31m-from test_framework.mininode import P2PInterface, mininode_lock[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
     disconnect_nodes,[m
     connect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 [m
[36m@@ -28,7 +27,7 @@[m [mclass P2PIgnoreInv(P2PInterface):[m
         self.firstAddrnServices = message.addrs[0].nServices[m
     def wait_for_addr(self, timeout=5):[m
         test_function = lambda: self.last_message.get("addr")[m
[31m-        wait_until(test_function, timeout=timeout, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(test_function, timeout=timeout)[m
     def send_getdata_for_block(self, blockhash):[m
         getdata_request = msg_getdata()[m
         getdata_request.inv.append(CInv(MSG_BLOCK, int(blockhash, 16)))[m
[33mdiff --git a/test/functional/p2p_permissions.py b/test/functional/p2p_permissions.py[m
[33mindex 254352c816..3ec36edb41 100755[m
[33m--- a/test/functional/p2p_permissions.py[m
[33m+++ b/test/functional/p2p_permissions.py[m
[36m@@ -13,7 +13,7 @@[m [mfrom test_framework.messages import ([m
     CTxInWitness,[m
     FromHex,[m
 )[m
[31m-from test_framework.mininode import P2PDataStore[m
[32m+[m[32mfrom test_framework.p2p import P2PDataStore[m
 from test_framework.script import ([m
     CScript,[m
     OP_TRUE,[m
[36m@@ -24,7 +24,6 @@[m [mfrom test_framework.util import ([m
     assert_equal,[m
     connect_nodes,[m
     p2p_port,[m
[31m-    wait_until,[m
 )[m
 [m
 [m
[36m@@ -109,7 +108,7 @@[m [mclass P2PPermissionsTests(BitcoinTestFramework):[m
         self.sync_all()[m
 [m
         self.log.debug("Create a connection from a forcerelay peer that rebroadcasts raw txs")[m
[31m-        # A python mininode is needed to send the raw transaction directly. If a full node was used, it could only[m
[32m+[m[32m        # A test framework p2p connection is needed to send the raw transaction directly. If a full node was used, it could only[m
         # rebroadcast via the inv-getdata mechanism. However, even for forcerelay connections, a full node would[m
         # currently not request a txid that is already in the mempool.[m
         self.restart_node(1, extra_args=["-whitelist=forcerelay@127.0.0.1"])[m
[36m@@ -137,7 +136,7 @@[m [mclass P2PPermissionsTests(BitcoinTestFramework):[m
         connect_nodes(self.nodes[1], 0)[m
         with self.nodes[1].assert_debug_log(["Force relaying tx {} from peer=0".format(txid)]):[m
             p2p_rebroadcast_wallet.send_txs_and_test([tx], self.nodes[1])[m
[31m-            wait_until(lambda: txid in self.nodes[0].getrawmempool())[m
[32m+[m[32m            self.wait_until(lambda: txid in self.nodes[0].getrawmempool())[m
 [m
         self.log.debug("Check that node[1] will not send an invalid tx to node[0]")[m
         tx.vout[0].nValue += 1[m
[33mdiff --git a/test/functional/p2p_ping.py b/test/functional/p2p_ping.py[m
[33mindex 5f5fd3e104..888e986fba 100755[m
[33m--- a/test/functional/p2p_ping.py[m
[33m+++ b/test/functional/p2p_ping.py[m
[36m@@ -8,7 +8,7 @@[m
 import time[m
 [m
 from test_framework.messages import msg_pong[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import assert_equal[m
 [m
[33mdiff --git a/test/functional/p2p_segwit.py b/test/functional/p2p_segwit.py[m
[33mindex 564e49f3d8..2155c1d0e7 100755[m
[33m--- a/test/functional/p2p_segwit.py[m
[33m+++ b/test/functional/p2p_segwit.py[m
[36m@@ -42,9 +42,9 @@[m [mfrom test_framework.messages import ([m
     uint256_from_str,[m
     FromHex,[m
 )[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PInterface,[m
[31m-    mininode_lock,[m
[32m+[m[32m    p2p_lock,[m
 )[m
 from test_framework.script import ([m
     CScript,[m
[36m@@ -83,7 +83,6 @@[m [mfrom test_framework.util import ([m
     softfork_active,[m
     hex_str_to_bytes,[m
     assert_raises_rpc_error,[m
[31m-    wait_until,[m
 )[m
 [m
 # The versionbit bit used to signal activation of SegWit[m
[36m@@ -153,8 +152,8 @@[m [mclass TestP2PConn(P2PInterface):[m
         self.lastgetdata = [][m
         self.wtxidrelay = wtxidrelay[m
 [m
[31m-    # Avoid sending out msg_getdata in the mininode thread as a reply to invs.[m
[31m-    # They are not needed and would only lead to races because we send msg_getdata out in the test thread[m
[32m+[m[32m    # Don't send getdata message replies to invs automatically.[m
[32m+[m[32m    # We'll send the getdata messages explicitly in the test logic.[m
     def on_inv(self, message):[m
         pass[m
 [m
[36m@@ -177,7 +176,7 @@[m [mclass TestP2PConn(P2PInterface):[m
         if success:[m
             # sanity check[m
             assert (self.wtxidrelay and use_wtxid) or (not self.wtxidrelay and not use_wtxid)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.last_message.pop("getdata", None)[m
         if use_wtxid:[m
             wtxid = tx.calc_sha256(True)[m
[36m@@ -195,7 +194,7 @@[m [mclass TestP2PConn(P2PInterface):[m
             assert not self.last_message.get("getdata")[m
 [m
     def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.last_message.pop("getdata", None)[m
             self.last_message.pop("getheaders", None)[m
         msg = msg_headers()[m
[36m@@ -209,7 +208,7 @@[m [mclass TestP2PConn(P2PInterface):[m
         self.wait_for_getdata([block.sha256])[m
 [m
     def request_block(self, blockhash, inv_type, timeout=60):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.last_message.pop("block", None)[m
         self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))[m
         self.wait_for_block(blockhash, timeout)[m
[36m@@ -2114,7 +2113,7 @@[m [mclass SegWitTest(BitcoinTestFramework):[m
         # Check wtxidrelay feature negotiation message through connecting a new peer[m
         def received_wtxidrelay():[m
             return (len(self.wtx_node.last_wtxidrelay) > 0)[m
[31m-        wait_until(received_wtxidrelay, timeout=60, lock=mininode_lock)[m
[32m+[m[32m        self.wtx_node.wait_until(received_wtxidrelay)[m
 [m
         # Create a Segwit output from the latest UTXO[m
         # and announce it to the network[m
[36m@@ -2138,25 +2137,25 @@[m [mclass SegWitTest(BitcoinTestFramework):[m
         # Announce Segwit transaction with wtxid[m
         # and wait for getdata[m
         self.wtx_node.announce_tx_and_wait_for_getdata(tx2, use_wtxid=True)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             lgd = self.wtx_node.lastgetdata[:][m
         assert_equal(lgd, [CInv(MSG_WTX, tx2.calc_sha256(True))])[m
 [m
         # Announce Segwit transaction from non wtxidrelay peer[m
         # and wait for getdata[m
         self.tx_node.announce_tx_and_wait_for_getdata(tx2, use_wtxid=False)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             lgd = self.tx_node.lastgetdata[:][m
         assert_equal(lgd, [CInv(MSG_TX|MSG_WITNESS_FLAG, tx2.sha256)])[m
 [m
         # Send tx2 through; it's an orphan so won't be accepted[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.wtx_node.last_message.pop("getdata", None)[m
         test_transaction_acceptance(self.nodes[0], self.wtx_node, tx2, with_witness=True, accepted=False)[m
 [m
         # Expect a request for parent (tx) by txid despite use of WTX peer[m
         self.wtx_node.wait_for_getdata([tx.sha256], 60)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             lgd = self.wtx_node.lastgetdata[:][m
         assert_equal(lgd, [CInv(MSG_TX|MSG_WITNESS_FLAG, tx.sha256)])[m
 [m
[33mdiff --git a/test/functional/p2p_sendheaders.py b/test/functional/p2p_sendheaders.py[m
[33mindex 126a46bd53..04e6ec4172 100755[m
[33m--- a/test/functional/p2p_sendheaders.py[m
[33m+++ b/test/functional/p2p_sendheaders.py[m
[36m@@ -87,11 +87,11 @@[m [me. Announce one more that doesn't connect.[m
 """[m
 from test_framework.blocktools import create_block, create_coinbase[m
 from test_framework.messages import CInv[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     CBlockHeader,[m
     NODE_WITNESS,[m
     P2PInterface,[m
[31m-    mininode_lock,[m
[32m+[m[32m    p2p_lock,[m
     MSG_BLOCK,[m
     msg_block,[m
     msg_getblocks,[m
[36m@@ -104,7 +104,6 @@[m [mfrom test_framework.mininode import ([m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[31m-    wait_until,[m
 )[m
 [m
 DIRECT_FETCH_RESPONSE_TIME = 0.05[m
[36m@@ -147,7 +146,7 @@[m [mclass BaseNode(P2PInterface):[m
 [m
     def wait_for_block_announcement(self, block_hash, timeout=60):[m
         test_function = lambda: self.last_blockhash_announced == block_hash[m
[31m-        wait_until(test_function, timeout=timeout, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(test_function, timeout=timeout)[m
 [m
     def on_inv(self, message):[m
         self.block_announced = True[m
[36m@@ -163,7 +162,7 @@[m [mclass BaseNode(P2PInterface):[m
             self.last_blockhash_announced = message.headers[-1].sha256[m
 [m
     def clear_block_announcements(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             self.block_announced = False[m
             self.last_message.pop("inv", None)[m
             self.last_message.pop("headers", None)[m
[36m@@ -174,8 +173,8 @@[m [mclass BaseNode(P2PInterface):[m
         """Test whether the last headers announcements received are right.[m
            Headers may be announced across more than one message."""[m
         test_function = lambda: (len(self.recent_headers_announced) >= len(headers))[m
[31m-        wait_until(test_function, timeout=60, lock=mininode_lock)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        self.wait_until(test_function)[m
[32m+[m[32m        with p2p_lock:[m
             assert_equal(self.recent_headers_announced, headers)[m
             self.block_announced = False[m
             self.last_message.pop("headers", None)[m
[36m@@ -186,9 +185,9 @@[m [mclass BaseNode(P2PInterface):[m
         inv should be a list of block hashes."""[m
 [m
         test_function = lambda: self.block_announced[m
[31m-        wait_until(test_function, timeout=60, lock=mininode_lock)[m
[32m+[m[32m        self.wait_until(test_function)[m
 [m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             compare_inv = [][m
             if "inv" in self.last_message:[m
                 compare_inv = [x.hash for x in self.last_message["inv"].inv][m
[36m@@ -298,7 +297,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
                 test_node.send_header_for_blocks([new_block])[m
                 test_node.wait_for_getdata([new_block.sha256])[m
                 test_node.send_and_ping(msg_block(new_block))  # make sure this block is processed[m
[31m-                wait_until(lambda: inv_node.block_announced, timeout=60, lock=mininode_lock)[m
[32m+[m[32m                inv_node.wait_until(lambda: inv_node.block_announced)[m
                 inv_node.clear_block_announcements()[m
                 test_node.clear_block_announcements()[m
 [m
[36m@@ -456,7 +455,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
         test_node.send_header_for_blocks(blocks)[m
         test_node.sync_with_ping()[m
         # should not have received any getdata messages[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             assert "getdata" not in test_node.last_message[m
 [m
         # This time, direct fetch should work[m
[36m@@ -494,7 +493,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
         test_node.last_message.pop("getdata", None)[m
         test_node.send_header_for_blocks(blocks[0:1])[m
         test_node.sync_with_ping()[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             assert "getdata" not in test_node.last_message[m
 [m
         # Announcing one more block on fork should trigger direct fetch for[m
[36m@@ -513,7 +512,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
         test_node.last_message.pop("getdata", None)[m
         test_node.send_header_for_blocks(blocks[18:19])[m
         test_node.sync_with_ping()[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             assert "getdata" not in test_node.last_message[m
 [m
         self.log.info("Part 4: success!")[m
[36m@@ -536,7 +535,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
                 block_time += 1[m
                 height += 1[m
             # Send the header of the second block -> this won't connect.[m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 test_node.last_message.pop("getheaders", None)[m
             test_node.send_header_for_blocks([blocks[1]])[m
             test_node.wait_for_getheaders()[m
[36m@@ -559,7 +558,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
 [m
         for i in range(1, MAX_UNCONNECTING_HEADERS):[m
             # Send a header that doesn't connect, check that we get a getheaders.[m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 test_node.last_message.pop("getheaders", None)[m
             test_node.send_header_for_blocks([blocks[i]])[m
             test_node.wait_for_getheaders()[m
[36m@@ -574,7 +573,7 @@[m [mclass SendHeadersTest(BitcoinTestFramework):[m
         # before we get disconnected.  Should be 5*MAX_UNCONNECTING_HEADERS[m
         for i in range(5 * MAX_UNCONNECTING_HEADERS - 1):[m
             # Send a header that doesn't connect, check that we get a getheaders.[m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 test_node.last_message.pop("getheaders", None)[m
             test_node.send_header_for_blocks([blocks[i % len(blocks)]])[m
             test_node.wait_for_getheaders()[m
[33mdiff --git a/test/functional/p2p_timeouts.py b/test/functional/p2p_timeouts.py[m
[33mindex 5a4fa42988..ce12ce26ce 100755[m
[33m--- a/test/functional/p2p_timeouts.py[m
[33m+++ b/test/functional/p2p_timeouts.py[m
[36m@@ -24,7 +24,7 @@[m
 from time import sleep[m
 [m
 from test_framework.messages import msg_ping[m
[31m-from test_framework.mininode import P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 [m
 [m
[33mdiff --git a/test/functional/p2p_tx_download.py b/test/functional/p2p_tx_download.py[m
[33mindex 3ea1c6e5e7..653c7ae43f 100755[m
[33m--- a/test/functional/p2p_tx_download.py[m
[33m+++ b/test/functional/p2p_tx_download.py[m
[36m@@ -16,14 +16,13 @@[m [mfrom test_framework.messages import ([m
     msg_inv,[m
     msg_notfound,[m
 )[m
[31m-from test_framework.mininode import ([m
[32m+[m[32mfrom test_framework.p2p import ([m
     P2PInterface,[m
[31m-    mininode_lock,[m
[32m+[m[32m    p2p_lock,[m
 )[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[31m-    wait_until,[m
 )[m
 from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE[m
 [m
[36m@@ -73,14 +72,14 @@[m [mclass TxDownloadTest(BitcoinTestFramework):[m
 [m
         def getdata_found(peer_index):[m
             p = self.nodes[0].p2ps[peer_index][m
[31m-            with mininode_lock:[m
[32m+[m[32m            with p2p_lock:[m
                 return p.last_message.get("getdata") and p.last_message["getdata"].inv[-1].hash == txid[m
 [m
         node_0_mocktime = int(time.time())[m
         while outstanding_peer_index:[m
             node_0_mocktime += MAX_GETDATA_INBOUND_WAIT[m
             self.nodes[0].setmocktime(node_0_mocktime)[m
[31m-            wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))[m
[32m+[m[32m            self.wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))[m
             for i in outstanding_peer_index:[m
                 if getdata_found(i):[m
                     outstanding_peer_index.remove(i)[m
[36m@@ -134,24 +133,24 @@[m [mclass TxDownloadTest(BitcoinTestFramework):[m
 [m
         p = self.nodes[0].p2ps[0][m
 [m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             p.tx_getdata_count = 0[m
 [m
         p.send_message(msg_inv([CInv(t=MSG_WTX, h=i) for i in txids]))[m
[31m-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT, lock=mininode_lock)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT)[m
[32m+[m[32m        with p2p_lock:[m
             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)[m
 [m
         self.log.info("Now check that if we send a NOTFOUND for a transaction, we'll get one more request")[m
         p.send_message(msg_notfound(vec=[CInv(t=MSG_WTX, h=txids[0])]))[m
[31m-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10, lock=mininode_lock)[m
[31m-        with mininode_lock:[m
[32m+[m[32m        p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10)[m
[32m+[m[32m        with p2p_lock:[m
             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT + 1)[m
 [m
         WAIT_TIME = TX_EXPIRY_INTERVAL // 2 + TX_EXPIRY_INTERVAL[m
         self.log.info("if we wait about {} minutes, we should eventually get more requests".format(WAIT_TIME / 60))[m
         self.nodes[0].setmocktime(int(time.time() + WAIT_TIME))[m
[31m-        wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)[m
[32m+[m[32m        p.wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)[m
         self.nodes[0].setmocktime(0)[m
 [m
     def test_spurious_notfound(self):[m
[33mdiff --git a/test/functional/p2p_unrequested_blocks.py b/test/functional/p2p_unrequested_blocks.py[m
[33mindex 71b0b0f63a..36b434bce3 100755[m
[33m--- a/test/functional/p2p_unrequested_blocks.py[m
[33m+++ b/test/functional/p2p_unrequested_blocks.py[m
[36m@@ -55,7 +55,7 @@[m [mimport time[m
 [m
 from test_framework.blocktools import create_block, create_coinbase, create_tx_with_script[m
 from test_framework.messages import CBlockHeader, CInv, MSG_BLOCK, msg_block, msg_headers, msg_inv[m
[31m-from test_framework.mininode import mininode_lock, P2PInterface[m
[32m+[m[32mfrom test_framework.p2p import p2p_lock, P2PInterface[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_equal,[m
[36m@@ -199,13 +199,13 @@[m [mclass AcceptBlockTest(BitcoinTestFramework):[m
         # 6. Try to get node to request the missing block.[m
         # Poke the node with an inv for block at height 3 and see if that[m
         # triggers a getdata on block 2 (it should if block 2 is missing).[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             # Clear state so we can check the getdata request[m
             test_node.last_message.pop("getdata", None)[m
             test_node.send_message(msg_inv([CInv(MSG_BLOCK, block_h3.sha256)]))[m
 [m
         test_node.sync_with_ping()[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             getdata = test_node.last_message["getdata"][m
 [m
         # Check that the getdata includes the right block[m
[33mdiff --git a/test/functional/rpc_blockchain.py b/test/functional/rpc_blockchain.py[m
[33mindex 7f4241fb5f..c005584485 100755[m
[33m--- a/test/functional/rpc_blockchain.py[m
[33m+++ b/test/functional/rpc_blockchain.py[m
[36m@@ -22,16 +22,6 @@[m [mfrom decimal import Decimal[m
 import http.client[m
 import subprocess[m
 [m
[2m-from test_framework.test_framework import BitcoinTestFramework[m
[2m-from test_framework.util import ([m
[2m-    assert_equal,[m
[2m-    assert_greater_than,[m
[2m-    assert_greater_than_or_equal,[m
[2m-    assert_raises,[m
[2m-    assert_raises_rpc_error,[m
[2m-    assert_is_hex_string,[m
[2m-    assert_is_hash_string,[m
[31m-)[m
 from test_framework.blocktools import ([m
     create_block,[m
     create_coinbase,[m
[36m@@ -42,8 +32,16 @@[m [mfrom test_framework.messages import ([m
     FromHex,[m
     msg_block,[m
 )[m
[31m-from test_framework.mininode import ([m
[31m-    P2PInterface,[m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
[2m+[m[2mfrom test_framework.test_framework import BitcoinTestFramework[m
[2m+[m[2mfrom test_framework.util import ([m
[2m+[m[2m    assert_equal,[m
[2m+[m[2m    assert_greater_than,[m
[2m+[m[2m    assert_greater_than_or_equal,[m
[2m+[m[2m    assert_raises,[m
[2m+[m[2m    assert_raises_rpc_error,[m
[2m+[m[2m    assert_is_hex_string,[m
[2m+[m[2m    assert_is_hash_string,[m
 )[m
 [m
 [m
[33mdiff --git a/test/functional/rpc_generate.py b/test/functional/rpc_generate.py[m
[33mindex 9404f1e25e..e55f2e6d12 100755[m
[33m--- a/test/functional/rpc_generate.py[m
[33m+++ b/test/functional/rpc_generate.py[m
[36m@@ -17,7 +17,8 @@[m [mclass RPCGenerateTest(BitcoinTestFramework):[m
 [m
     def run_test(self):[m
         message = ([m
[31m-            "generate ( nblocks maxtries ) has been replaced by the -generate "[m
[32m+[m[32m            "generate\n"[m
[32m+[m[32m            "has been replaced by the -generate "[m
             "cli option. Refer to -help for more information."[m
         )[m
 [m
[33mdiff --git a/test/functional/rpc_invalidateblock.py b/test/functional/rpc_invalidateblock.py[m
[33mindex 1fdc134f97..e788e75557 100755[m
[33m--- a/test/functional/rpc_invalidateblock.py[m
[33m+++ b/test/functional/rpc_invalidateblock.py[m
[36m@@ -9,7 +9,6 @@[m [mfrom test_framework.address import ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR[m
 from test_framework.util import ([m
     assert_equal,[m
     connect_nodes,[m
[31m-    wait_until,[m
 )[m
 [m
 [m
[36m@@ -57,9 +56,9 @@[m [mclass InvalidateTest(BitcoinTestFramework):[m
         self.log.info("..and then mine a block")[m
         self.nodes[2].generatetoaddress(1, self.nodes[2].get_deterministic_priv_key().address)[m
         self.log.info("Verify all nodes are at the right height")[m
[31m-        wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)[m
[31m-        wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)[m
[31m-        wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)[m
 [m
         self.log.info("Verify that we reconsider all ancestors as well")[m
         blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)[m
[33mdiff --git a/test/functional/rpc_net.py b/test/functional/rpc_net.py[m
[33mindex 9b8e585b49..506c77c567 100755[m
[33m--- a/test/functional/rpc_net.py[m
[33m+++ b/test/functional/rpc_net.py[m
[36m@@ -11,6 +11,12 @@[m [mfrom decimal import Decimal[m
 from itertools import product[m
 import time[m
 [m
[32m+[m[32mfrom test_framework.p2p import P2PInterface[m
[2m+[m[2mimport test_framework.messages[m
[2m+[m[2mfrom test_framework.messages import ([m
[2m+[m[2m    NODE_NETWORK,[m
[2m+[m[2m    NODE_WITNESS,[m
[32m+[m[32m)[m
 from test_framework.test_framework import BitcoinTestFramework[m
 from test_framework.util import ([m
     assert_approx,[m
[36m@@ -20,13 +26,6 @@[m [mfrom test_framework.util import ([m
     assert_raises_rpc_error,[m
     connect_nodes,[m
     p2p_port,[m
[31m-    wait_until,[m
[31m-)[m
[31m-from test_framework.mininode import P2PInterface[m
[2;3m-import test_framework.messages[m
[2;3m-from test_framework.messages import ([m
[2;3m-    NODE_NETWORK,[m
[2;3m-    NODE_WITNESS,[m
 )[m
 [m
 [m
[36m@@ -93,8 +92,8 @@[m [mclass NetTest(BitcoinTestFramework):[m
         # the bytes sent/received should change[m
         # note ping and pong are 32 bytes each[m
         self.nodes[0].ping()[m
[31m-        wait_until(lambda: (self.nodes[0].getnettotals()['totalbytessent'] >= net_totals_after['totalbytessent'] + 32 * 2), timeout=1)[m
[31m-        wait_until(lambda: (self.nodes[0].getnettotals()['totalbytesrecv'] >= net_totals_after['totalbytesrecv'] + 32 * 2), timeout=1)[m
[32m+[m[32m        self.wait_until(lambda: (self.nodes[0].getnettotals()['totalbytessent'] >= net_totals_after['totalbytessent'] + 32 * 2), timeout=1)[m
[32m+[m[32m        self.wait_until(lambda: (self.nodes[0].getnettotals()['totalbytesrecv'] >= net_totals_after['totalbytesrecv'] + 32 * 2), timeout=1)[m
 [m
         peer_info_after_ping = self.nodes[0].getpeerinfo()[m
         for before, after in zip(peer_info, peer_info_after_ping):[m
[36m@@ -110,7 +109,7 @@[m [mclass NetTest(BitcoinTestFramework):[m
             self.nodes[0].setnetworkactive(state=False)[m
         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], False)[m
         # Wait a bit for all sockets to close[m
[31m-        wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)[m
[32m+[m[32m        self.wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)[m
 [m
         with self.nodes[0].assert_debug_log(expected_msgs=['SetNetworkActive: true\n']):[m
             self.nodes[0].setnetworkactive(state=True)[m
[33mdiff --git a/test/functional/rpc_psbt.py b/test/functional/rpc_psbt.py[m
[33mindex f7f23bc8f4..1c7dc98d16 100755[m
[33m--- a/test/functional/rpc_psbt.py[m
[33m+++ b/test/functional/rpc_psbt.py[m
[36m@@ -103,7 +103,16 @@[m [mclass PSBTTest(BitcoinTestFramework):[m
         final_tx = self.nodes[0].finalizepsbt(signed_tx)['hex'][m
         self.nodes[0].sendrawtransaction(final_tx)[m
 [m
[31m-        # Get pubkeys[m
[32m+[m[32m        # Manually selected inputs can be locked:[m
[32m+[m[32m        assert_equal(len(self.nodes[0].listlockunspent()), 0)[m
[32m+[m[32m        utxo1 = self.nodes[0].listunspent()[0][m
[32m+[m[32m        psbtx1 = self.nodes[0].walletcreatefundedpsbt([{"txid": utxo1['txid'], "vout": utxo1['vout']}], {self.nodes[2].getnewaddress():1}, 0,{"lockUnspents": True})["psbt"][m
[32m+[m[32m        assert_equal(len(self.nodes[0].listlockunspent()), 1)[m
[32m+[m
[32m+[m[32m        # Locks are ignored for manually selected inputs[m
[32m+[m[32m        self.nodes[0].walletcreatefundedpsbt([{"txid": utxo1['txid'], "vout": utxo1['vout']}], {self.nodes[2].getnewaddress():1}, 0)[m
[32m+[m
[32m+[m[32m        # Create p2sh, p2wpkh, and p2wsh addresses[m
         pubkey0 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())['pubkey'][m
         pubkey1 = self.nodes[1].getaddressinfo(self.nodes[1].getnewaddress())['pubkey'][m
         pubkey2 = self.nodes[2].getaddressinfo(self.nodes[2].getnewaddress())['pubkey'][m
[33mdiff --git a/test/functional/test_framework/messages.py b/test/functional/test_framework/messages.py[m
[33mindex 5207b563a1..bd4a53876e 100755[m
[33m--- a/test/functional/test_framework/messages.py[m
[33m+++ b/test/functional/test_framework/messages.py[m
[36m@@ -32,7 +32,7 @@[m [mfrom test_framework.util import hex_str_to_bytes, assert_equal[m
 [m
 MIN_VERSION_SUPPORTED = 60001[m
 MY_VERSION = 70016  # past wtxid relay[m
[31m-MY_SUBVERSION = b"/python-mininode-tester:0.0.3/"[m
[32m+[m[32mMY_SUBVERSION = b"/python-p2p-tester:0.0.3/"[m
 MY_RELAY = 1 # from version 70001 onwards, fRelay should be appended to version messages (BIP37)[m
 [m
 MAX_LOCATOR_SZ = 101[m
[33mdiff --git a/test/functional/test_framework/mininode.py b/test/functional/test_framework/p2p.py[m
[33msimilarity index 97%[m
[33mrename from test/functional/test_framework/mininode.py[m
[33mrename to test/functional/test_framework/p2p.py[m
[33mindex eaf637fbb8..57c77e60b5 100755[m
[33m--- a/test/functional/test_framework/mininode.py[m
[33m+++ b/test/functional/test_framework/p2p.py[m
[36m@@ -4,10 +4,14 @@[m
 # Copyright (c) 2010-2020 The Bitcoin Core developers[m
 # Distributed under the MIT software license, see the accompanying[m
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[31m-"""Bitcoin P2P network half-a-node.[m
[32m+[m[32m"""Test objects for interacting with a bitcoind node over the p2p protocol.[m
 [m
[31m-This python code was modified from ArtForz' public domain half-a-node, as[m
[31m-found in the mini-node branch of http://github.com/jgarzik/pynode.[m
[32m+[m[32mThe P2PInterface objects interact with the bitcoind nodes under test using the[m
[32m+[m[32mnode's p2p interface. They can be used to send messages to the node, and[m
[32m+[m[32mcallbacks can be registered that execute when messages are received from the[m
[32m+[m[32mnode. Messages are sent to/received from the node on an asyncio event loop.[m
[32m+[m[32mState held inside the objects must be guarded by the p2p_lock to avoid data[m
[32m+[m[32mraces between the main testing thread and the event loop.[m
 [m
 P2PConnection: A low-level connection object to a node's P2P interface[m
 P2PInterface: A high-level interface object for communicating to a node over P2P[m
[36m@@ -67,7 +71,7 @@[m [mfrom test_framework.messages import ([m
 )[m
 from test_framework.util import wait_until[m
 [m
[31m-logger = logging.getLogger("TestFramework.mininode")[m
[32m+[m[32mlogger = logging.getLogger("TestFramework.p2p")[m
 [m
 MESSAGEMAP = {[m
     b"addr": msg_addr,[m
[36m@@ -320,7 +324,7 @@[m [mclass P2PInterface(P2PConnection):[m
 [m
         We keep a count of how many of each message type has been received[m
         and the most recent message of each type."""[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             try:[m
                 msgtype = message.msgtype.decode('ascii')[m
                 self.message_count[msgtype] += 1[m
[36m@@ -394,7 +398,7 @@[m [mclass P2PInterface(P2PConnection):[m
                 assert self.is_connected[m
             return test_function_in()[m
 [m
[31m-        wait_until(test_function, timeout=timeout, lock=mininode_lock, timeout_factor=self.timeout_factor)[m
[32m+[m[32m        wait_until(test_function, timeout=timeout, lock=p2p_lock, timeout_factor=self.timeout_factor)[m
 [m
     def wait_for_disconnect(self, timeout=60):[m
         test_function = lambda: not self.is_connected[m
[36m@@ -498,7 +502,7 @@[m [mclass P2PInterface(P2PConnection):[m
 # P2PConnection acquires this lock whenever delivering a message to a P2PInterface.[m
 # This lock should be acquired in the thread running the test logic to synchronize[m
 # access to any data shared with the P2PInterface or P2PConnection.[m
[31m-mininode_lock = threading.Lock()[m
[32m+[m[32mp2p_lock = threading.Lock()[m
 [m
 [m
 class NetworkThread(threading.Thread):[m
[36m@@ -592,7 +596,7 @@[m [mclass P2PDataStore(P2PInterface):[m
          - if success is False: assert that the node's tip doesn't advance[m
          - if reject_reason is set: assert that the correct reject message is logged"""[m
 [m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             for block in blocks:[m
                 self.block_store[block.sha256] = block[m
                 self.last_block_hash = block.sha256[m
[36m@@ -629,7 +633,7 @@[m [mclass P2PDataStore(P2PInterface):[m
          - if expect_disconnect is True: Skip the sync with ping[m
          - if reject_reason is set: assert that the correct reject message is logged."""[m
 [m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             for tx in txs:[m
                 self.tx_store[tx.sha256] = tx[m
 [m
[36m@@ -668,7 +672,7 @@[m [mclass P2PTxInvStore(P2PInterface):[m
                 self.tx_invs_received[i.hash] += 1[m
 [m
     def get_invs(self):[m
[31m-        with mininode_lock:[m
[32m+[m[32m        with p2p_lock:[m
             return list(self.tx_invs_received.keys())[m
 [m
     def wait_for_broadcast(self, txns, timeout=60):[m
[33mdiff --git a/test/functional/test_framework/test_framework.py b/test/functional/test_framework/test_framework.py[m
[33mindex 8d402d4888..2a60f8e0c1 100755[m
[33m--- a/test/functional/test_framework/test_framework.py[m
[33m+++ b/test/functional/test_framework/test_framework.py[m
[36m@@ -20,8 +20,8 @@[m [mimport time[m
 [m
 from .authproxy import JSONRPCException[m
 from . import coverage[m
[32m+[m[32mfrom .p2p import NetworkThread[m
 from .test_node import TestNode[m
[31m-from .mininode import NetworkThread[m
 from .util import ([m
     MAX_NODES,[m
     PortSeed,[m
[33mdiff --git a/test/functional/test_framework/test_node.py b/test/functional/test_framework/test_node.py[m
[33mindex 5eba554a42..5c7a883c43 100755[m
[33m--- a/test/functional/test_framework/test_node.py[m
[33m+++ b/test/functional/test_framework/test_node.py[m
[36m@@ -551,7 +551,7 @@[m [mclass TestNode():[m
         assert self.p2ps, self._node_msg("No p2p connection")[m
         return self.p2ps[0][m
 [m
[31m-    def num_connected_mininodes(self):[m
[32m+[m[32m    def num_test_p2p_connections(self):[m
         """Return number of test framework p2p connections to the node."""[m
         return len([peer for peer in self.getpeerinfo() if peer['subver'] == MY_SUBVERSION])[m
 [m
[36m@@ -560,7 +560,7 @@[m [mclass TestNode():[m
         for p in self.p2ps:[m
             p.peer_disconnect()[m
         del self.p2ps[:][m
[31m-        wait_until(lambda: self.num_connected_mininodes() == 0)[m
[32m+[m[32m        wait_until(lambda: self.num_test_p2p_connections() == 0)[m
 [m
 [m
 class TestNodeCLIAttr:[m
[33mdiff --git a/test/functional/test_framework/util.py b/test/functional/test_framework/util.py[m
[33mindex 3362b41209..cfc4ee65d4 100644[m
[33m--- a/test/functional/test_framework/util.py[m
[33m+++ b/test/functional/test_framework/util.py[m
[36m@@ -226,6 +226,14 @@[m [mdef satoshi_round(amount):[m
 [m
 [m
 def wait_until(predicate, *, attempts=float('inf'), timeout=float('inf'), lock=None, timeout_factor=1.0):[m
[32m+[m[32m    """Sleep until the predicate resolves to be True.[m
[32m+[m
[32m+[m[32m    Warning: Note that this method is not recommended to be used in tests as it is[m
[32m+[m[32m    not aware of the context of the test framework. Using `wait_until()` counterpart[m
[32m+[m[32m    from `BitcoinTestFramework` or `P2PInterface` class ensures an understandable[m
[32m+[m[32m    amount of timeout and a common shared timeout_factor. Furthermore, `wait_until()`[m
[32m+[m[32m    from `P2PInterface` class in `mininode.py` has a preset lock.[m
[32m+[m[32m    """[m
     if attempts == float('inf') and timeout == float('inf'):[m
         timeout = 60[m
     timeout = timeout * timeout_factor[m
[33mdiff --git a/test/functional/test_runner.py b/test/functional/test_runner.py[m
[33mindex 01232bda3c..28fdf354dd 100755[m
[33m--- a/test/functional/test_runner.py[m
[33m+++ b/test/functional/test_runner.py[m
[36m@@ -105,7 +105,6 @@[m [mBASE_SCRIPTS = [[m
     'wallet_listtransactions.py',[m
     # vv Tests less than 60s vv[m
     'p2p_sendheaders.py',[m
[31m-    'wallet_zapwallettxes.py',[m
     'wallet_importmulti.py',[m
     'mempool_limit.py',[m
     'rpc_txoutproof.py',[m
[33mdiff --git a/test/functional/wallet_basic.py b/test/functional/wallet_basic.py[m
[33mindex 71a1a3f4f6..147c43f2f7 100755[m
[33m--- a/test/functional/wallet_basic.py[m
[33m+++ b/test/functional/wallet_basic.py[m
[36m@@ -135,11 +135,19 @@[m [mclass WalletTest(BitcoinTestFramework):[m
                                 self.nodes[2].lockunspent, False,[m
                                 [{"txid": unspent_0["txid"], "vout": 999}])[m
 [m
[31m-        # An output should be unlocked when spent[m
[32m+[m[32m        # The lock on a manually selected output is ignored[m
         unspent_0 = self.nodes[1].listunspent()[0][m
         self.nodes[1].lockunspent(False, [unspent_0])[m
         tx = self.nodes[1].createrawtransaction([unspent_0], { self.nodes[1].getnewaddress() : 1 })[m
[31m-        tx = self.nodes[1].fundrawtransaction(tx)['hex'][m
[32m+[m[32m        self.nodes[1].fundrawtransaction(tx,{"lockUnspents": True})[m
[32m+[m
[32m+[m[32m        # fundrawtransaction can lock an input[m
[32m+[m[32m        self.nodes[1].lockunspent(True, [unspent_0])[m
[32m+[m[32m        assert_equal(len(self.nodes[1].listlockunspent()), 0)[m
[32m+[m[32m        tx = self.nodes[1].fundrawtransaction(tx,{"lockUnspents": True})['hex'][m
[32m+[m[32m        assert_equal(len(self.nodes[1].listlockunspent()), 1)[m
[32m+[m
[32m+[m[32m        # Send transaction[m
         tx = self.nodes[1].signrawtransactionwithwallet(tx)["hex"][m
         self.nodes[1].sendrawtransaction(tx)[m
         assert_equal(len(self.nodes[1].listlockunspent()), 0)[m
[36m@@ -526,8 +534,6 @@[m [mclass WalletTest(BitcoinTestFramework):[m
         maintenance = [[m
             '-rescan',[m
             '-reindex',[m
[31m-            '-zapwallettxes=1',[m
[31m-            '-zapwallettxes=2',[m
         ][m
         chainlimit = 6[m
         for m in maintenance:[m
[33mdiff --git a/test/functional/wallet_bumpfee.py b/test/functional/wallet_bumpfee.py[m
[33mindex 53496084ef..56d1da60b7 100755[m
[33m--- a/test/functional/wallet_bumpfee.py[m
[33m+++ b/test/functional/wallet_bumpfee.py[m
[36m@@ -50,6 +50,11 @@[m [mclass BumpFeeTest(BitcoinTestFramework):[m
     def skip_test_if_missing_module(self):[m
         self.skip_if_no_wallet()[m
 [m
[32m+[m[32m    def clear_mempool(self):[m
[32m+[m[32m        # Clear mempool between subtests. The subtests may only depend on chainstate (utxos)[m
[32m+[m[32m        self.nodes[1].generate(1)[m
[32m+[m[32m        self.sync_all()[m
[32m+[m
     def run_test(self):[m
         # Encrypt wallet for test_locked_wallet_fails test[m
         self.nodes[1].encryptwallet(WALLET_PASSPHRASE)[m
[36m@@ -71,7 +76,7 @@[m [mclass BumpFeeTest(BitcoinTestFramework):[m
 [m
         self.log.info("Running tests")[m
         dest_address = peer_node.getnewaddress()[m
[31m-        test_invalid_parameters(rbf_node, dest_address)[m
[32m+[m[32m        self.test_invalid_parameters(rbf_node, dest_address)[m
         test_simple_bumpfee_succeeds(self, "default", rbf_node, peer_node, dest_address)[m
         test_simple_bumpfee_succeeds(self, "fee_rate", rbf_node, peer_node, dest_address)[m
         test_feerate_args(self, rbf_node, peer_node, dest_address)[m
[36m@@ -93,28 +98,30 @@[m [mclass BumpFeeTest(BitcoinTestFramework):[m
         test_small_output_with_feerate_succeeds(self, rbf_node, dest_address)[m
         test_no_more_inputs_fails(self, rbf_node, dest_address)[m
 [m
[31m-def test_invalid_parameters(node, dest_address):[m
[31m-    txid = spend_one_input(node, dest_address)[m
[31m-    # invalid estimate mode[m
[31m-    assert_raises_rpc_error(-8, "Invalid estimate_mode parameter", node.bumpfee, txid, {[m
[31m-        "estimate_mode": "moo",[m
[31m-    })[m
[31m-    assert_raises_rpc_error(-3, "Expected type string", node.bumpfee, txid, {[m
[31m-        "estimate_mode": 38,[m
[31m-    })[m
[31m-    assert_raises_rpc_error(-3, "Expected type string", node.bumpfee, txid, {[m
[31m-        "estimate_mode": {[m
[31m-            "foo": "bar",[m
[31m-        },[m
[31m-    })[m
[31m-    assert_raises_rpc_error(-8, "Invalid estimate_mode parameter", node.bumpfee, txid, {[m
[31m-        "estimate_mode": Decimal("3.141592"),[m
[31m-    })[m
[31m-    # confTarget and conf_target[m
[31m-    assert_raises_rpc_error(-8, "confTarget and conf_target options should not both be set", node.bumpfee, txid, {[m
[31m-        "confTarget": 123,[m
[31m-        "conf_target": 456,[m
[31m-    })[m
[32m+[m[32m    def test_invalid_parameters(self, node, dest_address):[m
[32m+[m[32m        txid = spend_one_input(node, dest_address)[m
[32m+[m[32m        # invalid estimate mode[m
[32m+[m[32m        assert_raises_rpc_error(-8, "Invalid estimate_mode parameter", node.bumpfee, txid, {[m
[32m+[m[32m            "estimate_mode": "moo",[m
[32m+[m[32m        })[m
[32m+[m[32m        assert_raises_rpc_error(-3, "Expected type string", node.bumpfee, txid, {[m
[32m+[m[32m            "estimate_mode": 38,[m
[32m+[m[32m        })[m
[32m+[m[32m        assert_raises_rpc_error(-3, "Expected type string", node.bumpfee, txid, {[m
[32m+[m[32m            "estimate_mode": {[m
[32m+[m[32m                "foo": "bar",[m
[32m+[m[32m            },[m
[32m+[m[32m        })[m
[32m+[m[32m        assert_raises_rpc_error(-8, "Invalid estimate_mode parameter", node.bumpfee, txid, {[m
[32m+[m[32m            "estimate_mode": Decimal("3.141592"),[m
[32m+[m[32m        })[m
[32m+[m[32m        # confTarget and conf_target[m
[32m+[m[32m        assert_raises_rpc_error(-8, "confTarget and conf_target options should not both be set", node.bumpfee, txid, {[m
[32m+[m[32m            "confTarget": 123,[m
[32m+[m[32m            "conf_target": 456,[m
[32m+[m[32m        })[m
[32m+[m[32m        self.clear_mempool()[m
[32m+[m
 [m
 def test_simple_bumpfee_succeeds(self, mode, rbf_node, peer_node, dest_address):[m
     self.log.info('Test simple bumpfee: {}'.format(mode))[m
[36m@@ -148,6 +155,7 @@[m [mdef test_simple_bumpfee_succeeds(self, mode, rbf_node, peer_node, dest_address):[m
     bumpedwtx = rbf_node.gettransaction(bumped_tx["txid"])[m
     assert_equal(oldwtx["replaced_by_txid"], bumped_tx["txid"])[m
     assert_equal(bumpedwtx["replaces_txid"], rbfid)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_feerate_args(self, rbf_node, peer_node, dest_address):[m
[36m@@ -167,6 +175,7 @@[m [mdef test_feerate_args(self, rbf_node, peer_node, dest_address):[m
     assert_raises_rpc_error(-3, "Amount out of range", rbf_node.bumpfee, rbfid, {"fee_rate": -1})[m
 [m
     assert_raises_rpc_error(-4, "is too high (cannot be higher than", rbf_node.bumpfee, rbfid, {"fee_rate": TOO_HIGH})[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_segwit_bumpfee_succeeds(self, rbf_node, dest_address):[m
[36m@@ -198,12 +207,14 @@[m [mdef test_segwit_bumpfee_succeeds(self, rbf_node, dest_address):[m
     bumped_tx = rbf_node.bumpfee(rbfid)[m
     assert bumped_tx["txid"] in rbf_node.getrawmempool()[m
     assert rbfid not in rbf_node.getrawmempool()[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_nonrbf_bumpfee_fails(self, peer_node, dest_address):[m
     self.log.info('Test that we cannot replace a non RBF transaction')[m
     not_rbfid = peer_node.sendtoaddress(dest_address, Decimal("0.00090000"))[m
     assert_raises_rpc_error(-4, "not BIP 125 replaceable", peer_node.bumpfee, not_rbfid)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_notmine_bumpfee_fails(self, rbf_node, peer_node, dest_address):[m
[36m@@ -211,20 +222,22 @@[m [mdef test_notmine_bumpfee_fails(self, rbf_node, peer_node, dest_address):[m
     # here, the rbftx has a peer_node coin and then adds a rbf_node input[m
     # Note that this test depends upon the RPC code checking input ownership prior to change outputs[m
     # (since it can't use fundrawtransaction, it lacks a proper change output)[m
[31m-    utxos = [node.listunspent()[-1] for node in (rbf_node, peer_node)][m
[32m+[m[32m    fee = Decimal("0.001")[m
[32m+[m[32m    utxos = [node.listunspent(query_options={'minimumAmount': fee})[-1] for node in (rbf_node, peer_node)][m
     inputs = [{[m
         "txid": utxo["txid"],[m
         "vout": utxo["vout"],[m
         "address": utxo["address"],[m
         "sequence": BIP125_SEQUENCE_NUMBER[m
     } for utxo in utxos][m
[31m-    output_val = sum(utxo["amount"] for utxo in utxos) - Decimal("0.001")[m
[32m+[m[32m    output_val = sum(utxo["amount"] for utxo in utxos) - fee[m
     rawtx = rbf_node.createrawtransaction(inputs, {dest_address: output_val})[m
     signedtx = rbf_node.signrawtransactionwithwallet(rawtx)[m
     signedtx = peer_node.signrawtransactionwithwallet(signedtx["hex"])[m
     rbfid = rbf_node.sendrawtransaction(signedtx["hex"])[m
     assert_raises_rpc_error(-4, "Transaction contains inputs that don't belong to this wallet",[m
                             rbf_node.bumpfee, rbfid)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_bumpfee_with_descendant_fails(self, rbf_node, rbf_node_address, dest_address):[m
[36m@@ -235,6 +248,7 @@[m [mdef test_bumpfee_with_descendant_fails(self, rbf_node, rbf_node_address, dest_ad[m
     tx = rbf_node.signrawtransactionwithwallet(tx)[m
     rbf_node.sendrawtransaction(tx["hex"])[m
     assert_raises_rpc_error(-8, "Transaction has descendants in the wallet", rbf_node.bumpfee, parent_id)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_small_output_with_feerate_succeeds(self, rbf_node, dest_address):[m
[36m@@ -276,6 +290,7 @@[m [mdef test_small_output_with_feerate_succeeds(self, rbf_node, dest_address):[m
 [m
     rbf_node.generatetoaddress(1, rbf_node.getnewaddress())[m
     assert_equal(rbf_node.gettransaction(rbfid)["confirmations"], 1)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_dust_to_fee(self, rbf_node, dest_address):[m
[36m@@ -298,6 +313,7 @@[m [mdef test_dust_to_fee(self, rbf_node, dest_address):[m
     assert_equal(len(fulltx["vout"]), 2)[m
     assert_equal(len(full_bumped_tx["vout"]), 1)  # change output is eliminated[m
     assert_equal(full_bumped_tx["vout"][0]['value'], Decimal("0.00050000"))[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_settxfee(self, rbf_node, dest_address):[m
[36m@@ -320,6 +336,8 @@[m [mdef test_settxfee(self, rbf_node, dest_address):[m
     assert_raises_rpc_error(-8, "txfee cannot be more than wallet max tx fee", rbf_node.settxfee, Decimal('0.00003'))[m
     self.restart_node(1, self.extra_args[1])[m
     rbf_node.walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)[m
[32m+[m[32m    self.connect_nodes(1, 0)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_maxtxfee_fails(self, rbf_node, dest_address):[m
[36m@@ -333,6 +351,8 @@[m [mdef test_maxtxfee_fails(self, rbf_node, dest_address):[m
     assert_raises_rpc_error(-4, "Unable to create transaction. Fee exceeds maximum configured by -maxtxfee", rbf_node.bumpfee, rbfid)[m
     self.restart_node(1, self.extra_args[1])[m
     rbf_node.walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)[m
[32m+[m[32m    self.connect_nodes(1, 0)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_watchonly_psbt(self, peer_node, rbf_node, dest_address):[m
[36m@@ -415,6 +435,7 @@[m [mdef test_watchonly_psbt(self, peer_node, rbf_node, dest_address):[m
 [m
     rbf_node.unloadwallet("watcher")[m
     rbf_node.unloadwallet("signer")[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_rebumping(self, rbf_node, dest_address):[m
[36m@@ -423,6 +444,7 @@[m [mdef test_rebumping(self, rbf_node, dest_address):[m
     bumped = rbf_node.bumpfee(rbfid, {"fee_rate": ECONOMICAL})[m
     assert_raises_rpc_error(-4, "already bumped", rbf_node.bumpfee, rbfid, {"fee_rate": NORMAL})[m
     rbf_node.bumpfee(bumped["txid"], {"fee_rate": NORMAL})[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_rebumping_not_replaceable(self, rbf_node, dest_address):[m
[36m@@ -431,6 +453,7 @@[m [mdef test_rebumping_not_replaceable(self, rbf_node, dest_address):[m
     bumped = rbf_node.bumpfee(rbfid, {"fee_rate": ECONOMICAL, "replaceable": False})[m
     assert_raises_rpc_error(-4, "Transaction is not BIP 125 replaceable", rbf_node.bumpfee, bumped["txid"],[m
                             {"fee_rate": NORMAL})[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):[m
[36m@@ -470,6 +493,7 @@[m [mdef test_unconfirmed_not_spendable(self, rbf_node, rbf_node_address):[m
     assert_equal([m
         sum(1 for t in rbf_node.listunspent(minconf=0, include_unsafe=False)[m
             if t["txid"] == rbfid and t["address"] == rbf_node_address and t["spendable"]), 1)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_bumpfee_metadata(self, rbf_node, dest_address):[m
[36m@@ -481,6 +505,7 @@[m [mdef test_bumpfee_metadata(self, rbf_node, dest_address):[m
     bumped_wtx = rbf_node.gettransaction(bumped_tx["txid"])[m
     assert_equal(bumped_wtx["comment"], "comment value")[m
     assert_equal(bumped_wtx["to"], "to value")[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_locked_wallet_fails(self, rbf_node, dest_address):[m
[36m@@ -490,6 +515,7 @@[m [mdef test_locked_wallet_fails(self, rbf_node, dest_address):[m
     assert_raises_rpc_error(-13, "Please enter the wallet passphrase with walletpassphrase first.",[m
                             rbf_node.bumpfee, rbfid)[m
     rbf_node.walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def test_change_script_match(self, rbf_node, dest_address):[m
[36m@@ -510,6 +536,7 @@[m [mdef test_change_script_match(self, rbf_node, dest_address):[m
     assert_equal(change_addresses, get_change_address(bumped_total_tx['txid']))[m
     bumped_rate_tx = rbf_node.bumpfee(bumped_total_tx["txid"])[m
     assert_equal(change_addresses, get_change_address(bumped_rate_tx['txid']))[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 def spend_one_input(node, dest_address, change_size=Decimal("0.00049000")):[m
[36m@@ -548,6 +575,7 @@[m [mdef test_no_more_inputs_fails(self, rbf_node, dest_address):[m
     # spend all funds, no change output[m
     rbfid = rbf_node.sendtoaddress(rbf_node.getnewaddress(), rbf_node.getbalance(), "", "", True)[m
     assert_raises_rpc_error(-4, "Unable to create transaction. Insufficient funds", rbf_node.bumpfee, rbfid)[m
[32m+[m[32m    self.clear_mempool()[m
 [m
 [m
 if __name__ == "__main__":[m
[33mdiff --git a/test/functional/wallet_multiwallet.py b/test/functional/wallet_multiwallet.py[m
[33mindex 1872545cdb..5c9d7ff629 100755[m
[33m--- a/test/functional/wallet_multiwallet.py[m
[33m+++ b/test/functional/wallet_multiwallet.py[m
[36m@@ -134,11 +134,6 @@[m [mclass MultiWalletTest(BitcoinTestFramework):[m
         open(not_a_dir, 'a', encoding="utf8").close()[m
         self.nodes[0].assert_start_raises_init_error(['-walletdir=' + not_a_dir], 'Error: Specified -walletdir "' + not_a_dir + '" is not a directory')[m
 [m
[31m-        self.log.info("Do not allow -zapwallettxes with multiwallet")[m
[31m-        self.nodes[0].assert_start_raises_init_error(['-zapwallettxes', '-wallet=w1', '-wallet=w2'], "Error: -zapwallettxes is only allowed with a single wallet file")[m
[31m-        self.nodes[0].assert_start_raises_init_error(['-zapwallettxes=1', '-wallet=w1', '-wallet=w2'], "Error: -zapwallettxes is only allowed with a single wallet file")[m
[31m-        self.nodes[0].assert_start_raises_init_error(['-zapwallettxes=2', '-wallet=w1', '-wallet=w2'], "Error: -zapwallettxes is only allowed with a single wallet file")[m
[31m-[m
         # if wallets/ doesn't exist, datadir should be the default wallet dir[m
         wallet_dir2 = data_dir('walletdir')[m
         os.rename(wallet_dir(), wallet_dir2)[m
[33mdiff --git a/test/functional/wallet_resendwallettransactions.py b/test/functional/wallet_resendwallettransactions.py[m
[33mindex 3417616d77..0327c9e070 100755[m
[33m--- a/test/functional/wallet_resendwallettransactions.py[m
[33m+++ b/test/functional/wallet_resendwallettransactions.py[m
[36m@@ -7,9 +7,9 @@[m [mimport time[m
 [m
 from test_framework.blocktools import create_block, create_coinbase[m
 from test_framework.messages import ToHex[m
[31m-from test_framework.mininode import P2PTxInvStore, mininode_lock[m
[32m+[m[32mfrom test_framework.p2p import P2PTxInvStore[m
 from test_framework.test_framework import BitcoinTestFramework[m
[31m-from test_framework.util import assert_equal, wait_until[m
[32m+[m[32mfrom test_framework.util import assert_equal[m
 [m
 class ResendWalletTransactionsTest(BitcoinTestFramework):[m
     def set_test_params(self):[m
[36m@@ -24,7 +24,7 @@[m [mclass ResendWalletTransactionsTest(BitcoinTestFramework):[m
         node.add_p2p_connection(P2PTxInvStore())[m
 [m
         self.log.info("Create a new transaction and wait until it's broadcast")[m
[31m-        txid = int(node.sendtoaddress(node.getnewaddress(), 1), 16)[m
[32m+[m[32m        txid = node.sendtoaddress(node.getnewaddress(), 1)[m
 [m
         # Wallet rebroadcast is first scheduled 1 sec after startup (see[m
         # nNextResend in ResendWalletTransactions()). Sleep for just over a[m
[36m@@ -33,7 +33,7 @@[m [mclass ResendWalletTransactionsTest(BitcoinTestFramework):[m
         time.sleep(1.1)[m
 [m
         # Can take a few seconds due to transaction trickling[m
[31m-        wait_until(lambda: node.p2p.tx_invs_received[txid] >= 1, lock=mininode_lock)[m
[32m+[m[32m        node.p2p.wait_for_broadcast([txid])[m
 [m
         # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)[m
         node.add_p2p_connection(P2PTxInvStore())[m
[36m@@ -58,13 +58,13 @@[m [mclass ResendWalletTransactionsTest(BitcoinTestFramework):[m
         two_min = 2 * 60[m
         node.setmocktime(now + twelve_hrs - two_min)[m
         time.sleep(2) # ensure enough time has passed for rebroadcast attempt to occur[m
[31m-        assert_equal(txid in node.p2ps[1].get_invs(), False)[m
[32m+[m[32m        assert_equal(int(txid, 16) in node.p2ps[1].get_invs(), False)[m
 [m
         self.log.info("Bump time & check that transaction is rebroadcast")[m
         # Transaction should be rebroadcast approximately 24 hours in the future,[m
         # but can range from 12-36. So bump 36 hours to be sure.[m
         node.setmocktime(now + 36 * 60 * 60)[m
[31m-        wait_until(lambda: node.p2ps[1].tx_invs_received[txid] >= 1, lock=mininode_lock)[m
[32m+[m[32m        node.p2p.wait_for_broadcast([txid])[m
 [m
 [m
 if __name__ == '__main__':[m
[33mdiff --git a/test/functional/wallet_upgradewallet.py b/test/functional/wallet_upgradewallet.py[m
[33mindex 1a76f65215..f3d6e74829 100755[m
[33m--- a/test/functional/wallet_upgradewallet.py[m
[33m+++ b/test/functional/wallet_upgradewallet.py[m
[36m@@ -6,7 +6,7 @@[m
 [m
 Test upgradewallet RPC. Download node binaries:[m
 [m
[31m-contrib/devtools/previous_release.py -b v0.19.1 v0.18.1 v0.17.1 v0.16.3 v0.15.2[m
[32m+[m[32mtest/get_previous_releases.py -b v0.19.1 v0.18.1 v0.17.1 v0.16.3 v0.15.2[m
 [m
 Only v0.15.2 and v0.16.3 are required by this test. The others are used in feature_backwards_compatibility.py[m
 """[m
[33mdiff --git a/test/functional/wallet_zapwallettxes.py b/test/functional/wallet_zapwallettxes.py[m
[33mdeleted file mode 100755[m
[33mindex 7f1cdbd20b..0000000000[m
[33m--- a/test/functional/wallet_zapwallettxes.py[m
[33m+++ /dev/null[m
[36m@@ -1,79 +0,0 @@[m
[31m-#!/usr/bin/env python3[m
[31m-# Copyright (c) 2014-2018 The Bitcoin Core developers[m
[31m-# Distributed under the MIT software license, see the accompanying[m
[31m-# file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[31m-"""Test the zapwallettxes functionality.[m
[31m-[m
[31m-- start two bitcoind nodes[m
[31m-- create two transactions on node 0 - one is confirmed and one is unconfirmed.[m
[31m-- restart node 0 and verify that both the confirmed and the unconfirmed[m
[31m-  transactions are still available.[m
[31m-- restart node 0 with zapwallettxes and persistmempool, and verify that both[m
[31m-  the confirmed and the unconfirmed transactions are still available.[m
[31m-- restart node 0 with just zapwallettxes and verify that the confirmed[m
[31m-  transactions are still available, but that the unconfirmed transaction has[m
[31m-  been zapped.[m
[31m-"""[m
[2;3m-from test_framework.test_framework import BitcoinTestFramework[m
[2;3m-from test_framework.util import ([m
[1;34m-    assert_equal,[m
[1;35m-    assert_raises_rpc_error,[m
[31m-    wait_until,[m
[31m-)[m
[31m-[m
[31m-class ZapWalletTXesTest (BitcoinTestFramework):[m
[31m-    def set_test_params(self):[m
[31m-        self.setup_clean_chain = True[m
[31m-        self.num_nodes = 2[m
[31m-[m
[31m-    def skip_test_if_missing_module(self):[m
[31m-        self.skip_if_no_wallet()[m
[31m-[m
[31m-    def run_test(self):[m
[31m-        self.log.info("Mining blocks...")[m
[31m-        self.nodes[0].generate(1)[m
[31m-        self.sync_all()[m
[31m-        self.nodes[1].generate(100)[m
[31m-        self.sync_all()[m
[31m-[m
[31m-        # This transaction will be confirmed[m
[31m-        txid1 = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 10)[m
[31m-[m
[31m-        self.nodes[0].generate(1)[m
[31m-        self.sync_all()[m
[31m-[m
[31m-        # This transaction will not be confirmed[m
[31m-        txid2 = self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 20)[m
[31m-[m
[31m-        # Confirmed and unconfirmed transactions are now in the wallet.[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid2)['txid'], txid2)[m
[31m-[m
[31m-        # Restart node0. Both confirmed and unconfirmed transactions remain in the wallet.[m
[31m-        self.restart_node(0)[m
[31m-[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid2)['txid'], txid2)[m
[31m-[m
[31m-        # Restart node0 with zapwallettxes and persistmempool. The unconfirmed[m
[31m-        # transaction is zapped from the wallet, but is re-added when the mempool is reloaded.[m
[31m-        self.restart_node(0, ["-persistmempool=1", "-zapwallettxes=2"])[m
[31m-[m
[31m-        wait_until(lambda: self.nodes[0].getmempoolinfo()['size'] == 1, timeout=3)[m
[31m-        self.nodes[0].syncwithvalidationinterfacequeue()  # Flush mempool to wallet[m
[31m-[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid2)['txid'], txid2)[m
[31m-[m
[31m-        # Restart node0 with zapwallettxes, but not persistmempool.[m
[31m-        # The unconfirmed transaction is zapped and is no longer in the wallet.[m
[31m-        self.restart_node(0, ["-zapwallettxes=2"])[m
[31m-[m
[31m-        # tx1 is still be available because it was confirmed[m
[31m-        assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)[m
[31m-[m
[31m-        # This will raise an exception because the unconfirmed transaction has been zapped[m
[31m-        assert_raises_rpc_error(-5, 'Invalid or non-wallet transaction id', self.nodes[0].gettransaction, txid2)[m
[31m-[m
[31m-if __name__ == '__main__':[m
[31m-    ZapWalletTXesTest().main()[m
[33mdiff --git a/contrib/devtools/previous_release.py b/test/get_previous_releases.py[m
[33msimilarity index 66%[m
[33mrename from contrib/devtools/previous_release.py[m
[33mrename to test/get_previous_releases.py[m
[33mindex 5599051cf3..1348b8246b 100755[m
[33m--- a/contrib/devtools/previous_release.py[m
[33m+++ b/test/get_previous_releases.py[m
[36m@@ -20,6 +20,40 @@[m [mimport sys[m
 import hashlib[m
 [m
 [m
[32m+[m[32mSHA256_SUMS = {[m
[32m+[m[32m"d40f18b4e43c6e6370ef7db9131f584fbb137276ec2e3dba67a4b267f81cb644": "bitcoin-0.15.2-aarch64-linux-gnu.tar.gz",[m
[32m+[m[32m"54fb877a148a6ad189a1e1ab1ff8b11181e58ff2aaf430da55b3fd46ae549a6b": "bitcoin-0.15.2-arm-linux-gnueabihf.tar.gz",[m
[32m+[m[32m"2b843506c3f1af0eeca5854a920264f9a829f02d0d50328005950ddcbe88874d": "bitcoin-0.15.2-i686-pc-linux-gnu.tar.gz",[m
[32m+[m[32m"87e9340ff3d382d543b2b69112376077f0c8b4f7450d372e83b68f5a1e22b2df": "bitcoin-0.15.2-osx64.tar.gz",[m
[32m+[m[32m"566be44190fd76daa01f13d428939dadfb8e3daacefc8fa17f433cad28f73bd5": "bitcoin-0.15.2-x86_64-linux-gnu.tar.gz",[m
[32m+[m
[32m+[m[32m"0768c6c15caffbaca6524824c9563b42c24f70633c681c2744649158aa3fd484": "bitcoin-0.16.3-aarch64-linux-gnu.tar.gz",[m
[32m+[m[32m"fb2818069854a6ad20ea03b28b55dbd35d8b1f7d453e90b83eace5d0098a2a87": "bitcoin-0.16.3-arm-linux-gnueabihf.tar.gz",[m
[32m+[m[32m"75a537844313b0a84bdb61ffcdc5c4ce19a738f7ddf71007cd2edf664efd7c37": "bitcoin-0.16.3-i686-pc-linux-gnu.tar.gz",[m
[32m+[m[32m"78c3bff3b619a19aed575961ea43cc9e142959218835cf51aede7f0b764fc25d": "bitcoin-0.16.3-osx64.tar.gz",[m
[32m+[m[32m"5d422a9d544742bc0df12427383f9c2517433ce7b58cf672b9a9b17c2ef51e4f": "bitcoin-0.16.3-x86_64-linux-gnu.tar.gz",[m
[32m+[m
[32m+[m[32m"5a6b35d1a348a402f2d2d6ab5aed653a1a1f13bc63aaaf51605e3501b0733b7a": "bitcoin-0.17.2-aarch64-linux-gnu.tar.gz",[m
[32m+[m[32m"d1913a5d19c8e8da4a67d1bd5205d03c8614dfd2e02bba2fe3087476643a729e": "bitcoin-0.17.2-arm-linux-gnueabihf.tar.gz",[m
[32m+[m[32m"d295fc93f39bbf0fd937b730a93184899a2eb6c3a6d53f3d857cbe77ef89b98c": "bitcoin-0.17.2-i686-pc-linux-gnu.tar.gz",[m
[32m+[m[32m"a783ba20706dbfd5b47fbedf42165fce70fbbc7d78003305d964f6b3da14887f": "bitcoin-0.17.2-osx64.tar.gz",[m
[32m+[m[32m"943f9362b9f11130177839116f48f809d83478b4c28591d486ee9a7e35179da6": "bitcoin-0.17.2-x86_64-linux-gnu.tar.gz",[m
[32m+[m
[32m+[m[32m"88f343af72803b851c7da13874cc5525026b0b55e63e1b5e1298390c4688adc6": "bitcoin-0.18.1-aarch64-linux-gnu.tar.gz",[m
[32m+[m[32m"cc7d483e4b20c5dabd4dcaf304965214cf4934bcc029ca99cbc9af00d3771a1f": "bitcoin-0.18.1-arm-linux-gnueabihf.tar.gz",[m
[32m+[m[32m"989e847b3e95fc9fedc0b109cae1b4fa43348f2f712e187a118461876af9bd16": "bitcoin-0.18.1-i686-pc-linux-gnu.tar.gz",[m
[32m+[m[32m"b7bbcee7a7540f711b171d6981f939ca8482005fde22689bc016596d80548bb1": "bitcoin-0.18.1-osx64.tar.gz",[m
[32m+[m[32m"425ee5ec631ae8da71ebc1c3f5c0269c627cf459379b9b030f047107a28e3ef8": "bitcoin-0.18.1-riscv64-linux-gnu.tar.gz",[m
[32m+[m[32m"600d1db5e751fa85903e935a01a74f5cc57e1e7473c15fd3e17ed21e202cfe5a": "bitcoin-0.18.1-x86_64-linux-gnu.tar.gz",[m
[32m+[m
[32m+[m[32m"3a80431717842672df682bdb619e66523b59541483297772a7969413be3502ff": "bitcoin-0.19.1-aarch64-linux-gnu.tar.gz",[m
[32m+[m[32m"657f28213823d240dd3324d14829702f9ad6f0710f8bdd1c379cb3c447197f48": "bitcoin-0.19.1-arm-linux-gnueabihf.tar.gz",[m
[32m+[m[32m"10d1e53208aa7603022f4acc084a046299ab4ccf25fe01e81b3fb6f856772589": "bitcoin-0.19.1-i686-pc-linux-gnu.tar.gz",[m
[32m+[m[32m"1ae1b87de26487075cd2fd22e0d4ead87d969bd55c44f2f1d873ecdc6147ebb3": "bitcoin-0.19.1-osx64.tar.gz",[m
[32m+[m[32m"aa7a9563b48aa79252c8e7b6a41c07a5441bd9f14c5e4562cc72720ea6cb0ee5": "bitcoin-0.19.1-riscv64-linux-gnu.tar.gz",[m
[32m+[m[32m"5fcac9416e486d4960e1a946145566350ca670f9aaba99de6542080851122e4c": "bitcoin-0.19.1-x86_64-linux-gnu.tar.gz"[m
[32m+[m[32m}[m
[32m+[m
 @contextlib.contextmanager[m
 def pushd(new_dir) -> None:[m
     previous_dir = os.getcwd()[m
[36m@@ -44,14 +78,10 @@[m [mdef download_binary(tag, args) -> int:[m
             match.group(1), match.group(2))[m
     tarball = 'bitcoin-{tag}-{platform}.tar.gz'.format([m
         tag=tag[1:], platform=args.platform)[m
[31m-    sha256Sums = "SHA256SUMS-{tag}.asc".format(tag=tag[1:])[m
     tarballUrl = 'https://bitcoincore.org/{bin_path}/{tarball}'.format([m
         bin_path=bin_path, tarball=tarball)[m
[31m-    sha256SumsUrl = 'https://bitcoincore.org/{bin_path}/SHA256SUMS.asc'.format([m
[31m-        bin_path=bin_path)[m
 [m
     print('Fetching: {tarballUrl}'.format(tarballUrl=tarballUrl))[m
[31m-    print('Fetching: {sha256SumsUrl}'.format(sha256SumsUrl=sha256SumsUrl))[m
 [m
     header, status = subprocess.Popen([m
         ['curl', '--head', tarballUrl], stdout=subprocess.PIPE).communicate()[m
[36m@@ -60,8 +90,7 @@[m [mdef download_binary(tag, args) -> int:[m
         return 1[m
 [m
     curlCmds = [[m
[31m-        ['curl', '--remote-name', tarballUrl],[m
[31m-        ['curl', '--output', sha256Sums, sha256SumsUrl],[m
[32m+[m[32m        ['curl', '--remote-name', tarballUrl][m
     ][m
 [m
     for cmd in curlCmds:[m
[36m@@ -73,29 +102,12 @@[m [mdef download_binary(tag, args) -> int:[m
     with open(tarball, "rb") as afile:[m
         hasher.update(afile.read())[m
     tarballHash = hasher.hexdigest()[m
[31m-    tarballHash = '{}  {}\n'.format(tarballHash, tarball)[m
[31m-    with open(sha256Sums, 'r', encoding="utf-8") as afile:[m
[31m-        shasums = afile.readlines()[m
 [m
[31m-    if tarballHash not in shasums:[m
[32m+[m[32m    if tarballHash not in SHA256_SUMS or SHA256_SUMS[tarballHash] != tarball:[m
         print("Checksum did not match")[m
[31m-        Path(tarball).unlink()[m
         return 1[m
     print("Checksum matched")[m
 [m
[31m-    # Bitcoin Core Release Signing Keys v0.11.0+[m
[31m-    signingKey = "01EA5486DE18A882D4C2684590C8019E36C2E964"[m
[31m-[m
[31m-    isKeyPresent = subprocess.run([m
[31m-        ["gpg", "--list-keys", signingKey]).returncode[m
[31m-    if isKeyPresent:[m
[31m-        return isKeyPresent[m
[31m-[m
[31m-    isVerified = subprocess.run([m
[31m-        ["gpg", "--verify", sha256Sums]).returncode[m
[31m-    if isVerified:[m
[31m-        return isVerified[m
[31m-[m
     # Extract tarball[m
     ret = subprocess.run(['tar', '-zxf', tarball, '-C', tag,[m
                           '--strip-components=1',[m
[36m@@ -104,7 +116,6 @@[m [mdef download_binary(tag, args) -> int:[m
         return ret[m
 [m
     Path(tarball).unlink()[m
[31m-    Path(sha256Sums).unlink()[m
     return 0[m
 [m
 [m
[33mdiff --git a/test/lint/check-doc.py b/test/lint/check-doc.py[m
[33mindex bd947d194c..f77242d335 100755[m
[33m--- a/test/lint/check-doc.py[m
[33m+++ b/test/lint/check-doc.py[m
[36m@@ -23,7 +23,7 @@[m [mCMD_GREP_WALLET_ARGS = r"git grep --function-context 'void WalletInit::AddWallet[m
 CMD_GREP_WALLET_HIDDEN_ARGS = r"git grep --function-context 'void DummyWalletInit::AddWalletOptions' -- {}".format(CMD_ROOT_DIR)[m
 CMD_GREP_DOCS = r"git grep --perl-regexp '{}' {}".format(REGEX_DOC, CMD_ROOT_DIR)[m
 # list unsupported, deprecated and duplicate args as they need no documentation[m
[31m-SET_DOC_OPTIONAL = set(['-h', '-help', '-dbcrashratio', '-forcecompactdb'])[m
[32m+[m[32mSET_DOC_OPTIONAL = set(['-h', '-help', '-dbcrashratio', '-forcecompactdb', '-zapwallettxes'])[m
 [m
 [m
 def lint_missing_argument_documentation():[m
[33mdiff --git a/test/lint/lint-locale-dependence.sh b/test/lint/lint-locale-dependence.sh[m
[33mindex 2e5b801849..e5657f7555 100755[m
[33m--- a/test/lint/lint-locale-dependence.sh[m
[33m+++ b/test/lint/lint-locale-dependence.sh[m
[36m@@ -4,6 +4,39 @@[m
 # file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
 [m
 export LC_ALL=C[m
[32m+[m
[32m+[m[32m# Be aware that bitcoind and bitcoin-qt differ in terms of localization: Qt[m
[32m+[m[32m# opts in to POSIX localization by running setlocale(LC_ALL, "") on startup,[m
[32m+[m[32m# whereas no such call is made in bitcoind.[m
[32m+[m[32m#[m
[32m+[m[32m# Qt runs setlocale(LC_ALL, "") on initialization. This installs the locale[m
[32m+[m[32m# specified by the user's LC_ALL (or LC_*) environment variable as the new[m
[32m+[m[32m# C locale.[m
[32m+[m[32m#[m
[32m+[m[32m# In contrast, bitcoind does not opt in to localization -- no call to[m
[32m+[m[32m# setlocale(LC_ALL, "") is made and the environment variables LC_* are[m
[32m+[m[32m# thus ignored.[m
[32m+[m[32m#[m
[32m+[m[32m# This results in situations where bitcoind is guaranteed to be running[m
[32m+[m[32m# with the classic locale ("C") whereas the locale of bitcoin-qt will vary[m
[32m+[m[32m# depending on the user's environment variables.[m
[32m+[m[32m#[m
[32m+[m[32m# An example: Assuming the environment variable LC_ALL=de_DE then the[m
[32m+[m[32m# call std::to_string(1.23) will return "1.230000" in bitcoind but[m
[32m+[m[32m# "1,230000" in bitcoin-qt.[m
[32m+[m[32m#[m
[32m+[m[32m# From the Qt documentation:[m
[32m+[m[32m# "On Unix/Linux Qt is configured to use the system locale settings by default.[m
[32m+[m[32m#  This can cause a conflict when using POSIX functions, for instance, when[m
[32m+[m[32m#  converting between data types such as floats and strings, since the notation[m
[32m+[m[32m#  may differ between locales. To get around this problem, call the POSIX function[m
[32m+[m[32m#  setlocale(LC_NUMERIC,"C") right after initializing QApplication, QGuiApplication[m
[32m+[m[32m#  or QCoreApplication to reset the locale that is used for number formatting to[m
[32m+[m[32m#  "C"-locale."[m
[32m+[m[32m#[m
[32m+[m[32m# See https://doc.qt.io/qt-5/qcoreapplication.html#locale-settings and[m
[32m+[m[32m# https://stackoverflow.com/a/34878283 for more details.[m
[32m+[m
 KNOWN_VIOLATIONS=([m
     "src/bitcoin-tx.cpp.*stoul"[m
     "src/bitcoin-tx.cpp.*trim_right"[m
[33mdiff --git a/test/sanitizer_suppressions/tsan b/test/sanitizer_suppressions/tsan[m
[33mindex 3d0ac7f995..3ba2b2a103 100644[m
[33m--- a/test/sanitizer_suppressions/tsan[m
[33m+++ b/test/sanitizer_suppressions/tsan[m
[36m@@ -24,6 +24,7 @@[m [mrace:WalletBatch::WriteHDChain[m
 race:BerkeleyBatch[m
 race:BerkeleyDatabase[m
 race:DatabaseBatch[m
[32m+[m[32mrace:leveldb::DBImpl::DeleteObsoleteFiles[m
 race:zmq::*[m
 race:bitcoin-qt[m
 # deadlock (TODO fix)[m