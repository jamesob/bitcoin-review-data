[33mdiff --git a/src/Makefile.am b/src/Makefile.am[m
[33mindex 9d15120b72..51dd60834c 100644[m
[33m--- a/src/Makefile.am[m
[33m+++ b/src/Makefile.am[m
[36m@@ -161,6 +161,8 @@[m [mBITCOIN_CORE_H = \[m
   index/txindex.h \[m
   indirectmap.h \[m
   init.h \[m
[32m+[m[32m  init/caches.h \[m
[32m+[m[32m  init/chainstate.h \[m
   init/common.h \[m
   interfaces/chain.h \[m
   interfaces/echo.h \[m
[36m@@ -547,6 +549,8 @@[m [mlibbitcoin_common_a_SOURCES = \[m
   core_write.cpp \[m
   deploymentinfo.cpp \[m
   external_signer.cpp \[m
[32m+[m[32m  init/caches.cpp \[m
[32m+[m[32m  init/chainstate.cpp \[m
   init/common.cpp \[m
   key.cpp \[m
   key_io.cpp \[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex 164b7bb55d..12709acafd 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -24,6 +24,8 @@[m
 #include <index/blockfilterindex.h>[m
 #include <index/coinstatsindex.h>[m
 #include <index/txindex.h>[m
[32m+[m[32m#include <init/caches.h> // for CalculateCacheSizes[m
[32m+[m[32m#include <init/chainstate.h> // for LoadChainstateSequence[m
 #include <init/common.h>[m
 #include <interfaces/chain.h>[m
 #include <interfaces/init.h>[m
[36m@@ -500,7 +502,7 @@[m [mvoid SetupServerArgs(ArgsManager& argsman)[m
     hidden_args.emplace_back("-zmqpubsequencehwm=<n>");[m
 #endif[m
 [m
[31m-    argsman.AddArg("-checkblocks=<n>", strprintf("How many blocks to check at startup (default: %u, 0 = all)", DEFAULT_CHECKBLOCKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);[m
[32m+[m[32m    argsman.AddArg("-checkblocks=<n>", strprintf("How many blocks to check at startup. Only available blocks will be checked, which may be less than the number requested (e.g. when pruning is enabled). (default: %u, 0 = all)", DEFAULT_CHECKBLOCKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);[m
     argsman.AddArg("-checklevel=<n>", strprintf("How thorough the block verification of -checkblocks is: %s (0-4, default: %u)", Join(CHECKLEVEL_DOC, ", "), DEFAULT_CHECKLEVEL), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);[m
     argsman.AddArg("-checkblockindex", strprintf("Do a consistency check for the block tree, chainstate, and other validation data structures occasionally. (default: %u, regtest: %u)", defaultChainParams->DefaultConsistencyChecks(), regtestChainParams->DefaultConsistencyChecks()), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);[m
     argsman.AddArg("-checkaddrman=<n>", strprintf("Run addrman consistency checks every <n> operations. Use 0 to disable. (default: %u)", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);[m
[36m@@ -1361,217 +1363,100 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
     bool fReindexChainState = args.GetBoolArg("-reindex-chainstate", false);[m
 [m
     // cache size calculations[m
[2m-    int64_t nTotalCache = (args.GetIntArg("-dbcache", nDefaultDbCache) << 20);[m
[2m-    nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache[m
[2m-    nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greater than nMaxDbcache[m
[2m-    int64_t nBlockTreeDBCache = std::min(nTotalCache / 8, nMaxBlockDBCache << 20);[m
[2m-    nTotalCache -= nBlockTreeDBCache;[m
[2m-    int64_t nTxIndexCache = std::min(nTotalCache / 8, args.GetBoolArg("-txindex", DEFAULT_TXINDEX) ? nMaxTxIndexCache << 20 : 0);[m
[2m-    nTotalCache -= nTxIndexCache;[m
[2m-    int64_t filter_index_cache = 0;[m
[31m-    if (!g_enabled_filter_types.empty()) {[m
[31m-        size_t n_indexes = g_enabled_filter_types.size();[m
[2m-        int64_t max_cache = std::min(nTotalCache / 8, max_filter_index_cache << 20);[m
[2m-        filter_index_cache = max_cache / n_indexes;[m
[2m-        nTotalCache -= filter_index_cache * n_indexes;[m
[2m-    }[m
[2m-    int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache[m
[2m-    nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache[m
[2m-    nTotalCache -= nCoinDBCache;[m
[2m-    int64_t nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache[m
[32m+[m[32m    CacheSizes cache_sizes;[m
[32m+[m[32m    CalculateCacheSizes(args, cache_sizes, g_enabled_filter_types.size());[m
[32m+[m
     int64_t nMempoolSizeMax = args.GetIntArg("-maxmempool", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;[m
     LogPrintf("Cache configuration:\n");[m
[31m-    LogPrintf("* Using %.1f MiB for block index database\n", nBlockTreeDBCache * (1.0 / 1024 / 1024));[m
[32m+[m[32m    LogPrintf("* Using %.1f MiB for block index database\n", cache_sizes.block_tree_db_cache_size * (1.0 / 1024 / 1024));[m
     if (args.GetBoolArg("-txindex", DEFAULT_TXINDEX)) {[m
[31m-        LogPrintf("* Using %.1f MiB for transaction index database\n", nTxIndexCache * (1.0 / 1024 / 1024));[m
[32m+[m[32m        LogPrintf("* Using %.1f MiB for transaction index database\n", cache_sizes.tx_index_cache_size * (1.0 / 1024 / 1024));[m
     }[m
     for (BlockFilterType filter_type : g_enabled_filter_types) {[m
         LogPrintf("* Using %.1f MiB for %s block filter index database\n",[m
[31m-                  filter_index_cache * (1.0 / 1024 / 1024), BlockFilterTypeName(filter_type));[m
[32m+[m[32m                  cache_sizes.filter_index_cache_size * (1.0 / 1024 / 1024), BlockFilterTypeName(filter_type));[m
     }[m
[31m-    LogPrintf("* Using %.1f MiB for chain state database\n", nCoinDBCache * (1.0 / 1024 / 1024));[m
[31m-    LogPrintf("* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\n", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));[m
[32m+[m[32m    LogPrintf("* Using %.1f MiB for chain state database\n", cache_sizes.coin_db_cache_size * (1.0 / 1024 / 1024));[m
[32m+[m[32m    LogPrintf("* Using %.1f MiB for in-memory UTXO set (plus up to %.1f MiB of unused mempool space)\n", cache_sizes.coin_cache_usage_size * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));[m
 [m
     bool fLoaded = false;[m
     while (!fLoaded && !ShutdownRequested()) {[m
         const bool fReset = fReindex;[m
[31m-        auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {[m
[31m-            return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();[m
[31m-        };[m
         bilingual_str strLoadError;[m
 [m
         uiInterface.InitMessage(_("Loading block indexâ€¦").translated);[m
[31m-[m
[31m-        do {[m
[31m-            const int64_t load_block_index_start_time = GetTimeMillis();[m
[31m-            try {[m
[31m-                LOCK(cs_main);[m
[31m-                chainman.InitializeChainstate(Assert(node.mempool.get()));[m
[31m-                chainman.m_total_coinstip_cache = nCoinCacheUsage;[m
[31m-                chainman.m_total_coinsdb_cache = nCoinDBCache;[m
[31m-[m
[31m-                UnloadBlockIndex(node.mempool.get(), chainman);[m
[31m-[m
[31m-                auto& pblocktree{chainman.m_blockman.m_block_tree_db};[m
[31m-                // new CBlockTreeDB tries to delete the existing file, which[m
[31m-                // fails if it's still open from the previous loop. Close it first:[m
[31m-                pblocktree.reset();[m
[31m-                pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, false, fReset));[m
[31m-[m
[31m-                if (fReset) {[m
[31m-                    pblocktree->WriteReindexing(true);[m
[31m-                    //If we're reindexing in prune mode, wipe away unusable block files and all undo data files[m
[31m-                    if (fPruneMode)[m
[31m-                        CleanupBlockRevFiles();[m
[31m-                }[m
[31m-[m
[31m-                if (ShutdownRequested()) break;[m
[31m-[m
[31m-                // LoadBlockIndex will load fHavePruned if we've ever removed a[m
[31m-                // block file from disk.[m
[31m-                // Note that it also sets fReindex based on the disk flag![m
[31m-                // From here on out fReindex and fReset mean something different![m
[31m-                if (!chainman.LoadBlockIndex()) {[m
[31m-                    if (ShutdownRequested()) break;[m
[31m-                    strLoadError = _("Error loading block database");[m
[31m-                    break;[m
[31m-                }[m
[31m-[m
[31m-                // If the loaded chain has a wrong genesis, bail out immediately[m
[31m-                // (we're likely using a testnet datadir, or the other way around).[m
[31m-                if (!chainman.BlockIndex().empty() &&[m
[31m-                        !chainman.m_blockman.LookupBlockIndex(chainparams.GetConsensus().hashGenesisBlock)) {[m
[31m-                    return InitError(_("Incorrect or no genesis block found. Wrong datadir for network?"));[m
[31m-                }[m
[31m-[m
[31m-                // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks[m
[31m-                // in the past, but is now trying to run unpruned.[m
[31m-                if (fHavePruned && !fPruneMode) {[m
[31m-                    strLoadError = _("You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain");[m
[31m-                    break;[m
[31m-                }[m
[31m-[m
[31m-                // At this point blocktree args are consistent with what's on disk.[m
[31m-                // If we're not mid-reindex (based on disk + args), add a genesis block on disk[m
[31m-                // (otherwise we use the one already on disk).[m
[31m-                // This is called again in ThreadImport after the reindex completes.[m
[31m-                if (!fReindex && !chainman.ActiveChainstate().LoadGenesisBlock()) {[m
[31m-                    strLoadError = _("Error initializing block database");[m
[31m-                    break;[m
[31m-                }[m
[31m-[m
[31m-                // At this point we're either in reindex or we've loaded a useful[m
[31m-                // block tree into BlockIndex()![m
[31m-[m
[31m-                bool failed_chainstate_init = false;[m
[31m-[m
[31m-                for (CChainState* chainstate : chainman.GetAll()) {[m
[31m-                    chainstate->InitCoinsDB([m
[31m-                        /* cache_size_bytes */ nCoinDBCache,[m
[31m-                        /* in_memory */ false,[m
[31m-                        /* should_wipe */ fReset || fReindexChainState);[m
[31m-[m
[31m-                    chainstate->CoinsErrorCatcher().AddReadErrCallback([]() {[m
[31m-                        uiInterface.ThreadSafeMessageBox([m
[31m-                            _("Error reading from database, shutting down."),[m
[31m-                            "", CClientUIInterface::MSG_ERROR);[m
[31m-                    });[m
[31m-[m
[31m-                    // If necessary, upgrade from older database format.[m
[31m-                    // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate[m
[31m-                    if (!chainstate->CoinsDB().Upgrade()) {[m
[31m-                        strLoadError = _("Error upgrading chainstate database");[m
[31m-                        failed_chainstate_init = true;[m
[31m-                        break;[m
[31m-                    }[m
[31m-[m
[31m-                    // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate[m
[31m-                    if (!chainstate->ReplayBlocks()) {[m
[31m-                        strLoadError = _("Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.");[m
[31m-                        failed_chainstate_init = true;[m
[31m-                        break;[m
[31m-                    }[m
[31m-[m
[31m-                    // The on-disk coinsdb is now in a good state, create the cache[m
[31m-                    chainstate->InitCoinsCache(nCoinCacheUsage);[m
[31m-                    assert(chainstate->CanFlushToDisk());[m
[31m-[m
[31m-                    if (!is_coinsview_empty(chainstate)) {[m
[31m-                        // LoadChainTip initializes the chain based on CoinsTip()'s best block[m
[31m-                        if (!chainstate->LoadChainTip()) {[m
[31m-                            strLoadError = _("Error initializing block database");[m
[31m-                            failed_chainstate_init = true;[m
[31m-                            break; // out of the per-chainstate loop[m
[31m-                        }[m
[31m-                        assert(chainstate->m_chain.Tip() != nullptr);[m
[31m-                    }[m
[31m-                }[m
[31m-[m
[31m-                if (failed_chainstate_init) {[m
[31m-                    break; // out of the chainstate activation do-while[m
[31m-                }[m
[31m-            } catch (const std::exception& e) {[m
[31m-                LogPrintf("%s\n", e.what());[m
[31m-                strLoadError = _("Error opening block database");[m
[32m+[m[32m        const int64_t load_block_index_start_time = GetTimeMillis();[m
[32m+[m[32m        std::optional<ChainstateLoadingError> rv;[m
[32m+[m[32m        try {[m
[32m+[m[32m            rv = LoadChainstateSequence(fReset,[m
[32m+[m[32m                                        chainman,[m
[32m+[m[32m                                        Assert(node.mempool.get()),[m
[32m+[m[32m                                        fPruneMode,[m
[32m+[m[32m                                        chainparams.GetConsensus(),[m
[32m+[m[32m                                        fReindexChainState,[m
[32m+[m[32m                                        cache_sizes.block_tree_db_cache_size,[m
[32m+[m[32m                                        cache_sizes.coin_db_cache_size,[m
[32m+[m[32m                                        cache_sizes.coin_cache_usage_size,[m
[32m+[m[32m                                        args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS),[m
[32m+[m[32m                                        args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL),[m
[32m+[m[32m                                        false,[m
[32m+[m[32m                                        false,[m
[32m+[m[32m                                        GetAdjustedTime,[m
[32m+[m[32m                                        ShutdownRequested,[m
[32m+[m[32m                                        []() {[m
[32m+[m[32m                                            uiInterface.ThreadSafeMessageBox([m
[32m+[m[32m                                                _("Error reading from database, shutting down."),[m
[32m+[m[32m                                                "", CClientUIInterface::MSG_ERROR);[m
[32m+[m[32m                                        },[m
[32m+[m[32m                                        []() {[m
[32m+[m[32m                                            uiInterface.InitMessage(_("Verifying blocksâ€¦").translated);[m
[32m+[m[32m                                        });[m
[32m+[m[32m        } catch (const std::exception& e) {[m
[32m+[m[32m            LogPrintf("%s\n", e.what()); // XXX[m
[32m+[m[32m            rv = ChainstateLoadingError::ERROR_GENERIC_BLOCKDB_OPEN_FAILED;[m
[32m+[m[32m        }[m
[32m+[m[32m        if (rv.has_value()) {[m
[32m+[m[32m            switch (rv.value()) {[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_LOADING_BLOCK_DB:[m
[32m+[m[32m                strLoadError = _("Error loading block database");[m
                 break;[m
[31m-            }[m
[31m-[m
[31m-            if (!fReset) {[m
[31m-                LOCK(cs_main);[m
[31m-                auto chainstates{chainman.GetAll()};[m
[31m-                if (std::any_of(chainstates.begin(), chainstates.end(),[m
[31m-                                [](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(); })) {[m
[31m-                    strLoadError = strprintf(_("Witness data for blocks after height %d requires validation. Please restart with -reindex."),[m
[31m-                                             chainparams.GetConsensus().SegwitHeight);[m
[31m-                    break;[m
[31m-                }[m
[31m-            }[m
[31m-[m
[31m-            bool failed_verification = false;[m
[31m-[m
[31m-            try {[m
[31m-                LOCK(cs_main);[m
[31m-[m
[31m-                for (CChainState* chainstate : chainman.GetAll()) {[m
[31m-                    if (!is_coinsview_empty(chainstate)) {[m
[31m-                        uiInterface.InitMessage(_("Verifying blocksâ€¦").translated);[m
[31m-                        if (fHavePruned && args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {[m
[31m-                            LogPrintf("Prune: pruned datadir may not have more than %d blocks; only checking available blocks\n",[m
[31m-                                MIN_BLOCKS_TO_KEEP);[m
[31m-                        }[m
[31m-[m
[31m-                        const CBlockIndex* tip = chainstate->m_chain.Tip();[m
[31m-                        RPCNotifyBlockChange(tip);[m
[31m-                        if (tip && tip->nTime > GetAdjustedTime() + 2 * 60 * 60) {[m
[31m-                            strLoadError = _("The block database contains a block which appears to be from the future. "[m
[31m-                                    "This may be due to your computer's date and time being set incorrectly. "[m
[31m-                                    "Only rebuild the block database if you are sure that your computer's date and time are correct");[m
[31m-                            failed_verification = true;[m
[31m-                            break;[m
[31m-                        }[m
[31m-[m
[31m-                        if (!CVerifyDB().VerifyDB([m
[31m-                                *chainstate, chainparams, chainstate->CoinsDB(),[m
[31m-                                args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL),[m
[31m-                                args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS))) {[m
[31m-                            strLoadError = _("Corrupted block database detected");[m
[31m-                            failed_verification = true;[m
[31m-                            break;[m
[31m-                        }[m
[31m-                    }[m
[31m-                }[m
[31m-            } catch (const std::exception& e) {[m
[31m-                LogPrintf("%s\n", e.what());[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_BAD_GENESIS_BLOCK:[m
[32m+[m[32m                return false;  // bail immediately![m
[32m+[m[32m            case ChainstateLoadingError::ERROR_PRUNED_NEEDS_REINDEX:[m
[32m+[m[32m                strLoadError = _("You need to rebuild the database using -reindex to go back to unpruned mode.  This will redownload the entire blockchain");[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_LOAD_GENESIS_BLOCK_FAILED:[m
[32m+[m[32m                strLoadError = _("Error initializing block database");[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_CHAINSTATE_UPGRADE_FAILED:[m
[32m+[m[32m                strLoadError = _("Error upgrading chainstate database");[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_REPLAYBLOCKS_FAILED:[m
[32m+[m[32m                strLoadError = _("Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.");[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_LOADCHAINTIP_FAILED:[m
[32m+[m[32m                strLoadError = _("Error initializing block database");[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_GENERIC_BLOCKDB_OPEN_FAILED:[m
                 strLoadError = _("Error opening block database");[m
[31m-                failed_verification = true;[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_BLOCKS_WITNESS_INSUFFICIENTLY_VALIDATED:[m
[32m+[m[32m                strLoadError = strprintf(_("Witness data for blocks after height %d requires validation. Please restart with -reindex."),[m
[32m+[m[32m                                         chainparams.GetConsensus().SegwitHeight);[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_BLOCK_FROM_FUTURE:[m
[32m+[m[32m                strLoadError = _("The block database contains a block which appears to be from the future. "[m
[32m+[m[32m                                 "This may be due to your computer's date and time being set incorrectly. "[m
[32m+[m[32m                                 "Only rebuild the block database if you are sure that your computer's date and time are correct");[m
[32m+[m[32m                break;[m
[32m+[m[32m            case ChainstateLoadingError::ERROR_CORRUPTED_BLOCK_DB:[m
[32m+[m[32m                strLoadError = _("Corrupted block database detected");[m
                 break;[m
             }[m
[31m-[m
[31m-            if (!failed_verification) {[m
[31m-                fLoaded = true;[m
[31m-                LogPrintf(" block index %15dms\n", GetTimeMillis() - load_block_index_start_time);[m
[31m-            }[m
[31m-        } while(false);[m
[32m+[m[32m        } else if (!ShutdownRequested()) {[m
[32m+[m[32m            fLoaded = true;[m
[32m+[m[32m            LogPrintf(" block index %15dms\n", GetTimeMillis() - load_block_index_start_time);[m
[32m+[m[32m        }[m
 [m
         if (!fLoaded && !ShutdownRequested()) {[m
             // first suggest a reindex[m
[36m@@ -1607,14 +1492,14 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
             return InitError(*error);[m
         }[m
 [m
[31m-        g_txindex = std::make_unique<TxIndex>(nTxIndexCache, false, fReindex);[m
[32m+[m[32m        g_txindex = std::make_unique<TxIndex>(cache_sizes.tx_index_cache_size, false, fReindex);[m
         if (!g_txindex->Start(chainman.ActiveChainstate())) {[m
             return false;[m
         }[m
     }[m
 [m
     for (const auto& filter_type : g_enabled_filter_types) {[m
[31m-        InitBlockFilterIndex(filter_type, filter_index_cache, false, fReindex);[m
[32m+[m[32m        InitBlockFilterIndex(filter_type, cache_sizes.filter_index_cache_size, false, fReindex);[m
         if (!GetBlockFilterIndex(filter_type)->Start(chainman.ActiveChainstate())) {[m
             return false;[m
         }[m
[33mdiff --git a/src/init/caches.cpp b/src/init/caches.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..d3a222c9c9[m
[33m--- /dev/null[m
[33m+++ b/src/init/caches.cpp[m
[36m@@ -0,0 +1,36 @@[m
[32m+[m[32m// Copyright (c) 2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <init/caches.h>[m
[32m+[m
[32m+[m[32m#include <txdb.h>[m
[32m+[m[32m#include <util/system.h>[m
[32m+[m[32m#include <validation.h>[m
[32m+[m
[32m+[m[32mvoid CalculateCacheSizes(const ArgsManager& args, CacheSizes& cache_sizes, size_t n_indexes)[m
[32m+[m[32m{[m
[2m+[m[2m    int64_t nTotalCache = (args.GetIntArg("-dbcache", nDefaultDbCache) << 20);[m
[2m+[m[2m    nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache[m
[2m+[m[2m    nTotalCache = std::min(nTotalCache, nMaxDbCache << 20); // total cache cannot be greater than nMaxDbcache[m
[2m+[m[2m    int64_t nBlockTreeDBCache = std::min(nTotalCache / 8, nMaxBlockDBCache << 20);[m
[2m+[m[2m    nTotalCache -= nBlockTreeDBCache;[m
[2m+[m[2m    int64_t nTxIndexCache = std::min(nTotalCache / 8, args.GetBoolArg("-txindex", DEFAULT_TXINDEX) ? nMaxTxIndexCache << 20 : 0);[m
[2m+[m[2m    nTotalCache -= nTxIndexCache;[m
[2m+[m[2m    int64_t filter_index_cache = 0;[m
[32m+[m[32m    if (n_indexes > 0) {[m
[2m+[m[2m        int64_t max_cache = std::min(nTotalCache / 8, max_filter_index_cache << 20);[m
[2m+[m[2m        filter_index_cache = max_cache / n_indexes;[m
[2m+[m[2m        nTotalCache -= filter_index_cache * n_indexes;[m
[2m+[m[2m    }[m
[2m+[m[2m    int64_t nCoinDBCache = std::min(nTotalCache / 2, (nTotalCache / 4) + (1 << 23)); // use 25%-50% of the remainder for disk cache[m
[2m+[m[2m    nCoinDBCache = std::min(nCoinDBCache, nMaxCoinsDBCache << 20); // cap total coins db cache[m
[2m+[m[2m    nTotalCache -= nCoinDBCache;[m
[2m+[m[2m    int64_t nCoinCacheUsage = nTotalCache; // the rest goes to in-memory cache[m
[32m+[m
[32m+[m[32m    cache_sizes.block_tree_db_cache_size = nBlockTreeDBCache;[m
[32m+[m[32m    cache_sizes.coin_db_cache_size = nCoinDBCache;[m
[32m+[m[32m    cache_sizes.coin_cache_usage_size = nCoinCacheUsage;[m
[32m+[m[32m    cache_sizes.tx_index_cache_size = nTxIndexCache;[m
[32m+[m[32m    cache_sizes.filter_index_cache_size = filter_index_cache;[m
[32m+[m[32m}[m
[33mdiff --git a/src/init/caches.h b/src/init/caches.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..7362e78ee0[m
[33m--- /dev/null[m
[33m+++ b/src/init/caches.h[m
[36m@@ -0,0 +1,22 @@[m
[32m+[m[32m// Copyright (c) 2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_INIT_CACHES_H[m
[32m+[m[32m#define BITCOIN_INIT_CACHES_H[m
[32m+[m
[32m+[m[32m#include <cstddef> // for size_t[m
[32m+[m[32m#include <cstdint> // for int64_t[m
[32m+[m
[32m+[m[32mclass ArgsManager;[m
[32m+[m
[32m+[m[32mstruct CacheSizes {[m
[32m+[m[32m    int64_t block_tree_db_cache_size;[m
[32m+[m[32m    int64_t coin_db_cache_size;[m
[32m+[m[32m    int64_t coin_cache_usage_size;[m
[32m+[m[32m    int64_t tx_index_cache_size;[m
[32m+[m[32m    int64_t filter_index_cache_size;[m
[32m+[m[32m};[m
[32m+[m[32mvoid CalculateCacheSizes(const ArgsManager& args, CacheSizes& cache_sizes, size_t n_indexes = 0);[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_INIT_CACHES_H[m
[33mdiff --git a/src/init/chainstate.cpp b/src/init/chainstate.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..6a6cdc94a3[m
[33m--- /dev/null[m
[33m+++ b/src/init/chainstate.cpp[m
[36m@@ -0,0 +1,157 @@[m
[32m+[m[32m// Copyright (c) 2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <init/chainstate.h>[m
[32m+[m
[32m+[m[32m#include <consensus/params.h> // for Consensus::Params[m
[32m+[m[32m#include <node/blockstorage.h> // for CleanupBlockRevFiles, fHavePruned, fReindex[m
[32m+[m[32m#include <validation.h> // for a lot of things[m
[32m+[m
[32m+[m[32mstd::optional<ChainstateLoadingError> LoadChainstateSequence(bool fReset,[m
[32m+[m[32m                                                             ChainstateManager& chainman,[m
[32m+[m[32m                                                             CTxMemPool* mempool,[m
[32m+[m[32m                                                             bool fPruneMode,[m
[32m+[m[32m                                                             const Consensus::Params& consensus_params,[m
[32m+[m[32m                                                             bool fReindexChainState,[m
[32m+[m[32m                                                             int64_t nBlockTreeDBCache,[m
[32m+[m[32m                                                             int64_t nCoinDBCache,[m
[32m+[m[32m                                                             int64_t nCoinCacheUsage,[m
[32m+[m[32m                                                             unsigned int check_blocks,[m
[32m+[m[32m                                                             unsigned int check_level,[m
[32m+[m[32m                                                             bool block_tree_db_in_memory,[m
[32m+[m[32m                                                             bool coins_db_in_memory,[m
[32m+[m[32m                                                             std::function<int64_t()> get_unix_time_seconds,[m
[32m+[m[32m                                                             std::optional<std::function<bool()>> shutdown_requested,[m
[32m+[m[32m                                                             std::optional<std::function<void()>> coins_error_cb,[m
[32m+[m[32m                                                             std::optional<std::function<void()>> verifying_blocks_cb) {[m
[32m+[m[32m    auto is_coinsview_empty = [&](CChainState* chainstate) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {[m
[32m+[m[32m        return fReset || fReindexChainState || chainstate->CoinsTip().GetBestBlock().IsNull();[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(cs_main);[m
[32m+[m[32m        chainman.InitializeChainstate(mempool);[m
[32m+[m[32m        chainman.m_total_coinstip_cache = nCoinCacheUsage;[m
[32m+[m[32m        chainman.m_total_coinsdb_cache = nCoinDBCache;[m
[32m+[m
[32m+[m[32m        UnloadBlockIndex(mempool, chainman);[m
[32m+[m
[32m+[m[32m        auto& pblocktree{chainman.m_blockman.m_block_tree_db};[m
[32m+[m[32m        // new CBlockTreeDB tries to delete the existing file, which[m
[32m+[m[32m        // fails if it's still open from the previous loop. Close it first:[m
[32m+[m[32m        pblocktree.reset();[m
[32m+[m[32m        pblocktree.reset(new CBlockTreeDB(nBlockTreeDBCache, block_tree_db_in_memory, fReset));[m
[32m+[m
[32m+[m[32m        if (fReset) {[m
[32m+[m[32m            pblocktree->WriteReindexing(true);[m
[32m+[m[32m            //If we're reindexing in prune mode, wipe away unusable block files and all undo data files[m
[32m+[m[32m            if (fPruneMode)[m
[32m+[m[32m                CleanupBlockRevFiles();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (shutdown_requested && (*shutdown_requested)()) return std::nullopt;[m
[32m+[m
[32m+[m[32m        // LoadBlockIndex will load fHavePruned if we've ever removed a[m
[32m+[m[32m        // block file from disk.[m
[32m+[m[32m        // Note that it also sets fReindex based on the disk flag![m
[32m+[m[32m        // From here on out fReindex and fReset mean something different![m
[32m+[m[32m        if (!chainman.LoadBlockIndex()) {[m
[32m+[m[32m            if (shutdown_requested && (*shutdown_requested)()) return std::nullopt;[m
[32m+[m[32m            return ChainstateLoadingError::ERROR_LOADING_BLOCK_DB;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // If the loaded chain has a wrong genesis, bail out immediately[m
[32m+[m[32m        // (we're likely using a testnet datadir, or the other way around).[m
[32m+[m[32m        if (!chainman.BlockIndex().empty() &&[m
[32m+[m[32m                !chainman.m_blockman.LookupBlockIndex(consensus_params.hashGenesisBlock)) {[m
[32m+[m[32m            return ChainstateLoadingError::ERROR_BAD_GENESIS_BLOCK;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Check for changed -prune state.  What we are concerned about is a user who has pruned blocks[m
[32m+[m[32m        // in the past, but is now trying to run unpruned.[m
[32m+[m[32m        if (fHavePruned && !fPruneMode) {[m
[32m+[m[32m            return ChainstateLoadingError::ERROR_PRUNED_NEEDS_REINDEX;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // At this point blocktree args are consistent with what's on disk.[m
[32m+[m[32m        // If we're not mid-reindex (based on disk + args), add a genesis block on disk[m
[32m+[m[32m        // (otherwise we use the one already on disk).[m
[32m+[m[32m        // This is called again in ThreadImport after the reindex completes.[m
[32m+[m[32m        if (!fReindex && !chainman.ActiveChainstate().LoadGenesisBlock()) {[m
[32m+[m[32m            return ChainstateLoadingError::ERROR_LOAD_GENESIS_BLOCK_FAILED;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // At this point we're either in reindex or we've loaded a useful[m
[32m+[m[32m        // block tree into BlockIndex()![m
[32m+[m
[32m+[m[32m        for (CChainState* chainstate : chainman.GetAll()) {[m
[32m+[m[32m            chainstate->InitCoinsDB([m
[32m+[m[32m                /* cache_size_bytes */ nCoinDBCache,[m
[32m+[m[32m                /* in_memory */ coins_db_in_memory,[m
[32m+[m[32m                /* should_wipe */ fReset || fReindexChainState);[m
[32m+[m
[32m+[m[32m            if (coins_error_cb.has_value()) {[m
[32m+[m[32m                chainstate->CoinsErrorCatcher().AddReadErrCallback(coins_error_cb.value());[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // If necessary, upgrade from older database format.[m
[32m+[m[32m            // This is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate[m
[32m+[m[32m            if (!chainstate->CoinsDB().Upgrade()) {[m
[32m+[m[32m                return ChainstateLoadingError::ERROR_CHAINSTATE_UPGRADE_FAILED;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // ReplayBlocks is a no-op if we cleared the coinsviewdb with -reindex or -reindex-chainstate[m
[32m+[m[32m            if (!chainstate->ReplayBlocks()) {[m
[32m+[m[32m                return ChainstateLoadingError::ERROR_REPLAYBLOCKS_FAILED;[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // The on-disk coinsdb is now in a good state, create the cache[m
[32m+[m[32m            chainstate->InitCoinsCache(nCoinCacheUsage);[m
[32m+[m[32m            assert(chainstate->CanFlushToDisk());[m
[32m+[m
[32m+[m[32m            if (!is_coinsview_empty(chainstate)) {[m
[32m+[m[32m                // LoadChainTip initializes the chain based on CoinsTip()'s best block[m
[32m+[m[32m                if (!chainstate->LoadChainTip()) {[m
[32m+[m[32m                    return ChainstateLoadingError::ERROR_LOADCHAINTIP_FAILED;[m
[32m+[m[32m                }[m
[32m+[m[32m                assert(chainstate->m_chain.Tip() != nullptr);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if (!fReset) {[m
[32m+[m[32m        LOCK(cs_main);[m
[32m+[m[32m        auto chainstates{chainman.GetAll()};[m
[32m+[m[32m        if (std::any_of(chainstates.begin(), chainstates.end(),[m
[32m+[m[32m                        [](const CChainState* cs) EXCLUSIVE_LOCKS_REQUIRED(cs_main) { return cs->NeedsRedownload(); })) {[m
[32m+[m[32m            return ChainstateLoadingError::ERROR_BLOCKS_WITNESS_INSUFFICIENTLY_VALIDATED;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(cs_main);[m
[32m+[m
[32m+[m[32m        for (CChainState* chainstate : chainman.GetAll()) {[m
[32m+[m[32m            if (!is_coinsview_empty(chainstate)) {[m
[32m+[m[32m                if (verifying_blocks_cb.has_value()) {[m
[32m+[m[32m                    verifying_blocks_cb.value()();[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                const CBlockIndex* tip = chainstate->m_chain.Tip();[m
[32m+[m[32m                if (tip && tip->nTime > get_unix_time_seconds() + 2 * 60 * 60) {[m
[32m+[m[32m                    return ChainstateLoadingError::ERROR_BLOCK_FROM_FUTURE;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m[32m                if (!CVerifyDB().VerifyDB([m
[32m+[m[32m                        *chainstate, consensus_params, chainstate->CoinsDB(),[m
[32m+[m[32m                        check_level,[m
[32m+[m[32m                        check_blocks)) {[m
[32m+[m[32m                    return ChainstateLoadingError::ERROR_CORRUPTED_BLOCK_DB;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    return std::nullopt;[m
[32m+[m[32m}[m
[33mdiff --git a/src/init/chainstate.h b/src/init/chainstate.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..97ee147fc6[m
[33m--- /dev/null[m
[33m+++ b/src/init/chainstate.h[m
[36m@@ -0,0 +1,49 @@[m
[32m+[m[32m// Copyright (c) 2021 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_INIT_CHAINSTATE_H[m
[32m+[m[32m#define BITCOIN_INIT_CHAINSTATE_H[m
[32m+[m
[32m+[m[32m#include <cstdint> // for int64_t[m
[32m+[m[32m#include <functional> // for std::function[m
[32m+[m[32m#include <optional> // for std::optional[m
[32m+[m
[32m+[m[32mclass ChainstateManager;[m
[32m+[m[32mnamespace Consensus {[m
[32m+[m[32m    struct Params;[m
[32m+[m[32m}[m
[32m+[m[32mclass CTxMemPool;[m
[32m+[m
[32m+[m[32menum class ChainstateLoadingError {[m
[32m+[m[32m    ERROR_LOADING_BLOCK_DB,[m
[32m+[m[32m    ERROR_BAD_GENESIS_BLOCK,[m
[32m+[m[32m    ERROR_PRUNED_NEEDS_REINDEX,[m
[32m+[m[32m    ERROR_LOAD_GENESIS_BLOCK_FAILED,[m
[32m+[m[32m    ERROR_CHAINSTATE_UPGRADE_FAILED,[m
[32m+[m[32m    ERROR_REPLAYBLOCKS_FAILED,[m
[32m+[m[32m    ERROR_LOADCHAINTIP_FAILED,[m
[32m+[m[32m    ERROR_GENERIC_BLOCKDB_OPEN_FAILED,[m
[32m+[m[32m    ERROR_BLOCKS_WITNESS_INSUFFICIENTLY_VALIDATED,[m
[32m+[m[32m    ERROR_BLOCK_FROM_FUTURE,[m
[32m+[m[32m    ERROR_CORRUPTED_BLOCK_DB,[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mstd::optional<ChainstateLoadingError> LoadChainstateSequence(bool fReset,[m
[32m+[m[32m                                                             ChainstateManager& chainman,[m
[32m+[m[32m                                                             CTxMemPool* mempool,[m
[32m+[m[32m                                                             bool fPruneMode,[m
[32m+[m[32m                                                             const Consensus::Params& consensus_params,[m
[32m+[m[32m                                                             bool fReindexChainState,[m
[32m+[m[32m                                                             int64_t nBlockTreeDBCache,[m
[32m+[m[32m                                                             int64_t nCoinDBCache,[m
[32m+[m[32m                                                             int64_t nCoinCacheUsage,[m
[32m+[m[32m                                                             unsigned int check_blocks,[m
[32m+[m[32m                                                             unsigned int check_level,[m
[32m+[m[32m                                                             bool block_tree_db_in_memory,[m
[32m+[m[32m                                                             bool coins_db_in_memory,[m
[32m+[m[32m                                                             std::function<int64_t()> get_unix_time_seconds,[m
[32m+[m[32m                                                             std::optional<std::function<bool()>> shutdown_requested = std::nullopt,[m
[32m+[m[32m                                                             std::optional<std::function<void()>> coins_error_cb = std::nullopt,[m
[32m+[m[32m                                                             std::optional<std::function<void()>> verifying_blocks_cb = std::nullopt);[m
[32m+[m[32m#endif // BITCOIN_INIT_CHAINSTATE_H[m
[33mdiff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp[m
[33mindex fc99c8eed9..64bcb9087d 100644[m
[33m--- a/src/rpc/blockchain.cpp[m
[33m+++ b/src/rpc/blockchain.cpp[m
[36m@@ -1345,7 +1345,7 @@[m [mstatic RPCHelpMan verifychain()[m
 [m
     CChainState& active_chainstate = chainman.ActiveChainstate();[m
     return CVerifyDB().VerifyDB([m
[31m-        active_chainstate, Params(), active_chainstate.CoinsTip(), check_level, check_depth);[m
[32m+[m[32m        active_chainstate, Params().GetConsensus(), active_chainstate.CoinsTip(), check_level, check_depth);[m
 },[m
     };[m
 }[m
[33mdiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp[m
[33mindex a3c7564d76..b8e106921b 100644[m
[33m--- a/src/test/util/setup_common.cpp[m
[33m+++ b/src/test/util/setup_common.cpp[m
[36m@@ -12,11 +12,13 @@[m
 #include <consensus/validation.h>[m
 #include <crypto/sha256.h>[m
 #include <init.h>[m
[32m+[m[32m#include <init/chainstate.h> // for LoadChainstateSequence[m
 #include <interfaces/chain.h>[m
 #include <miner.h>[m
 #include <net.h>[m
 #include <net_processing.h>[m
 #include <noui.h>[m
[32m+[m[32m#include <node/blockstorage.h> // for fReindex, fPruneMode[m
 #include <policy/fees.h>[m
 #include <pow.h>[m
 #include <rpc/blockchain.h>[m
[36m@@ -24,6 +26,7 @@[m
 #include <rpc/server.h>[m
 #include <scheduler.h>[m
 #include <script/sigcache.h>[m
[32m+[m[32m#include <shutdown.h> // for ShutdownRequested[m
 #include <streams.h>[m
 #include <txdb.h>[m
 #include <util/strencodings.h>[m
[36m@@ -74,9 +77,9 @@[m [mstd::ostream& operator<<(std::ostream& os, const uint256& num)[m
 [m
 BasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::vector<const char*>& extra_args)[m
     : m_path_root{fs::temp_directory_path() / "test_common_" PACKAGE_NAME / g_insecure_rand_ctx_temp_path.rand256().ToString()},[m
[31m-      m_args{}[m
[32m+[m[32m      m_args{gArgs}[m
 {[m
[31m-    m_node.args = &gArgs;[m
[32m+[m[32m    m_node.args = &m_args;[m
     const std::vector<const char*> arguments = Cat([m
         {[m
             "dummy",[m
[36m@@ -92,8 +95,7 @@[m [mBasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::ve[m
     util::ThreadRename("test");[m
     fs::create_directories(m_path_root);[m
     m_args.ForceSetArg("-datadir", fs::PathToString(m_path_root));[m
[31m-    gArgs.ForceSetArg("-datadir", fs::PathToString(m_path_root));[m
[31m-    gArgs.ClearPathCache();[m
[32m+[m[32m    m_args.ClearPathCache();[m
     {[m
         SetupServerArgs(*m_node.args);[m
         std::string error;[m
[36m@@ -127,7 +129,7 @@[m [mBasicTestingSetup::~BasicTestingSetup()[m
     SetMockTime(0s); // Reset mocktime for following tests[m
     LogInstance().DisconnectTestLogger();[m
     fs::remove_all(m_path_root);[m
[31m-    gArgs.ClearArgs();[m
[32m+[m[32m    m_args.ClearArgs();[m
     ECC_Stop();[m
 }[m
 [m
[36m@@ -143,8 +145,10 @@[m [mChainTestingSetup::ChainTestingSetup(const std::string& chainName, const std::ve[m
     m_node.fee_estimator = std::make_unique<CBlockPolicyEstimator>();[m
     m_node.mempool = std::make_unique<CTxMemPool>(m_node.fee_estimator.get(), 1);[m
 [m
[32m+[m[32m    CalculateCacheSizes(m_args, m_cache_sizes);[m
[32m+[m
     m_node.chainman = std::make_unique<ChainstateManager>();[m
[31m-    m_node.chainman->m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(1 << 20, true);[m
[32m+[m[32m    m_node.chainman->m_blockman.m_block_tree_db = std::make_unique<CBlockTreeDB>(m_cache_sizes.block_tree_db_cache_size, true);[m
 [m
     // Start script-checking threads. Set g_parallel_script_checks to true so they are used.[m
     constexpr int script_check_threads = 2;[m
[36m@@ -177,15 +181,21 @@[m [mTestingSetup::TestingSetup(const std::string& chainName, const std::vector<const[m
     // instead of unit tests, but for now we need these here.[m
     RegisterAllCoreRPCCommands(tableRPC);[m
 [m
[31m-    m_node.chainman->InitializeChainstate(m_node.mempool.get());[m
[31m-    m_node.chainman->ActiveChainstate().InitCoinsDB([m
[31m-        /* cache_size_bytes */ 1 << 23, /* in_memory */ true, /* should_wipe */ false);[m
[31m-    assert(!m_node.chainman->ActiveChainstate().CanFlushToDisk());[m
[31m-    m_node.chainman->ActiveChainstate().InitCoinsCache(1 << 23);[m
[31m-    assert(m_node.chainman->ActiveChainstate().CanFlushToDisk());[m
[31m-    if (!m_node.chainman->ActiveChainstate().LoadGenesisBlock()) {[m
[31m-        throw std::runtime_error("LoadGenesisBlock failed.");[m
[31m-    }[m
[32m+[m[32m    auto rv = LoadChainstateSequence(fReindex.load(),[m
[32m+[m[32m                                     *Assert(m_node.chainman.get()),[m
[32m+[m[32m                                     Assert(m_node.mempool.get()),[m
[32m+[m[32m                                     fPruneMode,[m
[32m+[m[32m                                     chainparams.GetConsensus(),[m
[32m+[m[32m                                     m_args.GetBoolArg("-reindex-chainstate", false),[m
[32m+[m[32m                                     m_cache_sizes.block_tree_db_cache_size,[m
[32m+[m[32m                                     m_cache_sizes.coin_db_cache_size,[m
[32m+[m[32m                                     m_cache_sizes.coin_cache_usage_size,[m
[32m+[m[32m                                     m_args.GetIntArg("-checkblocks", DEFAULT_CHECKBLOCKS),[m
[32m+[m[32m                                     m_args.GetIntArg("-checklevel", DEFAULT_CHECKLEVEL),[m
[32m+[m[32m                                     true,[m
[32m+[m[32m                                     true,[m
[32m+[m[32m                                     GetAdjustedTime);[m
[32m+[m[32m    assert(!rv.has_value());[m
 [m
     BlockValidationState state;[m
     if (!m_node.chainman->ActiveChainstate().ActivateBestChain(state)) {[m
[33mdiff --git a/src/test/util/setup_common.h b/src/test/util/setup_common.h[m
[33mindex 7518cdb042..f5148df4e5 100644[m
[33m--- a/src/test/util/setup_common.h[m
[33m+++ b/src/test/util/setup_common.h[m
[36m@@ -7,6 +7,7 @@[m
 [m
 #include <chainparamsbase.h>[m
 #include <fs.h>[m
[32m+[m[32m#include <init/caches.h>[m
 #include <key.h>[m
 #include <util/system.h>[m
 #include <node/context.h>[m
[36m@@ -81,7 +82,7 @@[m [mstruct BasicTestingSetup {[m
     ~BasicTestingSetup();[m
 [m
     const fs::path m_path_root;[m
[31m-    ArgsManager m_args;[m
[32m+[m[32m    ArgsManager& m_args;[m
 };[m
 [m
 /** Testing setup that performs all steps up until right before[m
[36m@@ -89,6 +90,7 @@[m [mstruct BasicTestingSetup {[m
  * initialization behaviour.[m
  */[m
 struct ChainTestingSetup : public BasicTestingSetup {[m
[32m+[m[32m    CacheSizes m_cache_sizes{};[m
 [m
     explicit ChainTestingSetup(const std::string& chainName = CBaseChainParams::MAIN, const std::vector<const char*>& extra_args = {});[m
     ~ChainTestingSetup();[m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex 4b9a61320c..d1ddb4ac3d 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -3764,6 +3764,7 @@[m [mbool CChainState::LoadChainTip()[m
     PruneBlockIndexCandidates();[m
 [m
     tip = m_chain.Tip();[m
[32m+[m[32m    uiInterface.NotifyBlockTip(GetSynchronizationState(IsInitialBlockDownload()), tip);[m
     LogPrintf("Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\n",[m
               tip->GetBlockHash().ToString(),[m
               m_chain.Height(),[m
[36m@@ -3784,7 +3785,7 @@[m [mCVerifyDB::~CVerifyDB()[m
 [m
 bool CVerifyDB::VerifyDB([m
     CChainState& chainstate,[m
[31m-    const CChainParams& chainparams,[m
[32m+[m[32m    const Consensus::Params& consensus_params,[m
     CCoinsView& coinsview,[m
     int nCheckLevel, int nCheckDepth)[m
 {[m
[36m@@ -3826,10 +3827,10 @@[m [mbool CVerifyDB::VerifyDB([m
         }[m
         CBlock block;[m
         // check level 0: read from disk[m
[31m-        if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))[m
[32m+[m[32m        if (!ReadBlockFromDisk(block, pindex, consensus_params))[m
             return error("VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s", pindex->nHeight, pindex->GetBlockHash().ToString());[m
         // check level 1: verify block validity[m
[31m-        if (nCheckLevel >= 1 && !CheckBlock(block, state, chainparams.GetConsensus()))[m
[32m+[m[32m        if (nCheckLevel >= 1 && !CheckBlock(block, state, consensus_params))[m
             return error("%s: *** found bad block at %d, hash=%s (%s)\n", __func__,[m
                          pindex->nHeight, pindex->GetBlockHash().ToString(), state.ToString());[m
         // check level 2: verify undo validity[m
[36m@@ -3877,7 +3878,7 @@[m [mbool CVerifyDB::VerifyDB([m
             uiInterface.ShowProgress(_("Verifying blocksâ€¦").translated, percentageDone, false);[m
             pindex = chainstate.m_chain.Next(pindex);[m
             CBlock block;[m
[31m-            if (!ReadBlockFromDisk(block, pindex, chainparams.GetConsensus()))[m
[32m+[m[32m            if (!ReadBlockFromDisk(block, pindex, consensus_params))[m
                 return error("VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s", pindex->nHeight, pindex->GetBlockHash().ToString());[m
             if (!chainstate.ConnectBlock(block, state, pindex, coins)) {[m
                 return error("VerifyDB(): *** found unconnectable block at %d, hash=%s (%s)", pindex->nHeight, pindex->GetBlockHash().ToString(), state.ToString());[m
[33mdiff --git a/src/validation.h b/src/validation.h[m
[33mindex b10050f931..7a665b0625 100644[m
[33m--- a/src/validation.h[m
[33m+++ b/src/validation.h[m
[36m@@ -339,7 +339,7 @@[m [mpublic:[m
     ~CVerifyDB();[m
     bool VerifyDB([m
         CChainState& chainstate,[m
[31m-        const CChainParams& chainparams,[m
[32m+[m[32m        const Consensus::Params& consensus_params,[m
         CCoinsView& coinsview,[m
         int nCheckLevel,[m
         int nCheckDepth) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m