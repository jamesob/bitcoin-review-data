[33mdiff --git a/src/rest.cpp b/src/rest.cpp[m
[33mindex aa97470ca7..36c7da1e30 100644[m
[33m--- a/src/rest.cpp[m
[33m+++ b/src/rest.cpp[m
[36m@@ -181,13 +181,14 @@[m [mstatic bool rest_headers(const std::any& context,[m
     headers.reserve(count);[m
     {[m
         LOCK(cs_main);[m
[31m-        tip = ::ChainActive().Tip();[m
[31m-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[31m-        while (pindex != nullptr && ::ChainActive().Contains(pindex)) {[m
[32m+[m[32m        ChainstateManager& chainman = EnsureChainman(context);[m
[32m+[m[32m        tip = chainman.ActiveChain().Tip();[m
[32m+[m[32m        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        while (pindex != nullptr && chainman.ActiveChain().Contains(pindex)) {[m
             headers.push_back(pindex);[m
             if (headers.size() == (unsigned long)count)[m
                 break;[m
[31m-            pindex = ::ChainActive().Next(pindex);[m
[32m+[m[32m            pindex = chainman.ActiveChain().Next(pindex);[m
         }[m
     }[m
 [m
[36m@@ -231,7 +232,8 @@[m [mstatic bool rest_headers(const std::any& context,[m
     }[m
 }[m
 [m
[31m-static bool rest_block(HTTPRequest* req,[m
[32m+[m[32mstatic bool rest_block(const std::any& context,[m
[32m+[m[32m                       HTTPRequest* req,[m
                        const std::string& strURIPart,[m
                        bool showTxDetails)[m
 {[m
[36m@@ -249,8 +251,9 @@[m [mstatic bool rest_block(HTTPRequest* req,[m
     CBlockIndex* tip = nullptr;[m
     {[m
         LOCK(cs_main);[m
[31m-        tip = ::ChainActive().Tip();[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        ChainstateManager& chainman = EnsureChainman(context);[m
[32m+[m[32m        tip = chainman.ActiveChain().Tip();[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (!pblockindex) {[m
             return RESTERR(req, HTTP_NOT_FOUND, hashStr + " not found");[m
         }[m
[36m@@ -297,12 +300,12 @@[m [mstatic bool rest_block(HTTPRequest* req,[m
 [m
 static bool rest_block_extended(const std::any& context, HTTPRequest* req, const std::string& strURIPart)[m
 {[m
[31m-    return rest_block(req, strURIPart, true);[m
[32m+[m[32m    return rest_block(context, req, strURIPart, true);[m
 }[m
 [m
 static bool rest_block_notxdetails(const std::any& context, HTTPRequest* req, const std::string& strURIPart)[m
 {[m
[31m-    return rest_block(req, strURIPart, false);[m
[32m+[m[32m    return rest_block(context, req, strURIPart, false);[m
 }[m
 [m
 // A bit of a hack - dependency on a function defined in rpc/blockchain.cpp[m
[36m@@ -535,6 +538,7 @@[m [mstatic bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::[m
     std::string bitmapStringRepresentation;[m
     std::vector<bool> hits;[m
     bitmap.resize((vOutPoints.size() + 7) / 8);[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(context);[m
     {[m
         auto process_utxos = [&vOutPoints, &outs, &hits](const CCoinsView& view, const CTxMemPool& mempool) {[m
             for (const COutPoint& vOutPoint : vOutPoints) {[m
[36m@@ -550,12 +554,12 @@[m [mstatic bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::[m
             if (!mempool) return false;[m
             // use db+mempool as cache backend in case user likes to query mempool[m
             LOCK2(cs_main, mempool->cs);[m
[31m-            CCoinsViewCache& viewChain = ::ChainstateActive().CoinsTip();[m
[32m+[m[32m            CCoinsViewCache& viewChain = chainman.ActiveChainstate().CoinsTip();[m
             CCoinsViewMemPool viewMempool(&viewChain, *mempool);[m
             process_utxos(viewMempool, *mempool);[m
         } else {[m
             LOCK(cs_main);  // no need to lock mempool![m
[31m-            process_utxos(::ChainstateActive().CoinsTip(), CTxMemPool());[m
[32m+[m[32m            process_utxos(chainman.ActiveChainstate().CoinsTip(), CTxMemPool());[m
         }[m
 [m
         for (size_t i = 0; i < hits.size(); ++i) {[m
[36m@@ -570,7 +574,7 @@[m [mstatic bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::[m
         // serialize data[m
         // use exact same output as mentioned in Bip64[m
         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);[m
[31m-        ssGetUTXOResponse << ::ChainActive().Height() << ::ChainActive().Tip()->GetBlockHash() << bitmap << outs;[m
[32m+[m[32m        ssGetUTXOResponse << chainman.ActiveChain().Height() << chainman.ActiveChain().Tip()->GetBlockHash() << bitmap << outs;[m
         std::string ssGetUTXOResponseString = ssGetUTXOResponse.str();[m
 [m
         req->WriteHeader("Content-Type", "application/octet-stream");[m
[36m@@ -580,7 +584,7 @@[m [mstatic bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::[m
 [m
     case RetFormat::HEX: {[m
         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);[m
[31m-        ssGetUTXOResponse << ::ChainActive().Height() << ::ChainActive().Tip()->GetBlockHash() << bitmap << outs;[m
[32m+[m[32m        ssGetUTXOResponse << chainman.ActiveChain().Height() << chainman.ActiveChain().Tip()->GetBlockHash() << bitmap << outs;[m
         std::string strHex = HexStr(ssGetUTXOResponse) + "\n";[m
 [m
         req->WriteHeader("Content-Type", "text/plain");[m
[36m@@ -593,8 +597,8 @@[m [mstatic bool rest_getutxos(const std::any& context, HTTPRequest* req, const std::[m
 [m
         // pack in some essentials[m
         // use more or less the same output as mentioned in Bip64[m
[31m-        objGetUTXOResponse.pushKV("chainHeight", ::ChainActive().Height());[m
[31m-        objGetUTXOResponse.pushKV("chaintipHash", ::ChainActive().Tip()->GetBlockHash().GetHex());[m
[32m+[m[32m        objGetUTXOResponse.pushKV("chainHeight", chainman.ActiveChain().Height());[m
[32m+[m[32m        objGetUTXOResponse.pushKV("chaintipHash", chainman.ActiveChain().Tip()->GetBlockHash().GetHex());[m
         objGetUTXOResponse.pushKV("bitmap", bitmapStringRepresentation);[m
 [m
         UniValue utxos(UniValue::VARR);[m
[36m@@ -638,10 +642,11 @@[m [mstatic bool rest_blockhash_by_height(const std::any& context, HTTPRequest* req,[m
     CBlockIndex* pblockindex = nullptr;[m
     {[m
         LOCK(cs_main);[m
[31m-        if (blockheight > ::ChainActive().Height()) {[m
[32m+[m[32m        const CChain& active_chain = EnsureChainman(context).ActiveChain();[m
[32m+[m[32m        if (blockheight > active_chain.Height()) {[m
             return RESTERR(req, HTTP_NOT_FOUND, "Block height out of range");[m
         }[m
[31m-        pblockindex = ::ChainActive()[blockheight];[m
[32m+[m[32m        pblockindex = active_chain[blockheight];[m
     }[m
     switch (rf) {[m
     case RetFormat::BINARY: {[m
[33mdiff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp[m
[33mindex e1501d7254..ffabca0aff 100644[m
[33m--- a/src/rpc/blockchain.cpp[m
[33m+++ b/src/rpc/blockchain.cpp[m
[36m@@ -79,6 +79,7 @@[m [mChainstateManager& EnsureChainman(const std::any& context)[m
     if (!node.chainman) {[m
         throw JSONRPCError(RPC_INTERNAL_ERROR, "Node chainman not found");[m
     }[m
[32m+[m[32m    WITH_LOCK(::cs_main, CHECK_NONFATAL(std::addressof(g_chainman) == std::addressof(*node.chainman)));[m
     return *node.chainman;[m
 }[m
 [m
[36m@@ -198,7 +199,7 @@[m [mstatic RPCHelpMan getblockcount()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[31m-    return ::ChainActive().Height();[m
[32m+[m[32m    return EnsureChainman(request.context).ActiveChain().Height();[m
 },[m
     };[m
 }[m
[36m@@ -217,7 +218,7 @@[m [mstatic RPCHelpMan getbestblockhash()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[31m-    return ::ChainActive().Tip()->GetBlockHash().GetHex();[m
[32m+[m[32m    return EnsureChainman(request.context).ActiveChain().Tip()->GetBlockHash().GetHex();[m
 },[m
     };[m
 }[m
[36m@@ -398,7 +399,7 @@[m [mstatic RPCHelpMan getdifficulty()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[31m-    return GetDifficulty(::ChainActive().Tip());[m
[32m+[m[32m    return GetDifficulty(EnsureChainman(request.context).ActiveChain().Tip());[m
 },[m
     };[m
 }[m
[36m@@ -763,12 +764,13 @@[m [mstatic RPCHelpMan getblockhash()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[32m+[m[32m    const CChain& active_chain = EnsureChainman(request.context).ActiveChain();[m
 [m
     int nHeight = request.params[0].get_int();[m
[31m-    if (nHeight < 0 || nHeight > ::ChainActive().Height())[m
[32m+[m[32m    if (nHeight < 0 || nHeight > active_chain.Height())[m
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Block height out of range");[m
 [m
[31m-    CBlockIndex* pblockindex = ::ChainActive()[nHeight];[m
[32m+[m[32m    CBlockIndex* pblockindex = active_chain[nHeight];[m
     return pblockindex->GetBlockHash().GetHex();[m
 },[m
     };[m
[36m@@ -822,8 +824,9 @@[m [mstatic RPCHelpMan getblockheader()[m
     const CBlockIndex* tip;[m
     {[m
         LOCK(cs_main);[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[31m-        tip = ::ChainActive().Tip();[m
[32m+[m[32m        ChainstateManager& chainman = EnsureChainman(request.context);[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        tip = chainman.ActiveChain().Tip();[m
     }[m
 [m
     if (!pblockindex) {[m
[36m@@ -946,8 +949,9 @@[m [mstatic RPCHelpMan getblock()[m
     const CBlockIndex* tip;[m
     {[m
         LOCK(cs_main);[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[31m-        tip = ::ChainActive().Tip();[m
[32m+[m[32m        ChainstateManager& chainman = EnsureChainman(request.context);[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        tip = chainman.ActiveChain().Tip();[m
 [m
         if (!pblockindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
[36m@@ -988,6 +992,7 @@[m [mstatic RPCHelpMan pruneblockchain()[m
         throw JSONRPCError(RPC_MISC_ERROR, "Cannot prune blocks because node is not in prune mode.");[m
 [m
     LOCK(cs_main);[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
 [m
     int heightParam = request.params[0].get_int();[m
     if (heightParam < 0)[m
[36m@@ -997,7 +1002,7 @@[m [mstatic RPCHelpMan pruneblockchain()[m
     // too low to be a block time (corresponds to timestamp from Sep 2001).[m
     if (heightParam > 1000000000) {[m
         // Add a 2 hour buffer to include blocks which might have had old timestamps[m
[31m-        CBlockIndex* pindex = ::ChainActive().FindEarliestAtLeast(heightParam - TIMESTAMP_WINDOW, 0);[m
[32m+[m[32m        CBlockIndex* pindex = chainman.ActiveChain().FindEarliestAtLeast(heightParam - TIMESTAMP_WINDOW, 0);[m
         if (!pindex) {[m
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Could not find block with at least the specified timestamp.");[m
         }[m
[36m@@ -1005,7 +1010,7 @@[m [mstatic RPCHelpMan pruneblockchain()[m
     }[m
 [m
     unsigned int height = (unsigned int) heightParam;[m
[31m-    unsigned int chainHeight = (unsigned int) ::ChainActive().Height();[m
[32m+[m[32m    unsigned int chainHeight = (unsigned int) chainman.ActiveChain().Height();[m
     if (chainHeight < Params().PruneAfterHeight())[m
         throw JSONRPCError(RPC_MISC_ERROR, "Blockchain is too short for pruning.");[m
     else if (height > chainHeight)[m
[36m@@ -1015,8 +1020,8 @@[m [mstatic RPCHelpMan pruneblockchain()[m
         height = chainHeight - MIN_BLOCKS_TO_KEEP;[m
     }[m
 [m
[31m-    PruneBlockFilesManual(::ChainstateActive(), height);[m
[31m-    const CBlockIndex* block = ::ChainActive().Tip();[m
[32m+[m[32m    PruneBlockFilesManual(chainman.ActiveChainstate(), height);[m
[32m+[m[32m    const CBlockIndex* block = chainman.ActiveChain().Tip();[m
     CHECK_NONFATAL(block);[m
     while (block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA)) {[m
         block = block->pprev;[m
[36m@@ -1069,13 +1074,20 @@[m [mstatic RPCHelpMan gettxoutsetinfo()[m
     UniValue ret(UniValue::VOBJ);[m
 [m
     CCoinsStats stats;[m
[31m-    ::ChainstateActive().ForceFlushStateToDisk();[m
[32m+[m[32m    CChainState& active_chainstate = EnsureChainman(request.context).ActiveChainstate();[m
[32m+[m[32m    active_chainstate.ForceFlushStateToDisk();[m
 [m
     const CoinStatsHashType hash_type{request.params[0].isNull() ? CoinStatsHashType::HASH_SERIALIZED : ParseHashType(request.params[0].get_str())};[m
 [m
[31m-    CCoinsView* coins_view = WITH_LOCK(::cs_main, return &::ChainstateActive().CoinsDB());[m
[32m+[m[32m    CCoinsView* coins_view;[m
[32m+[m[32m    BlockManager* blockman;[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(::cs_main);[m
[32m+[m[32m        coins_view = &active_chainstate.CoinsDB();[m
[32m+[m[32m        blockman = &active_chainstate.m_blockman;[m
[32m+[m[32m    }[m
     NodeContext& node = EnsureNodeContext(request.context);[m
[31m-    if (GetUTXOStats(coins_view, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)), stats, hash_type, node.rpc_interruption_point)) {[m
[32m+[m[32m    if (GetUTXOStats(coins_view, *blockman, stats, hash_type, node.rpc_interruption_point)) {[m
         ret.pushKV("height", (int64_t)stats.nHeight);[m
         ret.pushKV("bestblock", stats.hashBlock.GetHex());[m
         ret.pushKV("transactions", (int64_t)stats.nTransactions);[m
[36m@@ -1146,7 +1158,8 @@[m [mstatic RPCHelpMan gettxout()[m
         fMempool = request.params[2].get_bool();[m
 [m
     Coin coin;[m
[31m-    CCoinsViewCache* coins_view = &::ChainstateActive().CoinsTip();[m
[32m+[m[32m    CChainState& active_chainstate = EnsureChainman(request.context).ActiveChainstate();[m
[32m+[m[32m    CCoinsViewCache* coins_view = &active_chainstate.CoinsTip();[m
 [m
     if (fMempool) {[m
         const CTxMemPool& mempool = EnsureMemPool(request.context);[m
[36m@@ -1161,7 +1174,7 @@[m [mstatic RPCHelpMan gettxout()[m
         }[m
     }[m
 [m
[31m-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(coins_view->GetBestBlock());[m
[32m+[m[32m    const CBlockIndex* pindex = active_chainstate.m_blockman.LookupBlockIndex(coins_view->GetBestBlock());[m
     ret.pushKV("bestblock", pindex->GetBlockHash().GetHex());[m
     if (coin.nHeight == MEMPOOL_HEIGHT) {[m
         ret.pushKV("confirmations", 0);[m
[36m@@ -1201,12 +1214,13 @@[m [mstatic RPCHelpMan verifychain()[m
 [m
     LOCK(cs_main);[m
 [m
[31m-    return CVerifyDB().VerifyDB(Params(), ::ChainstateActive(), &::ChainstateActive().CoinsTip(), check_level, check_depth);[m
[32m+[m[32m    CChainState& active_chainstate = EnsureChainman(request.context).ActiveChainstate();[m
[32m+[m[32m    return CVerifyDB().VerifyDB(Params(), active_chainstate, &active_chainstate.CoinsTip(), check_level, check_depth);[m
 },[m
     };[m
 }[m
 [m
[31m-static void BuriedForkDescPushBack(UniValue& softforks, const std::string &name, int height) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
[32m+[m[32mstatic void BuriedForkDescPushBack(UniValue& softforks, const std::string &name, int height, int active_tip_nheight) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
 {[m
     // For buried deployments.[m
     // A buried deployment is one where the height of the activation has been hardcoded into[m
[36m@@ -1219,12 +1233,12 @@[m [mstatic void BuriedForkDescPushBack(UniValue& softforks, const std::string &name,[m
     rv.pushKV("type", "buried");[m
     // getblockchaininfo reports the softfork as active from when the chain height is[m
     // one below the activation height[m
[31m-    rv.pushKV("active", ::ChainActive().Tip()->nHeight + 1 >= height);[m
[32m+[m[32m    rv.pushKV("active", active_tip_nheight + 1 >= height);[m
     rv.pushKV("height", height);[m
     softforks.pushKV(name, rv);[m
 }[m
 [m
[31m-static void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
[32m+[m[32mstatic void BIP9SoftForkDescPushBack(const CBlockIndex* active_chain_tip, UniValue& softforks, const std::string &name, const Consensus::Params& consensusParams, Consensus::DeploymentPos id) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
 {[m
     // For BIP9 deployments.[m
     // Deployments (e.g. testdummy) with timeout value before Jan 1, 2009 are hidden.[m
[36m@@ -1233,7 +1247,7 @@[m [mstatic void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &nam[m
     if (consensusParams.vDeployments[id].nTimeout <= 1230768000) return;[m
 [m
     UniValue bip9(UniValue::VOBJ);[m
[31m-    const ThresholdState thresholdState = VersionBitsState(::ChainActive().Tip(), consensusParams, id, versionbitscache);[m
[32m+[m[32m    const ThresholdState thresholdState = VersionBitsState(active_chain_tip, consensusParams, id, versionbitscache);[m
     switch (thresholdState) {[m
     case ThresholdState::DEFINED: bip9.pushKV("status", "defined"); break;[m
     case ThresholdState::STARTED: bip9.pushKV("status", "started"); break;[m
[36m@@ -1247,12 +1261,12 @@[m [mstatic void BIP9SoftForkDescPushBack(UniValue& softforks, const std::string &nam[m
     }[m
     bip9.pushKV("start_time", consensusParams.vDeployments[id].nStartTime);[m
     bip9.pushKV("timeout", consensusParams.vDeployments[id].nTimeout);[m
[31m-    int64_t since_height = VersionBitsStateSinceHeight(::ChainActive().Tip(), consensusParams, id, versionbitscache);[m
[32m+[m[32m    int64_t since_height = VersionBitsStateSinceHeight(active_chain_tip, consensusParams, id, versionbitscache);[m
     bip9.pushKV("since", since_height);[m
     if (ThresholdState::STARTED == thresholdState)[m
     {[m
         UniValue statsUV(UniValue::VOBJ);[m
[31m-        BIP9Stats statsStruct = VersionBitsStatistics(::ChainActive().Tip(), consensusParams, id);[m
[32m+[m[32m        BIP9Stats statsStruct = VersionBitsStatistics(active_chain_tip, consensusParams, id);[m
         statsUV.pushKV("period", statsStruct.period);[m
         statsUV.pushKV("threshold", statsStruct.threshold);[m
         statsUV.pushKV("elapsed", statsStruct.elapsed);[m
[36m@@ -1328,17 +1342,20 @@[m [mRPCHelpMan getblockchaininfo()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
 [m
[31m-    const CBlockIndex* tip = ::ChainActive().Tip();[m
[32m+[m[32m    const CBlockIndex* tip = chainman.ActiveChain().Tip();[m
[32m+[m[32m    CHECK_NONFATAL(tip);[m
[32m+[m[32m    const int height = tip->nHeight;[m
     UniValue obj(UniValue::VOBJ);[m
     obj.pushKV("chain",                 Params().NetworkIDString());[m
[31m-    obj.pushKV("blocks",                (int)::ChainActive().Height());[m
[32m+[m[32m    obj.pushKV("blocks",                (int)height);[m
     obj.pushKV("headers",               pindexBestHeader ? pindexBestHeader->nHeight : -1);[m
     obj.pushKV("bestblockhash",         tip->GetBlockHash().GetHex());[m
     obj.pushKV("difficulty",            (double)GetDifficulty(tip));[m
     obj.pushKV("mediantime",            (int64_t)tip->GetMedianTimePast());[m
     obj.pushKV("verificationprogress",  GuessVerificationProgress(Params().TxData(), tip));[m
[31m-    obj.pushKV("initialblockdownload",  ::ChainstateActive().IsInitialBlockDownload());[m
[32m+[m[32m    obj.pushKV("initialblockdownload",  chainman.ActiveChainstate().IsInitialBlockDownload());[m
     obj.pushKV("chainwork",             tip->nChainWork.GetHex());[m
     obj.pushKV("size_on_disk",          CalculateCurrentUsage());[m
     obj.pushKV("pruned",                fPruneMode);[m
[36m@@ -1361,13 +1378,13 @@[m [mRPCHelpMan getblockchaininfo()[m
 [m
     const Consensus::Params& consensusParams = Params().GetConsensus();[m
     UniValue softforks(UniValue::VOBJ);[m
[31m-    BuriedForkDescPushBack(softforks, "bip34", consensusParams.BIP34Height);[m
[31m-    BuriedForkDescPushBack(softforks, "bip66", consensusParams.BIP66Height);[m
[31m-    BuriedForkDescPushBack(softforks, "bip65", consensusParams.BIP65Height);[m
[31m-    BuriedForkDescPushBack(softforks, "csv", consensusParams.CSVHeight);[m
[31m-    BuriedForkDescPushBack(softforks, "segwit", consensusParams.SegwitHeight);[m
[31m-    BIP9SoftForkDescPushBack(softforks, "testdummy", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);[m
[31m-    BIP9SoftForkDescPushBack(softforks, "taproot", consensusParams, Consensus::DEPLOYMENT_TAPROOT);[m
[32m+[m[32m    BuriedForkDescPushBack(softforks, "bip34", consensusParams.BIP34Height, height);[m
[32m+[m[32m    BuriedForkDescPushBack(softforks, "bip66", consensusParams.BIP66Height, height);[m
[32m+[m[32m    BuriedForkDescPushBack(softforks, "bip65", consensusParams.BIP65Height, height);[m
[32m+[m[32m    BuriedForkDescPushBack(softforks, "csv", consensusParams.CSVHeight, height);[m
[32m+[m[32m    BuriedForkDescPushBack(softforks, "segwit", consensusParams.SegwitHeight, height);[m
[32m+[m[32m    BIP9SoftForkDescPushBack(tip, softforks, "testdummy", consensusParams, Consensus::DEPLOYMENT_TESTDUMMY);[m
[32m+[m[32m    BIP9SoftForkDescPushBack(tip, softforks, "taproot", consensusParams, Consensus::DEPLOYMENT_TAPROOT);[m
     obj.pushKV("softforks",             softforks);[m
 [m
     obj.pushKV("warnings", GetWarnings(false).original);[m
[36m@@ -1554,16 +1571,17 @@[m [mstatic RPCHelpMan preciousblock()[m
     uint256 hash(ParseHashV(request.params[0], "blockhash"));[m
     CBlockIndex* pblockindex;[m
 [m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     {[m
         LOCK(cs_main);[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (!pblockindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
     }[m
 [m
     BlockValidationState state;[m
[31m-    ::ChainstateActive().PreciousBlock(state, Params(), pblockindex);[m
[32m+[m[32m    chainman.ActiveChainstate().PreciousBlock(state, Params(), pblockindex);[m
 [m
     if (!state.IsValid()) {[m
         throw JSONRPCError(RPC_DATABASE_ERROR, state.ToString());[m
[36m@@ -1591,18 +1609,19 @@[m [mstatic RPCHelpMan invalidateblock()[m
     uint256 hash(ParseHashV(request.params[0], "blockhash"));[m
     BlockValidationState state;[m
 [m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     CBlockIndex* pblockindex;[m
     {[m
         LOCK(cs_main);[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (!pblockindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
     }[m
[31m-    ::ChainstateActive().InvalidateBlock(state, Params(), pblockindex);[m
[32m+[m[32m    chainman.ActiveChainstate().InvalidateBlock(state, Params(), pblockindex);[m
 [m
     if (state.IsValid()) {[m
[31m-        ::ChainstateActive().ActivateBestChain(state, Params());[m
[32m+[m[32m        chainman.ActiveChainstate().ActivateBestChain(state, Params());[m
     }[m
 [m
     if (!state.IsValid()) {[m
[36m@@ -1629,20 +1648,21 @@[m [mstatic RPCHelpMan reconsiderblock()[m
                 },[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     uint256 hash(ParseHashV(request.params[0], "blockhash"));[m
 [m
     {[m
         LOCK(cs_main);[m
[31m-        CBlockIndex* pblockindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        CBlockIndex* pblockindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (!pblockindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
 [m
[31m-        ::ChainstateActive().ResetBlockFailureFlags(pblockindex);[m
[32m+[m[32m        chainman.ActiveChainstate().ResetBlockFailureFlags(pblockindex);[m
     }[m
 [m
     BlockValidationState state;[m
[31m-    ::ChainstateActive().ActivateBestChain(state, Params());[m
[32m+[m[32m    chainman.ActiveChainstate().ActivateBestChain(state, Params());[m
 [m
     if (!state.IsValid()) {[m
         throw JSONRPCError(RPC_DATABASE_ERROR, state.ToString());[m
[36m@@ -1679,20 +1699,21 @@[m [mstatic RPCHelpMan getchaintxstats()[m
                 },[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     const CBlockIndex* pindex;[m
     int blockcount = 30 * 24 * 60 * 60 / Params().GetConsensus().nPowTargetSpacing; // By default: 1 month[m
 [m
     if (request.params[1].isNull()) {[m
         LOCK(cs_main);[m
[31m-        pindex = ::ChainActive().Tip();[m
[32m+[m[32m        pindex = chainman.ActiveChain().Tip();[m
     } else {[m
         uint256 hash(ParseHashV(request.params[1], "blockhash"));[m
         LOCK(cs_main);[m
[31m-        pindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        pindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (!pindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
[31m-        if (!::ChainActive().Contains(pindex)) {[m
[32m+[m[32m        if (!chainman.ActiveChain().Contains(pindex)) {[m
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Block is not in main chain");[m
         }[m
     }[m
[36m@@ -1861,11 +1882,12 @@[m [mstatic RPCHelpMan getblockstats()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
 [m
     CBlockIndex* pindex;[m
     if (request.params[0].isNum()) {[m
         const int height = request.params[0].get_int();[m
[31m-        const int current_tip = ::ChainActive().Height();[m
[32m+[m[32m        const int current_tip = chainman.ActiveChain().Height();[m
         if (height < 0) {[m
             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Target block height %d is negative", height));[m
         }[m
[36m@@ -1873,14 +1895,14 @@[m [mstatic RPCHelpMan getblockstats()[m
             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Target block height %d after current tip %d", height, current_tip));[m
         }[m
 [m
[31m-        pindex = ::ChainActive()[height];[m
[32m+[m[32m        pindex = chainman.ActiveChain()[height];[m
     } else {[m
         const uint256 hash(ParseHashV(request.params[0], "hash_or_height"));[m
[31m-        pindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        pindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (!pindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
[31m-        if (!::ChainActive().Contains(pindex)) {[m
[32m+[m[32m        if (!chainman.ActiveChain().Contains(pindex)) {[m
             throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Block is not in chain %s", Params().NetworkIDString()));[m
         }[m
     }[m
[36m@@ -2263,10 +2285,11 @@[m [mstatic RPCHelpMan scantxoutset()[m
         CBlockIndex* tip;[m
         {[m
             LOCK(cs_main);[m
[31m-            ::ChainstateActive().ForceFlushStateToDisk();[m
[31m-            pcursor = std::unique_ptr<CCoinsViewCursor>(::ChainstateActive().CoinsDB().Cursor());[m
[32m+[m[32m            ChainstateManager& chainman = EnsureChainman(request.context);[m
[32m+[m[32m            chainman.ActiveChainstate().ForceFlushStateToDisk();[m
[32m+[m[32m            pcursor = std::unique_ptr<CCoinsViewCursor>(chainman.ActiveChainstate().CoinsDB().Cursor());[m
             CHECK_NONFATAL(pcursor);[m
[31m-            tip = ::ChainActive().Tip();[m
[32m+[m[32m            tip = chainman.ActiveChain().Tip();[m
             CHECK_NONFATAL(tip);[m
         }[m
         NodeContext& node = EnsureNodeContext(request.context);[m
[36m@@ -2343,7 +2366,7 @@[m [mstatic RPCHelpMan getblockfilter()[m
     bool block_was_connected;[m
     {[m
         LOCK(cs_main);[m
[31m-        block_index = g_chainman.m_blockman.LookupBlockIndex(block_hash);[m
[32m+[m[32m        block_index = EnsureChainman(request.context).m_blockman.LookupBlockIndex(block_hash);[m
         if (!block_index) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
[36m@@ -2464,7 +2487,7 @@[m [mUniValue CreateUTXOSnapshot(NodeContext& node, CChainState& chainstate, CAutoFil[m
         }[m
 [m
         pcursor = std::unique_ptr<CCoinsViewCursor>(chainstate.CoinsDB().Cursor());[m
[31m-        tip = g_chainman.m_blockman.LookupBlockIndex(stats.hashBlock);[m
[32m+[m[32m        tip = chainstate.m_blockman.LookupBlockIndex(stats.hashBlock);[m
         CHECK_NONFATAL(tip);[m
     }[m
 [m
[33mdiff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp[m
[33mindex 72ad0df199..8b54d07b50 100644[m
[33m--- a/src/rpc/mining.cpp[m
[33m+++ b/src/rpc/mining.cpp[m
[36m@@ -44,11 +44,12 @@[m
  * or from the last difficulty change if 'lookup' is nonpositive.[m
  * If 'height' is nonnegative, compute the estimate at the time when a given block was found.[m
  */[m
[31m-static UniValue GetNetworkHashPS(int lookup, int height) {[m
[31m-    CBlockIndex *pb = ::ChainActive().Tip();[m
[32m+[m[32mstatic UniValue GetNetworkHashPS(int lookup, int height, const CChain& active_chain) {[m
[32m+[m[32m    const CBlockIndex* pb = active_chain.Tip();[m
 [m
[31m-    if (height >= 0 && height < ::ChainActive().Height())[m
[31m-        pb = ::ChainActive()[height];[m
[32m+[m[32m    if (height >= 0 && height < active_chain.Height()) {[m
[32m+[m[32m        pb = active_chain[height];[m
[32m+[m[32m    }[m
 [m
     if (pb == nullptr || !pb->nHeight)[m
         return 0;[m
[36m@@ -61,7 +62,7 @@[m [mstatic UniValue GetNetworkHashPS(int lookup, int height) {[m
     if (lookup > pb->nHeight)[m
         lookup = pb->nHeight;[m
 [m
[31m-    CBlockIndex *pb0 = pb;[m
[32m+[m[32m    const CBlockIndex* pb0 = pb;[m
     int64_t minTime = pb0->GetBlockTime();[m
     int64_t maxTime = minTime;[m
     for (int i = 0; i < lookup; i++) {[m
[36m@@ -100,7 +101,8 @@[m [mstatic RPCHelpMan getnetworkhashps()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[31m-    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);[m
[32m+[m[32m    const CChain& active_chain = EnsureChainman(request.context).ActiveChain();[m
[32m+[m[32m    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1, active_chain);[m
 },[m
     };[m
 }[m
[36m@@ -111,7 +113,8 @@[m [mstatic bool GenerateBlock(ChainstateManager& chainman, CBlock& block, uint64_t&[m
 [m
     {[m
         LOCK(cs_main);[m
[31m-        IncrementExtraNonce(&block, ::ChainActive().Tip(), extra_nonce);[m
[32m+[m[32m        CHECK_NONFATAL(std::addressof(::ChainActive()) == std::addressof(chainman.ActiveChain()));[m
[32m+[m[32m        IncrementExtraNonce(&block, chainman.ActiveChain().Tip(), extra_nonce);[m
     }[m
 [m
     CChainParams chainparams(Params());[m
[36m@@ -143,7 +146,8 @@[m [mstatic UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me[m
 [m
     {   // Don't keep cs_main locked[m
         LOCK(cs_main);[m
[31m-        nHeight = ::ChainActive().Height();[m
[32m+[m[32m        CHECK_NONFATAL(std::addressof(::ChainActive()) == std::addressof(chainman.ActiveChain()));[m
[32m+[m[32m        nHeight = chainman.ActiveChain().Height();[m
         nHeightEnd = nHeight+nGenerate;[m
     }[m
     unsigned int nExtraNonce = 0;[m
[36m@@ -354,11 +358,12 @@[m [mstatic RPCHelpMan generateblock()[m
     CChainParams chainparams(Params());[m
     CBlock block;[m
 [m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     {[m
         LOCK(cs_main);[m
 [m
         CTxMemPool empty_mempool;[m
[31m-        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(::ChainstateActive(), empty_mempool, chainparams).CreateNewBlock(coinbase_script));[m
[32m+[m[32m        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(chainman.ActiveChainstate(), empty_mempool, chainparams).CreateNewBlock(coinbase_script));[m
         if (!blocktemplate) {[m
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");[m
         }[m
[36m@@ -369,13 +374,14 @@[m [mstatic RPCHelpMan generateblock()[m
 [m
     // Add transactions[m
     block.vtx.insert(block.vtx.end(), txs.begin(), txs.end());[m
[31m-    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(g_chainman.m_blockman)));[m
[32m+[m[32m    WITH_LOCK(::cs_main, CHECK_NONFATAL(std::addressof(g_chainman.m_blockman) == std::addressof(chainman.m_blockman)));[m
[32m+[m[32m    RegenerateCommitments(block, WITH_LOCK(::cs_main, return std::ref(chainman.m_blockman)));[m
 [m
     {[m
         LOCK(cs_main);[m
 [m
         BlockValidationState state;[m
[31m-        if (!TestBlockValidity(state, chainparams, ::ChainstateActive(), block, g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock), false, false)) {[m
[32m+[m[32m        if (!TestBlockValidity(state, chainparams, chainman.ActiveChainstate(), block, chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock), false, false)) {[m
             throw JSONRPCError(RPC_VERIFY_ERROR, strprintf("TestBlockValidity failed: %s", state.ToString()));[m
         }[m
     }[m
[36m@@ -384,7 +390,7 @@[m [mstatic RPCHelpMan generateblock()[m
     uint64_t max_tries{DEFAULT_MAX_TRIES};[m
     unsigned int extra_nonce{0};[m
 [m
[31m-    if (!GenerateBlock(EnsureChainman(request.context), block, max_tries, extra_nonce, block_hash) || block_hash.IsNull()) {[m
[32m+[m[32m    if (!GenerateBlock(chainman, block, max_tries, extra_nonce, block_hash) || block_hash.IsNull()) {[m
         throw JSONRPCError(RPC_MISC_ERROR, "Failed to make block.");[m
     }[m
 [m
[36m@@ -420,12 +426,13 @@[m [mstatic RPCHelpMan getmininginfo()[m
 {[m
     LOCK(cs_main);[m
     const CTxMemPool& mempool = EnsureMemPool(request.context);[m
[32m+[m[32m    const CChain& active_chain = EnsureChainman(request.context).ActiveChain();[m
 [m
     UniValue obj(UniValue::VOBJ);[m
[31m-    obj.pushKV("blocks",           (int)::ChainActive().Height());[m
[32m+[m[32m    obj.pushKV("blocks",           (int)active_chain.Height());[m
     if (BlockAssembler::m_last_block_weight) obj.pushKV("currentblockweight", *BlockAssembler::m_last_block_weight);[m
     if (BlockAssembler::m_last_block_num_txs) obj.pushKV("currentblocktx", *BlockAssembler::m_last_block_num_txs);[m
[31m-    obj.pushKV("difficulty",       (double)GetDifficulty(::ChainActive().Tip()));[m
[32m+[m[32m    obj.pushKV("difficulty",       (double)GetDifficulty(active_chain.Tip()));[m
     obj.pushKV("networkhashps",    getnetworkhashps().HandleRequest(request));[m
     obj.pushKV("pooledtx",         (uint64_t)mempool.size());[m
     obj.pushKV("chain",            Params().NetworkIDString());[m
[36m@@ -589,6 +596,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     LOCK(cs_main);[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
 [m
     std::string strMode = "template";[m
     UniValue lpval = NullUniValue;[m
[36m@@ -619,7 +627,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block decode failed");[m
 [m
             uint256 hash = block.GetHash();[m
[31m-            const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m            const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(hash);[m
             if (pindex) {[m
                 if (pindex->IsValid(BLOCK_VALID_SCRIPTS))[m
                     return "duplicate";[m
[36m@@ -628,12 +636,12 @@[m [mstatic RPCHelpMan getblocktemplate()[m
                 return "duplicate-inconclusive";[m
             }[m
 [m
[31m-            CBlockIndex* const pindexPrev = ::ChainActive().Tip();[m
[32m+[m[32m            CBlockIndex* const pindexPrev = chainman.ActiveChain().Tip();[m
             // TestBlockValidity only supports blocks built on the current Tip[m
             if (block.hashPrevBlock != pindexPrev->GetBlockHash())[m
                 return "inconclusive-not-best-prevblk";[m
             BlockValidationState state;[m
[31m-            TestBlockValidity(state, Params(), ::ChainstateActive(), block, pindexPrev, false, true);[m
[32m+[m[32m            TestBlockValidity(state, Params(), chainman.ActiveChainstate(), block, pindexPrev, false, true);[m
             return BIP22ValidationResult(state);[m
         }[m
 [m
[36m@@ -664,7 +672,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
             throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME " is not connected!");[m
         }[m
 [m
[31m-        if (::ChainstateActive().IsInitialBlockDownload()) {[m
[32m+[m[32m        if (chainman.ActiveChainstate().IsInitialBlockDownload()) {[m
             throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, PACKAGE_NAME " is in initial sync and waiting for blocks...");[m
         }[m
     }[m
[36m@@ -690,7 +698,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
         else[m
         {[m
             // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier[m
[31m-            hashWatchedChain = ::ChainActive().Tip()->GetBlockHash();[m
[32m+[m[32m            hashWatchedChain = chainman.ActiveChain().Tip()->GetBlockHash();[m
             nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;[m
         }[m
 [m
[36m@@ -735,7 +743,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
     static CBlockIndex* pindexPrev;[m
     static int64_t nStart;[m
     static std::unique_ptr<CBlockTemplate> pblocktemplate;[m
[31m-    if (pindexPrev != ::ChainActive().Tip() ||[m
[32m+[m[32m    if (pindexPrev != chainman.ActiveChain().Tip() ||[m
         (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5))[m
     {[m
         // Clear pindexPrev so future calls make a new block, despite any failures from here on[m
[36m@@ -743,12 +751,12 @@[m [mstatic RPCHelpMan getblocktemplate()[m
 [m
         // Store the pindexBest used before CreateNewBlock, to avoid races[m
         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();[m
[31m-        CBlockIndex* pindexPrevNew = ::ChainActive().Tip();[m
[32m+[m[32m        CBlockIndex* pindexPrevNew = chainman.ActiveChain().Tip();[m
         nStart = GetTime();[m
 [m
         // Create new block[m
         CScript scriptDummy = CScript() << OP_TRUE;[m
[31m-        pblocktemplate = BlockAssembler(::ChainstateActive(), mempool, Params()).CreateNewBlock(scriptDummy);[m
[32m+[m[32m        pblocktemplate = BlockAssembler(chainman.ActiveChainstate(), mempool, Params()).CreateNewBlock(scriptDummy);[m
         if (!pblocktemplate)[m
             throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");[m
 [m
[36m@@ -884,7 +892,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
     result.pushKV("transactions", transactions);[m
     result.pushKV("coinbaseaux", aux);[m
     result.pushKV("coinbasevalue", (int64_t)pblock->vtx[0]->vout[0].nValue);[m
[31m-    result.pushKV("longpollid", ::ChainActive().Tip()->GetBlockHash().GetHex() + ToString(nTransactionsUpdatedLast));[m
[32m+[m[32m    result.pushKV("longpollid", chainman.ActiveChain().Tip()->GetBlockHash().GetHex() + ToString(nTransactionsUpdatedLast));[m
     result.pushKV("target", hashTarget.GetHex());[m
     result.pushKV("mintime", (int64_t)pindexPrev->GetMedianTimePast()+1);[m
     result.pushKV("mutable", aMutable);[m
[36m@@ -967,10 +975,11 @@[m [mstatic RPCHelpMan submitblock()[m
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block does not start with a coinbase");[m
     }[m
 [m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     uint256 hash = block.GetHash();[m
     {[m
         LOCK(cs_main);[m
[31m-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hash);[m
[32m+[m[32m        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(hash);[m
         if (pindex) {[m
             if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {[m
                 return "duplicate";[m
[36m@@ -983,7 +992,7 @@[m [mstatic RPCHelpMan submitblock()[m
 [m
     {[m
         LOCK(cs_main);[m
[31m-        const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock);[m
[32m+[m[32m        const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(block.hashPrevBlock);[m
         if (pindex) {[m
             UpdateUncommittedBlockStructures(block, pindex, Params().GetConsensus());[m
         }[m
[36m@@ -992,7 +1001,7 @@[m [mstatic RPCHelpMan submitblock()[m
     bool new_block;[m
     auto sc = std::make_shared<submitblock_StateCatcher>(block.GetHash());[m
     RegisterSharedValidationInterface(sc);[m
[31m-    bool accepted = EnsureChainman(request.context).ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);[m
[32m+[m[32m    bool accepted = chainman.ProcessNewBlock(Params(), blockptr, /* fForceProcessing */ true, /* fNewBlock */ &new_block);[m
     UnregisterSharedValidationInterface(sc);[m
     if (!new_block && accepted) {[m
         return "duplicate";[m
[36m@@ -1025,15 +1034,16 @@[m [mstatic RPCHelpMan submitheader()[m
     if (!DecodeHexBlockHeader(h, request.params[0].get_str())) {[m
         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, "Block header decode failed");[m
     }[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     {[m
         LOCK(cs_main);[m
[31m-        if (!g_chainman.m_blockman.LookupBlockIndex(h.hashPrevBlock)) {[m
[32m+[m[32m        if (!chainman.m_blockman.LookupBlockIndex(h.hashPrevBlock)) {[m
             throw JSONRPCError(RPC_VERIFY_ERROR, "Must submit previous header (" + h.hashPrevBlock.GetHex() + ") first");[m
         }[m
     }[m
 [m
     BlockValidationState state;[m
[31m-    EnsureChainman(request.context).ProcessNewBlockHeaders({h}, state, Params());[m
[32m+[m[32m    chainman.ProcessNewBlockHeaders({h}, state, Params());[m
     if (state.IsValid()) return NullUniValue;[m
     if (state.IsError()) {[m
         throw JSONRPCError(RPC_VERIFY_ERROR, state.ToString());[m
[33mdiff --git a/src/rpc/rawtransaction.cpp b/src/rpc/rawtransaction.cpp[m
[33mindex 7932bd2915..0ed0af3493 100644[m
[33m--- a/src/rpc/rawtransaction.cpp[m
[33m+++ b/src/rpc/rawtransaction.cpp[m
[36m@@ -40,7 +40,7 @@[m
 [m
 #include <univalue.h>[m
 [m
[31m-static void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)[m
[32m+[m[32mstatic void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry, CChainState& active_chainstate)[m
 {[m
     // Call into TxToUniv() in bitcoin-common to decode the transaction hex.[m
     //[m
[36m@@ -53,10 +53,10 @@[m [mstatic void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue&[m
         LOCK(cs_main);[m
 [m
         entry.pushKV("blockhash", hashBlock.GetHex());[m
[31m-        CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(hashBlock);[m
[32m+[m[32m        CBlockIndex* pindex = active_chainstate.m_blockman.LookupBlockIndex(hashBlock);[m
         if (pindex) {[m
[31m-            if (::ChainActive().Contains(pindex)) {[m
[31m-                entry.pushKV("confirmations", 1 + ::ChainActive().Height() - pindex->nHeight);[m
[32m+[m[32m            if (active_chainstate.m_chain.Contains(pindex)) {[m
[32m+[m[32m                entry.pushKV("confirmations", 1 + active_chainstate.m_chain.Height() - pindex->nHeight);[m
                 entry.pushKV("time", pindex->GetBlockTime());[m
                 entry.pushKV("blocktime", pindex->GetBlockTime());[m
             }[m
[36m@@ -158,6 +158,7 @@[m [mstatic RPCHelpMan getrawtransaction()[m
         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue[m
 {[m
     const NodeContext& node = EnsureNodeContext(request.context);[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
 [m
     bool in_active_chain = true;[m
     uint256 hash = ParseHashV(request.params[0], "parameter 1");[m
[36m@@ -178,11 +179,11 @@[m [mstatic RPCHelpMan getrawtransaction()[m
         LOCK(cs_main);[m
 [m
         uint256 blockhash = ParseHashV(request.params[2], "parameter 3");[m
[31m-        blockindex = g_chainman.m_blockman.LookupBlockIndex(blockhash);[m
[32m+[m[32m        blockindex = chainman.m_blockman.LookupBlockIndex(blockhash);[m
         if (!blockindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block hash not found");[m
         }[m
[31m-        in_active_chain = ::ChainActive().Contains(blockindex);[m
[32m+[m[32m        in_active_chain = chainman.ActiveChain().Contains(blockindex);[m
     }[m
 [m
     bool f_txindex_ready = false;[m
[36m@@ -215,7 +216,7 @@[m [mstatic RPCHelpMan getrawtransaction()[m
 [m
     UniValue result(UniValue::VOBJ);[m
     if (blockindex) result.pushKV("in_active_chain", in_active_chain);[m
[31m-    TxToJSON(*tx, hash_block, result);[m
[32m+[m[32m    TxToJSON(*tx, hash_block, result, chainman.ActiveChainstate());[m
     return result;[m
 },[m
     };[m
[36m@@ -257,10 +258,11 @@[m [mstatic RPCHelpMan gettxoutproof()[m
 [m
     CBlockIndex* pblockindex = nullptr;[m
     uint256 hashBlock;[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
     if (!request.params[1].isNull()) {[m
         LOCK(cs_main);[m
         hashBlock = ParseHashV(request.params[1], "blockhash");[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hashBlock);[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hashBlock);[m
         if (!pblockindex) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found");[m
         }[m
[36m@@ -269,9 +271,9 @@[m [mstatic RPCHelpMan gettxoutproof()[m
 [m
         // Loop through txids and try to find which block they're in. Exit loop once a block is found.[m
         for (const auto& tx : setTxids) {[m
[31m-            const Coin& coin = AccessByTxid(::ChainstateActive().CoinsTip(), tx);[m
[32m+[m[32m            const Coin& coin = AccessByTxid(chainman.ActiveChainstate().CoinsTip(), tx);[m
             if (!coin.IsSpent()) {[m
[31m-                pblockindex = ::ChainActive()[coin.nHeight];[m
[32m+[m[32m                pblockindex = chainman.ActiveChain()[coin.nHeight];[m
                 break;[m
             }[m
         }[m
[36m@@ -290,7 +292,7 @@[m [mstatic RPCHelpMan gettxoutproof()[m
         if (!tx || hashBlock.IsNull()) {[m
             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Transaction not yet in block");[m
         }[m
[31m-        pblockindex = g_chainman.m_blockman.LookupBlockIndex(hashBlock);[m
[32m+[m[32m        pblockindex = chainman.m_blockman.LookupBlockIndex(hashBlock);[m
         if (!pblockindex) {[m
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Transaction index corrupt");[m
         }[m
[36m@@ -350,8 +352,9 @@[m [mstatic RPCHelpMan verifytxoutproof()[m
 [m
     LOCK(cs_main);[m
 [m
[31m-    const CBlockIndex* pindex = g_chainman.m_blockman.LookupBlockIndex(merkleBlock.header.GetHash());[m
[31m-    if (!pindex || !::ChainActive().Contains(pindex) || pindex->nTx == 0) {[m
[32m+[m[32m    ChainstateManager& chainman = EnsureChainman(request.context);[m
[32m+[m[32m    const CBlockIndex* pindex = chainman.m_blockman.LookupBlockIndex(merkleBlock.header.GetHash());[m
[32m+[m[32m    if (!pindex || !chainman.ActiveChain().Contains(pindex) || pindex->nTx == 0) {[m
         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Block not found in chain");[m
     }[m
 [m
[36m@@ -678,7 +681,7 @@[m [mstatic RPCHelpMan combinerawtransaction()[m
         const CTxMemPool& mempool = EnsureMemPool(request.context);[m
         LOCK(cs_main);[m
         LOCK(mempool.cs);[m
[31m-        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();[m
[32m+[m[32m        CCoinsViewCache &viewChain = EnsureChainman(request.context).ActiveChainstate().CoinsTip();[m
         CCoinsViewMemPool viewMempool(&viewChain, mempool);[m
         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view[m
 [m
[36m@@ -949,7 +952,7 @@[m [mstatic RPCHelpMan testmempoolaccept()[m
     result_0.pushKV("txid", tx->GetHash().GetHex());[m
     result_0.pushKV("wtxid", tx->GetWitnessHash().GetHex());[m
 [m
[31m-    const MempoolAcceptResult accept_result = WITH_LOCK(cs_main, return AcceptToMemoryPool(::ChainstateActive(), mempool, std::move(tx),[m
[32m+[m[32m    const MempoolAcceptResult accept_result = WITH_LOCK(cs_main, return AcceptToMemoryPool(EnsureChainman(request.context).ActiveChainstate(), mempool, std::move(tx),[m
                                                   false /* bypass_limits */, /* test_accept */ true));[m
 [m
     // Only return the fee and vsize if the transaction would pass ATMP.[m
[36m@@ -1600,7 +1603,7 @@[m [mstatic RPCHelpMan utxoupdatepsbt()[m
     {[m
         const CTxMemPool& mempool = EnsureMemPool(request.context);[m
         LOCK2(cs_main, mempool.cs);[m
[31m-        CCoinsViewCache &viewChain = ::ChainstateActive().CoinsTip();[m
[32m+[m[32m        CCoinsViewCache &viewChain = EnsureChainman(request.context).ActiveChainstate().CoinsTip();[m
         CCoinsViewMemPool viewMempool(&viewChain, mempool);[m
         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view[m
 [m