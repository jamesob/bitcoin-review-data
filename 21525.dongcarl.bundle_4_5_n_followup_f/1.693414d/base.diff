[33mdiff --git a/src/miner.cpp b/src/miner.cpp[m
[33mindex fe7a54c05..8a9406f81 100644[m
[33m--- a/src/miner.cpp[m
[33m+++ b/src/miner.cpp[m
[36m@@ -55,9 +55,10 @@[m [mBlockAssembler::Options::Options() {[m
     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;[m
 }[m
 [m
[31m-BlockAssembler::BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options)[m
[32m+[m[32mBlockAssembler::BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params, const Options& options)[m
     : chainparams(params),[m
[31m-      m_mempool(mempool)[m
[32m+[m[32m      m_mempool(mempool),[m
[32m+[m[32m      m_chainstate(chainstate)[m
 {[m
     blockMinFeeRate = options.blockMinFeeRate;[m
     // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:[m
[36m@@ -79,8 +80,8 @@[m [mstatic BlockAssembler::Options DefaultOptions()[m
     return options;[m
 }[m
 [m
[31m-BlockAssembler::BlockAssembler(const CTxMemPool& mempool, const CChainParams& params)[m
[31m-    : BlockAssembler(mempool, params, DefaultOptions()) {}[m
[32m+[m[32mBlockAssembler::BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params)[m
[32m+[m[32m    : BlockAssembler(chainstate, mempool, params, DefaultOptions()) {}[m
 [m
 void BlockAssembler::resetBlock()[m
 {[m
[36m@@ -96,7 +97,7 @@[m [mvoid BlockAssembler::resetBlock()[m
     nFees = 0;[m
 }[m
 [m
[31m-std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn)[m
[32m+[m[32mstd::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)[m
 {[m
     int64_t nTimeStart = GetTimeMicros();[m
 [m
[36m@@ -114,8 +115,8 @@[m [mstd::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chai[m
     pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end[m
 [m
     LOCK2(cs_main, m_mempool.cs);[m
[31m-    assert(std::addressof(*::ChainActive().Tip()) == std::addressof(*chainstate.m_chain.Tip()));[m
[31m-    CBlockIndex* pindexPrev = chainstate.m_chain.Tip();[m
[32m+[m[32m    assert(std::addressof(*::ChainActive().Tip()) == std::addressof(*m_chainstate.m_chain.Tip()));[m
[32m+[m[32m    CBlockIndex* pindexPrev = m_chainstate.m_chain.Tip();[m
     assert(pindexPrev != nullptr);[m
     nHeight = pindexPrev->nHeight + 1;[m
 [m
[36m@@ -174,8 +175,8 @@[m [mstd::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(CChainState& chai[m
     pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);[m
 [m
     BlockValidationState state;[m
[31m-    assert(std::addressof(::ChainstateActive()) == std::addressof(chainstate));[m
[31m-    if (!TestBlockValidity(state, chainparams, chainstate, *pblock, pindexPrev, false, false)) {[m
[32m+[m[32m    assert(std::addressof(::ChainstateActive()) == std::addressof(m_chainstate));[m
[32m+[m[32m    if (!TestBlockValidity(state, chainparams, m_chainstate, *pblock, pindexPrev, false, false)) {[m
         throw std::runtime_error(strprintf("%s: TestBlockValidity failed: %s", __func__, state.ToString()));[m
     }[m
     int64_t nTime2 = GetTimeMicros();[m
[33mdiff --git a/src/miner.h b/src/miner.h[m
[33mindex 023635814..c400c90f6 100644[m
[33m--- a/src/miner.h[m
[33m+++ b/src/miner.h[m
[36m@@ -146,6 +146,7 @@[m [mprivate:[m
     int64_t nLockTimeCutoff;[m
     const CChainParams& chainparams;[m
     const CTxMemPool& m_mempool;[m
[32m+[m[32m    CChainState& m_chainstate;[m
 [m
 public:[m
     struct Options {[m
[36m@@ -154,11 +155,11 @@[m [mpublic:[m
         CFeeRate blockMinFeeRate;[m
     };[m
 [m
[31m-    explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params);[m
[31m-    explicit BlockAssembler(const CTxMemPool& mempool, const CChainParams& params, const Options& options);[m
[32m+[m[32m    explicit BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params);[m
[32m+[m[32m    explicit BlockAssembler(CChainState& chainstate, const CTxMemPool& mempool, const CChainParams& params, const Options& options);[m
 [m
     /** Construct a new block template with coinbase to scriptPubKeyIn */[m
[31m-    std::unique_ptr<CBlockTemplate> CreateNewBlock(CChainState& chainstate, const CScript& scriptPubKeyIn);[m
[32m+[m[32m    std::unique_ptr<CBlockTemplate> CreateNewBlock(const CScript& scriptPubKeyIn);[m
 [m
     inline static std::optional<int64_t> m_last_block_num_txs{};[m
     inline static std::optional<int64_t> m_last_block_weight{};[m
[36m@@ -201,6 +202,7 @@[m [mprivate:[m
 void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce);[m
 int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev);[m
 [m
[32m+[m[32m// TODO just accept a CBlockIndex*[m
 /** Update an old GenerateCoinbaseCommitment from CreateNewBlock after the block txs have changed */[m
 void RegenerateCommitments(CBlock& block, BlockManager& blockman);[m
 [m
[33mdiff --git a/src/net_processing.cpp b/src/net_processing.cpp[m
[33mindex e561f02c4..d0c3e8802 100644[m
[33m--- a/src/net_processing.cpp[m
[33m+++ b/src/net_processing.cpp[m
[36m@@ -475,19 +475,70 @@[m [mprivate:[m
     /** Offset into vExtraTxnForCompact to insert the next tx */[m
     size_t vExtraTxnForCompactIt GUARDED_BY(g_cs_orphans) = 0;[m
 [m
[32m+[m[32m    /** Check whether the last unknown block a peer advertised is not yet known. */[m
     void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m[32m    /** Update tracking information about which blocks a peer is assumed to have. */[m
     void UpdateBlockAvailability(NodeId nodeid, const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     bool CanDirectFetch() EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * To prevent fingerprinting attacks, only send blocks/headers outside of[m
[32m+[m[32m     * the active chain if they are no more than a month older (both in time,[m
[32m+[m[32m     * and in best equivalent proof of work) than the best header chain we know[m
[32m+[m[32m     * about and we fully-validated them at some point.[m
[32m+[m[32m     */[m
     bool BlockRequestAllowed(const CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     bool AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     void ProcessGetBlockData(CNode& pfrom, Peer& peer, const CInv& inv);[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Validation logic for compact filters request handling.[m
[32m+[m[32m     *[m
[32m+[m[32m     * May disconnect from the peer in the case of a bad request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param[in]   peer            The peer that we received the request from[m
[32m+[m[32m     * @param[in]   filter_type     The filter type the request is for. Must be basic filters.[m
[32m+[m[32m     * @param[in]   start_height    The start height for the request[m
[32m+[m[32m     * @param[in]   stop_hash       The stop_hash for the request[m
[32m+[m[32m     * @param[in]   max_height_diff The maximum number of items permitted to request, as specified in BIP 157[m
[32m+[m[32m     * @param[out]  stop_index      The CBlockIndex for the stop_hash block, if the request can be serviced.[m
[32m+[m[32m     * @param[out]  filter_index    The filter index, if the request can be serviced.[m
[32m+[m[32m     * @return                      True if the request can be serviced.[m
[32m+[m[32m     */[m
     bool PrepareBlockFilterRequest(CNode& peer,[m
                                    BlockFilterType filter_type, uint32_t start_height,[m
                                    const uint256& stop_hash, uint32_t max_height_diff,[m
                                    const CBlockIndex*& stop_index,[m
                                    BlockFilterIndex*& filter_index);[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle a cfilters request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * May disconnect from the peer in the case of a bad request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param[in]   peer            The peer that we received the request from[m
[32m+[m[32m     * @param[in]   vRecv           The raw message received[m
[32m+[m[32m     */[m
     void ProcessGetCFilters(CNode& peer, CDataStream& vRecv);[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle a cfheaders request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * May disconnect from the peer in the case of a bad request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param[in]   peer            The peer that we received the request from[m
[32m+[m[32m     * @param[in]   vRecv           The raw message received[m
[32m+[m[32m     */[m
     void ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv);[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Handle a getcfcheckpt request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * May disconnect from the peer in the case of a bad request.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param[in]   peer            The peer that we received the request from[m
[32m+[m[32m     * @param[in]   vRecv           The raw message received[m
[32m+[m[32m     */[m
     void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv);[m
 };[m
 } // namespace[m
[36m@@ -741,7 +792,6 @@[m [mstatic bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV[m
     return false;[m
 }[m
 [m
[31m-/** Check whether the last unknown block a peer advertised is not yet known. */[m
 void PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {[m
     CNodeState *state = State(nodeid);[m
     assert(state != nullptr);[m
[36m@@ -757,7 +807,6 @@[m [mvoid PeerManagerImpl::ProcessBlockAvailability(NodeId nodeid) {[m
     }[m
 }[m
 [m
[31m-/** Update tracking information about which blocks a peer is assumed to have. */[m
 void PeerManagerImpl::UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {[m
     CNodeState *state = State(nodeid);[m
     assert(state != nullptr);[m
[36m@@ -1182,16 +1231,6 @@[m [mbool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationStat[m
     return false;[m
 }[m
 [m
[31m-[m
[31m-//////////////////////////////////////////////////////////////////////////////[m
[31m-//[m
[31m-// blockchain -> download logic notification[m
[31m-//[m
[31m-[m
[31m-// To prevent fingerprinting attacks, only send blocks/headers outside of the[m
[31m-// active chain if they are no more than a month older (both in time, and in[m
[31m-// best equivalent proof of work) than the best header chain we know about and[m
[31m-// we fully-validated them at some point.[m
 bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)[m
 {[m
     AssertLockHeld(cs_main);[m
[36m@@ -2091,20 +2130,6 @@[m [mvoid PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)[m
     m_mempool.check(m_chainman.ActiveChainstate());[m
 }[m
 [m
[31m-/**[m
[31m- * Validation logic for compact filters request handling.[m
[31m- *[m
[31m- * May disconnect from the peer in the case of a bad request.[m
[31m- *[m
[31m- * @param[in]   peer            The peer that we received the request from[m
[31m- * @param[in]   filter_type     The filter type the request is for. Must be basic filters.[m
[31m- * @param[in]   start_height    The start height for the request[m
[31m- * @param[in]   stop_hash       The stop_hash for the request[m
[31m- * @param[in]   max_height_diff The maximum number of items permitted to request, as specified in BIP 157[m
[31m- * @param[out]  stop_index      The CBlockIndex for the stop_hash block, if the request can be serviced.[m
[31m- * @param[out]  filter_index    The filter index, if the request can be serviced.[m
[31m- * @return                      True if the request can be serviced.[m
[31m- */[m
 bool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,[m
                                                 BlockFilterType filter_type, uint32_t start_height,[m
                                                 const uint256& stop_hash, uint32_t max_height_diff,[m
[36m@@ -2158,14 +2183,6 @@[m [mbool PeerManagerImpl::PrepareBlockFilterRequest(CNode& peer,[m
     return true;[m
 }[m
 [m
[31m-/**[m
[31m- * Handle a cfilters request.[m
[31m- *[m
[31m- * May disconnect from the peer in the case of a bad request.[m
[31m- *[m
[31m- * @param[in]   peer            The peer that we received the request from[m
[31m- * @param[in]   vRecv           The raw message received[m
[31m- */[m
 void PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)[m
 {[m
     uint8_t filter_type_ser;[m
[36m@@ -2197,14 +2214,6 @@[m [mvoid PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)[m
     }[m
 }[m
 [m
[31m-/**[m
[31m- * Handle a cfheaders request.[m
[31m- *[m
[31m- * May disconnect from the peer in the case of a bad request.[m
[31m- *[m
[31m- * @param[in]   peer            The peer that we received the request from[m
[31m- * @param[in]   vRecv           The raw message received[m
[31m- */[m
 void PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)[m
 {[m
     uint8_t filter_type_ser;[m
[36m@@ -2249,14 +2258,6 @@[m [mvoid PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)[m
     m_connman.PushMessage(&peer, std::move(msg));[m
 }[m
 [m
[31m-/**[m
[31m- * Handle a getcfcheckpt request.[m
[31m- *[m
[31m- * May disconnect from the peer in the case of a bad request.[m
[31m- *[m
[31m- * @param[in]   peer            The peer that we received the request from[m
[31m- * @param[in]   vRecv           The raw message received[m
[31m- */[m
 void PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)[m
 {[m
     uint8_t filter_type_ser;[m
[33mdiff --git a/src/node/coin.cpp b/src/node/coin.cpp[m
[33mindex 263dcff65..23d4fa2aa 100644[m
[33m--- a/src/node/coin.cpp[m
[33m+++ b/src/node/coin.cpp[m
[36m@@ -11,6 +11,7 @@[m
 void FindCoins(const NodeContext& node, std::map<COutPoint, Coin>& coins)[m
 {[m
     assert(node.mempool);[m
[32m+[m[32m    assert(node.chainman);[m
     LOCK2(cs_main, node.mempool->cs);[m
     assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));[m
     CCoinsViewCache& chain_view = node.chainman->ActiveChainstate().CoinsTip();[m
[33mdiff --git a/src/node/coinstats.h b/src/node/coinstats.h[m
[33mindex 83f228aa7..975651dcc 100644[m
[33m--- a/src/node/coinstats.h[m
[33m+++ b/src/node/coinstats.h[m
[36m@@ -8,11 +8,11 @@[m
 [m
 #include <amount.h>[m
 #include <uint256.h>[m
[31m-#include <validation.h>[m
 [m
 #include <cstdint>[m
 #include <functional>[m
 [m
[32m+[m[32mclass BlockManager;[m
 class CCoinsView;[m
 [m
 enum class CoinStatsHashType {[m
[33mdiff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp[m
[33mindex 50c8c2917..9f0090066 100644[m
[33m--- a/src/node/interfaces.cpp[m
[33m+++ b/src/node/interfaces.cpp[m
[36m@@ -65,6 +65,8 @@[m [mnamespace node {[m
 namespace {[m
 class NodeImpl : public Node[m
 {[m
[32m+[m[32mprivate:[m
[32m+[m[32m    ChainstateManager& chainman() { return *Assert(m_context->chainman); }[m
 public:[m
     explicit NodeImpl(NodeContext* context) { setContext(context); }[m
     void initLogging() override { InitLogging(*Assert(m_context->args)); }[m
[36m@@ -183,21 +185,28 @@[m [mpublic:[m
     int getNumBlocks() override[m
     {[m
         LOCK(::cs_main);[m
[31m-        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));[m
[31m-        return m_context->chainman->ActiveChain().Height();[m
[32m+[m[32m        assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));[m
[32m+[m[32m        return chainman().ActiveChain().Height();[m
     }[m
     uint256 getBestBlockHash() override[m
     {[m
[31m-        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));[m
[31m-        const CBlockIndex* tip = WITH_LOCK(::cs_main, return m_context->chainman->ActiveChain().Tip());[m
[32m+[m[32m        const CBlockIndex* tip;[m
[32m+[m[32m        {[m
[32m+[m[32m            // TODO: Temporary scope to check correctness of refactored code.[m
[32m+[m[32m            // Should be removed manually after merge of[m
[32m+[m[32m            // https://github.com/bitcoin/bitcoin/pull/20158[m
[32m+[m[32m            LOCK(cs_main);[m
[32m+[m[32m            assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));[m
[32m+[m[32m            tip = chainman().ActiveChain().Tip();[m
[32m+[m[32m        }[m
         return tip ? tip->GetBlockHash() : Params().GenesisBlock().GetHash();[m
     }[m
     int64_t getLastBlockTime() override[m
     {[m
         LOCK(::cs_main);[m
[31m-        assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));[m
[31m-        if (m_context->chainman->ActiveChain().Tip()) {[m
[31m-            return m_context->chainman->ActiveChain().Tip()->GetBlockTime();[m
[32m+[m[32m        assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));[m
[32m+[m[32m        if (chainman().ActiveChain().Tip()) {[m
[32m+[m[32m            return chainman().ActiveChain().Tip()->GetBlockTime();[m
         }[m
         return Params().GenesisBlock().GetBlockTime(); // Genesis block's time of current network[m
     }[m
[36m@@ -206,14 +215,22 @@[m [mpublic:[m
         const CBlockIndex* tip;[m
         {[m
             LOCK(::cs_main);[m
[31m-            assert(std::addressof(::ChainActive()) == std::addressof(m_context->chainman->ActiveChain()));[m
[31m-            tip = m_context->chainman->ActiveChain().Tip();[m
[32m+[m[32m            assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));[m
[32m+[m[32m            tip = chainman().ActiveChain().Tip();[m
         }[m
         return GuessVerificationProgress(Params().TxData(), tip);[m
     }[m
     bool isInitialBlockDownload() override {[m
[31m-        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));[m
[31m-        return m_context->chainman->ActiveChainstate().IsInitialBlockDownload();[m
[32m+[m[32m        const CChainState* active_chainstate;[m
[32m+[m[32m        {[m
[32m+[m[32m            // TODO: Temporary scope to check correctness of refactored code.[m
[32m+[m[32m            // Should be removed manually after merge of[m
[32m+[m[32m            // https://github.com/bitcoin/bitcoin/pull/20158[m
[32m+[m[32m            LOCK(::cs_main);[m
[32m+[m[32m            active_chainstate = &m_context->chainman->ActiveChainstate();[m
[32m+[m[32m            assert(std::addressof(::ChainstateActive()) == std::addressof(*active_chainstate));[m
[32m+[m[32m        }[m
[32m+[m[32m        return active_chainstate->IsInitialBlockDownload();[m
     }[m
     bool getReindex() override { return ::fReindex; }[m
     bool getImporting() override { return ::fImporting; }[m
[36m@@ -239,8 +256,8 @@[m [mpublic:[m
     bool getUnspentOutput(const COutPoint& output, Coin& coin) override[m
     {[m
         LOCK(::cs_main);[m
[31m-        assert(std::addressof(::ChainstateActive()) == std::addressof(m_context->chainman->ActiveChainstate()));[m
[31m-        return m_context->chainman->ActiveChainstate().CoinsTip().GetCoin(output, coin);[m
[32m+[m[32m        assert(std::addressof(::ChainstateActive()) == std::addressof(chainman().ActiveChainstate()));[m
[32m+[m[32m        return chainman().ActiveChainstate().CoinsTip().GetCoin(output, coin);[m
     }[m
     WalletClient& walletClient() override[m
     {[m
[36m@@ -414,6 +431,8 @@[m [mpublic:[m
 [m
 class ChainImpl : public Chain[m
 {[m
[32m+[m[32mprivate:[m
[32m+[m[32m    ChainstateManager& chainman() { return *Assert(m_node.chainman); }[m
 public:[m
     explicit ChainImpl(NodeContext& node) : m_node(node) {}[m
     std::optional<int> getHeight() override[m
[36m@@ -450,8 +469,8 @@[m [mpublic:[m
     bool checkFinalTx(const CTransaction& tx) override[m
     {[m
         LOCK(cs_main);[m
[31m-        assert(std::addressof(::ChainActive()) == std::addressof(m_node.chainman->ActiveChain()));[m
[31m-        return CheckFinalTx(m_node.chainman->ActiveChain().Tip(), tx);[m
[32m+[m[32m        assert(std::addressof(::ChainActive()) == std::addressof(chainman().ActiveChain()));[m
[32m+[m[32m        return CheckFinalTx(chainman().ActiveChain().Tip(), tx);[m
     }[m
     std::optional<int> findLocatorFork(const CBlockLocator& locator) override[m
     {[m
[36m@@ -516,8 +535,8 @@[m [mpublic:[m
     double guessVerificationProgress(const uint256& block_hash) override[m
     {[m
         LOCK(cs_main);[m
[31m-        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));[m
[31m-        return GuessVerificationProgress(Params().TxData(), m_node.chainman->m_blockman.LookupBlockIndex(block_hash));[m
[32m+[m[32m        assert(std::addressof(g_chainman.m_blockman) == std::addressof(chainman().m_blockman));[m
[32m+[m[32m        return GuessVerificationProgress(Params().TxData(), chainman().m_blockman.LookupBlockIndex(block_hash));[m
     }[m
     bool hasBlocks(const uint256& block_hash, int min_height, std::optional<int> max_height) override[m
     {[m
[36m@@ -529,8 +548,8 @@[m [mpublic:[m
         // used to limit the range, and passing min_height that's too low or[m
         // max_height that's too high will not crash or change the result.[m
         LOCK(::cs_main);[m
[31m-        assert(std::addressof(g_chainman) == std::addressof(*m_node.chainman));[m
[31m-        if (CBlockIndex* block = m_node.chainman->m_blockman.LookupBlockIndex(block_hash)) {[m
[32m+[m[32m        assert(std::addressof(g_chainman.m_blockman) == std::addressof(chainman().m_blockman));[m
[32m+[m[32m        if (CBlockIndex* block = chainman().m_blockman.LookupBlockIndex(block_hash)) {[m
             if (max_height && block->nHeight >= *max_height) block = block->GetAncestor(*max_height);[m
             for (; block->nStatus & BLOCK_HAVE_DATA; block = block->pprev) {[m
                 // Check pprev to not segfault if min_height is too low[m
[36m@@ -621,8 +640,16 @@[m [mpublic:[m
     }[m
     bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }[m
     bool isInitialBlockDownload() override {[m
[31m-        assert(std::addressof(::ChainstateActive()) == std::addressof(m_node.chainman->ActiveChainstate()));[m
[31m-        return m_node.chainman->ActiveChainstate().IsInitialBlockDownload();[m
[32m+[m[32m        const CChainState* active_chainstate;[m
[32m+[m[32m        {[m
[32m+[m[32m            // TODO: Temporary scope to check correctness of refactored code.[m
[32m+[m[32m            // Should be removed manually after merge of[m
[32m+[m[32m            // https://github.com/bitcoin/bitcoin/pull/20158[m
[32m+[m[32m            LOCK(::cs_main);[m
[32m+[m[32m            active_chainstate = &chainman().ActiveChainstate();[m
[32m+[m[32m            assert(std::addressof(::ChainstateActive()) == std::addressof(*active_chainstate));[m
[32m+[m[32m        }[m
[32m+[m[32m        return active_chainstate->IsInitialBlockDownload();[m
     }[m
     bool shutdownRequested() override { return ShutdownRequested(); }[m
     int64_t getAdjustedTime() override { return GetAdjustedTime(); }[m
[33mdiff --git a/src/node/transaction.cpp b/src/node/transaction.cpp[m
[33mindex f47e85ace..691b2791d 100644[m
[33m--- a/src/node/transaction.cpp[m
[33m+++ b/src/node/transaction.cpp[m
[36m@@ -38,6 +38,7 @@[m [mTransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t[m
     bool callback_set = false;[m
 [m
     { // cs_main scope[m
[32m+[m[32m    assert(node.chainman);[m
     LOCK(cs_main);[m
     assert(std::addressof(::ChainstateActive()) == std::addressof(node.chainman->ActiveChainstate()));[m
     // If the transaction is already confirmed in the chain, don't do anything[m
[33mdiff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp[m
[33mindex fd780ba78..72ad0df19 100644[m
[33m--- a/src/rpc/mining.cpp[m
[33m+++ b/src/rpc/mining.cpp[m
[36m@@ -150,7 +150,7 @@[m [mstatic UniValue generateBlocks(ChainstateManager& chainman, const CTxMemPool& me[m
     UniValue blockHashes(UniValue::VARR);[m
     while (nHeight < nHeightEnd && !ShutdownRequested())[m
     {[m
[31m-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), coinbase_script));[m
[32m+[m[32m        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(chainman.ActiveChainstate(), mempool, Params()).CreateNewBlock(coinbase_script));[m
         if (!pblocktemplate.get())[m
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");[m
         CBlock *pblock = &pblocktemplate->block;[m
[36m@@ -358,7 +358,7 @@[m [mstatic RPCHelpMan generateblock()[m
         LOCK(cs_main);[m
 [m
         CTxMemPool empty_mempool;[m
[31m-        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(empty_mempool, chainparams).CreateNewBlock(::ChainstateActive(), coinbase_script));[m
[32m+[m[32m        std::unique_ptr<CBlockTemplate> blocktemplate(BlockAssembler(::ChainstateActive(), empty_mempool, chainparams).CreateNewBlock(coinbase_script));[m
         if (!blocktemplate) {[m
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");[m
         }[m
[36m@@ -748,7 +748,7 @@[m [mstatic RPCHelpMan getblocktemplate()[m
 [m
         // Create new block[m
         CScript scriptDummy = CScript() << OP_TRUE;[m
[31m-        pblocktemplate = BlockAssembler(mempool, Params()).CreateNewBlock(::ChainstateActive(), scriptDummy);[m
[32m+[m[32m        pblocktemplate = BlockAssembler(::ChainstateActive(), mempool, Params()).CreateNewBlock(scriptDummy);[m
         if (!pblocktemplate)[m
             throw JSONRPCError(RPC_OUT_OF_MEMORY, "Out of memory");[m
 [m
[33mdiff --git a/src/test/blockfilter_index_tests.cpp b/src/test/blockfilter_index_tests.cpp[m
[33mindex 04da10715..9903ba75c 100644[m
[33m--- a/src/test/blockfilter_index_tests.cpp[m
[33m+++ b/src/test/blockfilter_index_tests.cpp[m
[36m@@ -62,7 +62,7 @@[m [mCBlock BuildChainTestingSetup::CreateBlock(const CBlockIndex* prev,[m
     const CScript& scriptPubKey)[m
 {[m
     const CChainParams& chainparams = Params();[m
[31m-    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(*m_node.mempool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);[m
[32m+[m[32m    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(::ChainstateActive(), *m_node.mempool, chainparams).CreateNewBlock(scriptPubKey);[m
     CBlock& block = pblocktemplate->block;[m
     block.hashPrevBlock = prev->GetBlockHash();[m
     block.nTime = prev->nTime + 1;[m
[33mdiff --git a/src/test/miner_tests.cpp b/src/test/miner_tests.cpp[m
[33mindex 9acd17c46..9ba004cc3 100644[m
[33m--- a/src/test/miner_tests.cpp[m
[33m+++ b/src/test/miner_tests.cpp[m
[36m@@ -44,7 +44,7 @@[m [mBlockAssembler MinerTestingSetup::AssemblerForTest(const CChainParams& params)[m
 [m
     options.nBlockMaxWeight = MAX_BLOCK_WEIGHT;[m
     options.blockMinFeeRate = blockMinFeeRate;[m
[31m-    return BlockAssembler(*m_node.mempool, params, options);[m
[32m+[m[32m    return BlockAssembler(::ChainstateActive(), *m_node.mempool, params, options);[m
 }[m
 [m
 constexpr static struct {[m
[36m@@ -122,7 +122,7 @@[m [mvoid MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co[m
     uint256 hashHighFeeTx = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(50000).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));[m
 [m
[31m-    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);[m
[32m+[m[32m    std::unique_ptr<CBlockTemplate> pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);[m
     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 4U);[m
     BOOST_CHECK(pblocktemplate->block.vtx[1]->GetHash() == hashParentTx);[m
     BOOST_CHECK(pblocktemplate->block.vtx[2]->GetHash() == hashHighFeeTx);[m
[36m@@ -143,7 +143,7 @@[m [mvoid MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co[m
     tx.vout[0].nValue = 5000000000LL - 1000 - 50000 - feeToUse;[m
     uint256 hashLowFeeTx = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(feeToUse).FromTx(tx));[m
[31m-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);[m
[32m+[m[32m    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);[m
     // Verify that the free tx and the low fee tx didn't get selected[m
     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {[m
         BOOST_CHECK(pblocktemplate->block.vtx[i]->GetHash() != hashFreeTx);[m
[36m@@ -157,7 +157,7 @@[m [mvoid MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co[m
     tx.vout[0].nValue -= 2; // Now we should be just over the min relay fee[m
     hashLowFeeTx = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(feeToUse+2).FromTx(tx));[m
[31m-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);[m
[32m+[m[32m    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);[m
     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 6U);[m
     BOOST_CHECK(pblocktemplate->block.vtx[4]->GetHash() == hashFreeTx);[m
     BOOST_CHECK(pblocktemplate->block.vtx[5]->GetHash() == hashLowFeeTx);[m
[36m@@ -179,7 +179,7 @@[m [mvoid MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co[m
     tx.vout[0].nValue = 5000000000LL - 100000000 - feeToUse;[m
     uint256 hashLowFeeTx2 = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(feeToUse).SpendsCoinbase(false).FromTx(tx));[m
[31m-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);[m
[32m+[m[32m    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);[m
 [m
     // Verify that this tx isn't selected.[m
     for (size_t i=0; i<pblocktemplate->block.vtx.size(); ++i) {[m
[36m@@ -192,7 +192,7 @@[m [mvoid MinerTestingSetup::TestPackageSelection(const CChainParams& chainparams, co[m
     tx.vin[0].prevout.n = 1;[m
     tx.vout[0].nValue = 100000000 - 10000; // 10k satoshi fee[m
     m_node.mempool->addUnchecked(entry.Fee(10000).FromTx(tx));[m
[31m-    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey);[m
[32m+[m[32m    pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey);[m
     BOOST_REQUIRE_EQUAL(pblocktemplate->block.vtx.size(), 9U);[m
     BOOST_CHECK(pblocktemplate->block.vtx[8]->GetHash() == hashLowFeeTx2);[m
 }[m
[36m@@ -215,7 +215,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     fCheckpointsEnabled = false;[m
 [m
     // Simple block creation, nothing special yet:[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
 [m
     // We can't make transactions until we have inputs[m
     // Therefore, load 110 blocks :)[m
[36m@@ -252,7 +252,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     LOCK(m_node.mempool->cs);[m
 [m
     // Just to make sure we can still make simple blocks[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
 [m
     const CAmount BLOCKSUBSIDY = 50*COIN;[m
     const CAmount LOWFEE = CENT;[m
[36m@@ -277,7 +277,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
         tx.vin[0].prevout.hash = hash;[m
     }[m
 [m
[31m-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason("bad-blk-sigops"));[m
[32m+[m[32m    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason("bad-blk-sigops"));[m
     m_node.mempool->clear();[m
 [m
     tx.vin[0].prevout.hash = txFirst[0]->GetHash();[m
[36m@@ -291,7 +291,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));[m
         tx.vin[0].prevout.hash = hash;[m
     }[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
     m_node.mempool->clear();[m
 [m
     // block size > limit[m
[36m@@ -311,13 +311,13 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
         m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));[m
         tx.vin[0].prevout.hash = hash;[m
     }[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
     m_node.mempool->clear();[m
 [m
     // orphan in *m_node.mempool, template creation fails[m
     hash = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).FromTx(tx));[m
[31m-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason("bad-txns-inputs-missingorspent"));[m
[32m+[m[32m    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason("bad-txns-inputs-missingorspent"));[m
     m_node.mempool->clear();[m
 [m
     // child with higher feerate than parent[m
[36m@@ -334,7 +334,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     tx.vout[0].nValue = tx.vout[0].nValue+BLOCKSUBSIDY-HIGHERFEE; //First txn output + fresh coinbase - new txn fee[m
     hash = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(HIGHERFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
     m_node.mempool->clear();[m
 [m
     // coinbase in *m_node.mempool, template creation fails[m
[36m@@ -346,7 +346,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     // give it a fee so it'll get mined[m
     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));[m
     // Should throw bad-cb-multiple[m
[31m-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason("bad-cb-multiple"));[m
[32m+[m[32m    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason("bad-cb-multiple"));[m
     m_node.mempool->clear();[m
 [m
     // double spend txn pair in *m_node.mempool, template creation fails[m
[36m@@ -359,7 +359,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     tx.vout[0].scriptPubKey = CScript() << OP_2;[m
     hash = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));[m
[31m-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason("bad-txns-inputs-missingorspent"));[m
[32m+[m[32m    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason("bad-txns-inputs-missingorspent"));[m
     m_node.mempool->clear();[m
 [m
     // subsidy changing[m
[36m@@ -375,7 +375,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
         next->BuildSkip();[m
         ::ChainActive().SetTip(next);[m
     }[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
     // Extend to a 210000-long block chain.[m
     while (::ChainActive().Tip()->nHeight < 210000) {[m
         CBlockIndex* prev = ::ChainActive().Tip();[m
[36m@@ -387,7 +387,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
         next->BuildSkip();[m
         ::ChainActive().SetTip(next);[m
     }[m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
 [m
     // invalid p2sh txn in *m_node.mempool, template creation fails[m
     tx.vin[0].prevout.hash = txFirst[0]->GetHash();[m
[36m@@ -404,7 +404,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     hash = tx.GetHash();[m
     m_node.mempool->addUnchecked(entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(false).FromTx(tx));[m
     // Should throw block-validation-failed[m
[31m-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey), std::runtime_error, HasReason("block-validation-failed"));[m
[32m+[m[32m    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason("block-validation-failed"));[m
     m_node.mempool->clear();[m
 [m
     // Delete the dummy blocks again.[m
[36m@@ -492,7 +492,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     tx.vin[0].nSequence = CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG | 1;[m
     BOOST_CHECK(!TestSequenceLocks(CTransaction(tx), flags)); // Sequence locks fail[m
 [m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
 [m
     // None of the of the absolute height/time locked tx should have made[m
     // it into the template because we still check IsFinalTx in CreateNewBlock,[m
[36m@@ -505,7 +505,7 @@[m [mBOOST_AUTO_TEST_CASE(CreateNewBlock_validity)[m
     ::ChainActive().Tip()->nHeight++;[m
     SetMockTime(::ChainActive().Tip()->GetMedianTimePast() + 1);[m
 [m
[31m-    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey));[m
[32m+[m[32m    BOOST_CHECK(pblocktemplate = AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey));[m
     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 5U);[m
 [m
     ::ChainActive().Tip()->nHeight--;[m
[33mdiff --git a/src/test/util/mining.cpp b/src/test/util/mining.cpp[m
[33mindex ba1edba0a..3fc3329da 100644[m
[33m--- a/src/test/util/mining.cpp[m
[33m+++ b/src/test/util/mining.cpp[m
[36m@@ -41,8 +41,8 @@[m [mCTxIn MineBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)[m
 std::shared_ptr<CBlock> PrepareBlock(const NodeContext& node, const CScript& coinbase_scriptPubKey)[m
 {[m
     auto block = std::make_shared<CBlock>([m
[31m-        BlockAssembler{*Assert(node.mempool), Params()}[m
[31m-            .CreateNewBlock(::ChainstateActive(), coinbase_scriptPubKey)[m
[32m+[m[32m        BlockAssembler{::ChainstateActive(), *Assert(node.mempool), Params()}[m
[32m+[m[32m            .CreateNewBlock(coinbase_scriptPubKey)[m
             ->block);[m
 [m
     LOCK(cs_main);[m
[33mdiff --git a/src/test/util/setup_common.cpp b/src/test/util/setup_common.cpp[m
[33mindex f866c2a1f..ff19a1feb 100644[m
[33m--- a/src/test/util/setup_common.cpp[m
[33m+++ b/src/test/util/setup_common.cpp[m
[36m@@ -244,7 +244,7 @@[m [mCBlock TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransa[m
 {[m
     const CChainParams& chainparams = Params();[m
     CTxMemPool empty_pool;[m
[31m-    CBlock block = BlockAssembler(empty_pool, chainparams).CreateNewBlock(::ChainstateActive(), scriptPubKey)->block;[m
[32m+[m[32m    CBlock block = BlockAssembler(::ChainstateActive(), empty_pool, chainparams).CreateNewBlock(scriptPubKey)->block;[m
 [m
     Assert(block.vtx.size() == 1);[m
     for (const CMutableTransaction& tx : txns) {[m
[33mdiff --git a/src/test/validation_block_tests.cpp b/src/test/validation_block_tests.cpp[m
[33mindex f3fc83078..552be0a2d 100644[m
[33m--- a/src/test/validation_block_tests.cpp[m
[33m+++ b/src/test/validation_block_tests.cpp[m
[36m@@ -63,7 +63,7 @@[m [mstd::shared_ptr<CBlock> MinerTestingSetup::Block(const uint256& prev_hash)[m
     static int i = 0;[m
     static uint64_t time = Params().GenesisBlock().nTime;[m
 [m
[31m-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), CScript{} << i++ << OP_TRUE);[m
[32m+[m[32m    auto ptemplate = BlockAssembler(m_node.chainman->ActiveChainstate(), *m_node.mempool, Params()).CreateNewBlock(CScript{} << i++ << OP_TRUE);[m
     auto pblock = std::make_shared<CBlock>(ptemplate->block);[m
     pblock->hashPrevBlock = prev_hash;[m
     pblock->nTime = ++time;[m
[36m@@ -325,7 +325,7 @@[m [mBOOST_AUTO_TEST_CASE(witness_commitment_index)[m
 {[m
     CScript pubKey;[m
     pubKey << 1 << OP_TRUE;[m
[31m-    auto ptemplate = BlockAssembler(*m_node.mempool, Params()).CreateNewBlock(::ChainstateActive(), pubKey);[m
[32m+[m[32m    auto ptemplate = BlockAssembler(m_node.chainman->ActiveChainstate(), *m_node.mempool, Params()).CreateNewBlock(pubKey);[m
     CBlock pblock = ptemplate->block;[m
 [m
     CTxOut witness;[m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex d1b9efe7b..b5c19971b 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -169,7 +169,7 @@[m [mnamespace {[m
     std::set<int> setDirtyFileInfo;[m
 } // anon namespace[m
 [m
[31m-CBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash)[m
[32m+[m[32mCBlockIndex* BlockManager::LookupBlockIndex(const uint256& hash) const[m
 {[m
     AssertLockHeld(cs_main);[m
     assert(std::addressof(g_chainman.BlockIndex()) == std::addressof(m_block_index));[m
[33mdiff --git a/src/validation.h b/src/validation.h[m
[33mindex 2ff5f4ac8..21e63947f 100644[m
[33m--- a/src/validation.h[m
[33m+++ b/src/validation.h[m
[36m@@ -457,7 +457,7 @@[m [mpublic:[m
         const CChainParams& chainparams,[m
         CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[31m-    CBlockIndex* LookupBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m[32m    CBlockIndex* LookupBlockIndex(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
     /** Find the last common block between the parameter chain and a locator. */[m
     CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m