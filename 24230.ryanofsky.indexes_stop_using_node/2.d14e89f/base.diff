[33mdiff --git a/src/Makefile.am b/src/Makefile.am[m
[33mindex e940736b71..2d3446a465 100644[m
[33m--- a/src/Makefile.am[m
[33m+++ b/src/Makefile.am[m
[36m@@ -183,6 +183,7 @@[m [mBITCOIN_CORE_H = \[m
   netmessagemaker.h \[m
   node/blockstorage.h \[m
   node/caches.h \[m
[32m+[m[32m  node/chain.h \[m
   node/chainstate.h \[m
   node/coin.h \[m
   node/coinstats.h \[m
[36m@@ -353,6 +354,7 @@[m [mlibbitcoin_node_a_SOURCES = \[m
   net_processing.cpp \[m
   node/blockstorage.cpp \[m
   node/caches.cpp \[m
[32m+[m[32m  node/chain.cpp \[m
   node/chainstate.cpp \[m
   node/coin.cpp \[m
   node/coinstats.cpp \[m
[36m@@ -805,6 +807,7 @@[m [mbitcoin_chainstate_SOURCES = \[m
   logging.cpp \[m
   netaddress.cpp \[m
   node/blockstorage.cpp \[m
[32m+[m[32m  node/chain.cpp \[m
   node/chainstate.cpp \[m
   node/coinstats.cpp \[m
   node/ui_interface.cpp \[m
[33mdiff --git a/src/index/base.cpp b/src/index/base.cpp[m
[33mindex 8fe30f8960..66c107af3c 100644[m
[33m--- a/src/index/base.cpp[m
[33m+++ b/src/index/base.cpp[m
[36m@@ -4,16 +4,22 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/base.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
[32m+[m[32m#include <interfaces/handler.h>[m
 #include <node/blockstorage.h>[m
[32m+[m[32m#include <node/chain.h>[m
[32m+[m[32m#include <node/context.h>[m
 #include <node/ui_interface.h>[m
 #include <shutdown.h>[m
 #include <tinyformat.h>[m
[32m+[m[32m#include <undo.h>[m
 #include <util/syscall_sandbox.h>[m
 #include <util/thread.h>[m
 #include <util/translation.h>[m
 #include <validation.h> // For g_chainman[m
 #include <warnings.h>[m
 [m
[32m+[m[32musing interfaces::FoundBlock;[m
 using node::ReadBlockFromDisk;[m
 [m
 constexpr uint8_t DB_BEST_BLOCK{'B'};[m
[36m@@ -31,294 +37,213 @@[m [mstatic void FatalError(const char* fmt, const Args&... args)[m
     StartShutdown();[m
 }[m
 [m
[2m-BaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :[m
[2m-    CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)[m
[2m-{}[m
[31m-[m
[2m-bool BaseIndex::DB::ReadBestBlock(CBlockLocator& locator) const[m
[32m+[m[32mCBlockLocator GetLocator(interfaces::Chain& chain, const uint256& block_hash)[m
 {[m
[2m-    bool success = Read(DB_BEST_BLOCK, locator);[m
[2m-    if (!success) {[m
[2m-        locator.SetNull();[m
[31m-    }[m
[31m-    return success;[m
[31m-}[m
[31m-[m
[2m-void BaseIndex::DB::WriteBestBlock(CDBBatch& batch, const CBlockLocator& locator)[m
[2m-{[m
[2m-    batch.Write(DB_BEST_BLOCK, locator);[m
[31m-}[m
[31m-[m
[31m-BaseIndex::~BaseIndex()[m
[31m-{[m
[31m-    Interrupt();[m
[31m-    Stop();[m
[2m+[m[2m    CBlockLocator locator;[m
[32m+[m[32m    bool found = chain.findBlock(block_hash, interfaces::FoundBlock().locator(locator));[m
[32m+[m[32m    assert(found);[m
[32m+[m[32m    assert(!locator.IsNull());[m
[32m+[m[32m    return locator;[m
 }[m
 [m
[31m-bool BaseIndex::Init()[m
[32m+[m[32mclass BaseIndexNotifications : public interfaces::Chain::Notifications[m
 {[m
[2m-    CBlockLocator locator;[m
[2m-    if (!GetDB().ReadBestBlock(locator)) {[m
[2m-        locator.SetNull();[m
[32m+[m[32mpublic:[m
[32m+[m[32m    BaseIndexNotifications(BaseIndex& index) : m_index(index) {}[m
[32m+[m[32m    void blockConnected(const interfaces::BlockInfo& block) override;[m
[32m+[m[32m    void blockDisconnected(const interfaces::BlockInfo& block) override;[m
[32m+[m[32m    void chainStateFlushed(const CBlockLocator& locator) override;[m
[32m+[m[32m    std::optional<interfaces::BlockKey> getBest()[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(m_index.m_mutex);[m
[32m+[m[32m        return m_index.m_best_block;[m
[32m+[m[32m    }[m
[32m+[m[32m    void setBest(const interfaces::BlockKey& block)[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(m_index.m_mutex);[m
[32m+[m[32m        assert(!block.hash.IsNull());[m
[32m+[m[32m        assert(block.height >= 0);[m
[32m+[m[32m        m_index.m_best_block = block;[m
     }[m
 [m
[31m-    LOCK(cs_main);[m
[31m-    CChain& active_chain = m_chainstate->m_chain;[m
[31m-    if (locator.IsNull()) {[m
[31m-        m_best_block_index = nullptr;[m
[31m-    } else {[m
[31m-        m_best_block_index = m_chainstate->FindForkInGlobalIndex(locator);[m
[32m+[m[32m    BaseIndex& m_index;[m
[32m+[m[32m    std::optional<bool> m_init_result;[m
[32m+[m[32m    int64_t m_last_log_time = 0;[m
[32m+[m[32m    int64_t m_last_locator_write_time = 0;[m
[32m+[m[32m    //! As blocks are disconnected, index is updated but not committed to until[m
[32m+[m[32m    //! the next flush or block connection. start/end variables record the first[m
[32m+[m[32m    //! and last disconnected blocks as an inclusive range. If start is set and[m
[32m+[m[32m    //! end is null it means an error has occurred, and the index will stop[m
[32m+[m[32m    //! trying to rewind and handle the error on the next new block or flush.[m
[32m+[m[32m    std::optional<interfaces::BlockKey> m_rewind_start;[m
[32m+[m[32m    std::optional<interfaces::BlockKey> m_rewind_end;[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32mvoid BaseIndexNotifications::blockConnected(const interfaces::BlockInfo& block)[m
[32m+[m[32m{[m
[32m+[m[32m    if (!block.error.empty()) {[m
[32m+[m[32m        FatalError("%s", block.error);[m
[32m+[m[32m        return m_index.Interrupt();[m
     }[m
[31m-    m_synced = m_best_block_index.load() == active_chain.Tip();[m
[31m-    if (!m_synced) {[m
[2m-        bool prune_violation = false;[m
[31m-        if (!m_best_block_index) {[m
[31m-            // index is not built yet[m
[2m-            // make sure we have all block data back to the genesis[m
[2m-            const CBlockIndex* block = active_chain.Tip();[m
[2m-            while (block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA)) {[m
[2m-                block = block->pprev;[m
[2m-            }[m
[2m-            prune_violation = block != active_chain.Genesis();[m
[32m+[m[32m    if (!m_index.m_synced && !block.data) {[m
[32m+[m[32m        // Before sync, attachChain will send an initial blockConnected event[m
[32m+[m[32m        // without any block data, indicating the starting block (based on the[m
[32m+[m[32m        // index locator) where the index was last synced. If the index is[m
[32m+[m[32m        // already synced at this point, block.chain_tip will be true, and[m
[32m+[m[32m        // m_synced can latch to true. Otherwise, more blockConnected events[m
[32m+[m[32m        // will be sent with block data, followed by a final blockConnected[m
[32m+[m[32m        // event without block data, to finish the sync and update[m
[32m+[m[32m        // m_best_block and m_synced.[m
[32m+[m[32m        if (block.height >= 0) {[m
[32m+[m[32m            setBest({block.hash, block.height});[m
[32m+[m[32m        } else {[m
[32m+[m[32m            assert(!getBest());[m
         }[m
[2m-        // in case the index has a best block set and is not fully synced[m
[2m-        // check if we have the required blocks to continue building the index[m
[2m-        else {[m
[31m-            const CBlockIndex* block_to_test = m_best_block_index.load();[m
[2m-            if (!active_chain.Contains(block_to_test)) {[m
[2m-                // if the bestblock is not part of the mainchain, find the fork[m
[2m-                // and make sure we have all data down to the fork[m
[2m-                block_to_test = active_chain.FindFork(block_to_test);[m
[2m-            }[m
[2m-            const CBlockIndex* block = active_chain.Tip();[m
[2m-            prune_violation = true;[m
[2m-            // check backwards from the tip if we have all block data until we reach the indexes bestblock[m
[2m-            while (block_to_test && block && (block->nStatus & BLOCK_HAVE_DATA)) {[m
[2m-                if (block_to_test == block) {[m
[2m-                    prune_violation = false;[m
[2m-                    break;[m
[2m-                }[m
[2m-                // block->pprev must exist at this point, since block_to_test is part of the chain[m
[2m-                // and thus must be encountered when going backwards from the tip[m
[2m-                assert(block->pprev);[m
[2m-                block = block->pprev;[m
[32m+[m[32m        if (block.chain_tip) {[m
[32m+[m[32m            m_index.m_synced = true;[m
[32m+[m[32m            if (block.height >= 0) {[m
[32m+[m[32m                LogPrintf("%s is enabled at height %d\n", m_index.GetName(), block.height);[m
[32m+[m[32m            } else {[m
[32m+[m[32m                LogPrintf("%s is enabled\n", m_index.GetName());[m
             }[m
         }[m
[31m-        if (prune_violation) {[m
[31m-            return InitError(strprintf(Untranslated("%s best block of the index goes beyond pruned data. Please disable the index or reindex (which will download the whole blockchain again)"), GetName()));[m
[32m+[m[32m        if (!m_init_result) {[m
[32m+[m[32m            m_init_result = m_index.CustomInit(block.height >= 0 ? std::make_optional(interfaces::BlockKey{block.hash, block.height}) : std::nullopt);[m
         }[m
     }[m
[31m-    return true;[m
[31m-}[m
[31m-[m
[31m-static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev, CChain& chain) EXCLUSIVE_LOCKS_REQUIRED(cs_main)[m
[31m-{[m
[31m-    AssertLockHeld(cs_main);[m
 [m
[31m-    if (!pindex_prev) {[m
[31m-        return chain.Genesis();[m
[32m+[m[32m    if (!block.data) return;[m
[32m+[m
[32m+[m[32m    bool success = !m_rewind_start || m_rewind_end;[m
[32m+[m[32m    if (m_rewind_start && success) {[m
[32m+[m[32m        auto best_block = getBest();[m
[32m+[m[32m        // Assert m_best_block is null or is parent of new connected block, or is[m
[32m+[m[32m        // descendant of parent of new connected block.[m
[32m+[m[32m        if (best_block && best_block->hash != *block.prev_hash) {[m
[32m+[m[32m            uint256 best_ancestor_hash;[m
[32m+[m[32m            assert(m_index.m_chain->findAncestorByHeight(best_block->hash, block.height - 1, FoundBlock().hash(best_ancestor_hash)));[m
[32m+[m[32m            assert(best_ancestor_hash == *block.prev_hash);[m
[32m+[m[32m        }[m
[32m+[m[32m        setBest({*block.prev_hash, block.height-1});[m
[32m+[m[32m        chainStateFlushed(GetLocator(*m_index.m_chain, *block.prev_hash));[m
[32m+[m[32m        success = getBest()->hash == *block.prev_hash;[m
     }[m
[31m-[m
[31m-    const CBlockIndex* pindex = chain.Next(pindex_prev);[m
[31m-    if (pindex) {[m
[31m-        return pindex;[m
[32m+[m[32m    if (!success) {[m
[32m+[m[32m        FatalError("%s: Failed to rewind index %s to a previous chain tip",[m
[32m+[m[32m                   __func__, m_index.GetName());[m
[32m+[m[32m        return m_index.Interrupt();[m
     }[m
 [m
[31m-    return chain.Next(chain.FindFork(pindex_prev));[m
[31m-}[m
[31m-[m
[31m-void BaseIndex::ThreadSync()[m
[31m-{[m
[31m-    SetSyscallSandboxPolicy(SyscallSandboxPolicy::TX_INDEX);[m
[31m-    const CBlockIndex* pindex = m_best_block_index.load();[m
[31m-    if (!m_synced) {[m
[2m-        auto& consensus_params = Params().GetConsensus();[m
[31m-[m
[31m-        int64_t last_log_time = 0;[m
[31m-        int64_t last_locator_write_time = 0;[m
[31m-        while (true) {[m
[31m-            if (m_interrupt) {[m
[31m-                m_best_block_index = pindex;[m
[31m-                // No need to handle errors in Commit. If it fails, the error will be already be[m
[31m-                // logged. The best way to recover is to continue, as index cannot be corrupted by[m
[31m-                // a missed commit to disk for an advanced index state.[m
[31m-                Commit();[m
[31m-                return;[m
[31m-            }[m
[31m-[m
[31m-            {[m
[31m-                LOCK(cs_main);[m
[31m-                const CBlockIndex* pindex_next = NextSyncBlock(pindex, m_chainstate->m_chain);[m
[31m-                if (!pindex_next) {[m
[31m-                    m_best_block_index = pindex;[m
[31m-                    m_synced = true;[m
[31m-                    // No need to handle errors in Commit. See rationale above.[m
[31m-                    Commit();[m
[31m-                    break;[m
[31m-                }[m
[31m-                if (pindex_next->pprev != pindex && !Rewind(pindex, pindex_next->pprev)) {[m
[31m-                    FatalError("%s: Failed to rewind index %s to a previous chain tip",[m
[31m-                               __func__, GetName());[m
[31m-                    return;[m
[31m-                }[m
[31m-                pindex = pindex_next;[m
[31m-            }[m
[31m-[m
[31m-            int64_t current_time = GetTime();[m
[31m-            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {[m
[31m-                LogPrintf("Syncing %s with block chain from height %d\n",[m
[31m-                          GetName(), pindex->nHeight);[m
[31m-                last_log_time = current_time;[m
[31m-            }[m
[31m-[m
[31m-            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {[m
[31m-                m_best_block_index = pindex;[m
[31m-                last_locator_write_time = current_time;[m
[31m-                // No need to handle errors in Commit. See rationale above.[m
[31m-                Commit();[m
[31m-            }[m
[31m-[m
[31m-            CBlock block;[m
[31m-            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {[m
[31m-                FatalError("%s: Failed to read block %s from disk",[m
[31m-                           __func__, pindex->GetBlockHash().ToString());[m
[31m-                return;[m
[31m-            }[m
[31m-            if (!WriteBlock(block, pindex)) {[m
[31m-                FatalError("%s: Failed to write block %s to index database",[m
[31m-                           __func__, pindex->GetBlockHash().ToString());[m
[31m-                return;[m
[31m-            }[m
[32m+[m[32m    int64_t current_time = 0;[m
[32m+[m[32m    if (!m_index.m_synced) {[m
[32m+[m[32m        current_time = GetTime();[m
[32m+[m[32m        if (m_last_log_time + SYNC_LOG_INTERVAL < current_time) {[m
[32m+[m[32m            LogPrintf("Syncing %s with block chain from height %d\n",[m
[32m+[m[32m                      m_index.GetName(), block.height);[m
[32m+[m[32m            m_last_log_time = current_time;[m
         }[m
     }[m
[31m-[m
[31m-    if (pindex) {[m
[31m-        LogPrintf("%s is enabled at height %d\n", GetName(), pindex->nHeight);[m
[31m-    } else {[m
[31m-        LogPrintf("%s is enabled\n", GetName());[m
[32m+[m[32m    if (!m_index.CustomAppend(block)) {[m
[2m+[m[2m        FatalError("%s: Failed to write block %s to index",[m
[32m+[m[32m                   __func__, block.hash.ToString());[m
[32m+[m[32m        return m_index.Interrupt();[m
[32m+[m[32m    }[m
[32m+[m[32m    // Only update m_best_block between flushes if synced. Unclear why[m
[32m+[m[32m    // best block is not updated here before sync, but this has been[m
[32m+[m[32m    // longstanding behavior since syncing was introduced in #13033 so care[m
[32m+[m[32m    // should be taken if changing m_best_block semantics.[m
[32m+[m[32m    if (m_index.m_synced) {[m
[32m+[m[32m        setBest({block.hash, block.height});[m
[32m+[m[32m    } else if (m_last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {[m
[32m+[m[32m        setBest({block.hash, block.height});[m
[32m+[m[32m        m_last_locator_write_time = current_time;[m
[32m+[m[32m        // No need to handle errors in Commit. If it fails, the error will be already be[m
[32m+[m[32m        // logged. The best way to recover is to continue, as index cannot be corrupted by[m
[32m+[m[32m        // a missed commit to disk for an advanced index state.[m
[32m+[m[32m        m_index.Commit(GetLocator(*m_index.m_chain, block.hash));[m
     }[m
 }[m
 [m
[31m-bool BaseIndex::Commit()[m
[32m+[m[32mvoid BaseIndexNotifications::blockDisconnected(const interfaces::BlockInfo& block)[m
 {[m
[31m-    CDBBatch batch(GetDB());[m
[31m-    if (!CommitInternal(batch) || !GetDB().WriteBatch(batch)) {[m
[2m-        return error("%s: Failed to commit latest %s state", __func__, GetName());[m
[32m+[m[32m    if (!block.error.empty()) {[m
[32m+[m[32m        FatalError("%s", block.error);[m
[32m+[m[32m        return m_index.Interrupt();[m
     }[m
[31m-    return true;[m
[31m-}[m
 [m
[31m-bool BaseIndex::CommitInternal(CDBBatch& batch)[m
[31m-{[m
[31m-    LOCK(cs_main);[m
[2m-    // Don't commit anything if we haven't indexed any block yet[m
[2m-    // (this could happen if init is interrupted).[m
[31m-    if (m_best_block_index == nullptr) {[m
[31m-        return false;[m
[32m+[m[32m    auto best_block = getBest();[m
[32m+[m[32m    if (!m_rewind_start || m_rewind_end) m_rewind_end = best_block;[m
[32m+[m[32m    if (!m_rewind_start) m_rewind_start = best_block;[m
[32m+[m
[32m+[m[32m    if (m_rewind_end && !m_index.CustomRemove(block)) {[m
[32m+[m[32m        m_rewind_end = std::nullopt;[m
     }[m
[31m-    GetDB().WriteBestBlock(batch, m_chainstate->m_chain.GetLocator(m_best_block_index));[m
[31m-    return true;[m
 }[m
 [m
[31m-bool BaseIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)[m
[32m+[m[32mvoid BaseIndexNotifications::chainStateFlushed(const CBlockLocator& locator)[m
 {[m
[31m-    assert(current_tip == m_best_block_index);[m
[31m-    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);[m
[31m-[m
[2m+[m[2m    // No need to handle errors in Commit. If it fails, the error will be already be logged. The[m
[2m+[m[2m    // best way to recover is to continue, as index cannot be corrupted by a missed commit to disk[m
[2m+[m[2m    // for an advanced index state.[m
     // In the case of a reorg, ensure persisted block locator is not stale.[m
     // Pruning has a minimum of 288 blocks-to-keep and getting the index[m
     // out of sync may be possible but a users fault.[m
     // In case we reorg beyond the pruned depth, ReadBlockFromDisk would[m
     // throw and lead to a graceful shutdown[m
[31m-    m_best_block_index = new_tip;[m
[31m-    if (!Commit()) {[m
[32m+[m[32m    if (!m_index.Commit(locator) && m_rewind_start) {[m
         // If commit fails, revert the best block index to avoid corruption.[m
[31m-        m_best_block_index = current_tip;[m
[31m-        return false;[m
[32m+[m[32m        setBest(*m_rewind_start);[m
     }[m
[31m-[m
[31m-    return true;[m
[32m+[m[32m    m_rewind_start = std::nullopt;[m
 }[m
 [m
[31m-void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex)[m
[31m-{[m
[31m-    if (!m_synced) {[m
[31m-        return;[m
[31m-    }[m
[2m+[m[2mBaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :[m
[2m+[m[2m    CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)[m
[2m+[m[2m{}[m
 [m
[31m-    const CBlockIndex* best_block_index = m_best_block_index.load();[m
[31m-    if (!best_block_index) {[m
[31m-        if (pindex->nHeight != 0) {[m
[31m-            FatalError("%s: First block connected is not the genesis block (height=%d)",[m
[31m-                       __func__, pindex->nHeight);[m
[31m-            return;[m
[31m-        }[m
[31m-    } else {[m
[31m-        // Ensure block connects to an ancestor of the current best block. This should be the case[m
[31m-        // most of the time, but may not be immediately after the sync thread catches up and sets[m
[31m-        // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are[m
[31m-        // in the ValidationInterface queue backlog even after the sync thread has caught up to the[m
[31m-        // new chain tip. In this unlikely event, log a warning and let the queue clear.[m
[31m-        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {[m
[31m-            LogPrintf("%s: WARNING: Block %s does not connect to an ancestor of " /* Continued */[m
[31m-                      "known best chain (tip=%s); not updating index\n",[m
[31m-                      __func__, pindex->GetBlockHash().ToString(),[m
[31m-                      best_block_index->GetBlockHash().ToString());[m
[31m-            return;[m
[31m-        }[m
[31m-        if (best_block_index != pindex->pprev && !Rewind(best_block_index, pindex->pprev)) {[m
[31m-            FatalError("%s: Failed to rewind index %s to a previous chain tip",[m
[31m-                       __func__, GetName());[m
[31m-            return;[m
[31m-        }[m
[2m+[m[2mbool BaseIndex::DB::ReadBestBlock(CBlockLocator& locator) const[m
[32m+[m[32m{[m
[2m+[m[2m    bool success = Read(DB_BEST_BLOCK, locator);[m
[2m+[m[2m    if (!success) {[m
[2m+[m[2m        locator.SetNull();[m
     }[m
[32m+[m[32m    return success;[m
[32m+[m[32m}[m
 [m
[31m-    if (WriteBlock(*block, pindex)) {[m
[31m-        m_best_block_index = pindex;[m
[31m-    } else {[m
[2m-        FatalError("%s: Failed to write block %s to index",[m
[31m-                   __func__, pindex->GetBlockHash().ToString());[m
[31m-        return;[m
[31m-    }[m
[2m+[m[2mvoid BaseIndex::DB::WriteBestBlock(CDBBatch& batch, const CBlockLocator& locator)[m
[2m+[m[2m{[m
[2m+[m[2m    batch.Write(DB_BEST_BLOCK, locator);[m
 }[m
 [m
[31m-void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)[m
[32m+[m[32mBaseIndex::BaseIndex(std::unique_ptr<interfaces::Chain> chain)[m
[32m+[m[32m    : m_chain{std::move(chain)} {}[m
[32m+[m
[32m+[m[32mBaseIndex::~BaseIndex()[m
 {[m
[31m-    if (!m_synced) {[m
[31m-        return;[m
[31m-    }[m
[32m+[m[32m    //! Assert Stop() was called before this base destructor. Notification[m
[32m+[m[32m    //! handlers call pure virtual methods like GetName(), so if they are still[m
[32m+[m[32m    //! being called at this point, they would segfault.[m
[32m+[m[32m    LOCK(m_mutex);[m
[32m+[m[32m    assert(!m_notifications);[m
[32m+[m[32m    assert(!m_handler);[m
[32m+[m[32m}[m
 [m
[31m-    const uint256& locator_tip_hash = locator.vHave.front();[m
[31m-    const CBlockIndex* locator_tip_index;[m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        locator_tip_index = m_chainstate->m_blockman.LookupBlockIndex(locator_tip_hash);[m
[32m+[m[32mbool BaseIndex::Commit(const CBlockLocator& locator)[m
[32m+[m[32m{[m
[2m+[m[2m    // Don't commit anything if we haven't indexed any block yet[m
[2m+[m[2m    // (this could happen if init is interrupted).[m
[32m+[m[32m    if (locator.IsNull()) {[m
[32m+[m[32m        return false;[m
     }[m
[31m-[m
[31m-    if (!locator_tip_index) {[m
[31m-        FatalError("%s: First block (hash=%s) in locator was not found",[m
[31m-                   __func__, locator_tip_hash.ToString());[m
[31m-        return;[m
[32m+[m[32m    CDBBatch batch(GetDB());[m
[32m+[m[32m    bool success = CustomCommit(batch);[m
[32m+[m[32m    if (success) {[m
[32m+[m[32m        GetDB().WriteBestBlock(batch, locator);[m
     }[m
[31m-[m
[31m-    // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail[m
[31m-    // immediately after the sync thread catches up and sets m_synced. Consider the case where[m
[31m-    // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue[m
[31m-    // backlog even after the sync thread has caught up to the new chain tip. In this unlikely[m
[31m-    // event, log a warning and let the queue clear.[m
[31m-    const CBlockIndex* best_block_index = m_best_block_index.load();[m
[31m-    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {[m
[31m-        LogPrintf("%s: WARNING: Locator contains block (hash=%s) not on known best " /* Continued */[m
[31m-                  "chain (tip=%s); not writing index locator\n",[m
[31m-                  __func__, locator_tip_hash.ToString(),[m
[31m-                  best_block_index->GetBlockHash().ToString());[m
[31m-        return;[m
[32m+[m[32m    if (!success || !GetDB().WriteBatch(batch)) {[m
[2m+[m[2m        return error("%s: Failed to commit latest %s state", __func__, GetName());[m
     }[m
[31m-[m
[2m-    // No need to handle errors in Commit. If it fails, the error will be already be logged. The[m
[2m-    // best way to recover is to continue, as index cannot be corrupted by a missed commit to disk[m
[2m-    // for an advanced index state.[m
[31m-    Commit();[m
[32m+[m[32m    return true;[m
 }[m
 [m
 bool BaseIndex::BlockUntilSyncedToCurrentChain() const[m
[36m@@ -329,48 +254,61 @@[m [mbool BaseIndex::BlockUntilSyncedToCurrentChain() const[m
         return false;[m
     }[m
 [m
[31m-    {[m
[32m+[m[32m    if (const auto best_block = WITH_LOCK(m_mutex, return m_best_block)) {[m
         // Skip the queue-draining stuff if we know we're caught up with[m
         // m_chain.Tip().[m
[31m-        LOCK(cs_main);[m
[31m-        const CBlockIndex* chain_tip = m_chainstate->m_chain.Tip();[m
[31m-        const CBlockIndex* best_block_index = m_best_block_index.load();[m
[31m-        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {[m
[32m+[m[32m        interfaces::BlockKey tip;[m
[32m+[m[32m        uint256 ancestor;[m
[32m+[m[32m        if (m_chain->getTip(FoundBlock().hash(tip.hash).height(tip.height)) &&[m
[32m+[m[32m            m_chain->findAncestorByHeight(best_block->hash, tip.height, FoundBlock().hash(ancestor)) &&[m
[32m+[m[32m            ancestor == tip.hash) {[m
             return true;[m
         }[m
     }[m
 [m
     LogPrintf("%s: %s is catching up on block notifications\n", __func__, GetName());[m
[31m-    SyncWithValidationInterfaceQueue();[m
[32m+[m[32m    m_chain->waitForNotifications();[m
     return true;[m
 }[m
 [m
 void BaseIndex::Interrupt()[m
 {[m
[31m-    m_interrupt();[m
[32m+[m[32m    LOCK(m_mutex);[m
[32m+[m[32m    if (m_handler) m_handler->interrupt();[m
[32m+[m[32m    m_notifications.reset();[m
 }[m
 [m
[31m-bool BaseIndex::Start(CChainState& active_chainstate)[m
[32m+[m[32mbool BaseIndex::Start()[m
 {[m
[31m-    m_chainstate = &active_chainstate;[m
[31m-    // Need to register this ValidationInterface before running Init(), so that[m
[31m-    // callbacks are not missed if Init sets m_synced to true.[m
[31m-    RegisterValidationInterface(this);[m
[31m-    if (!Init()) {[m
[31m-        return false;[m
[2m+[m[2m    CBlockLocator locator;[m
[2m+[m[2m    if (!GetDB().ReadBestBlock(locator)) {[m
[2m+[m[2m        locator.SetNull();[m
     }[m
 [m
[31m-    m_thread_sync = std::thread(&util::TraceThread, GetName(), [this] { ThreadSync(); });[m
[31m-    return true;[m
[32m+[m[32m    auto options = CustomOptions();[m
[32m+[m[32m    options.thread_name = GetName();[m
[32m+[m[32m    auto notifications = std::make_shared<BaseIndexNotifications>(*this);[m
[32m+[m[32m    auto handler = m_chain->attachChain(notifications, locator, options);[m
[32m+[m[32m    if (!handler) {[m
[32m+[m[32m        return InitError(strprintf(Untranslated("%s best block of the index goes beyond pruned data. Please disable the index or reindex (which will download the whole blockchain again)"), GetName()));[m
[32m+[m[32m    } else {[m
[32m+[m[32m        LOCK(m_mutex);[m
[32m+[m[32m        m_notifications = std::move(notifications);[m
[32m+[m[32m        m_handler = std::move(handler);[m
[32m+[m[32m        assert(m_notifications->m_init_result.has_value());[m
[32m+[m[32m        return m_notifications->m_init_result.value();[m
[32m+[m[32m    }[m
 }[m
 [m
 void BaseIndex::Stop()[m
 {[m
[31m-    UnregisterValidationInterface(this);[m
[31m-[m
[31m-    if (m_thread_sync.joinable()) {[m
[31m-        m_thread_sync.join();[m
[31m-    }[m
[32m+[m[32m    Interrupt();[m
[32m+[m[32m    // Call handler destructor after releasing m_mutex. Locking the mutex is[m
[32m+[m[32m    // required to access m_handler, but the lock should not be held while[m
[32m+[m[32m    // destroying the handler, because the handler destructor waits for the last[m
[32m+[m[32m    // notification to be processed, so holding the lock would deadlock if that[m
[32m+[m[32m    // last notification also needs the lock.[m
[32m+[m[32m    auto handler = WITH_LOCK(m_mutex, return std::move(m_handler));[m
 }[m
 [m
 IndexSummary BaseIndex::GetSummary() const[m
[36m@@ -378,6 +316,7 @@[m [mIndexSummary BaseIndex::GetSummary() const[m
     IndexSummary summary{};[m
     summary.name = GetName();[m
     summary.synced = m_synced;[m
[31m-    summary.best_block_height = m_best_block_index ? m_best_block_index.load()->nHeight : 0;[m
[32m+[m[32m    const auto best_block = WITH_LOCK(m_mutex, return m_best_block);[m
[32m+[m[32m    summary.best_block_height = best_block ? best_block->height : 0;[m
     return summary;[m
 }[m
[33mdiff --git a/src/index/base.h b/src/index/base.h[m
[33mindex c4a8215bc4..a75797698b 100644[m
[33m--- a/src/index/base.h[m
[33m+++ b/src/index/base.h[m
[36m@@ -6,12 +6,17 @@[m
 #define BITCOIN_INDEX_BASE_H[m
 [m
 #include <dbwrapper.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
[32m+[m[32m#include <interfaces/handler.h>[m
 #include <threadinterrupt.h>[m
 #include <validationinterface.h>[m
 [m
[32m+[m[32mclass BaseIndexNotifications;[m
 class CBlock;[m
[31m-class CBlockIndex;[m
 class CChainState;[m
[32m+[m[32mnamespace interfaces {[m
[32m+[m[32mclass Chain;[m
[32m+[m[32m} // namespace interfaces[m
 [m
 struct IndexSummary {[m
     std::string name;[m
[36m@@ -20,11 +25,11 @@[m [mstruct IndexSummary {[m
 };[m
 [m
 /**[m
[31m- * Base class for indices of blockchain data. This implements[m
[31m- * CValidationInterface and ensures blocks are indexed sequentially according[m
[31m- * to their position in the active chain.[m
[32m+[m[32m * Base class for indices of blockchain data. This handles block connected and[m
[32m+[m[32m * disconnected notifications and ensures blocks are indexed sequentially[m
[32m+[m[32m * according to their position in the active chain.[m
  */[m
[31m-class BaseIndex : public CValidationInterface[m
[32m+[m[32mclass BaseIndex[m
 {[m
 protected:[m
     /**[m
[36m@@ -54,17 +59,10 @@[m [mprivate:[m
     std::atomic<bool> m_synced{false};[m
 [m
     /// The last block in the chain that the index is in sync with.[m
[31m-    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};[m
[32m+[m[32m    std::optional<interfaces::BlockKey> m_best_block GUARDED_BY(m_mutex);[m
 [m
[2m-    std::thread m_thread_sync;[m
[2m-    CThreadInterrupt m_interrupt;[m
[31m-[m
[31m-    /// Sync the index with the block index starting from the current best block.[m
[31m-    /// Intended to be run in its own thread, m_thread_sync, and can be[m
[31m-    /// interrupted with m_interrupt. Once the index gets in sync, the m_synced[m
[31m-    /// flag is set and the BlockConnected ValidationInterface callback takes[m
[31m-    /// over and the sync thread exits.[m
[31m-    void ThreadSync();[m
[32m+[m[32m    /// Read best block locator and check that data needed to sync has not been pruned.[m
[32m+[m[32m    bool Init();[m
 [m
     /// Write the current index state (eg. chain block locator and subclass-specific items) to disk.[m
     ///[m
[36m@@ -74,29 +72,34 @@[m [mprivate:[m
     /// from further behind on reboot. If the new state is not a successor of the previous state (due[m
     /// to a chain reorganization), the index must halt until Commit succeeds or else it could end up[m
     /// getting corrupted.[m
[31m-    bool Commit();[m
[31m-protected:[m
[31m-    CChainState* m_chainstate{nullptr};[m
[32m+[m[32m    bool Commit(const CBlockLocator& locator);[m
 [m
[31m-    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    /// Loop over disconnected blocks and call CustomRemove.[m
[32m+[m[32m    bool Rewind(const interfaces::BlockKey& current_tip, const interfaces::BlockKey& new_tip);[m
 [m
[31m-    void ChainStateFlushed(const CBlockLocator& locator) override;[m
[32m+[m[32m    mutable Mutex m_mutex;[m
[32m+[m[32m    friend class BaseIndexNotifications;[m
[32m+[m[32m    std::shared_ptr<BaseIndexNotifications> m_notifications GUARDED_BY(m_mutex);[m
[32m+[m[32m    std::unique_ptr<interfaces::Handler> m_handler GUARDED_BY(m_mutex);[m
[32m+[m
[32m+[m[32mprotected:[m
[32m+[m[32m    std::unique_ptr<interfaces::Chain> m_chain;[m
 [m
[31m-    const CBlockIndex* CurrentIndex() { return m_best_block_index.load(); };[m
[32m+[m[32m    /// Return custom notification options for index.[m
[32m+[m[32m    [[nodiscard]] virtual interfaces::Chain::NotifyOptions CustomOptions() { return {}; }[m
 [m
     /// Initialize internal state from the database and block index.[m
[31m-    [[nodiscard]] virtual bool Init();[m
[32m+[m[32m    [[nodiscard]] virtual bool CustomInit(const std::optional<interfaces::BlockKey>& block) { return true; }[m
 [m
     /// Write update index entries for a newly connected block.[m
[31m-    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }[m
[32m+[m[32m    [[nodiscard]] virtual bool CustomAppend(const interfaces::BlockInfo& block) { return true; }[m
 [m
     /// Virtual method called internally by Commit that can be overridden to atomically[m
     /// commit more index state.[m
[31m-    virtual bool CommitInternal(CDBBatch& batch);[m
[32m+[m[32m    virtual bool CustomCommit(CDBBatch& batch) { return true; }[m
 [m
[31m-    /// Rewind index to an earlier chain tip during a chain reorg. The tip must[m
[31m-    /// be an ancestor of the current best block.[m
[31m-    virtual bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip);[m
[32m+[m[32m    /// Rewind index by one block during a chain reorg.[m
[32m+[m[32m    [[nodiscard]] virtual bool CustomRemove(const interfaces::BlockInfo& block) { return true; }[m
 [m
     virtual DB& GetDB() const = 0;[m
 [m
[36m@@ -104,7 +107,7 @@[m [mprotected:[m
     virtual const char* GetName() const = 0;[m
 [m
 public:[m
[31m-    /// Destructor interrupts sync thread if running and blocks until it exits.[m
[32m+[m[32m    BaseIndex(std::unique_ptr<interfaces::Chain> chain);[m
     virtual ~BaseIndex();[m
 [m
     /// Blocks the current thread until the index is caught up to the current[m
[36m@@ -118,7 +121,7 @@[m [mpublic:[m
 [m
     /// Start initializes the sync state and registers the instance as a[m
     /// ValidationInterface so that it stays in sync with blockchain updates.[m
[31m-    [[nodiscard]] bool Start(CChainState& active_chainstate);[m
[32m+[m[32m    [[nodiscard]] bool Start();[m
 [m
     /// Stops the instance from staying in sync with blockchain updates.[m
     void Stop();[m
[33mdiff --git a/src/index/blockfilterindex.cpp b/src/index/blockfilterindex.cpp[m
[33mindex 4f99eddfd7..be96568182 100644[m
[33m--- a/src/index/blockfilterindex.cpp[m
[33m+++ b/src/index/blockfilterindex.cpp[m
[36m@@ -8,8 +8,9 @@[m
 #include <index/blockfilterindex.h>[m
 #include <node/blockstorage.h>[m
 #include <util/system.h>[m
[32m+[m[32m#include <validation.h>[m
 [m
[31m-using node::UndoReadFromDisk;[m
[32m+[m[32musing interfaces::FoundBlock;[m
 [m
 /* The index database stores three items for each block: the disk location of the encoded filter,[m
  * its dSHA256 hash, and the header. Those belonging to blocks on the active chain are indexed by[m
[36m@@ -93,9 +94,9 @@[m [mstruct DBHashKey {[m
 [m
 static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;[m
 [m
[31m-BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32mBlockFilterIndex::BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, BlockFilterType filter_type,[m
                                    size_t n_cache_size, bool f_memory, bool f_wipe)[m
[31m-    : m_filter_type(filter_type)[m
[32m+[m[32m    : BaseIndex(std::move(chain)), m_filter_type(filter_type)[m
 {[m
     const std::string& filter_name = BlockFilterTypeName(filter_type);[m
     if (filter_name.empty()) throw std::invalid_argument("unknown filter_type");[m
[36m@@ -108,7 +109,14 @@[m [mBlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,[m
     m_filter_fileseq = std::make_unique<FlatFileSeq>(std::move(path), "fltr", FLTR_FILE_CHUNK_SIZE);[m
 }[m
 [m
[31m-bool BlockFilterIndex::Init()[m
[32m+[m[32minterfaces::Chain::NotifyOptions BlockFilterIndex::CustomOptions()[m
[32m+[m[32m{[m
[32m+[m[32m    interfaces::Chain::NotifyOptions options;[m
[32m+[m[32m    options.connect_undo_data = true;[m
[32m+[m[32m    return options;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool BlockFilterIndex::CustomInit(const std::optional<interfaces::BlockKey>& block)[m
 {[m
     if (!m_db->Read(DB_FILTER_POS, m_next_filter_pos)) {[m
         // Check that the cause of the read failure is that the key does not exist. Any other errors[m
[36m@@ -123,10 +131,10 @@[m [mbool BlockFilterIndex::Init()[m
         m_next_filter_pos.nFile = 0;[m
         m_next_filter_pos.nPos = 0;[m
     }[m
[31m-    return BaseIndex::Init();[m
[32m+[m[32m    return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::CommitInternal(CDBBatch& batch)[m
[32m+[m[32mbool BlockFilterIndex::CustomCommit(CDBBatch& batch)[m
 {[m
     const FlatFilePos& pos = m_next_filter_pos;[m
 [m
[36m@@ -140,7 +148,7 @@[m [mbool BlockFilterIndex::CommitInternal(CDBBatch& batch)[m
     }[m
 [m
     batch.Write(DB_FILTER_POS, pos);[m
[31m-    return BaseIndex::CommitInternal(batch);[m
[32m+[m[32m    return true;[m
 }[m
 [m
 bool BlockFilterIndex::ReadFilterFromDisk(const FlatFilePos& pos, BlockFilter& filter) const[m
[36m@@ -209,22 +217,17 @@[m [msize_t BlockFilterIndex::WriteFilterToDisk(FlatFilePos& pos, const BlockFilter&[m
     return data_size;[m
 }[m
 [m
[31m-bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool BlockFilterIndex::CustomAppend(const interfaces::BlockInfo& block)[m
 {[m
[31m-    CBlockUndo block_undo;[m
     uint256 prev_header;[m
 [m
[31m-    if (pindex->nHeight > 0) {[m
[31m-        if (!UndoReadFromDisk(block_undo, pindex)) {[m
[31m-            return false;[m
[31m-        }[m
[31m-[m
[32m+[m[32m    if (block.height > 0) {[m
         std::pair<uint256, DBVal> read_out;[m
[31m-        if (!m_db->Read(DBHeightKey(pindex->nHeight - 1), read_out)) {[m
[32m+[m[32m        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {[m
             return false;[m
         }[m
 [m
[31m-        uint256 expected_block_hash = pindex->pprev->GetBlockHash();[m
[32m+[m[32m        uint256 expected_block_hash = *block.prev_hash;[m
         if (read_out.first != expected_block_hash) {[m
             return error("%s: previous block header belongs to unexpected block %s; expected %s",[m
                          __func__, read_out.first.ToString(), expected_block_hash.ToString());[m
[36m@@ -233,18 +236,18 @@[m [mbool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex[m
         prev_header = read_out.second.header;[m
     }[m
 [m
[31m-    BlockFilter filter(m_filter_type, block, block_undo);[m
[32m+[m[32m    BlockFilter filter(m_filter_type, *block.data, block.undo_data ? *block.undo_data : CBlockUndo());[m
 [m
     size_t bytes_written = WriteFilterToDisk(m_next_filter_pos, filter);[m
     if (bytes_written == 0) return false;[m
 [m
     std::pair<uint256, DBVal> value;[m
[31m-    value.first = pindex->GetBlockHash();[m
[32m+[m[32m    value.first = block.hash;[m
     value.second.hash = filter.GetHash();[m
     value.second.header = filter.ComputeHeader(prev_header);[m
     value.second.pos = m_next_filter_pos;[m
 [m
[31m-    if (!m_db->Write(DBHeightKey(pindex->nHeight), value)) {[m
[32m+[m[32m    if (!m_db->Write(DBHeightKey(block.height), value)) {[m
         return false;[m
     }[m
 [m
[36m@@ -278,17 +281,15 @@[m [mstatic bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,[m
     return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)[m
[32m+[m[32mbool BlockFilterIndex::CustomRemove(const interfaces::BlockInfo& block)[m
 {[m
[31m-    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);[m
[31m-[m
     CDBBatch batch(*m_db);[m
     std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());[m
 [m
     // During a reorg, we need to copy all filters for blocks that are getting disconnected from the[m
     // height index to the hash index so we can still find them when the height index entries are[m
     // overwritten.[m
[31m-    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip->nHeight, current_tip->nHeight)) {[m
[32m+[m[32m    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, block.height - 1, block.height)) {[m
         return false;[m
     }[m
 [m
[36m@@ -298,45 +299,45 @@[m [mbool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex*[m
     batch.Write(DB_FILTER_POS, m_next_filter_pos);[m
     if (!m_db->WriteBatch(batch)) return false;[m
 [m
[31m-    return BaseIndex::Rewind(current_tip, new_tip);[m
[32m+[m[32m    return true;[m
 }[m
 [m
[31m-static bool LookupOne(const CDBWrapper& db, const CBlockIndex* block_index, DBVal& result)[m
[32m+[m[32mstatic bool LookupOne(const CDBWrapper& db, const interfaces::BlockKey& block, DBVal& result)[m
 {[m
     // First check if the result is stored under the height index and the value there matches the[m
     // block hash. This should be the case if the block is on the active chain.[m
     std::pair<uint256, DBVal> read_out;[m
[31m-    if (!db.Read(DBHeightKey(block_index->nHeight), read_out)) {[m
[32m+[m[32m    if (!db.Read(DBHeightKey(block.height), read_out)) {[m
         return false;[m
     }[m
[31m-    if (read_out.first == block_index->GetBlockHash()) {[m
[32m+[m[32m    if (read_out.first == block.hash) {[m
         result = std::move(read_out.second);[m
         return true;[m
     }[m
 [m
     // If value at the height index corresponds to an different block, the result will be stored in[m
     // the hash index.[m
[31m-    return db.Read(DBHashKey(block_index->GetBlockHash()), result);[m
[32m+[m[32m    return db.Read(DBHashKey(block.hash), result);[m
 }[m
 [m
[31m-static bool LookupRange(CDBWrapper& db, const std::string& index_name, int start_height,[m
[31m-                        const CBlockIndex* stop_index, std::vector<DBVal>& results)[m
[32m+[m[32mstatic bool LookupRange(CDBWrapper& db, const std::string& index_name, interfaces::Chain& chain, int start_height,[m
[32m+[m[32m                        const interfaces::BlockKey& stop, std::vector<DBVal>& results)[m
 {[m
     if (start_height < 0) {[m
         return error("%s: start height (%d) is negative", __func__, start_height);[m
     }[m
[31m-    if (start_height > stop_index->nHeight) {[m
[32m+[m[32m    if (start_height > stop.height) {[m
         return error("%s: start height (%d) is greater than stop height (%d)",[m
[31m-                     __func__, start_height, stop_index->nHeight);[m
[32m+[m[32m                     __func__, start_height, stop.height);[m
     }[m
 [m
[31m-    size_t results_size = static_cast<size_t>(stop_index->nHeight - start_height + 1);[m
[32m+[m[32m    size_t results_size = static_cast<size_t>(stop.height - start_height + 1);[m
     std::vector<std::pair<uint256, DBVal>> values(results_size);[m
 [m
     DBHeightKey key(start_height);[m
     std::unique_ptr<CDBIterator> db_it(db.NewIterator());[m
     db_it->Seek(DBHeightKey(start_height));[m
[31m-    for (int height = start_height; height <= stop_index->nHeight; ++height) {[m
[32m+[m[32m    for (int height = start_height; height <= stop.height; ++height) {[m
         if (!db_it->Valid() || !db_it->GetKey(key) || key.height != height) {[m
             return false;[m
         }[m
[36m@@ -354,12 +355,13 @@[m [mstatic bool LookupRange(CDBWrapper& db, const std::string& index_name, int start[m
 [m
     // Iterate backwards through block indexes collecting results in order to access the block hash[m
     // of each entry in case we need to look it up in the hash index.[m
[31m-    for (const CBlockIndex* block_index = stop_index;[m
[31m-         block_index && block_index->nHeight >= start_height;[m
[31m-         block_index = block_index->pprev) {[m
[31m-        uint256 block_hash = block_index->GetBlockHash();[m
[31m-[m
[31m-        size_t i = static_cast<size_t>(block_index->nHeight - start_height);[m
[32m+[m[32m    uint256 block_hash = stop.hash;[m
[32m+[m[32m    for (int block_height = stop.height; block_height >= start_height; --block_height) {[m
[32m+[m[32m        if (block_height < stop.height) {[m
[32m+[m[32m            bool found_hash = chain.findAncestorByHeight(block_hash, block_height, FoundBlock().hash(block_hash));[m
[32m+[m[32m            assert(found_hash);[m
[32m+[m[32m        }[m
[32m+[m[32m        size_t i = static_cast<size_t>(block_height - start_height);[m
         if (block_hash == values[i].first) {[m
             results[i] = std::move(values[i].second);[m
             continue;[m
[36m@@ -374,25 +376,25 @@[m [mstatic bool LookupRange(CDBWrapper& db, const std::string& index_name, int start[m
     return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::LookupFilter(const CBlockIndex* block_index, BlockFilter& filter_out) const[m
[32m+[m[32mbool BlockFilterIndex::LookupFilter(const interfaces::BlockKey& block, BlockFilter& filter_out) const[m
 {[m
     DBVal entry;[m
[31m-    if (!LookupOne(*m_db, block_index, entry)) {[m
[32m+[m[32m    if (!LookupOne(*m_db, block, entry)) {[m
         return false;[m
     }[m
 [m
     return ReadFilterFromDisk(entry.pos, filter_out);[m
 }[m
 [m
[31m-bool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out)[m
[32m+[m[32mbool BlockFilterIndex::LookupFilterHeader(const interfaces::BlockKey& block, uint256& header_out)[m
 {[m
     LOCK(m_cs_headers_cache);[m
 [m
[31m-    bool is_checkpoint{block_index->nHeight % CFCHECKPT_INTERVAL == 0};[m
[32m+[m[32m    bool is_checkpoint{block.height % CFCHECKPT_INTERVAL == 0};[m
 [m
     if (is_checkpoint) {[m
         // Try to find the block in the headers cache if this is a checkpoint height.[m
[31m-        auto header = m_headers_cache.find(block_index->GetBlockHash());[m
[32m+[m[32m        auto header = m_headers_cache.find(block.hash);[m
         if (header != m_headers_cache.end()) {[m
             header_out = header->second;[m
             return true;[m
[36m@@ -400,25 +402,26 @@[m [mbool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint25[m
     }[m
 [m
     DBVal entry;[m
[31m-    if (!LookupOne(*m_db, block_index, entry)) {[m
[32m+[m[32m    if (!LookupOne(*m_db, block, entry)) {[m
         return false;[m
     }[m
 [m
     if (is_checkpoint &&[m
         m_headers_cache.size() < CF_HEADERS_CACHE_MAX_SZ) {[m
         // Add to the headers cache if this is a checkpoint height.[m
[31m-        m_headers_cache.emplace(block_index->GetBlockHash(), entry.header);[m
[32m+[m[32m        m_headers_cache.emplace(block.hash, entry.header);[m
     }[m
 [m
     header_out = entry.header;[m
     return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::LookupFilterRange(int start_height, const CBlockIndex* stop_index,[m
[32m+[m[32mbool BlockFilterIndex::LookupFilterRange(int start_height, const interfaces::BlockKey& stop_index,[m
                                          std::vector<BlockFilter>& filters_out) const[m
 {[m
     std::vector<DBVal> entries;[m
[31m-    if (!LookupRange(*m_db, m_name, start_height, stop_index, entries)) {[m
[32m+[m[32m    assert(m_chain);[m
[32m+[m[32m    if (!LookupRange(*m_db, m_name, *m_chain, start_height, stop_index, entries)) {[m
         return false;[m
     }[m
 [m
[36m@@ -434,12 +437,13 @@[m [mbool BlockFilterIndex::LookupFilterRange(int start_height, const CBlockIndex* st[m
     return true;[m
 }[m
 [m
[31m-bool BlockFilterIndex::LookupFilterHashRange(int start_height, const CBlockIndex* stop_index,[m
[32m+[m[32mbool BlockFilterIndex::LookupFilterHashRange(int start_height, const interfaces::BlockKey& stop_index,[m
                                              std::vector<uint256>& hashes_out) const[m
 [m
 {[m
     std::vector<DBVal> entries;[m
[31m-    if (!LookupRange(*m_db, m_name, start_height, stop_index, entries)) {[m
[32m+[m[32m    assert(m_chain);[m
[32m+[m[32m    if (!LookupRange(*m_db, m_name, *m_chain, start_height, stop_index, entries)) {[m
         return false;[m
     }[m
 [m
[36m@@ -462,12 +466,12 @@[m [mvoid ForEachBlockFilterIndex(std::function<void (BlockFilterIndex&)> fn)[m
     for (auto& entry : g_filter_indexes) fn(entry.second);[m
 }[m
 [m
[31m-bool InitBlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32mbool InitBlockFilterIndex(std::function<std::unique_ptr<interfaces::Chain>()> make_chain, BlockFilterType filter_type,[m
                           size_t n_cache_size, bool f_memory, bool f_wipe)[m
 {[m
     auto result = g_filter_indexes.emplace(std::piecewise_construct,[m
                                            std::forward_as_tuple(filter_type),[m
[31m-                                           std::forward_as_tuple(filter_type,[m
[32m+[m[32m                                           std::forward_as_tuple(make_chain(), filter_type,[m
                                                                  n_cache_size, f_memory, f_wipe));[m
     return result.second;[m
 }[m
[33mdiff --git a/src/index/blockfilterindex.h b/src/index/blockfilterindex.h[m
[33mindex a049019c02..c1561801b4 100644[m
[33m--- a/src/index/blockfilterindex.h[m
[33m+++ b/src/index/blockfilterindex.h[m
[36m@@ -39,13 +39,15 @@[m [mprivate:[m
     std::unordered_map<uint256, uint256, FilterHeaderHasher> m_headers_cache GUARDED_BY(m_cs_headers_cache);[m
 [m
 protected:[m
[31m-    bool Init() override;[m
[32m+[m[32m    interfaces::Chain::NotifyOptions CustomOptions() override;[m
 [m
[31m-    bool CommitInternal(CDBBatch& batch) override;[m
[32m+[m[32m    bool CustomInit(const std::optional<interfaces::BlockKey>& block) override;[m
 [m
[31m-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    bool CustomCommit(CDBBatch& batch) override;[m
 [m
[31m-    bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip) override;[m
[32m+[m[32m    bool CustomAppend(const interfaces::BlockInfo& block) override;[m
[32m+[m
[32m+[m[32m    bool CustomRemove(const interfaces::BlockInfo& block) override;[m
 [m
     BaseIndex::DB& GetDB() const override { return *m_db; }[m
 [m
[36m@@ -53,23 +55,23 @@[m [mprotected:[m
 [m
 public:[m
     /** Constructs the index, which becomes available to be queried. */[m
[31m-    explicit BlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32m    explicit BlockFilterIndex(std::unique_ptr<interfaces::Chain> chain, BlockFilterType filter_type,[m
                               size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
     BlockFilterType GetFilterType() const { return m_filter_type; }[m
 [m
     /** Get a single filter by block. */[m
[31m-    bool LookupFilter(const CBlockIndex* block_index, BlockFilter& filter_out) const;[m
[32m+[m[32m    bool LookupFilter(const interfaces::BlockKey& block, BlockFilter& filter_out) const;[m
 [m
     /** Get a single filter header by block. */[m
[31m-    bool LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out);[m
[32m+[m[32m    bool LookupFilterHeader(const interfaces::BlockKey& block, uint256& header_out);[m
 [m
     /** Get a range of filters between two heights on a chain. */[m
[31m-    bool LookupFilterRange(int start_height, const CBlockIndex* stop_index,[m
[32m+[m[32m    bool LookupFilterRange(int start_height, const interfaces::BlockKey& stop_index,[m
                            std::vector<BlockFilter>& filters_out) const;[m
 [m
     /** Get a range of filter hashes between two heights on a chain. */[m
[31m-    bool LookupFilterHashRange(int start_height, const CBlockIndex* stop_index,[m
[32m+[m[32m    bool LookupFilterHashRange(int start_height, const interfaces::BlockKey& stop_index,[m
                                std::vector<uint256>& hashes_out) const;[m
 };[m
 [m
[36m@@ -86,7 +88,7 @@[m [mvoid ForEachBlockFilterIndex(std::function<void (BlockFilterIndex&)> fn);[m
  * Initialize a block filter index for the given type if one does not already exist. Returns true if[m
  * a new index is created and false if one has already been initialized.[m
  */[m
[31m-bool InitBlockFilterIndex(BlockFilterType filter_type,[m
[32m+[m[32mbool InitBlockFilterIndex(std::function<std::unique_ptr<interfaces::Chain>()> make_chain, BlockFilterType filter_type,[m
                           size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
 /**[m
[33mdiff --git a/src/index/coinstatsindex.cpp b/src/index/coinstatsindex.cpp[m
[33mindex 69078708f9..8fa3ba76d3 100644[m
[33m--- a/src/index/coinstatsindex.cpp[m
[33m+++ b/src/index/coinstatsindex.cpp[m
[36m@@ -16,7 +16,6 @@[m [musing node::CCoinsStats;[m
 using node::GetBogoSize;[m
 using node::ReadBlockFromDisk;[m
 using node::TxOutSer;[m
[31m-using node::UndoReadFromDisk;[m
 [m
 static constexpr uint8_t DB_BLOCK_HASH{'s'};[m
 static constexpr uint8_t DB_BLOCK_HEIGHT{'t'};[m
[36m@@ -101,7 +100,7 @@[m [mstruct DBHashKey {[m
 [m
 std::unique_ptr<CoinStatsIndex> g_coin_stats_index;[m
 [m
[31m-CoinStatsIndex::CoinStatsIndex(size_t n_cache_size, bool f_memory, bool f_wipe)[m
[32m+[m[32mCoinStatsIndex::CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe) : BaseIndex(std::move(chain))[m
 {[m
     fs::path path{gArgs.GetDataDirNet() / "indexes" / "coinstats"};[m
     fs::create_directories(path);[m
[36m@@ -109,24 +108,19 @@[m [mCoinStatsIndex::CoinStatsIndex(size_t n_cache_size, bool f_memory, bool f_wipe)[m
     m_db = std::make_unique<CoinStatsIndex::DB>(path / "db", n_cache_size, f_memory, f_wipe);[m
 }[m
 [m
[31m-bool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool CoinStatsIndex::CustomAppend(const interfaces::BlockInfo& block)[m
 {[m
[31m-    CBlockUndo block_undo;[m
[31m-    const CAmount block_subsidy{GetBlockSubsidy(pindex->nHeight, Params().GetConsensus())};[m
[32m+[m[32m    const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};[m
     m_total_subsidy += block_subsidy;[m
 [m
     // Ignore genesis block[m
[31m-    if (pindex->nHeight > 0) {[m
[31m-        if (!UndoReadFromDisk(block_undo, pindex)) {[m
[31m-            return false;[m
[31m-        }[m
[31m-[m
[32m+[m[32m    if (block.height > 0) {[m
         std::pair<uint256, DBVal> read_out;[m
[31m-        if (!m_db->Read(DBHeightKey(pindex->nHeight - 1), read_out)) {[m
[32m+[m[32m        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {[m
             return false;[m
         }[m
 [m
[31m-        uint256 expected_block_hash{pindex->pprev->GetBlockHash()};[m
[32m+[m[32m        uint256 expected_block_hash{*block.prev_hash};[m
         if (read_out.first != expected_block_hash) {[m
             LogPrintf("WARNING: previous block header belongs to unexpected block %s; expected %s\n",[m
                       read_out.first.ToString(), expected_block_hash.ToString());[m
[36m@@ -138,12 +132,12 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
         }[m
 [m
         // TODO: Deduplicate BIP30 related code[m
[31m-        bool is_bip30_block{(pindex->nHeight == 91722 && pindex->GetBlockHash() == uint256S("0x00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")) ||[m
[31m-                            (pindex->nHeight == 91812 && pindex->GetBlockHash() == uint256S("0x00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"))};[m
[32m+[m[32m        bool is_bip30_block{(block.height == 91722 && block.hash == uint256S("0x00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")) ||[m
[32m+[m[32m                            (block.height == 91812 && block.hash == uint256S("0x00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"))};[m
 [m
         // Add the new utxos created from the block[m
[31m-        for (size_t i = 0; i < block.vtx.size(); ++i) {[m
[31m-            const auto& tx{block.vtx.at(i)};[m
[32m+[m[32m        for (size_t i = 0; i < block.data->vtx.size(); ++i) {[m
[32m+[m[32m            const auto& tx{block.data->vtx.at(i)};[m
 [m
             // Skip duplicate txid coinbase transactions (BIP30).[m
             if (is_bip30_block && tx->IsCoinBase()) {[m
[36m@@ -154,7 +148,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
 [m
             for (uint32_t j = 0; j < tx->vout.size(); ++j) {[m
                 const CTxOut& out{tx->vout[j]};[m
[31m-                Coin coin{out, pindex->nHeight, tx->IsCoinBase()};[m
[32m+[m[32m                Coin coin{out, block.height, tx->IsCoinBase()};[m
                 COutPoint outpoint{tx->GetHash(), j};[m
 [m
                 // Skip unspendable coins[m
[36m@@ -179,7 +173,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
 [m
             // The coinbase tx has no undo data since no former output is spent[m
             if (!tx->IsCoinBase()) {[m
[31m-                const auto& tx_undo{block_undo.vtxundo.at(i - 1)};[m
[32m+[m[32m                const auto& tx_undo{block.undo_data->vtxundo.at(i - 1)};[m
 [m
                 for (size_t j = 0; j < tx_undo.vprevout.size(); ++j) {[m
                     Coin coin{tx_undo.vprevout[j]};[m
[36m@@ -210,7 +204,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
     m_total_unspendables_unclaimed_rewards += unclaimed_rewards;[m
 [m
     std::pair<uint256, DBVal> value;[m
[31m-    value.first = pindex->GetBlockHash();[m
[32m+[m[32m    value.first = block.hash;[m
     value.second.transaction_output_count = m_transaction_output_count;[m
     value.second.bogo_size = m_bogo_size;[m
     value.second.total_amount = m_total_amount;[m
[36m@@ -230,7 +224,7 @@[m [mbool CoinStatsIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
 [m
     // Intentionally do not update DB_MUHASH here so it stays in sync with[m
     // DB_BEST_BLOCK, and the index is not corrupted if there is an unclean shutdown.[m
[31m-    return m_db->Write(DBHeightKey(pindex->nHeight), value);[m
[32m+[m[32m    return m_db->Write(DBHeightKey(block.height), value);[m
 }[m
 [m
 static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,[m
[36m@@ -259,67 +253,48 @@[m [mstatic bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,[m
     return true;[m
 }[m
 [m
[31m-bool CoinStatsIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)[m
[32m+[m[32mbool CoinStatsIndex::CustomRemove(const interfaces::BlockInfo& block)[m
 {[m
[31m-    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);[m
[31m-[m
     CDBBatch batch(*m_db);[m
     std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());[m
 [m
     // During a reorg, we need to copy all hash digests for blocks that are[m
     // getting disconnected from the height index to the hash index so we can[m
     // still find them when the height index entries are overwritten.[m
[31m-    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, new_tip->nHeight, current_tip->nHeight)) {[m
[32m+[m[32m    if (!CopyHeightIndexToHashIndex(*db_it, batch, m_name, block.height - 1, block.height)) {[m
         return false;[m
     }[m
 [m
     if (!m_db->WriteBatch(batch)) return false;[m
 [m
[31m-    {[m
[31m-        LOCK(cs_main);[m
[31m-        const CBlockIndex* iter_tip{m_chainstate->m_blockman.LookupBlockIndex(current_tip->GetBlockHash())};[m
[31m-        const auto& consensus_params{Params().GetConsensus()};[m
[31m-[m
[31m-        do {[m
[31m-            CBlock block;[m
[31m-[m
[31m-            if (!ReadBlockFromDisk(block, iter_tip, consensus_params)) {[m
[31m-                return error("%s: Failed to read block %s from disk",[m
[31m-                             __func__, iter_tip->GetBlockHash().ToString());[m
[31m-            }[m
[31m-[m
[31m-            ReverseBlock(block, iter_tip);[m
[31m-[m
[31m-            iter_tip = iter_tip->GetAncestor(iter_tip->nHeight - 1);[m
[31m-        } while (new_tip != iter_tip);[m
[31m-    }[m
[32m+[m[32m    ReverseBlock(block);[m
 [m
[31m-    return BaseIndex::Rewind(current_tip, new_tip);[m
[32m+[m[32m    return true;[m
 }[m
 [m
[31m-static bool LookUpOne(const CDBWrapper& db, const CBlockIndex* block_index, DBVal& result)[m
[32m+[m[32mstatic bool LookUpOne(const CDBWrapper& db, const uint256& block_hash, int block_height, DBVal& result)[m
 {[m
     // First check if the result is stored under the height index and the value[m
     // there matches the block hash. This should be the case if the block is on[m
     // the active chain.[m
     std::pair<uint256, DBVal> read_out;[m
[31m-    if (!db.Read(DBHeightKey(block_index->nHeight), read_out)) {[m
[32m+[m[32m    if (!db.Read(DBHeightKey(block_height), read_out)) {[m
         return false;[m
     }[m
[31m-    if (read_out.first == block_index->GetBlockHash()) {[m
[32m+[m[32m    if (read_out.first == block_hash) {[m
         result = std::move(read_out.second);[m
         return true;[m
     }[m
 [m
     // If value at the height index corresponds to an different block, the[m
     // result will be stored in the hash index.[m
[31m-    return db.Read(DBHashKey(block_index->GetBlockHash()), result);[m
[32m+[m[32m    return db.Read(DBHashKey(block_hash), result);[m
 }[m
 [m
[31m-bool CoinStatsIndex::LookUpStats(const CBlockIndex* block_index, CCoinsStats& coins_stats) const[m
[32m+[m[32mbool CoinStatsIndex::LookUpStats(const interfaces::BlockKey& block, CCoinsStats& coins_stats) const[m
 {[m
     DBVal entry;[m
[31m-    if (!LookUpOne(*m_db, block_index, entry)) {[m
[32m+[m[32m    if (!LookUpOne(*m_db, block.hash, block.height, entry)) {[m
         return false;[m
     }[m
 [m
[36m@@ -340,7 +315,7 @@[m [mbool CoinStatsIndex::LookUpStats(const CBlockIndex* block_index, CCoinsStats& co[m
     return true;[m
 }[m
 [m
[31m-bool CoinStatsIndex::Init()[m
[32m+[m[32mbool CoinStatsIndex::CustomInit(const std::optional<interfaces::BlockKey>& block)[m
 {[m
     if (!m_db->Read(DB_MUHASH, m_muhash)) {[m
         // Check that the cause of the read failure is that the key does not[m
[36m@@ -352,13 +327,9 @@[m [mbool CoinStatsIndex::Init()[m
         }[m
     }[m
 [m
[31m-    if (!BaseIndex::Init()) return false;[m
[31m-[m
[31m-    const CBlockIndex* pindex{CurrentIndex()};[m
[31m-[m
[31m-    if (pindex) {[m
[32m+[m[32m    if (block) {[m
         DBVal entry;[m
[31m-        if (!LookUpOne(*m_db, pindex, entry)) {[m
[32m+[m[32m        if (!LookUpOne(*m_db, block->hash, block->height, entry)) {[m
             return error("%s: Cannot read current %s state; index may be corrupted",[m
                          __func__, GetName());[m
         }[m
[36m@@ -387,34 +358,38 @@[m [mbool CoinStatsIndex::Init()[m
     return true;[m
 }[m
 [m
[31m-bool CoinStatsIndex::CommitInternal(CDBBatch& batch)[m
[32m+[m[32mbool CoinStatsIndex::CustomCommit(CDBBatch& batch)[m
 {[m
     // DB_MUHASH should always be committed in a batch together with DB_BEST_BLOCK[m
     // to prevent an inconsistent state of the DB.[m
     batch.Write(DB_MUHASH, m_muhash);[m
[31m-    return BaseIndex::CommitInternal(batch);[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32minterfaces::Chain::NotifyOptions CoinStatsIndex::CustomOptions()[m
[32m+[m[32m{[m
[32m+[m[32m    interfaces::Chain::NotifyOptions options;[m
[32m+[m[32m    options.connect_undo_data = true;[m
[32m+[m[32m    options.disconnect_data = true;[m
[32m+[m[32m    options.disconnect_undo_data = true;[m
[32m+[m[32m    return options;[m
 }[m
 [m
 // Reverse a single block as part of a reorg[m
[31m-bool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool CoinStatsIndex::ReverseBlock(const interfaces::BlockInfo& block)[m
 {[m
[31m-    CBlockUndo block_undo;[m
     std::pair<uint256, DBVal> read_out;[m
 [m
[31m-    const CAmount block_subsidy{GetBlockSubsidy(pindex->nHeight, Params().GetConsensus())};[m
[32m+[m[32m    const CAmount block_subsidy{GetBlockSubsidy(block.height, Params().GetConsensus())};[m
     m_total_subsidy -= block_subsidy;[m
 [m
     // Ignore genesis block[m
[31m-    if (pindex->nHeight > 0) {[m
[31m-        if (!UndoReadFromDisk(block_undo, pindex)) {[m
[31m-            return false;[m
[31m-        }[m
[31m-[m
[31m-        if (!m_db->Read(DBHeightKey(pindex->nHeight - 1), read_out)) {[m
[32m+[m[32m    if (block.height > 0) {[m
[32m+[m[32m        if (!m_db->Read(DBHeightKey(block.height - 1), read_out)) {[m
             return false;[m
         }[m
 [m
[31m-        uint256 expected_block_hash{pindex->pprev->GetBlockHash()};[m
[32m+[m[32m        uint256 expected_block_hash{*block.prev_hash};[m
         if (read_out.first != expected_block_hash) {[m
             LogPrintf("WARNING: previous block header belongs to unexpected block %s; expected %s\n",[m
                       read_out.first.ToString(), expected_block_hash.ToString());[m
[36m@@ -427,13 +402,13 @@[m [mbool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex[m
     }[m
 [m
     // Remove the new UTXOs that were created from the block[m
[31m-    for (size_t i = 0; i < block.vtx.size(); ++i) {[m
[31m-        const auto& tx{block.vtx.at(i)};[m
[32m+[m[32m    for (size_t i = 0; i < block.data->vtx.size(); ++i) {[m
[32m+[m[32m        const auto& tx{block.data->vtx.at(i)};[m
 [m
         for (uint32_t j = 0; j < tx->vout.size(); ++j) {[m
             const CTxOut& out{tx->vout[j]};[m
             COutPoint outpoint{tx->GetHash(), j};[m
[31m-            Coin coin{out, pindex->nHeight, tx->IsCoinBase()};[m
[32m+[m[32m            Coin coin{out, block.height, tx->IsCoinBase()};[m
 [m
             // Skip unspendable coins[m
             if (coin.out.scriptPubKey.IsUnspendable()) {[m
[36m@@ -457,7 +432,7 @@[m [mbool CoinStatsIndex::ReverseBlock(const CBlock& block, const CBlockIndex* pindex[m
 [m
         // The coinbase tx has no undo data since no former output is spent[m
         if (!tx->IsCoinBase()) {[m
[31m-            const auto& tx_undo{block_undo.vtxundo.at(i - 1)};[m
[32m+[m[32m            const auto& tx_undo{block.undo_data->vtxundo.at(i - 1)};[m
 [m
             for (size_t j = 0; j < tx_undo.vprevout.size(); ++j) {[m
                 Coin coin{tx_undo.vprevout[j]};[m
[33mdiff --git a/src/index/coinstatsindex.h b/src/index/coinstatsindex.h[m
[33mindex 24190ac137..cc66c75059 100644[m
[33m--- a/src/index/coinstatsindex.h[m
[33m+++ b/src/index/coinstatsindex.h[m
[36m@@ -34,16 +34,18 @@[m [mprivate:[m
     CAmount m_total_unspendables_scripts{0};[m
     CAmount m_total_unspendables_unclaimed_rewards{0};[m
 [m
[31m-    bool ReverseBlock(const CBlock& block, const CBlockIndex* pindex);[m
[32m+[m[32m    bool ReverseBlock(const interfaces::BlockInfo& block);[m
 [m
 protected:[m
[31m-    bool Init() override;[m
[32m+[m[32m    interfaces::Chain::NotifyOptions CustomOptions() override;[m
 [m
[31m-    bool CommitInternal(CDBBatch& batch) override;[m
[32m+[m[32m    bool CustomInit(const std::optional<interfaces::BlockKey>& block) override;[m
 [m
[31m-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    bool CustomCommit(CDBBatch& batch) override;[m
 [m
[31m-    bool Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip) override;[m
[32m+[m[32m    bool CustomAppend(const interfaces::BlockInfo& block) override;[m
[32m+[m
[32m+[m[32m    bool CustomRemove(const interfaces::BlockInfo& block) override;[m
 [m
     BaseIndex::DB& GetDB() const override { return *m_db; }[m
 [m
[36m@@ -51,10 +53,10 @@[m [mprotected:[m
 [m
 public:[m
     // Constructs the index, which becomes available to be queried.[m
[31m-    explicit CoinStatsIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
[32m+[m[32m    explicit CoinStatsIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
[31m-    // Look up stats for a specific block using CBlockIndex[m
[31m-    bool LookUpStats(const CBlockIndex* block_index, node::CCoinsStats& coins_stats) const;[m
[32m+[m[32m    // Look up stats for a specific block using hash and height[m
[32m+[m[32m    bool LookUpStats(const interfaces::BlockKey& block, node::CCoinsStats& coins_stats) const;[m
 };[m
 [m
 /// The global UTXO set hash object.[m
[33mdiff --git a/src/index/txindex.cpp b/src/index/txindex.cpp[m
[33mindex e1d807f39a..433bbba40d 100644[m
[33m--- a/src/index/txindex.cpp[m
[33m+++ b/src/index/txindex.cpp[m
[36m@@ -48,23 +48,21 @@[m [mbool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_[m
     return WriteBatch(batch);[m
 }[m
 [m
[31m-TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)[m
[31m-    : m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))[m
[32m+[m[32mTxIndex::TxIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory, bool f_wipe)[m
[32m+[m[32m    : BaseIndex(std::move(chain)), m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))[m
 {}[m
 [m
 TxIndex::~TxIndex() {}[m
 [m
[31m-bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)[m
[32m+[m[32mbool TxIndex::CustomAppend(const interfaces::BlockInfo& block)[m
 {[m
     // Exclude genesis block transaction because outputs are not spendable.[m
[31m-    if (pindex->nHeight == 0) return true;[m
[32m+[m[32m    if (block.height == 0) return true;[m
 [m
[31m-    CDiskTxPos pos{[m
[31m-        WITH_LOCK(::cs_main, return pindex->GetBlockPos()),[m
[31m-        GetSizeOfCompactSize(block.vtx.size())};[m
[32m+[m[32m    CDiskTxPos pos({block.file_number, block.data_pos}, GetSizeOfCompactSize(block.data->vtx.size()));[m
     std::vector<std::pair<uint256, CDiskTxPos>> vPos;[m
[31m-    vPos.reserve(block.vtx.size());[m
[31m-    for (const auto& tx : block.vtx) {[m
[32m+[m[32m    vPos.reserve(block.data->vtx.size());[m
[32m+[m[32m    for (const auto& tx : block.data->vtx) {[m
         vPos.emplace_back(tx->GetHash(), pos);[m
         pos.nTxOffset += ::GetSerializeSize(*tx, CLIENT_VERSION);[m
     }[m
[33mdiff --git a/src/index/txindex.h b/src/index/txindex.h[m
[33mindex 2bbc602631..629d658d9b 100644[m
[33m--- a/src/index/txindex.h[m
[33m+++ b/src/index/txindex.h[m
[36m@@ -21,7 +21,7 @@[m [mprivate:[m
     const std::unique_ptr<DB> m_db;[m
 [m
 protected:[m
[31m-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;[m
[32m+[m[32m    bool CustomAppend(const interfaces::BlockInfo& block) override;[m
 [m
     BaseIndex::DB& GetDB() const override;[m
 [m
[36m@@ -29,7 +29,7 @@[m [mprotected:[m
 [m
 public:[m
     /// Constructs the index, which becomes available to be queried.[m
[31m-    explicit TxIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
[32m+[m[32m    explicit TxIndex(std::unique_ptr<interfaces::Chain> chain, size_t n_cache_size, bool f_memory = false, bool f_wipe = false);[m
 [m
     // Destructor is declared because this class contains a unique_ptr to an incomplete type.[m
     virtual ~TxIndex() override;[m
[33mdiff --git a/src/init.cpp b/src/init.cpp[m
[33mindex bad402e56e..6a5770add8 100644[m
[33m--- a/src/init.cpp[m
[33m+++ b/src/init.cpp[m
[36m@@ -1542,22 +1542,22 @@[m [mbool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)[m
             return InitError(*error);[m
         }[m
 [m
[31m-        g_txindex = std::make_unique<TxIndex>(cache_sizes.tx_index, false, fReindex);[m
[31m-        if (!g_txindex->Start(chainman.ActiveChainstate())) {[m
[32m+[m[32m        g_txindex = std::make_unique<TxIndex>(interfaces::MakeChain(node), cache_sizes.tx_index, false, fReindex);[m
[32m+[m[32m        if (!g_txindex->Start()) {[m
             return false;[m
         }[m
     }[m
 [m
     for (const auto& filter_type : g_enabled_filter_types) {[m
[31m-        InitBlockFilterIndex(filter_type, cache_sizes.filter_index, false, fReindex);[m
[31m-        if (!GetBlockFilterIndex(filter_type)->Start(chainman.ActiveChainstate())) {[m
[32m+[m[32m        InitBlockFilterIndex([&]{ return interfaces::MakeChain(node); }, filter_type, cache_sizes.filter_index, false, fReindex);[m
[32m+[m[32m        if (!GetBlockFilterIndex(filter_type)->Start()) {[m
             return false;[m
         }[m
     }[m
 [m
     if (args.GetBoolArg("-coinstatsindex", DEFAULT_COINSTATSINDEX)) {[m
[31m-        g_coin_stats_index = std::make_unique<CoinStatsIndex>(/* cache size */ 0, false, fReindex);[m
[31m-        if (!g_coin_stats_index->Start(chainman.ActiveChainstate())) {[m
[32m+[m[32m        g_coin_stats_index = std::make_unique<CoinStatsIndex>(interfaces::MakeChain(node), /* cache size */ 0, false, fReindex);[m
[32m+[m[32m        if (!g_coin_stats_index->Start()) {[m
             return false;[m
         }[m
     }[m
[33mdiff --git a/src/interfaces/chain.h b/src/interfaces/chain.h[m
[33mindex ddfb4bda95..8a067c4f18 100644[m
[33m--- a/src/interfaces/chain.h[m
[33m+++ b/src/interfaces/chain.h[m
[36m@@ -18,6 +18,7 @@[m
 [m
 class ArgsManager;[m
 class CBlock;[m
[32m+[m[32mclass CBlockUndo;[m
 class CFeeRate;[m
 class CRPCCommand;[m
 class CScheduler;[m
[36m@@ -37,6 +38,12 @@[m [mnamespace interfaces {[m
 class Handler;[m
 class Wallet;[m
 [m
[32m+[m[32m//! Hash/height pair to help track and identify blocks.[m
[32m+[m[32mstruct BlockKey {[m
[32m+[m[32m    uint256 hash;[m
[32m+[m[32m    int height = -1;[m
[32m+[m[32m};[m
[32m+[m
 //! Helper for findBlock to selectively return pieces of block data. If block is[m
 //! found, data will be returned by setting specified output variables. If block[m
 //! is not found, output variables will keep their previous values.[m
[36m@@ -50,6 +57,8 @@[m [mpublic:[m
     FoundBlock& mtpTime(int64_t& mtp_time) { m_mtp_time = &mtp_time; return *this; }[m
     //! Return whether block is in the active (most-work) chain.[m
     FoundBlock& inActiveChain(bool& in_active_chain) { m_in_active_chain = &in_active_chain; return *this; }[m
[32m+[m[32m    //! Return locator if block is in the active chain.[m
[32m+[m[32m    FoundBlock& locator(CBlockLocator& locator) { m_locator = &locator; return *this; }[m
     //! Return next block in the active chain if current block is in the active chain.[m
     FoundBlock& nextBlock(const FoundBlock& next_block) { m_next_block = &next_block; return *this; }[m
     //! Read block data from disk. If the block exists but doesn't have data[m
[36m@@ -62,11 +71,28 @@[m [mpublic:[m
     int64_t* m_max_time = nullptr;[m
     int64_t* m_mtp_time = nullptr;[m
     bool* m_in_active_chain = nullptr;[m
[32m+[m[32m    CBlockLocator* m_locator = nullptr;[m
     const FoundBlock* m_next_block = nullptr;[m
     CBlock* m_data = nullptr;[m
     mutable bool found = false;[m
 };[m
 [m
[32m+[m[32m//! Block data sent with blockConnected, blockDisconnected notifications.[m
[32m+[m[32mstruct BlockInfo {[m
[32m+[m[32m    const uint256& hash;[m
[32m+[m[32m    const uint256* prev_hash = nullptr;[m
[32m+[m[32m    int height = -1;[m
[32m+[m[32m    int file_number = -1;[m
[32m+[m[32m    unsigned data_pos = 0;[m
[32m+[m[32m    const CBlock* data = nullptr;[m
[32m+[m[32m    const CBlockUndo* undo_data = nullptr;[m
[32m+[m[32m    //! Block is from the tip of the chain (always true except when first calling attachChain and reading old blocks).[m
[32m+[m[32m    bool chain_tip = true;[m
[32m+[m[32m    std::string error;[m
[32m+[m
[32m+[m[32m    BlockInfo(const uint256& hash) : hash(hash) {}[m
[32m+[m[32m};[m
[32m+[m
 //! Interface giving clients (wallet processes, maybe other analysis tools in[m
 //! the future) ability to access to the chain state, receive notifications,[m
 //! estimate fees, and submit transactions.[m
[36m@@ -108,6 +134,9 @@[m [mpublic:[m
     //! pruned), and contains transactions.[m
     virtual bool haveBlockOnDisk(int height) = 0;[m
 [m
[32m+[m[32m    //! Get tip information.[m
[32m+[m[32m    virtual bool getTip(const FoundBlock& block={}) = 0;[m
[32m+[m
     //! Get locator for the current chain tip.[m
     virtual CBlockLocator getTipLocator() = 0;[m
 [m
[36m@@ -235,15 +264,34 @@[m [mpublic:[m
         virtual ~Notifications() {}[m
         virtual void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) {}[m
         virtual void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) {}[m
[31m-        virtual void blockConnected(const CBlock& block, int height) {}[m
[31m-        virtual void blockDisconnected(const CBlock& block, int height) {}[m
[32m+[m[32m        virtual void blockConnected(const BlockInfo& block) {}[m
[32m+[m[32m        virtual void blockDisconnected(const BlockInfo& block) {}[m
         virtual void updatedBlockTip() {}[m
         virtual void chainStateFlushed(const CBlockLocator& locator) {}[m
     };[m
 [m
[32m+[m[32m    struct NotifyOptions[m
[32m+[m[32m    {[m
[32m+[m[32m        //! Include undo data with block connected notifications.[m
[32m+[m[32m        bool connect_undo_data = false;[m
[32m+[m[32m        //! Include block data with block disconnected notifications.[m
[32m+[m[32m        bool disconnect_data = false;[m
[32m+[m[32m        //! Include undo data with block disconnected notifications.[m
[32m+[m[32m        bool disconnect_undo_data = false;[m
[32m+[m[32m        //! Name to use for sync thread.[m
[32m+[m[32m        const char* thread_name = nullptr;[m
[32m+[m[32m    };[m
[32m+[m
[32m+[m[32m    //! Register handler for notifications if all blocks needed to sync from[m
[32m+[m[32m    //! locator are present. Return null if necessary blocks were pruned.[m
[32m+[m[32m    virtual std::unique_ptr<Handler> attachChain(std::shared_ptr<Notifications> notifications, const CBlockLocator& locator, const NotifyOptions& options) = 0;[m
[32m+[m
     //! Register handler for notifications.[m
     virtual std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) = 0;[m
 [m
[32m+[m[32m    //! Wait for pending notifications.[m
[32m+[m[32m    virtual void waitForNotifications() = 0;[m
[32m+[m
     //! Wait for pending notifications to be processed unless block hash points to the current[m
     //! chain tip.[m
     virtual void waitForNotificationsIfTipChanged(const uint256& old_tip) = 0;[m
[36m@@ -283,6 +331,10 @@[m [mpublic:[m
     //! to be prepared to handle this by ignoring notifications about unknown[m
     //! removed transactions and already added new transactions.[m
     virtual void requestMempoolTransactions(Notifications& notifications) = 0;[m
[32m+[m
[32m+[m[32m    //! Get internal node context. Useful for testing, but not[m
[32m+[m[32m    //! accessible across processes.[m
[32m+[m[32m    virtual node::NodeContext* context() { return nullptr; }[m
 };[m
 [m
 //! Interface to let node manage chain clients (wallets, or maybe tools for[m
[33mdiff --git a/src/interfaces/handler.h b/src/interfaces/handler.h[m
[33mindex 11baf9dd65..75932c113d 100644[m
[33m--- a/src/interfaces/handler.h[m
[33m+++ b/src/interfaces/handler.h[m
[36m@@ -24,7 +24,10 @@[m [mclass Handler[m
 public:[m
     virtual ~Handler() {}[m
 [m
[31m-    //! Disconnect the handler.[m
[32m+[m[32m    //! Interrupt the handler, set flag for notification threads (if any) to quit.[m
[32m+[m[32m    virtual void interrupt() {};[m
[32m+[m
[32m+[m[32m    //! Disconnect the handler, stop receiving notifications.[m
     virtual void disconnect() = 0;[m
 };[m
 [m
[33mdiff --git a/src/net_processing.cpp b/src/net_processing.cpp[m
[33mindex 59cd83e493..3167e36a25 100644[m
[33m--- a/src/net_processing.cpp[m
[33m+++ b/src/net_processing.cpp[m
[36m@@ -2442,7 +2442,7 @@[m [mvoid PeerManagerImpl::ProcessGetCFilters(CNode& peer, CDataStream& vRecv)[m
     }[m
 [m
     std::vector<BlockFilter> filters;[m
[31m-    if (!filter_index->LookupFilterRange(start_height, stop_index, filters)) {[m
[32m+[m[32m    if (!filter_index->LookupFilterRange(start_height, {stop_index->GetBlockHash(), stop_index->nHeight}, filters)) {[m
         LogPrint(BCLog::NET, "Failed to find block filter in index: filter_type=%s, start_height=%d, stop_hash=%s\n",[m
                      BlockFilterTypeName(filter_type), start_height, stop_hash.ToString());[m
         return;[m
[36m@@ -2476,7 +2476,7 @@[m [mvoid PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)[m
     if (start_height > 0) {[m
         const CBlockIndex* const prev_block =[m
             stop_index->GetAncestor(static_cast<int>(start_height - 1));[m
[31m-        if (!filter_index->LookupFilterHeader(prev_block, prev_header)) {[m
[32m+[m[32m        if (!filter_index->LookupFilterHeader({prev_block->GetBlockHash(), prev_block->nHeight}, prev_header)) {[m
             LogPrint(BCLog::NET, "Failed to find block filter header in index: filter_type=%s, block_hash=%s\n",[m
                          BlockFilterTypeName(filter_type), prev_block->GetBlockHash().ToString());[m
             return;[m
[36m@@ -2484,7 +2484,7 @@[m [mvoid PeerManagerImpl::ProcessGetCFHeaders(CNode& peer, CDataStream& vRecv)[m
     }[m
 [m
     std::vector<uint256> filter_hashes;[m
[31m-    if (!filter_index->LookupFilterHashRange(start_height, stop_index, filter_hashes)) {[m
[32m+[m[32m    if (!filter_index->LookupFilterHashRange(start_height, {stop_index->GetBlockHash(), stop_index->nHeight}, filter_hashes)) {[m
         LogPrint(BCLog::NET, "Failed to find block filter hashes in index: filter_type=%s, start_height=%d, stop_hash=%s\n",[m
                      BlockFilterTypeName(filter_type), start_height, stop_hash.ToString());[m
         return;[m
[36m@@ -2524,7 +2524,7 @@[m [mvoid PeerManagerImpl::ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv)[m
         int height = (i + 1) * CFCHECKPT_INTERVAL;[m
         block_index = block_index->GetAncestor(height);[m
 [m
[31m-        if (!filter_index->LookupFilterHeader(block_index, headers[i])) {[m
[32m+[m[32m        if (!filter_index->LookupFilterHeader({block_index->GetBlockHash(), block_index->nHeight}, headers[i])) {[m
             LogPrint(BCLog::NET, "Failed to find block filter header in index: filter_type=%s, block_hash=%s\n",[m
                          BlockFilterTypeName(filter_type), block_index->GetBlockHash().ToString());[m
             return;[m
[33mdiff --git a/src/node/chain.cpp b/src/node/chain.cpp[m
[33mnew file mode 100644[m
[33mindex 0000000000..87c3241467[m
[33m--- /dev/null[m
[33m+++ b/src/node/chain.cpp[m
[36m@@ -0,0 +1,98 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#include <chain.h>[m
[32m+[m[32m#include <chainparams.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
[32m+[m[32m#include <node/chain.h>[m
[32m+[m[32m#include <threadinterrupt.h>[m
[32m+[m[32m#include <uint256.h>[m
[32m+[m[32m#include <undo.h>[m
[32m+[m[32m#include <validation.h>[m
[32m+[m
[32m+[m[32mnamespace node {[m
[32m+[m[32minterfaces::BlockInfo MakeBlockInfo(const CBlockIndex* index, const CBlock* data)[m
[32m+[m[32m{[m
[32m+[m[32m    interfaces::BlockInfo info{index ? *index->phashBlock : uint256::ZERO};[m
[32m+[m[32m    if (index) {[m
[32m+[m[32m        info.prev_hash = index->pprev ? index->pprev->phashBlock : nullptr;[m
[32m+[m[32m        info.height = index->nHeight;[m
[32m+[m[32m        LOCK(::cs_main);[m
[32m+[m[32m        info.file_number = index->nFile;[m
[32m+[m[32m        info.data_pos = index->nDataPos;[m
[32m+[m[32m    }[m
[32m+[m[32m    info.data = data;[m
[32m+[m[32m    return info;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool ReadBlockData(const CBlockIndex* block, CBlock* data, CBlockUndo* undo_data, interfaces::BlockInfo& info)[m
[32m+[m[32m{[m
[32m+[m[32m    if (data) {[m
[2m+[m[2m        auto& consensus_params = Params().GetConsensus();[m
[32m+[m[32m        if (ReadBlockFromDisk(*data, block, consensus_params)) {[m
[32m+[m[32m            info.data = data;[m
[32m+[m[32m        } else {[m
[32m+[m[32m            info.error = strprintf("%s: Failed to read block %s from disk", __func__, block->GetBlockHash().ToString());[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    if (undo_data && block->nHeight > 0) {[m
[32m+[m[32m        if (UndoReadFromDisk(*undo_data, block)) {[m
[32m+[m[32m            info.undo_data = undo_data;[m
[32m+[m[32m        } else {[m
[32m+[m[32m            info.error = strprintf("%s: Failed to read block %s undo data from disk", __func__, block->GetBlockHash().ToString());[m
[32m+[m[32m            return false;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    return true;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool SyncChain(const CChain& chain, const CBlockIndex* block, std::shared_ptr<interfaces::Chain::Notifications> notifications, const CThreadInterrupt& interrupt, std::function<void()> on_sync)[m
[32m+[m[32m{[m
[32m+[m[32m    while (true) {[m
[32m+[m[32m        AssertLockNotHeld(::cs_main);[m
[32m+[m[32m        WAIT_LOCK(::cs_main, main_lock);[m
[32m+[m
[32m+[m[32m        bool rewind = false;[m
[32m+[m[32m        if (!block) {[m
[32m+[m[32m            block = chain.Genesis();[m
[32m+[m[32m        } else if (chain.Contains(block)) {[m
[32m+[m[32m            block = chain.Next(block);[m
[32m+[m[32m        } else {[m
[32m+[m[32m            rewind = true;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if (block) {[m
[32m+[m[32m            // Release cs_main while reading block data and sending notifications.[m
[32m+[m[32m            REVERSE_LOCK(main_lock);[m
[32m+[m[32m            interfaces::BlockInfo block_info = MakeBlockInfo(block);[m
[32m+[m[32m            block_info.chain_tip = false;[m
[32m+[m[32m            CBlock data;[m
[32m+[m[32m            CBlockUndo undo_data;[m
[32m+[m[32m            ReadBlockData(block, &data, &undo_data, block_info);[m
[32m+[m[32m            if (rewind) {[m
[32m+[m[32m                notifications->blockDisconnected(block_info);[m
[32m+[m[32m                block = Assert(block->pprev);[m
[32m+[m[32m            } else {[m
[32m+[m[32m                notifications->blockConnected(block_info);[m
[32m+[m[32m            }[m
[32m+[m[32m        } else {[m
[32m+[m[32m            block = chain.Tip();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        bool synced = block == chain.Tip();[m
[32m+[m[32m        if (synced || interrupt) {[m
[32m+[m[32m            if (synced && on_sync) on_sync();[m
[32m+[m[32m            if (block) {[m
[32m+[m[32m                CBlockLocator locator = chain.GetLocator(block);[m
[32m+[m[32m                // Release cs_main while calling notification handlers.[m
[32m+[m[32m                REVERSE_LOCK(main_lock);[m
[32m+[m[32m                if (synced) notifications->blockConnected(MakeBlockInfo(block));[m
[32m+[m[32m                notifications->chainStateFlushed(locator);[m
[32m+[m[32m            }[m
[32m+[m[32m            return synced;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m[32m} // namespace node[m
[33mdiff --git a/src/node/chain.h b/src/node/chain.h[m
[33mnew file mode 100644[m
[33mindex 0000000000..e41effc122[m
[33m--- /dev/null[m
[33m+++ b/src/node/chain.h[m
[36m@@ -0,0 +1,42 @@[m
[32m+[m[32m// Copyright (c) 2022 The Bitcoin Core developers[m
[32m+[m[32m// Distributed under the MIT software license, see the accompanying[m
[32m+[m[32m// file COPYING or http://www.opensource.org/licenses/mit-license.php.[m
[32m+[m
[32m+[m[32m#ifndef BITCOIN_NODE_CHAIN_H[m
[32m+[m[32m#define BITCOIN_NODE_CHAIN_H[m
[32m+[m
[32m+[m[32m#include <interfaces/chain.h>[m
[32m+[m
[32m+[m[32m#include <functional>[m
[32m+[m
[32m+[m[32mclass CBlock;[m
[32m+[m[32mclass CBlockIndex;[m
[32m+[m[32mclass CChain;[m
[32m+[m[32mclass CThreadInterrupt;[m
[32m+[m
[32m+[m[32mnamespace node {[m
[32m+[m[32m//! Return data from block index.[m
[32m+[m[32minterfaces::BlockInfo MakeBlockInfo(const CBlockIndex* block_index, const CBlock* data = nullptr);[m
[32m+[m
[32m+[m[32m//! Read block data and/or undo data from disk and update BlockInfo with pointers and errors.[m
[32m+[m[32mbool ReadBlockData(const CBlockIndex* block, CBlock* data, CBlockUndo* undo_data, interfaces::BlockInfo& info);[m
[32m+[m
[32m+[m[32m//! Send blockConnected and blockDisconnected notifications needed to sync from[m
[32m+[m[32m//! a specified block to the chain tip. This sync function locks the ::cs_main[m
[32m+[m[32m//! mutex intermittently, releasing it while sending notifications and reading[m
[32m+[m[32m//! block data, so it follows the tip if the tip changes, and follows any[m
[32m+[m[32m//! reorgs.[m
[32m+[m[32m//![m
[32m+[m[32m//! @param chain - chain to sync to[m
[32m+[m[32m//! @param block - starting block to sync from[m
[32m+[m[32m//! @param notifications - object to send notifications to[m
[32m+[m[32m//! @param interrupt - flag to interrupt the sync[m
[32m+[m[32m//! @param on_sync - optional callback invoked when reaching the chain tip[m
[32m+[m[32m//!                  while cs_main is still held, before sending a final[m
[32m+[m[32m//!                  blockConnected notification. This can be used to[m
[32m+[m[32m//!                  synchronously register for new notifications.[m
[32m+[m[32m//! @return true if synced, false if interrupted[m
[32m+[m[32mbool SyncChain(const CChain& chain, const CBlockIndex* block, std::shared_ptr<interfaces::Chain::Notifications> notifications, const CThreadInterrupt& interrupt, std::function<void()> on_sync);[m
[32m+[m[32m} // namespace node[m
[32m+[m
[32m+[m[32m#endif // BITCOIN_NODE_CHAIN_H[m
[33mdiff --git a/src/node/coinstats.cpp b/src/node/coinstats.cpp[m
[33mindex eed43a1bc7..a944f38685 100644[m
[33m--- a/src/node/coinstats.cpp[m
[33m+++ b/src/node/coinstats.cpp[m
[36m@@ -108,7 +108,7 @@[m [mstatic bool GetUTXOStats(CCoinsView* view, BlockManager& blockman, CCoinsStats&[m
     // Use CoinStatsIndex if it is requested and available and a hash_type of Muhash or None was requested[m
     if ((stats.m_hash_type == CoinStatsHashType::MUHASH || stats.m_hash_type == CoinStatsHashType::NONE) && g_coin_stats_index && stats.index_requested) {[m
         stats.index_used = true;[m
[31m-        return g_coin_stats_index->LookUpStats(pindex, stats);[m
[32m+[m[32m        return g_coin_stats_index->LookUpStats({pindex->GetBlockHash(), pindex->nHeight}, stats);[m
     }[m
 [m
     PrepareHash(hash_obj, stats);[m
[33mdiff --git a/src/node/interfaces.cpp b/src/node/interfaces.cpp[m
[33mindex 74d53d2062..48ca94974f 100644[m
[33m--- a/src/node/interfaces.cpp[m
[33m+++ b/src/node/interfaces.cpp[m
[36m@@ -19,6 +19,7 @@[m
 #include <netaddress.h>[m
 #include <netbase.h>[m
 #include <node/blockstorage.h>[m
[32m+[m[32m#include <node/chain.h>[m
 #include <node/coin.h>[m
 #include <node/context.h>[m
 #include <node/transaction.h>[m
[36m@@ -38,9 +39,12 @@[m
 #include <timedata.h>[m
 #include <txmempool.h>[m
 #include <uint256.h>[m
[32m+[m[32m#include <undo.h>[m
 #include <univalue.h>[m
 #include <util/check.h>[m
[32m+[m[32m#include <util/syscall_sandbox.h>[m
 #include <util/system.h>[m
[32m+[m[32m#include <util/thread.h>[m
 #include <util/translation.h>[m
 #include <validation.h>[m
 #include <validationinterface.h>[m
[36m@@ -51,6 +55,7 @@[m
 #endif[m
 [m
 #include <any>[m
[32m+[m[32m#include <future>[m
 #include <memory>[m
 #include <optional>[m
 #include <utility>[m
[36m@@ -352,6 +357,7 @@[m [mbool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec[m
     if (block.m_max_time) *block.m_max_time = index->GetBlockTimeMax();[m
     if (block.m_mtp_time) *block.m_mtp_time = index->GetMedianTimePast();[m
     if (block.m_in_active_chain) *block.m_in_active_chain = active[index->nHeight] == index;[m
[32m+[m[32m    if (block.m_locator) { *block.m_locator = active.GetLocator(index); }[m
     if (block.m_next_block) FillBlock(active[index->nHeight] == index ? active[index->nHeight + 1] : nullptr, *block.m_next_block, lock, active);[m
     if (block.m_data) {[m
         REVERSE_LOCK(lock);[m
[36m@@ -364,8 +370,8 @@[m [mbool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<Rec[m
 class NotificationsProxy : public CValidationInterface[m
 {[m
 public:[m
[31m-    explicit NotificationsProxy(std::shared_ptr<Chain::Notifications> notifications)[m
[31m-        : m_notifications(std::move(notifications)) {}[m
[32m+[m[32m    explicit NotificationsProxy(std::shared_ptr<Chain::Notifications> notifications, const Chain::NotifyOptions& options)[m
[32m+[m[32m        : m_notifications(std::move(notifications)), m_options(options) {}[m
     virtual ~NotificationsProxy() = default;[m
     void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override[m
     {[m
[36m@@ -377,37 +383,67 @@[m [mpublic:[m
     }[m
     void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override[m
     {[m
[31m-        m_notifications->blockConnected(*block, index->nHeight);[m
[32m+[m[32m        interfaces::BlockInfo block_info = MakeBlockInfo(index, block.get());[m
[32m+[m[32m        CBlockUndo undo_data;[m
[32m+[m[32m        ReadBlockData(index, /*data=*/nullptr, m_options.connect_undo_data ? &undo_data : nullptr, block_info);[m
[32m+[m[32m        m_notifications->blockConnected(block_info);[m
     }[m
     void BlockDisconnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override[m
     {[m
[31m-        m_notifications->blockDisconnected(*block, index->nHeight);[m
[32m+[m[32m        interfaces::BlockInfo block_info = MakeBlockInfo(index, block.get());[m
[32m+[m[32m        CBlockUndo undo_data;[m
[32m+[m[32m        ReadBlockData(index, /*data=*/nullptr, m_options.disconnect_undo_data ? &undo_data : nullptr, block_info);[m
[32m+[m[32m        m_notifications->blockDisconnected(block_info);[m
     }[m
     void UpdatedBlockTip(const CBlockIndex* index, const CBlockIndex* fork_index, bool is_ibd) override[m
     {[m
         m_notifications->updatedBlockTip();[m
     }[m
     void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->chainStateFlushed(locator); }[m
[32m+[m[32m    bool connect()[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(m_mutex);[m
[32m+[m[32m        bool unregistered = m_state == UNREGISTERED;[m
[32m+[m[32m        if (unregistered) m_state = REGISTERED;[m
[32m+[m[32m        return unregistered;[m
[32m+[m[32m    }[m
[32m+[m[32m    bool disconnect()[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(m_mutex);[m
[32m+[m[32m        bool registered = m_state == REGISTERED;[m
[32m+[m[32m        m_state = DISCONNECTED;[m
[32m+[m[32m        return registered;[m
[32m+[m[32m    }[m
     std::shared_ptr<Chain::Notifications> m_notifications;[m
[32m+[m[32m    Chain::NotifyOptions m_options;[m
[32m+[m[32m    Mutex m_mutex;[m
[32m+[m[32m    enum { UNREGISTERED, REGISTERED, DISCONNECTED } m_state = UNREGISTERED;[m
 };[m
 [m
 class NotificationsHandlerImpl : public Handler[m
 {[m
 public:[m
[31m-    explicit NotificationsHandlerImpl(std::shared_ptr<Chain::Notifications> notifications)[m
[31m-        : m_proxy(std::make_shared<NotificationsProxy>(std::move(notifications)))[m
[32m+[m[32m    explicit NotificationsHandlerImpl(std::shared_ptr<Chain::Notifications> notifications, const Chain::NotifyOptions& options, bool connect)[m
[32m+[m[32m        : m_proxy(std::make_shared<NotificationsProxy>(std::move(notifications), options))[m
     {[m
[31m-        RegisterSharedValidationInterface(m_proxy);[m
[32m+[m[32m        if (connect && m_proxy->connect()) RegisterSharedValidationInterface(m_proxy);[m
     }[m
     ~NotificationsHandlerImpl() override { disconnect(); }[m
[32m+[m[32m    void interrupt() override { m_interrupt(); }[m
     void disconnect() override[m
     {[m
[32m+[m[32m        m_interrupt();[m
         if (m_proxy) {[m
[31m-            UnregisterSharedValidationInterface(m_proxy);[m
[32m+[m[32m            if (m_proxy->disconnect()) UnregisterSharedValidationInterface(m_proxy);[m
             m_proxy.reset();[m
         }[m
[32m+[m[32m        if (m_thread_sync.joinable()) {[m
[32m+[m[32m            m_thread_sync.join();[m
[32m+[m[32m        }[m
     }[m
     std::shared_ptr<NotificationsProxy> m_proxy;[m
[2m+[m[2m    std::thread m_thread_sync;[m
[2m+[m[2m    CThreadInterrupt m_interrupt;[m
 };[m
 [m
 class RpcHandlerImpl : public Handler[m
[36m@@ -480,6 +516,12 @@[m [mpublic:[m
         CBlockIndex* block = active[height];[m
         return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;[m
     }[m
[32m+[m[32m    bool getTip(const FoundBlock& block) override[m
[32m+[m[32m    {[m
[32m+[m[32m        WAIT_LOCK(cs_main, lock);[m
[32m+[m[32m        const CChain& active = Assert(m_node.chainman)->ActiveChain();[m
[32m+[m[32m        return FillBlock(active.Tip(), block, lock, active);[m
[32m+[m[32m    }[m
     CBlockLocator getTipLocator() override[m
     {[m
         LOCK(cs_main);[m
[36m@@ -658,9 +700,92 @@[m [mpublic:[m
     {[m
         ::uiInterface.ShowProgress(title, progress, resume_possible);[m
     }[m
[32m+[m[32m    bool checkBlocks(const CBlockIndex* locator_block) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {[m
[32m+[m[32m        const CChain& active_chain = Assert(m_node.chainman)->ActiveChain();[m
[2m+[m[2m        bool prune_violation = false;[m
[32m+[m[32m        if (!locator_block) {[m
[2m+[m[2m            // make sure we have all block data back to the genesis[m
[2m+[m[2m            const CBlockIndex* block = active_chain.Tip();[m
[2m+[m[2m            while (block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA)) {[m
[2m+[m[2m                block = block->pprev;[m
[2m+[m[2m            }[m
[2m+[m[2m            prune_violation = block != active_chain.Genesis();[m
[32m+[m[32m        }[m
[2m+[m[2m        // in case the index has a best block set and is not fully synced[m
[2m+[m[2m        // check if we have the required blocks to continue building the index[m
[2m+[m[2m        else {[m
[32m+[m[32m            const CBlockIndex* block_to_test = locator_block;[m
[2m+[m[2m            if (!active_chain.Contains(block_to_test)) {[m
[2m+[m[2m                // if the bestblock is not part of the mainchain, find the fork[m
[2m+[m[2m                // and make sure we have all data down to the fork[m
[2m+[m[2m                block_to_test = active_chain.FindFork(block_to_test);[m
[2m+[m[2m            }[m
[2m+[m[2m            const CBlockIndex* block = active_chain.Tip();[m
[2m+[m[2m            prune_violation = true;[m
[2m+[m[2m            // check backwards from the tip if we have all block data until we reach the indexes bestblock[m
[2m+[m[2m            while (block_to_test && block && (block->nStatus & BLOCK_HAVE_DATA)) {[m
[2m+[m[2m                if (block_to_test == block) {[m
[2m+[m[2m                    prune_violation = false;[m
[2m+[m[2m                    break;[m
[2m+[m[2m                }[m
[2m+[m[2m                // block->pprev must exist at this point, since block_to_test is part of the chain[m
[2m+[m[2m                // and thus must be encountered when going backwards from the tip[m
[2m+[m[2m                assert(block->pprev);[m
[2m+[m[2m                block = block->pprev;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return !prune_violation;[m
[32m+[m[32m    }[m
[32m+[m[32m    std::unique_ptr<Handler> attachChain(std::shared_ptr<Notifications> notifications, const CBlockLocator& locator, const NotifyOptions& options) override[m
[32m+[m[32m    {[m
[32m+[m[32m        std::unique_ptr<NotificationsHandlerImpl> handler;[m
[32m+[m[32m        std::optional<interfaces::BlockInfo> block_info;[m
[32m+[m[32m        // std::promise to wait for the first blockConnected notification, so[m
[32m+[m[32m        // caller is notified about the starting block before this returns.[m
[32m+[m[32m        // It might be good in the future to return without waiting for this,[m
[32m+[m[32m        // and allow more initialization code to run in parallel.[m
[32m+[m[32m        std::promise<void> promise;[m
[32m+[m[32m        {[m
[32m+[m[32m        // Lock cs_main while finding forks and determining which blocks to[m
[32m+[m[32m        // rescan. Release cs_main while processing blocks and while calling[m
[32m+[m[32m        // RegisterSharedValidationInterface in the notifications thread.[m
[32m+[m[32m        //[m
[32m+[m[32m        // To prevent older, stale notifications being received, it is important[m
[32m+[m[32m        // to connect the notifications proxy asynchronously inside the[m
[32m+[m[32m        // validation queue, so older notifications in the queue are cleared[m
[32m+[m[32m        // before the proxy becomes active.[m
[32m+[m[32m        //[m
[32m+[m[32m        // To prevent new notifications that may be happening in the background[m
[32m+[m[32m        // from being lost, it is important to keep cs_main locked while calling[m
[32m+[m[32m        // CallFunctionInValidationInterfaceQueue, so the new notifications will[m
[32m+[m[32m        // be added to the queue after the queue entry which connects the proxy.[m
[32m+[m[32m        AssertLockNotHeld(::cs_main);[m
[32m+[m[32m        LOCK(cs_main);[m
[32m+[m[32m        const CChainState& active = Assert(m_node.chainman)->ActiveChainstate();[m
[32m+[m[32m        const CBlockIndex* locator_block = locator.IsNull() ? nullptr : active.FindForkInGlobalIndex(locator);[m
[32m+[m[32m        block_info.emplace(MakeBlockInfo(locator_block));[m
[32m+[m[32m        block_info->chain_tip = locator_block == active.m_chain.Tip();[m
[32m+[m[32m        if (!block_info->chain_tip && !checkBlocks(locator_block)) return nullptr;[m
[32m+[m[32m        handler = std::make_unique<NotificationsHandlerImpl>(notifications, options, /*connect=*/false);[m
[32m+[m[32m        handler->m_thread_sync = std::thread(&util::TraceThread, options.thread_name,[m
[32m+[m[32m            [&block_info, &promise, &active, locator_block, notifications, &interrupt = handler->m_interrupt, proxy = handler->m_proxy] {[m
[32m+[m[32m            SetSyscallSandboxPolicy(SyscallSandboxPolicy::TX_INDEX);[m
[32m+[m[32m            notifications->blockConnected(*block_info);[m
[32m+[m[32m            promise.set_value();[m
[32m+[m[32m            SyncChain(active.m_chain, locator_block, notifications, interrupt,[m
[32m+[m[32m                      /*on_sync=*/[proxy] { CallFunctionInValidationInterfaceQueue([proxy] { if (proxy->connect()) RegisterSharedValidationInterface(proxy); }); });[m
[32m+[m[32m        });[m
[32m+[m[32m        }[m
[32m+[m[32m        promise.get_future().wait();[m
[32m+[m[32m        return handler;[m
[32m+[m[32m    }[m
     std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) override[m
     {[m
[31m-        return std::make_unique<NotificationsHandlerImpl>(std::move(notifications));[m
[32m+[m[32m        return std::make_unique<NotificationsHandlerImpl>(std::move(notifications), Chain::NotifyOptions{}, /*connect=*/true);[m
[32m+[m[32m    }[m
[32m+[m[32m    void waitForNotifications() override[m
[32m+[m[32m    {[m
[32m+[m[32m        SyncWithValidationInterfaceQueue();[m
     }[m
     void waitForNotificationsIfTipChanged(const uint256& old_tip) override[m
     {[m
[36m@@ -718,6 +843,7 @@[m [mpublic:[m
             notifications.transactionAddedToMempool(entry.GetSharedTx(), 0 /* mempool_sequence */);[m
         }[m
     }[m
[32m+[m[32m    NodeContext* context() override { return &m_node; }[m
     NodeContext& m_node;[m
 };[m
 } // namespace[m
[33mdiff --git a/src/rest.cpp b/src/rest.cpp[m
[33mindex 4b6bb7ecaf..8346bc7b76 100644[m
[33m--- a/src/rest.cpp[m
[33m+++ b/src/rest.cpp[m
[36m@@ -403,7 +403,7 @@[m [mstatic bool rest_filter_header(const std::any& context, HTTPRequest* req, const[m
     filter_headers.reserve(*parsed_count);[m
     for (const CBlockIndex* pindex : headers) {[m
         uint256 filter_header;[m
[31m-        if (!index->LookupFilterHeader(pindex, filter_header)) {[m
[32m+[m[32m        if (!index->LookupFilterHeader({pindex->GetBlockHash(), pindex->nHeight}, filter_header)) {[m
             std::string errmsg = "Filter not found.";[m
 [m
             if (!index_ready) {[m
[36m@@ -503,7 +503,7 @@[m [mstatic bool rest_block_filter(const std::any& context, HTTPRequest* req, const s[m
     bool index_ready = index->BlockUntilSyncedToCurrentChain();[m
 [m
     BlockFilter filter;[m
[31m-    if (!index->LookupFilter(block_index, filter)) {[m
[32m+[m[32m    if (!index->LookupFilter({block_index->GetBlockHash(), block_index->nHeight}, filter)) {[m
         std::string errmsg = "Filter not found.";[m
 [m
         if (!block_was_connected) {[m
[33mdiff --git a/src/rpc/blockchain.cpp b/src/rpc/blockchain.cpp[m
[33mindex 35b5b979eb..053a7b3adb 100644[m
[33m--- a/src/rpc/blockchain.cpp[m
[33m+++ b/src/rpc/blockchain.cpp[m
[36m@@ -2222,8 +2222,8 @@[m [mstatic RPCHelpMan getblockfilter()[m
 [m
     BlockFilter filter;[m
     uint256 filter_header;[m
[31m-    if (!index->LookupFilter(block_index, filter) ||[m
[31m-        !index->LookupFilterHeader(block_index, filter_header)) {[m
[32m+[m[32m    if (!index->LookupFilter({block_index->GetBlockHash(), block_index->nHeight}, filter) ||[m
[32m+[m[32m        !index->LookupFilterHeader({block_index->GetBlockHash(), block_index->nHeight}, filter_header)) {[m
         int err_code;[m
         std::string errmsg = "Filter not found.";[m
 [m
[33mdiff --git a/src/test/blockfilter_index_tests.cpp b/src/test/blockfilter_index_tests.cpp[m
[33mindex 7c502349b3..6faed78324 100644[m
[33m--- a/src/test/blockfilter_index_tests.cpp[m
[33m+++ b/src/test/blockfilter_index_tests.cpp[m
[36m@@ -6,6 +6,7 @@[m
 #include <chainparams.h>[m
 #include <consensus/validation.h>[m
 #include <index/blockfilterindex.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <node/miner.h>[m
 #include <pow.h>[m
 #include <script/standard.h>[m
[36m@@ -41,10 +42,10 @@[m [mstatic bool CheckFilterLookups(BlockFilterIndex& filter_index, const CBlockIndex[m
     std::vector<BlockFilter> filters;[m
     std::vector<uint256> filter_hashes;[m
 [m
[31m-    BOOST_CHECK(filter_index.LookupFilter(block_index, filter));[m
[31m-    BOOST_CHECK(filter_index.LookupFilterHeader(block_index, filter_header));[m
[31m-    BOOST_CHECK(filter_index.LookupFilterRange(block_index->nHeight, block_index, filters));[m
[31m-    BOOST_CHECK(filter_index.LookupFilterHashRange(block_index->nHeight, block_index,[m
[32m+[m[32m    BOOST_CHECK(filter_index.LookupFilter({block_index->GetBlockHash(), block_index->nHeight}, filter));[m
[32m+[m[32m    BOOST_CHECK(filter_index.LookupFilterHeader({block_index->GetBlockHash(), block_index->nHeight}, filter_header));[m
[32m+[m[32m    BOOST_CHECK(filter_index.LookupFilterRange(block_index->nHeight, {block_index->GetBlockHash(), block_index->nHeight}, filters));[m
[32m+[m[32m    BOOST_CHECK(filter_index.LookupFilterHashRange(block_index->nHeight, {block_index->GetBlockHash(), block_index->nHeight},[m
                                                    filter_hashes));[m
 [m
     BOOST_CHECK_EQUAL(filters.size(), 1U);[m
[36m@@ -108,7 +109,7 @@[m [mbool BuildChainTestingSetup::BuildChain(const CBlockIndex* pindex,[m
 [m
 BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)[m
 {[m
[31m-    BlockFilterIndex filter_index(BlockFilterType::BASIC, 1 << 20, true);[m
[32m+[m[32m    BlockFilterIndex filter_index(interfaces::MakeChain(m_node), BlockFilterType::BASIC, 1 << 20, true);[m
 [m
     uint256 last_header;[m
 [m
[36m@@ -124,10 +125,10 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)[m
         for (const CBlockIndex* block_index = m_node.chainman->ActiveChain().Genesis();[m
              block_index != nullptr;[m
              block_index = m_node.chainman->ActiveChain().Next(block_index)) {[m
[31m-            BOOST_CHECK(!filter_index.LookupFilter(block_index, filter));[m
[31m-            BOOST_CHECK(!filter_index.LookupFilterHeader(block_index, filter_header));[m
[31m-            BOOST_CHECK(!filter_index.LookupFilterRange(block_index->nHeight, block_index, filters));[m
[31m-            BOOST_CHECK(!filter_index.LookupFilterHashRange(block_index->nHeight, block_index,[m
[32m+[m[32m            BOOST_CHECK(!filter_index.LookupFilter({block_index->GetBlockHash(), block_index->nHeight}, filter));[m
[32m+[m[32m            BOOST_CHECK(!filter_index.LookupFilterHeader({block_index->GetBlockHash(), block_index->nHeight}, filter_header));[m
[32m+[m[32m            BOOST_CHECK(!filter_index.LookupFilterRange(block_index->nHeight, {block_index->GetBlockHash(), block_index->nHeight}, filters));[m
[32m+[m[32m            BOOST_CHECK(!filter_index.LookupFilterHashRange(block_index->nHeight, {block_index->GetBlockHash(), block_index->nHeight},[m
                                                             filter_hashes));[m
         }[m
     }[m
[36m@@ -135,7 +136,7 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)[m
     // BlockUntilSyncedToCurrentChain should return false before index is started.[m
     BOOST_CHECK(!filter_index.BlockUntilSyncedToCurrentChain());[m
 [m
[31m-    BOOST_REQUIRE(filter_index.Start(m_node.chainman->ActiveChainstate()));[m
[32m+[m[32m    BOOST_REQUIRE(filter_index.Start());[m
 [m
     // Allow filter index to catch up with the block index.[m
     constexpr int64_t timeout_ms = 10 * 1000;[m
[36m@@ -256,8 +257,8 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, BuildChainTestingSetup)[m
         LOCK(cs_main);[m
         tip = m_node.chainman->ActiveChain().Tip();[m
     }[m
[31m-    BOOST_CHECK(filter_index.LookupFilterRange(0, tip, filters));[m
[31m-    BOOST_CHECK(filter_index.LookupFilterHashRange(0, tip, filter_hashes));[m
[32m+[m[32m    BOOST_CHECK(filter_index.LookupFilterRange(0, {tip->GetBlockHash(), tip->nHeight}, filters));[m
[32m+[m[32m    BOOST_CHECK(filter_index.LookupFilterHashRange(0, {tip->GetBlockHash(), tip->nHeight}, filter_hashes));[m
 [m
     assert(tip->nHeight >= 0);[m
     BOOST_CHECK_EQUAL(filters.size(), tip->nHeight + 1U);[m
[36m@@ -277,14 +278,14 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_init_destroy, BasicTestingSetup)[m
     filter_index = GetBlockFilterIndex(BlockFilterType::BASIC);[m
     BOOST_CHECK(filter_index == nullptr);[m
 [m
[31m-    BOOST_CHECK(InitBlockFilterIndex(BlockFilterType::BASIC, 1 << 20, true, false));[m
[32m+[m[32m    BOOST_CHECK(InitBlockFilterIndex([&]{ return interfaces::MakeChain(m_node); }, BlockFilterType::BASIC, 1 << 20, true, false));[m
 [m
     filter_index = GetBlockFilterIndex(BlockFilterType::BASIC);[m
     BOOST_CHECK(filter_index != nullptr);[m
     BOOST_CHECK(filter_index->GetFilterType() == BlockFilterType::BASIC);[m
 [m
     // Initialize returns false if index already exists.[m
[31m-    BOOST_CHECK(!InitBlockFilterIndex(BlockFilterType::BASIC, 1 << 20, true, false));[m
[32m+[m[32m    BOOST_CHECK(!InitBlockFilterIndex([&]{ return interfaces::MakeChain(m_node); }, BlockFilterType::BASIC, 1 << 20, true, false));[m
 [m
     int iter_count = 0;[m
     ForEachBlockFilterIndex([&iter_count](BlockFilterIndex& _index) { iter_count++; });[m
[36m@@ -299,7 +300,7 @@[m [mBOOST_FIXTURE_TEST_CASE(blockfilter_index_init_destroy, BasicTestingSetup)[m
     BOOST_CHECK(filter_index == nullptr);[m
 [m
     // Reinitialize index.[m
[31m-    BOOST_CHECK(InitBlockFilterIndex(BlockFilterType::BASIC, 1 << 20, true, false));[m
[32m+[m[32m    BOOST_CHECK(InitBlockFilterIndex([&]{ return interfaces::MakeChain(m_node); }, BlockFilterType::BASIC, 1 << 20, true, false));[m
 [m
     DestroyAllBlockFilterIndexes();[m
 [m
[33mdiff --git a/src/test/coinstatsindex_tests.cpp b/src/test/coinstatsindex_tests.cpp[m
[33mindex 5b73481bc1..ea67b8b304 100644[m
[33m--- a/src/test/coinstatsindex_tests.cpp[m
[33m+++ b/src/test/coinstatsindex_tests.cpp[m
[36m@@ -4,6 +4,7 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/coinstatsindex.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <test/util/setup_common.h>[m
 #include <test/util/validation.h>[m
 #include <util/time.h>[m
[36m@@ -31,7 +32,7 @@[m [mstatic void IndexWaitSynced(BaseIndex& index)[m
 [m
 BOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)[m
 {[m
[31m-    CoinStatsIndex coin_stats_index{1 << 20, true};[m
[32m+[m[32m    CoinStatsIndex coin_stats_index{interfaces::MakeChain(m_node), 1 << 20, true};[m
 [m
     CCoinsStats coin_stats{CoinStatsHashType::MUHASH};[m
     const CBlockIndex* block_index;[m
[36m@@ -41,13 +42,13 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)[m
     }[m
 [m
     // CoinStatsIndex should not be found before it is started.[m
[31m-    BOOST_CHECK(!coin_stats_index.LookUpStats(block_index, coin_stats));[m
[32m+[m[32m    BOOST_CHECK(!coin_stats_index.LookUpStats({block_index->GetBlockHash(), block_index->nHeight}, coin_stats));[m
 [m
     // BlockUntilSyncedToCurrentChain should return false before CoinStatsIndex[m
     // is started.[m
     BOOST_CHECK(!coin_stats_index.BlockUntilSyncedToCurrentChain());[m
 [m
[31m-    BOOST_REQUIRE(coin_stats_index.Start(m_node.chainman->ActiveChainstate()));[m
[32m+[m[32m    BOOST_REQUIRE(coin_stats_index.Start());[m
 [m
     IndexWaitSynced(coin_stats_index);[m
 [m
[36m@@ -57,10 +58,10 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)[m
         LOCK(cs_main);[m
         genesis_block_index = m_node.chainman->ActiveChain().Genesis();[m
     }[m
[31m-    BOOST_CHECK(coin_stats_index.LookUpStats(genesis_block_index, coin_stats));[m
[32m+[m[32m    BOOST_CHECK(coin_stats_index.LookUpStats({genesis_block_index->GetBlockHash(), genesis_block_index->nHeight}, coin_stats));[m
 [m
     // Check that CoinStatsIndex updates with new blocks.[m
[31m-    coin_stats_index.LookUpStats(block_index, coin_stats);[m
[32m+[m[32m    coin_stats_index.LookUpStats({block_index->GetBlockHash(), block_index->nHeight}, coin_stats);[m
 [m
     const CScript script_pub_key{CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG};[m
     std::vector<CMutableTransaction> noTxns;[m
[36m@@ -75,7 +76,7 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_initial_sync, TestChain100Setup)[m
         LOCK(cs_main);[m
         new_block_index = m_node.chainman->ActiveChain().Tip();[m
     }[m
[31m-    coin_stats_index.LookUpStats(new_block_index, new_coin_stats);[m
[32m+[m[32m    coin_stats_index.LookUpStats({new_block_index->GetBlockHash(), new_block_index->nHeight}, new_coin_stats);[m
 [m
     BOOST_CHECK(block_index != new_block_index);[m
 [m
[36m@@ -92,8 +93,8 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)[m
     CChainState& chainstate = Assert(m_node.chainman)->ActiveChainstate();[m
     const CChainParams& params = Params();[m
     {[m
[31m-        CoinStatsIndex index{1 << 20};[m
[31m-        BOOST_REQUIRE(index.Start(chainstate));[m
[32m+[m[32m        CoinStatsIndex index{interfaces::MakeChain(m_node), 1 << 20};[m
[32m+[m[32m        BOOST_REQUIRE(index.Start());[m
         IndexWaitSynced(index);[m
         std::shared_ptr<const CBlock> new_block;[m
         CBlockIndex* new_block_index = nullptr;[m
[36m@@ -113,14 +114,15 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)[m
         // Send block connected notification, then stop the index without[m
         // sending a chainstate flushed notification. Prior to #24138, this[m
         // would cause the index to be corrupted and fail to reload.[m
[31m-        ValidationInterfaceTest::BlockConnected(index, new_block, new_block_index);[m
[32m+[m[32m        GetMainSignals().BlockConnected(new_block, new_block_index);[m
[32m+[m[32m        SyncWithValidationInterfaceQueue();[m
         index.Stop();[m
     }[m
 [m
     {[m
[31m-        CoinStatsIndex index{1 << 20};[m
[32m+[m[32m        CoinStatsIndex index{interfaces::MakeChain(m_node), 1 << 20};[m
         // Make sure the index can be loaded.[m
[31m-        BOOST_REQUIRE(index.Start(chainstate));[m
[32m+[m[32m        BOOST_REQUIRE(index.Start());[m
         index.Stop();[m
     }[m
 }[m
[33mdiff --git a/src/test/txindex_tests.cpp b/src/test/txindex_tests.cpp[m
[33mindex 15213f826b..62c7ddb673 100644[m
[33m--- a/src/test/txindex_tests.cpp[m
[33m+++ b/src/test/txindex_tests.cpp[m
[36m@@ -4,6 +4,7 @@[m
 [m
 #include <chainparams.h>[m
 #include <index/txindex.h>[m
[32m+[m[32m#include <interfaces/chain.h>[m
 #include <script/standard.h>[m
 #include <test/util/setup_common.h>[m
 #include <util/time.h>[m
[36m@@ -15,7 +16,7 @@[m [mBOOST_AUTO_TEST_SUITE(txindex_tests)[m
 [m
 BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)[m
 {[m
[31m-    TxIndex txindex(1 << 20, true);[m
[32m+[m[32m    TxIndex txindex(interfaces::MakeChain(m_node), 1 << 20, true);[m
 [m
     CTransactionRef tx_disk;[m
     uint256 block_hash;[m
[36m@@ -28,7 +29,7 @@[m [mBOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)[m
     // BlockUntilSyncedToCurrentChain should return false before txindex is started.[m
     BOOST_CHECK(!txindex.BlockUntilSyncedToCurrentChain());[m
 [m
[31m-    BOOST_REQUIRE(txindex.Start(m_node.chainman->ActiveChainstate()));[m
[32m+[m[32m    BOOST_REQUIRE(txindex.Start());[m
 [m
     // Allow tx index to catch up with the block index.[m
     constexpr int64_t timeout_ms = 10 * 1000;[m
[33mdiff --git a/src/wallet/test/fuzz/notifications.cpp b/src/wallet/test/fuzz/notifications.cpp[m
[33mindex 1c16da25bd..8685c1e3af 100644[m
[33m--- a/src/wallet/test/fuzz/notifications.cpp[m
[33m+++ b/src/wallet/test/fuzz/notifications.cpp[m
[36m@@ -138,8 +138,14 @@[m [mFUZZ_TARGET_INIT(wallet_notifications, initialize_setup)[m
                     block.vtx.emplace_back(MakeTransactionRef(tx));[m
                 }[m
                 // Mine block[m
[31m-                a.wallet->blockConnected(block, chain.size());[m
[31m-                b.wallet->blockConnected(block, chain.size());[m
[32m+[m[32m                const uint256& hash = block.GetHash();[m
[32m+[m[32m                const uint256& prev_hash = std::get<1>(chain.back()).GetHash();[m
[32m+[m[32m                interfaces::BlockInfo info{hash};[m
[32m+[m[32m                info.prev_hash = &prev_hash;[m
[32m+[m[32m                info.height = chain.size();[m
[32m+[m[32m                info.data = &block;[m
[32m+[m[32m                a.wallet->blockConnected(info);[m
[32m+[m[32m                b.wallet->blockConnected(info);[m
                 // Store the coins for the next block[m
                 Coins coins_new;[m
                 for (const auto& tx : block.vtx) {[m
[36m@@ -155,8 +161,14 @@[m [mFUZZ_TARGET_INIT(wallet_notifications, initialize_setup)[m
                 auto& [coins, block]{chain.back()};[m
                 if (block.vtx.empty()) return; // Can only disconnect if the block was submitted first[m
                 // Disconnect block[m
[31m-                a.wallet->blockDisconnected(block, chain.size() - 1);[m
[31m-                b.wallet->blockDisconnected(block, chain.size() - 1);[m
[32m+[m[32m                const uint256& hash = block.GetHash();[m
[32m+[m[32m                const uint256& prev_hash = chain.size() >= 2 ? std::get<1>(chain[chain.size() - 2]).GetHash() : uint256();[m
[32m+[m[32m                interfaces::BlockInfo info{hash};[m
[32m+[m[32m                info.prev_hash = &prev_hash;[m
[32m+[m[32m                info.height = chain.size() - 1;[m
[32m+[m[32m                info.data = &block;[m
[32m+[m[32m                a.wallet->blockDisconnected(info);[m
[32m+[m[32m                b.wallet->blockDisconnected(info);[m
                 chain.pop_back();[m
             });[m
         auto& [coins, first_block]{chain.front()};[m
[33mdiff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp[m
[33mindex 261d042529..281a113a01 100644[m
[33m--- a/src/wallet/wallet.cpp[m
[33m+++ b/src/wallet/wallet.cpp[m
[36m@@ -1307,30 +1307,31 @@[m [mvoid CWallet::transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRe[m
     }[m
 }[m
 [m
[31m-void CWallet::blockConnected(const CBlock& block, int height)[m
[32m+[m[32mvoid CWallet::blockConnected(const interfaces::BlockInfo& block)[m
 {[m
[31m-    const uint256& block_hash = block.GetHash();[m
[32m+[m[32m    assert(block.data);[m
     LOCK(cs_wallet);[m
 [m
[31m-    m_last_block_processed_height = height;[m
[31m-    m_last_block_processed = block_hash;[m
[31m-    for (size_t index = 0; index < block.vtx.size(); index++) {[m
[31m-        SyncTransaction(block.vtx[index], TxStateConfirmed{block_hash, height, static_cast<int>(index)});[m
[31m-        transactionRemovedFromMempool(block.vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);[m
[32m+[m[32m    m_last_block_processed_height = block.height;[m
[32m+[m[32m    m_last_block_processed = block.hash;[m
[32m+[m[32m    for (size_t index = 0; index < block.data->vtx.size(); index++) {[m
[32m+[m[32m        SyncTransaction(block.data->vtx[index], TxStateConfirmed{block.hash, block.height, static_cast<int>(index)});[m
[32m+[m[32m        transactionRemovedFromMempool(block.data->vtx[index], MemPoolRemovalReason::BLOCK, 0 /* mempool_sequence */);[m
     }[m
 }[m
 [m
[31m-void CWallet::blockDisconnected(const CBlock& block, int height)[m
[32m+[m[32mvoid CWallet::blockDisconnected(const interfaces::BlockInfo& block)[m
 {[m
[32m+[m[32m    assert(block.data);[m
     LOCK(cs_wallet);[m
 [m
     // At block disconnection, this will change an abandoned transaction to[m
     // be unconfirmed, whether or not the transaction is added back to the mempool.[m
     // User may have to call abandontransaction again. It may be addressed in the[m
     // future with a stickier abandoned state or even removing abandontransaction call.[m
[31m-    m_last_block_processed_height = height - 1;[m
[31m-    m_last_block_processed = block.hashPrevBlock;[m
[31m-    for (const CTransactionRef& ptx : block.vtx) {[m
[32m+[m[32m    m_last_block_processed_height = block.height - 1;[m
[32m+[m[32m    m_last_block_processed = *block.prev_hash;[m
[32m+[m[32m    for (const CTransactionRef& ptx : block.data->vtx) {[m
         SyncTransaction(ptx, TxStateInactive{});[m
     }[m
 }[m
[33mdiff --git a/src/wallet/wallet.h b/src/wallet/wallet.h[m
[33mindex e2c5c69c91..5f22120be5 100644[m
[33m--- a/src/wallet/wallet.h[m
[33m+++ b/src/wallet/wallet.h[m
[36m@@ -515,8 +515,8 @@[m [mpublic:[m
     CWalletTx* AddToWallet(CTransactionRef tx, const TxState& state, const UpdateWalletTxFn& update_wtx=nullptr, bool fFlushOnClose=true, bool rescanning_old_block = false);[m
     bool LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);[m
     void transactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override;[m
[31m-    void blockConnected(const CBlock& block, int height) override;[m
[31m-    void blockDisconnected(const CBlock& block, int height) override;[m
[32m+[m[32m    void blockConnected(const interfaces::BlockInfo& block) override;[m
[32m+[m[32m    void blockDisconnected(const interfaces::BlockInfo& block) override;[m
     void updatedBlockTip() override;[m
     int64_t RescanFromTime(int64_t startTime, const WalletRescanReserver& reserver, bool update);[m
 [m
[33mdiff --git a/test/lint/lint-circular-dependencies.sh b/test/lint/lint-circular-dependencies.sh[m
[33mindex 69185090d1..f0750f0de6 100755[m
[33m--- a/test/lint/lint-circular-dependencies.sh[m
[33m+++ b/test/lint/lint-circular-dependencies.sh[m
[36m@@ -11,8 +11,8 @@[m [mexport LC_ALL=C[m
 EXPECTED_CIRCULAR_DEPENDENCIES=([m
     "chainparamsbase -> util/system -> chainparamsbase"[m
     "node/blockstorage -> validation -> node/blockstorage"[m
[31m-    "index/blockfilterindex -> node/blockstorage -> validation -> index/blockfilterindex"[m
[31m-    "index/base -> validation -> index/blockfilterindex -> index/base"[m
[32m+[m[32m    "index/blockfilterindex -> validation -> index/blockfilterindex"[m
[32m+[m[32m    "index/base -> node/context -> net_processing -> index/blockfilterindex -> index/base"[m
     "index/coinstatsindex -> node/coinstats -> index/coinstatsindex"[m
     "policy/fees -> txmempool -> policy/fees"[m
     "qt/addresstablemodel -> qt/walletmodel -> qt/addresstablemodel"[m