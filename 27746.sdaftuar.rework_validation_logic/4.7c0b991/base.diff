[33mdiff --git a/doc/design/assumeutxo.md b/doc/design/assumeutxo.md[m
[33mindex 469c551536..1492877e62 100644[m
[33m--- a/doc/design/assumeutxo.md[m
[33m+++ b/doc/design/assumeutxo.md[m
[36m@@ -17,10 +17,9 @@[m [mrespectively generate and load UTXO snapshots. The utility script[m
 [m
 - A new block index `nStatus` flag is introduced, `BLOCK_ASSUMED_VALID`, to mark block[m
   index entries that are required to be assumed-valid by a chainstate created[m
[31m-  from a UTXO snapshot. This flag is mostly used as a way to modify certain[m
[32m+[m[32m  from a UTXO snapshot. This flag is used as a way to modify certain[m
   CheckBlockIndex() logic to account for index entries that are pending validation by a[m
[31m-  chainstate running asynchronously in the background. We also use this flag to control[m
[31m-  which index entries are added to setBlockIndexCandidates during LoadBlockIndex().[m
[32m+[m[32m  chainstate running asynchronously in the background.[m
 [m
 - The concept of UTXO snapshots is treated as an implementation detail that lives[m
   behind the ChainstateManager interface. The external presentation of the changes[m
[33mdiff --git a/src/bench/load_external.cpp b/src/bench/load_external.cpp[m
[33mindex 1378a7b20a..252cbb163b 100644[m
[33m--- a/src/bench/load_external.cpp[m
[33m+++ b/src/bench/load_external.cpp[m
[36m@@ -49,14 +49,13 @@[m [mstatic void LoadExternalBlockFile(benchmark::Bench& bench)[m
         fclose(file);[m
     }[m
 [m
[31m-    Chainstate& chainstate{testing_setup->m_node.chainman->ActiveChainstate()};[m
     std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;[m
     FlatFilePos pos;[m
     bench.run([&] {[m
         // "rb" is "binary, O_RDONLY", positioned to the start of the file.[m
         // The file will be closed by LoadExternalBlockFile().[m
         FILE* file{fsbridge::fopen(blkfile, "rb")};[m
[31m-        chainstate.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
[32m+[m[32m        testing_setup->m_node.chainman->LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
     });[m
     fs::remove(blkfile);[m
 }[m
[33mdiff --git a/src/chain.h b/src/chain.h[m
[33mindex f5dd0fd315..2ccd015e57 100644[m
[33m--- a/src/chain.h[m
[33m+++ b/src/chain.h[m
[36m@@ -113,10 +113,10 @@[m [menum BlockStatus : uint32_t {[m
     BLOCK_VALID_TRANSACTIONS =    3,[m
 [m
     //! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30.[m
[31m-    //! Implies all parents are also at least CHAIN.[m
[32m+[m[32m    //! Implies all parents are either at least VALID_CHAIN, or are ASSUMED_VALID[m
     BLOCK_VALID_CHAIN        =    4,[m
 [m
[31m-    //! Scripts & signatures ok. Implies all parents are also at least SCRIPTS.[m
[32m+[m[32m    //! Scripts & signatures ok. Implies all parents are either at least VALID_SCRIPTS, or are ASSUMED_VALID.[m
     BLOCK_VALID_SCRIPTS      =    5,[m
 [m
     //! All validity bits.[m
[36m@@ -134,10 +134,18 @@[m [menum BlockStatus : uint32_t {[m
     BLOCK_OPT_WITNESS        =   128, //!< block data in blk*.dat was received with a witness-enforcing client[m
 [m
     /**[m
[31m-     * If set, this indicates that the block index entry is assumed-valid.[m
[31m-     * Certain diagnostics will be skipped in e.g. CheckBlockIndex().[m
[31m-     * It almost certainly means that the block's full validation is pending[m
[31m-     * on a background chainstate. See `doc/design/assumeutxo.md`.[m
[32m+[m[32m     * If ASSUMED_VALID is set, it means that this block has not been validated[m
[32m+[m[32m     * and has validity status less than VALID_SCRIPTS. Also that it has[m
[32m+[m[32m     * descendant blocks with VALID_SCRIPTS set, because they were validated[m
[32m+[m[32m     * based on an assumeutxo snapshot.[m
[32m+[m[32m     *[m
[32m+[m[32m     * When an assumeutxo snapshot is loaded, the ASSUMED_VALID flag is added to[m
[32m+[m[32m     * unvalidated blocks below the snapshot height. Then, as the background[m
[32m+[m[32m     * validation progresses, and these blocks are validated, the ASSUMED_VALID[m
[32m+[m[32m     * flags are removed. See `doc/design/assumeutxo.md` for details.[m
[32m+[m[32m     *[m
[32m+[m[32m     * This flag is only used to implement checks in CheckBlockIndex() and[m
[32m+[m[32m     * should not be used elsewhere.[m
      */[m
     BLOCK_ASSUMED_VALID      =   256,[m
 };[m
[33mdiff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp[m
[33mindex 78416ec576..0d25c798ce 100644[m
[33m--- a/src/node/blockstorage.cpp[m
[33m+++ b/src/node/blockstorage.cpp[m
[36m@@ -618,7 +618,7 @@[m [mfs::path BlockManager::GetBlockPosFilename(const FlatFilePos& pos) const[m
     return BlockFileSeq().FileName(pos);[m
 }[m
 [m
[31m-bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown)[m
[32m+[m[32mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown)[m
 {[m
     LOCK(cs_LastBlockFile);[m
 [m
[36m@@ -644,7 +644,7 @@[m [mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne[m
             // when the undo file is keeping up with the block file, we want to flush it explicitly[m
             // when it is lagging behind (more blocks arrive than are being connected), we let the[m
             // undo block write case handle it[m
[31m-            finalize_undo = (m_blockfile_info[nFile].nHeightLast == (unsigned int)active_chain.Tip()->nHeight);[m
[32m+[m[32m            finalize_undo = (m_blockfile_info[nFile].nHeightLast == m_undo_height_in_last_blockfile);[m
             nFile++;[m
             if (m_blockfile_info.size() <= nFile) {[m
                 m_blockfile_info.resize(nFile + 1);[m
[36m@@ -660,6 +660,7 @@[m [mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne[m
         }[m
         FlushBlockFile(!fKnown, finalize_undo);[m
         m_last_blockfile = nFile;[m
[32m+[m[32m        m_undo_height_in_last_blockfile = 0; // No undo data yet in the new file, so reset our undo-height tracking.[m
     }[m
 [m
     m_blockfile_info[nFile].AddBlock(nHeight, nTime);[m
[36m@@ -749,8 +750,9 @@[m [mbool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid[m
         // the FindBlockPos function[m
         if (_pos.nFile < m_last_blockfile && static_cast<uint32_t>(block.nHeight) == m_blockfile_info[_pos.nFile].nHeightLast) {[m
             FlushUndoFile(_pos.nFile, true);[m
[32m+[m[32m        } else if (_pos.nFile == m_last_blockfile && static_cast<uint32_t>(block.nHeight) > m_undo_height_in_last_blockfile) {[m
[32m+[m[32m            m_undo_height_in_last_blockfile = block.nHeight;[m
         }[m
[31m-[m
         // update nUndoPos in block index[m
         block.nUndoPos = _pos.nPos;[m
         block.nStatus |= BLOCK_HAVE_UNDO;[m
[36m@@ -839,7 +841,7 @@[m [mbool BlockManager::ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatF[m
     return true;[m
 }[m
 [m
[31m-FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const FlatFilePos* dbp)[m
[32m+[m[32mFlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, const FlatFilePos* dbp)[m
 {[m
     unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);[m
     FlatFilePos blockPos;[m
[36m@@ -852,7 +854,7 @@[m [mFlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CCha[m
         // we add BLOCK_SERIALIZATION_HEADER_SIZE only for new blocks since they will have the serialization header added when written to disk.[m
         nBlockSize += static_cast<unsigned int>(BLOCK_SERIALIZATION_HEADER_SIZE);[m
     }[m
[31m-    if (!FindBlockPos(blockPos, nBlockSize, nHeight, active_chain, block.GetBlockTime(), position_known)) {[m
[32m+[m[32m    if (!FindBlockPos(blockPos, nBlockSize, nHeight, block.GetBlockTime(), position_known)) {[m
         error("%s: FindBlockPos failed", __func__);[m
         return FlatFilePos();[m
     }[m
[36m@@ -905,7 +907,7 @@[m [mvoid ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFile[m
                     break; // This error is logged in OpenBlockFile[m
                 }[m
                 LogPrintf("Reindexing block file blk%05u.dat...\n", (unsigned int)nFile);[m
[31m-                chainman.ActiveChainstate().LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
[32m+[m[32m                chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
                 if (chainman.m_interrupt) {[m
                     LogPrintf("Interrupt requested. Exit %s\n", __func__);[m
                     return;[m
[36m@@ -924,7 +926,7 @@[m [mvoid ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFile[m
             FILE* file = fsbridge::fopen(path, "rb");[m
             if (file) {[m
                 LogPrintf("Importing blocks file %s...\n", fs::PathToString(path));[m
[31m-                chainman.ActiveChainstate().LoadExternalBlockFile(file);[m
[32m+[m[32m                chainman.LoadExternalBlockFile(file);[m
                 if (chainman.m_interrupt) {[m
                     LogPrintf("Interrupt requested. Exit %s\n", __func__);[m
                     return;[m
[33mdiff --git a/src/node/blockstorage.h b/src/node/blockstorage.h[m
[33mindex c2e903e470..eb40d45aba 100644[m
[33m--- a/src/node/blockstorage.h[m
[33m+++ b/src/node/blockstorage.h[m
[36m@@ -24,7 +24,6 @@[m [mclass BlockValidationState;[m
 class CBlock;[m
 class CBlockFileInfo;[m
 class CBlockUndo;[m
[31m-class CChain;[m
 class CChainParams;[m
 class Chainstate;[m
 class ChainstateManager;[m
[36m@@ -94,7 +93,7 @@[m [mprivate:[m
         EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);[m
     void FlushUndoFile(int block_file, bool finalize = false);[m
[31m-    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown);[m
[32m+[m[32m    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);[m
     bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize);[m
 [m
     FlatFileSeq BlockFileSeq() const;[m
[36m@@ -128,6 +127,19 @@[m [mprivate:[m
     RecursiveMutex cs_LastBlockFile;[m
     std::vector<CBlockFileInfo> m_blockfile_info;[m
     int m_last_blockfile = 0;[m
[32m+[m
[32m+[m[32m    // Track the height of the highest block in m_last_blockfile whose undo[m
[32m+[m[32m    // data has been written. Block data is written to block files in download[m
[32m+[m[32m    // order, but is written to undo files in validation order, which is[m
[32m+[m[32m    // usually in order by height. To avoid wasting disk space, undo files will[m
[32m+[m[32m    // be trimmed whenever the corresponding block file is finalized and[m
[32m+[m[32m    // the height of the highest block written to the block file equals the[m
[32m+[m[32m    // height of the highest block written to the undo file. This is a[m
[32m+[m[32m    // heuristic and can sometimes preemptively trim undo files that will write[m
[32m+[m[32m    // more data later, and sometimes fail to trim undo files that can't have[m
[32m+[m[32m    // more data written later.[m
[32m+[m[32m    unsigned int m_undo_height_in_last_blockfile = 0;[m
[32m+[m
     /** Global flag to indicate we should check to see if there are[m
      *  block/undo files that should be deleted.  Set on startup[m
      *  or if we allocate more file space when we're in prune mode[m
[36m@@ -202,7 +214,7 @@[m [mpublic:[m
         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
 [m
     /** Store block on disk. If dbp is not nullptr, then it provides the known position of the block within a block file on disk. */[m
[31m-    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const FlatFilePos* dbp);[m
[32m+[m[32m    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, const FlatFilePos* dbp);[m
 [m
     /** Whether running in -prune mode. */[m
     [[nodiscard]] bool IsPruneMode() const { return m_prune_mode; }[m
[33mdiff --git a/src/node/chainstate.cpp b/src/node/chainstate.cpp[m
[33mindex 255d8be0ec..0828f64856 100644[m
[33m--- a/src/node/chainstate.cpp[m
[33m+++ b/src/node/chainstate.cpp[m
[36m@@ -221,7 +221,7 @@[m [mChainstateLoadResult LoadChainstate(ChainstateManager& chainman, const CacheSize[m
 [m
         // A reload of the block index is required to recompute setBlockIndexCandidates[m
         // for the fully validated chainstate.[m
[31m-        chainman.ActiveChainstate().UnloadBlockIndex();[m
[32m+[m[32m        chainman.ActiveChainstate().ClearBlockIndexCandidates();[m
 [m
         auto [init_status, init_error] = CompleteChainstateInitialization(chainman, cache_sizes, options);[m
         if (init_status != ChainstateLoadStatus::SUCCESS) {[m
[33mdiff --git a/src/test/blockmanager_tests.cpp b/src/test/blockmanager_tests.cpp[m
[33mindex e4ed861b12..f52c692649 100644[m
[33m--- a/src/test/blockmanager_tests.cpp[m
[33m+++ b/src/test/blockmanager_tests.cpp[m
[36m@@ -30,22 +30,21 @@[m [mBOOST_AUTO_TEST_CASE(blockmanager_find_block_pos)[m
         .notifications = notifications,[m
     };[m
     BlockManager blockman{m_node.kernel->interrupt, blockman_opts};[m
[31m-    CChain chain {};[m
     // simulate adding a genesis block normally[m
[31m-    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, chain, nullptr).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, nullptr).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
     // simulate what happens during reindex[m
     // simulate a well-formed genesis block being found at offset 8 in the blk00000.dat file[m
     // the block is found at offset 8 because there is an 8 byte serialization header[m
     // consisting of 4 magic bytes + 4 length bytes before each block in a well-formed blk file.[m
     FlatFilePos pos{0, BLOCK_SERIALIZATION_HEADER_SIZE};[m
[31m-    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, chain, &pos).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, &pos).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
     // now simulate what happens after reindex for the first new block processed[m
     // the actual block contents don't matter, just that it's a block.[m
     // verify that the write position is at offset 0x12d.[m
     // this is a check to make sure that https://github.com/bitcoin/bitcoin/issues/21379 does not recur[m
     // 8 bytes (for serialization header) + 285 (for serialized genesis block) = 293[m
     // add another 8 bytes for the second block's serialization header and we get 293 + 8 = 301[m
[31m-    FlatFilePos actual{blockman.SaveBlockToDisk(params->GenesisBlock(), 1, chain, nullptr)};[m
[32m+[m[32m    FlatFilePos actual{blockman.SaveBlockToDisk(params->GenesisBlock(), 1, nullptr)};[m
     BOOST_CHECK_EQUAL(actual.nPos, BLOCK_SERIALIZATION_HEADER_SIZE + ::GetSerializeSize(params->GenesisBlock(), CLIENT_VERSION) + BLOCK_SERIALIZATION_HEADER_SIZE);[m
 }[m
 [m
[33mdiff --git a/src/test/coinstatsindex_tests.cpp b/src/test/coinstatsindex_tests.cpp[m
[33mindex 74d6d7231a..787a196a0c 100644[m
[33m--- a/src/test/coinstatsindex_tests.cpp[m
[33m+++ b/src/test/coinstatsindex_tests.cpp[m
[36m@@ -98,7 +98,7 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)[m
             LOCK(cs_main);[m
             BlockValidationState state;[m
             BOOST_CHECK(CheckBlock(block, state, params.GetConsensus()));[m
[31m-            BOOST_CHECK(chainstate.AcceptBlock(new_block, state, &new_block_index, true, nullptr, nullptr, true));[m
[32m+[m[32m            BOOST_CHECK(m_node.chainman->AcceptBlock(new_block, state, &new_block_index, true, nullptr, nullptr, true));[m
             CCoinsViewCache view(&chainstate.CoinsTip());[m
             BOOST_CHECK(chainstate.ConnectBlock(block, state, new_block_index, view));[m
         }[m
[33mdiff --git a/src/test/fuzz/load_external_block_file.cpp b/src/test/fuzz/load_external_block_file.cpp[m
[33mindex f4b7dc08fd..7f8c9c4e71 100644[m
[33m--- a/src/test/fuzz/load_external_block_file.cpp[m
[33m+++ b/src/test/fuzz/load_external_block_file.cpp[m
[36m@@ -35,9 +35,9 @@[m [mFUZZ_TARGET_INIT(load_external_block_file, initialize_load_external_block_file)[m
         // Corresponds to the -reindex case (track orphan blocks across files).[m
         FlatFilePos flat_file_pos;[m
         std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;[m
[31m-        g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);[m
[32m+[m[32m        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);[m
     } else {[m
         // Corresponds to the -loadblock= case (orphan blocks aren't tracked across files).[m
[31m-        g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file);[m
[32m+[m[32m        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file);[m
     }[m
 }[m
[33mdiff --git a/src/test/util/chainstate.h b/src/test/util/chainstate.h[m
[33mindex bf8f8b5819..61938346e5 100644[m
[33m--- a/src/test/util/chainstate.h[m
[33m+++ b/src/test/util/chainstate.h[m
[36m@@ -71,6 +71,7 @@[m [mCreateAndActivateUTXOSnapshot([m
             // This is a stripped-down version of node::LoadChainstate which[m
             // preserves the block index.[m
             LOCK(::cs_main);[m
[32m+[m[32m            CBlockIndex *orig_tip = node.chainman->ActiveChainstate().m_chain.Tip();[m
             uint256 gen_hash = node.chainman->ActiveChainstate().m_chain[0]->GetBlockHash();[m
             node.chainman->ResetChainstates();[m
             node.chainman->InitializeChainstate(node.mempool.get());[m
[36m@@ -83,6 +84,18 @@[m [mCreateAndActivateUTXOSnapshot([m
             chain.setBlockIndexCandidates.insert(node.chainman->m_blockman.LookupBlockIndex(gen_hash));[m
             chain.LoadChainTip();[m
             node.chainman->MaybeRebalanceCaches();[m
[32m+[m
[32m+[m[32m            // Reset the HAVE_DATA flags below the snapshot height, simulating[m
[32m+[m[32m            // never-having-downloaded them in the first place.[m
[32m+[m[32m            // TODO: perhaps we could improve this by using pruning to delete[m
[32m+[m[32m            // these blocks instead[m
[32m+[m[32m            CBlockIndex *pindex = orig_tip;[m
[32m+[m[32m            while (pindex && pindex != chain.m_chain.Tip()) {[m
[32m+[m[32m                pindex->nStatus &= ~BLOCK_HAVE_DATA;[m
[32m+[m[32m                pindex->nStatus &= ~BLOCK_HAVE_UNDO;[m
[32m+[m[32m                pindex->nStatus |= BLOCK_ASSUMED_VALID;[m
[32m+[m[32m                pindex = pindex->pprev;[m
[32m+[m[32m            }[m
         }[m
         BlockValidationState state;[m
         if (!node.chainman->ActiveChainstate().ActivateBestChain(state)) {[m
[33mdiff --git a/src/test/validation_chainstate_tests.cpp b/src/test/validation_chainstate_tests.cpp[m
[33mindex 2078fcd8f8..fe2d2ba592 100644[m
[33m--- a/src/test/validation_chainstate_tests.cpp[m
[33m+++ b/src/test/validation_chainstate_tests.cpp[m
[36m@@ -77,6 +77,13 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)[m
     // After adding some blocks to the tip, best block should have changed.[m
     BOOST_CHECK(::g_best_block != curr_tip);[m
 [m
[32m+[m[32m    // Grab block 1 from disk; we'll add it to the background chain later.[m
[32m+[m[32m    std::shared_ptr<CBlock> pblockone = std::make_shared<CBlock>();[m
[32m+[m[32m    {[m
[32m+[m[32m        LOCK(::cs_main);[m
[32m+[m[32m        chainman.m_blockman.ReadBlockFromDisk(*pblockone, *chainman.ActiveChain()[1]);[m
[32m+[m[32m    }[m
[32m+[m
     BOOST_REQUIRE(CreateAndActivateUTXOSnapshot([m
         this, NoMalleation, /*reset_chainstate=*/ true));[m
 [m
[36m@@ -104,11 +111,7 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)[m
         assert(false);[m
     }()};[m
 [m
[31m-    // Create a block to append to the validation chain.[m
[31m-    std::vector<CMutableTransaction> noTxns;[m
[31m-    CScript scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;[m
[31m-    CBlock validation_block = this->CreateBlock(noTxns, scriptPubKey, background_cs);[m
[31m-    auto pblock = std::make_shared<const CBlock>(validation_block);[m
[32m+[m[32m    // Append the first block to the background chain.[m
     BlockValidationState state;[m
     CBlockIndex* pindex = nullptr;[m
     const CChainParams& chainparams = Params();[m
[36m@@ -118,17 +121,18 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)[m
     // once it is changed to support multiple chainstates.[m
     {[m
         LOCK(::cs_main);[m
[31m-        bool checked = CheckBlock(*pblock, state, chainparams.GetConsensus());[m
[32m+[m[32m        bool checked = CheckBlock(*pblockone, state, chainparams.GetConsensus());[m
         BOOST_CHECK(checked);[m
[31m-        bool accepted = background_cs.AcceptBlock([m
[31m-            pblock, state, &pindex, true, nullptr, &newblock, true);[m
[32m+[m[32m        bool accepted = chainman.AcceptBlock([m
[32m+[m[32m            pblockone, state, &pindex, true, nullptr, &newblock, true);[m
         BOOST_CHECK(accepted);[m
     }[m
[32m+[m
     // UpdateTip is called here[m
[31m-    bool block_added = background_cs.ActivateBestChain(state, pblock);[m
[32m+[m[32m    bool block_added = background_cs.ActivateBestChain(state, pblockone);[m
 [m
     // Ensure tip is as expected[m
[31m-    BOOST_CHECK_EQUAL(background_cs.m_chain.Tip()->GetBlockHash(), validation_block.GetHash());[m
[32m+[m[32m    BOOST_CHECK_EQUAL(background_cs.m_chain.Tip()->GetBlockHash(), pblockone->GetHash());[m
 [m
     // g_best_block should be unchanged after adding a block to the background[m
     // validation chain.[m
[33mdiff --git a/src/test/validation_chainstatemanager_tests.cpp b/src/test/validation_chainstatemanager_tests.cpp[m
[33mindex 99860961a2..ece8c298cd 100644[m
[33m--- a/src/test/validation_chainstatemanager_tests.cpp[m
[33m+++ b/src/test/validation_chainstatemanager_tests.cpp[m
[36m@@ -49,6 +49,9 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
     c1.InitCoinsDB([m
         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));[m
[32m+[m[32m    c1.LoadGenesisBlock();[m
[32m+[m[32m    BlockValidationState val_state;[m
[32m+[m[32m    BOOST_CHECK(c1.ActivateBestChain(val_state, nullptr));[m
 [m
     BOOST_CHECK(!manager.IsSnapshotActive());[m
     BOOST_CHECK(WITH_LOCK(::cs_main, return !manager.IsSnapshotValidated()));[m
[36m@@ -58,7 +61,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
     auto& active_chain = WITH_LOCK(manager.GetMutex(), return manager.ActiveChain());[m
     BOOST_CHECK_EQUAL(&active_chain, &c1.m_chain);[m
 [m
[31m-    BOOST_CHECK_EQUAL(WITH_LOCK(manager.GetMutex(), return manager.ActiveHeight()), -1);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(WITH_LOCK(manager.GetMutex(), return manager.ActiveHeight()), 0);[m
 [m
     auto active_tip = WITH_LOCK(manager.GetMutex(), return manager.ActiveTip());[m
     auto exp_tip = c1.m_chain.Tip();[m
[36m@@ -68,7 +71,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
 [m
     // Create a snapshot-based chainstate.[m
     //[m
[31m-    const uint256 snapshot_blockhash = GetRandHash();[m
[32m+[m[32m    const uint256 snapshot_blockhash = active_tip->GetBlockHash();[m
     Chainstate& c2 = WITH_LOCK(::cs_main, return manager.ActivateExistingSnapshot([m
         &mempool, snapshot_blockhash));[m
     chainstates.push_back(&c2);[m
[36m@@ -78,8 +81,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
     c2.InitCoinsDB([m
         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
     WITH_LOCK(::cs_main, c2.InitCoinsCache(1 << 23));[m
[31m-    // Unlike c1, which doesn't have any blocks. Gets us different tip, height.[m
[31m-    c2.LoadGenesisBlock();[m
[32m+[m[32m    c2.m_chain.SetTip(*active_tip);[m
     BlockValidationState _;[m
     BOOST_CHECK(c2.ActivateBestChain(_, nullptr));[m
 [m
[36m@@ -99,16 +101,12 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
     auto exp_tip2 = c2.m_chain.Tip();[m
     BOOST_CHECK_EQUAL(active_tip2, exp_tip2);[m
 [m
[31m-    // Ensure that these pointers actually correspond to different[m
[31m-    // CCoinsViewCache instances.[m
[31m-    BOOST_CHECK(exp_tip != exp_tip2);[m
[31m-[m
     // Let scheduler events finish running to avoid accessing memory that is going to be unloaded[m
     SyncWithValidationInterfaceQueue();[m
 }[m
 [m
 //! Test rebalancing the caches associated with each chainstate.[m
[31m-BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
[32m+[m[32mBOOST_FIXTURE_TEST_CASE(chainstatemanager_rebalance_caches, TestChain100Setup)[m
 {[m
     ChainstateManager& manager = *m_node.chainman;[m
     CTxMemPool& mempool = *m_node.mempool;[m
[36m@@ -121,7 +119,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
 [m
     // Create a legacy (IBD) chainstate.[m
     //[m
[31m-    Chainstate& c1 = WITH_LOCK(::cs_main, return manager.InitializeChainstate(&mempool));[m
[32m+[m[32m    Chainstate& c1 = manager.ActiveChainstate();[m
     chainstates.push_back(&c1);[m
     c1.InitCoinsDB([m
         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
[36m@@ -129,8 +127,6 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
     {[m
         LOCK(::cs_main);[m
         c1.InitCoinsCache(1 << 23);[m
[31m-        BOOST_REQUIRE(c1.LoadGenesisBlock());[m
[31m-        c1.CoinsTip().SetBestBlock(InsecureRand256());[m
         manager.MaybeRebalanceCaches();[m
     }[m
 [m
[36m@@ -139,7 +135,8 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
 [m
     // Create a snapshot-based chainstate.[m
     //[m
[31m-    Chainstate& c2 = WITH_LOCK(cs_main, return manager.ActivateExistingSnapshot(&mempool, GetRandHash()));[m
[32m+[m[32m    CBlockIndex* snapshot_base{WITH_LOCK(manager.GetMutex(), return manager.ActiveChain()[manager.ActiveChain().Height() / 2])};[m
[32m+[m[32m    Chainstate& c2 = WITH_LOCK(cs_main, return manager.ActivateExistingSnapshot(&mempool, *snapshot_base->phashBlock));[m
     chainstates.push_back(&c2);[m
     c2.InitCoinsDB([m
         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
[36m@@ -147,8 +144,6 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
     {[m
         LOCK(::cs_main);[m
         c2.InitCoinsCache(1 << 23);[m
[31m-        BOOST_REQUIRE(c2.LoadGenesisBlock());[m
[31m-        c2.CoinsTip().SetBestBlock(InsecureRand256());[m
         manager.MaybeRebalanceCaches();[m
     }[m
 [m
[36m@@ -430,28 +425,31 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)[m
     const int assumed_valid_start_idx = last_assumed_valid_idx - expected_assumed_valid;[m
 [m
     CBlockIndex* validated_tip{nullptr};[m
[32m+[m[32m    CBlockIndex* assumed_base{nullptr};[m
     CBlockIndex* assumed_tip{WITH_LOCK(chainman.GetMutex(), return chainman.ActiveChain().Tip())};[m
 [m
     auto reload_all_block_indexes = [&]() {[m
[32m+[m[32m        WITH_LOCK(::cs_main, return chainman.ResetBlockSequenceCounters());[m
         for (Chainstate* cs : chainman.GetAll()) {[m
             LOCK(::cs_main);[m
[31m-            cs->UnloadBlockIndex();[m
[32m+[m[32m            cs->ClearBlockIndexCandidates();[m
             BOOST_CHECK(cs->setBlockIndexCandidates.empty());[m
         }[m
 [m
         WITH_LOCK(::cs_main, chainman.LoadBlockIndex());[m
     };[m
 [m
[31m-    // Ensure that without any assumed-valid BlockIndex entries, all entries are considered[m
[31m-    // tip candidates.[m
[32m+[m[32m    // Ensure that without any assumed-valid BlockIndex entries, only the current tip is[m
[32m+[m[32m    // considered as a candidate.[m
     reload_all_block_indexes();[m
[31m-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), cs1.m_chain.Height() + 1);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), 1);[m
 [m
[31m-    // Mark some region of the chain assumed-valid.[m
[32m+[m[32m    // Mark some region of the chain assumed-valid, and remove the HAVE_DATA flag.[m
     for (int i = 0; i <= cs1.m_chain.Height(); ++i) {[m
         LOCK(::cs_main);[m
         auto index = cs1.m_chain[i];[m
 [m
[32m+[m[32m        // Blocks with heights in range [20, 40) are marked ASSUMED_VALID[m
         if (i < last_assumed_valid_idx && i >= assumed_valid_start_idx) {[m
             index->nStatus = BlockStatus::BLOCK_VALID_TREE | BlockStatus::BLOCK_ASSUMED_VALID;[m
         }[m
[36m@@ -464,25 +462,36 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)[m
             validated_tip = index;[m
             BOOST_CHECK(!index->IsAssumedValid());[m
         }[m
[32m+[m[32m        // Note the last assumed valid block as the snapshot base[m
[32m+[m[32m        if (i == last_assumed_valid_idx - 1) {[m
[32m+[m[32m            assumed_base = index;[m
[32m+[m[32m            BOOST_CHECK(index->IsAssumedValid());[m
[32m+[m[32m        }[m
     }[m
 [m
     BOOST_CHECK_EQUAL(expected_assumed_valid, num_assumed_valid);[m
 [m
[32m+[m[32m    // Note: cs2's tip is not set when ActivateExistingSnapshot is called.[m
     Chainstate& cs2 = WITH_LOCK(::cs_main,[m
[31m-        return chainman.ActivateExistingSnapshot(&mempool, GetRandHash()));[m
[32m+[m[32m        return chainman.ActivateExistingSnapshot(&mempool, *assumed_base->phashBlock));[m
[32m+[m
[32m+[m[32m    // Set tip of the fully validated chain to be the validated tip[m
[32m+[m[32m    cs1.m_chain.SetTip(*validated_tip);[m
 [m
     reload_all_block_indexes();[m
 [m
[31m-    // The fully validated chain only has candidates up to the start of the assumed-valid[m
[31m-    // blocks.[m
[32m+[m[32m    // The fully validated chain should have the current validated tip[m
[32m+[m[32m    // and the assumed valid base as candidates.[m
[32m+[m[32m    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), 2);[m
     BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(validated_tip), 1);[m
[31m-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(assumed_tip), 0);[m
[31m-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), assumed_valid_start_idx);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(assumed_base), 1);[m
 [m
[31m-    // The assumed-valid tolerant chain has all blocks as candidates.[m
[32m+[m[32m    // The assumed-valid tolerant chain has the assumed valid base as a[m
[32m+[m[32m    // candidate, but otherwise has none of the assumed-valid (which do not[m
[32m+[m[32m    // HAVE_DATA) blocks as candidates.[m
     BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(validated_tip), 1);[m
     BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(assumed_tip), 1);[m
[31m-    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes);[m
[32m+[m[32m    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes - num_assumed_valid + 1);[m
 }[m
 [m
 //! Ensure that snapshot chainstates initialize properly when found on disk.[m
[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
[33mindex 5bf8bd70e2..3ace375149 100644[m
[33m--- a/src/validation.cpp[m
[33m+++ b/src/validation.cpp[m
[36m@@ -1579,6 +1579,13 @@[m [mChainstate::Chainstate([m
       m_chainman(chainman),[m
       m_from_snapshot_blockhash(from_snapshot_blockhash) {}[m
 [m
[32m+[m[32mconst CBlockIndex* Chainstate::SnapshotBase()[m
[32m+[m[32m{[m
[32m+[m[32m    if (!m_from_snapshot_blockhash) return nullptr;[m
[32m+[m[32m    if (!m_cached_snapshot_base) m_cached_snapshot_base = Assert(m_chainman.m_blockman.LookupBlockIndex(*m_from_snapshot_blockhash));[m
[32m+[m[32m    return m_cached_snapshot_base;[m
[32m+[m[32m}[m
[32m+[m
 void Chainstate::InitCoinsDB([m
     size_t cache_size_bytes,[m
     bool in_memory,[m
[36m@@ -3193,7 +3200,8 @@[m [mbool Chainstate::ActivateBestChain(BlockValidationState& state, std::shared_ptr<[m
         // that the best block hash is non-null.[m
         if (m_chainman.m_interrupt) break;[m
     } while (pindexNewTip != pindexMostWork);[m
[31m-    CheckBlockIndex();[m
[32m+[m
[32m+[m[32m    m_chainman.CheckBlockIndex();[m
 [m
     // Write changes periodically to disk, after relay.[m
     if (!FlushStateToDisk(state, FlushStateMode::PERIODIC)) {[m
[36m@@ -3213,17 +3221,17 @@[m [mbool Chainstate::PreciousBlock(BlockValidationState& state, CBlockIndex* pindex)[m
             // Nothing to do, this block is not at the tip.[m
             return true;[m
         }[m
[31m-        if (m_chain.Tip()->nChainWork > nLastPreciousChainwork) {[m
[32m+[m[32m        if (m_chain.Tip()->nChainWork > m_chainman.nLastPreciousChainwork) {[m
             // The chain has been extended since the last call, reset the counter.[m
[31m-            nBlockReverseSequenceId = -1;[m
[32m+[m[32m            m_chainman.nBlockReverseSequenceId = -1;[m
         }[m
[31m-        nLastPreciousChainwork = m_chain.Tip()->nChainWork;[m
[32m+[m[32m        m_chainman.nLastPreciousChainwork = m_chain.Tip()->nChainWork;[m
         setBlockIndexCandidates.erase(pindex);[m
[31m-        pindex->nSequenceId = nBlockReverseSequenceId;[m
[31m-        if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {[m
[32m+[m[32m        pindex->nSequenceId = m_chainman.nBlockReverseSequenceId;[m
[32m+[m[32m        if (m_chainman.nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {[m
             // We can't keep reducing the counter if somebody really wants to[m
             // call preciousblock 2**31-1 times on the same set of tips...[m
[31m-            nBlockReverseSequenceId--;[m
[32m+[m[32m            m_chainman.nBlockReverseSequenceId--;[m
         }[m
         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->HaveTxsDownloaded()) {[m
             setBlockIndexCandidates.insert(pindex);[m
[36m@@ -3339,7 +3347,7 @@[m [mbool Chainstate::InvalidateBlock(BlockValidationState& state, CBlockIndex* pinde[m
         to_mark_failed = invalid_walk_tip;[m
     }[m
 [m
[31m-    CheckBlockIndex();[m
[32m+[m[32m    m_chainman.CheckBlockIndex();[m
 [m
     {[m
         LOCK(cs_main);[m
[36m@@ -3416,8 +3424,32 @@[m [mvoid Chainstate::ResetBlockFailureFlags(CBlockIndex *pindex) {[m
     }[m
 }[m
 [m
[32m+[m[32mvoid Chainstate::TryAddBlockIndexCandidate(CBlockIndex* pindex)[m
[32m+[m[32m{[m
[32m+[m[32m    AssertLockHeld(cs_main);[m
[32m+[m[32m    // The block only is a candidate for the most-work-chain if it has more work than our current tip.[m
[32m+[m[32m    if (m_chain.Tip() != nullptr && setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {[m
[32m+[m[32m        return;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    bool is_active_chainstate = this == &m_chainman.ActiveChainstate();[m
[32m+[m[32m    if (is_active_chainstate) {[m
[32m+[m[32m        // The active chainstate should always add entries that have more[m
[32m+[m[32m        // work than the tip.[m
[32m+[m[32m        setBlockIndexCandidates.insert(pindex);[m
[32m+[m[32m    } else if (!m_disabled) {[m
[32m+[m[32m        // For the background chainstate, we only consider connecting blocks[m
[32m+[m[32m        // towards the snapshot base (which can't be nullptr or else we'll[m
[32m+[m[32m        // never make progress).[m
[32m+[m[32m        const CBlockIndex* snapshot_base{Assert(m_chainman.ActiveSnapshotBase())};[m
[32m+[m[32m        if (snapshot_base->GetAncestor(pindex->nHeight) == pindex) {[m
[32m+[m[32m            setBlockIndexCandidates.insert(pindex);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
 /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */[m
[31m-void Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)[m
[32m+[m[32mvoid ChainstateManager::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)[m
 {[m
     AssertLockHeld(cs_main);[m
     pindexNew->nTx = block.vtx.size();[m
[36m@@ -3426,7 +3458,7 @@[m [mvoid Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pin[m
     pindexNew->nDataPos = pos.nPos;[m
     pindexNew->nUndoPos = 0;[m
     pindexNew->nStatus |= BLOCK_HAVE_DATA;[m
[31m-    if (DeploymentActiveAt(*pindexNew, m_chainman, Consensus::DEPLOYMENT_SEGWIT)) {[m
[32m+[m[32m    if (DeploymentActiveAt(*pindexNew, *this, Consensus::DEPLOYMENT_SEGWIT)) {[m
         pindexNew->nStatus |= BLOCK_OPT_WITNESS;[m
     }[m
     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);[m
[36m@@ -3443,8 +3475,8 @@[m [mvoid Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pin[m
             queue.pop_front();[m
             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;[m
             pindex->nSequenceId = nBlockSequenceId++;[m
[31m-            if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {[m
[31m-                setBlockIndexCandidates.insert(pindex);[m
[32m+[m[32m            for (Chainstate *c : GetAll()) {[m
[32m+[m[32m                c->TryAddBlockIndexCandidate(pindex);[m
             }[m
             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = m_blockman.m_blocks_unlinked.equal_range(pindex);[m
             while (range.first != range.second) {[m
[36m@@ -3858,7 +3890,7 @@[m [mbool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&[m
         for (const CBlockHeader& header : headers) {[m
             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast[m
             bool accepted{AcceptBlockHeader(header, state, &pindex, min_pow_checked)};[m
[31m-            ActiveChainstate().CheckBlockIndex();[m
[32m+[m[32m            CheckBlockIndex();[m
 [m
             if (!accepted) {[m
                 return false;[m
[36m@@ -3905,7 +3937,7 @@[m [mvoid ChainstateManager::ReportHeadersPresync(const arith_uint256& work, int64_t[m
 }[m
 [m
 /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */[m
[31m-bool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked)[m
[32m+[m[32mbool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked)[m
 {[m
     const CBlock& block = *pblock;[m
 [m
[36m@@ -3915,7 +3947,7 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
     CBlockIndex *pindexDummy = nullptr;[m
     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;[m
 [m
[31m-    bool accepted_header{m_chainman.AcceptBlockHeader(block, state, &pindex, min_pow_checked)};[m
[32m+[m[32m    bool accepted_header{AcceptBlockHeader(block, state, &pindex, min_pow_checked)};[m
     CheckBlockIndex();[m
 [m
     if (!accepted_header)[m
[36m@@ -3925,13 +3957,13 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
     // process an unrequested block if it's new and has enough work to[m
     // advance our tip, and isn't too many blocks ahead.[m
     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;[m
[31m-    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);[m
[32m+[m[32m    bool fHasMoreOrSameWork = (ActiveTip() ? pindex->nChainWork >= ActiveTip()->nChainWork : true);[m
     // Blocks that are too out-of-order needlessly limit the effectiveness of[m
     // pruning, because pruning will not delete block files that contain any[m
     // blocks which are too close in height to the tip.  Apply this test[m
     // regardless of whether pruning is enabled; it should generally be safe to[m
     // not process unrequested blocks.[m
[31m-    bool fTooFarAhead{pindex->nHeight > m_chain.Height() + int(MIN_BLOCKS_TO_KEEP)};[m
[32m+[m[32m    bool fTooFarAhead{pindex->nHeight > ActiveHeight() + int(MIN_BLOCKS_TO_KEEP)};[m
 [m
     // TODO: Decouple this function from the block download logic by removing fRequested[m
     // This requires some new chain data structure to efficiently look up if a[m
[36m@@ -3951,13 +3983,13 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
         // If our tip is behind, a peer could try to send us[m
         // low-work blocks on a fake chain that we would never[m
         // request; don't process these.[m
[31m-        if (pindex->nChainWork < m_chainman.MinimumChainWork()) return true;[m
[32m+[m[32m        if (pindex->nChainWork < MinimumChainWork()) return true;[m
     }[m
 [m
[31m-    const CChainParams& params{m_chainman.GetParams()};[m
[32m+[m[32m    const CChainParams& params{GetParams()};[m
 [m
     if (!CheckBlock(block, state, params.GetConsensus()) ||[m
[31m-        !ContextualCheckBlock(block, state, m_chainman, pindex->pprev)) {[m
[32m+[m[32m        !ContextualCheckBlock(block, state, *this, pindex->pprev)) {[m
         if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {[m
             pindex->nStatus |= BLOCK_FAILED_VALID;[m
             m_blockman.m_dirty_blockindex.insert(pindex);[m
[36m@@ -3967,23 +3999,30 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
 [m
     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW[m
     // (but if it does not build on our best tip, let the SendMessages loop relay it)[m
[31m-    if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)[m
[32m+[m[32m    if (!ActiveChainstate().IsInitialBlockDownload() && ActiveTip() == pindex->pprev)[m
         GetMainSignals().NewPoWValidBlock(pindex, pblock);[m
 [m
     // Write block to history file[m
     if (fNewBlock) *fNewBlock = true;[m
     try {[m
[31m-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, m_chain, dbp)};[m
[32m+[m[32m        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};[m
         if (blockPos.IsNull()) {[m
             state.Error(strprintf("%s: Failed to find position to write new block to disk", __func__));[m
             return false;[m
         }[m
         ReceivedBlockTransactions(block, pindex, blockPos);[m
     } catch (const std::runtime_error& e) {[m
[31m-        return FatalError(m_chainman.GetNotifications(), state, std::string("System error: ") + e.what());[m
[32m+[m[32m        return FatalError(GetNotifications(), state, std::string("System error: ") + e.what());[m
     }[m
 [m
[31m-    FlushStateToDisk(state, FlushStateMode::NONE);[m
[32m+[m[32m    // TODO: FlushStateToDisk() handles flushing of both block and chainstate[m
[32m+[m[32m    // data, so we should move this to ChainstateManager so that we can be more[m
[32m+[m[32m    // intelligent about how we flush.[m
[32m+[m[32m    // For now, since FlushStateMode::NONE is used, all that can happen is that[m
[32m+[m[32m    // the block files may be pruned, so we can just call this on one[m
[32m+[m[32m    // chainstate (particularly if we haven't implemented pruning with[m
[32m+[m[32m    // background validation yet).[m
[32m+[m[32m    ActiveChainstate().FlushStateToDisk(state, FlushStateMode::NONE);[m
 [m
     CheckBlockIndex();[m
 [m
[36m@@ -4011,7 +4050,7 @@[m [mbool ChainstateManager::ProcessNewBlock(const std::shared_ptr<const CBlock>& blo[m
         bool ret = CheckBlock(*block, state, GetConsensus());[m
         if (ret) {[m
             // Store to disk[m
[31m-            ret = ActiveChainstate().AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block, min_pow_checked);[m
[32m+[m[32m            ret = AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block, min_pow_checked);[m
         }[m
         if (!ret) {[m
             GetMainSignals().BlockChecked(*block, state);[m
[36m@@ -4379,10 +4418,9 @@[m [mbool Chainstate::NeedsRedownload() const[m
     return false;[m
 }[m
 [m
[31m-void Chainstate::UnloadBlockIndex()[m
[32m+[m[32mvoid Chainstate::ClearBlockIndexCandidates()[m
 {[m
     AssertLockHeld(::cs_main);[m
[31m-    nBlockSequenceId = 1;[m
     setBlockIndexCandidates.clear();[m
 }[m
 [m
[36m@@ -4401,62 +4439,14 @@[m [mbool ChainstateManager::LoadBlockIndex()[m
         std::sort(vSortedByHeight.begin(), vSortedByHeight.end(),[m
                   CBlockIndexHeightOnlyComparator());[m
 [m
[31m-        // Find start of assumed-valid region.[m
[31m-        int first_assumed_valid_height = std::numeric_limits<int>::max();[m
[31m-[m
[31m-        for (const CBlockIndex* block : vSortedByHeight) {[m
[31m-            if (block->IsAssumedValid()) {[m
[31m-                auto chainstates = GetAll();[m
[31m-[m
[31m-                // If we encounter an assumed-valid block index entry, ensure that we have[m
[31m-                // one chainstate that tolerates assumed-valid entries and another that does[m
[31m-                // not (i.e. the background validation chainstate), since assumed-valid[m
[31m-                // entries should always be pending validation by a fully-validated chainstate.[m
[31m-                auto any_chain = [&](auto fnc) { return std::any_of(chainstates.cbegin(), chainstates.cend(), fnc); };[m
[31m-                assert(any_chain([](auto chainstate) { return chainstate->reliesOnAssumedValid(); }));[m
[31m-                assert(any_chain([](auto chainstate) { return !chainstate->reliesOnAssumedValid(); }));[m
[31m-[m
[31m-                first_assumed_valid_height = block->nHeight;[m
[31m-                LogPrintf("Saw first assumedvalid block at height %d (%s)\n",[m
[31m-                        first_assumed_valid_height, block->ToString());[m
[31m-                break;[m
[31m-            }[m
[31m-        }[m
[31m-[m
         for (CBlockIndex* pindex : vSortedByHeight) {[m
             if (m_interrupt) return false;[m
[31m-            if (pindex->IsAssumedValid() ||[m
[32m+[m[32m            if (pindex == GetSnapshotBaseBlock() ||[m
                     (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) &&[m
                      (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))) {[m
 [m
[31m-                // Fill each chainstate's block candidate set. Only add assumed-valid[m
[31m-                // blocks to the tip candidate set if the chainstate is allowed to rely on[m
[31m-                // assumed-valid blocks.[m
[31m-                //[m
[31m-                // If all setBlockIndexCandidates contained the assumed-valid blocks, the[m
[31m-                // background chainstate's ActivateBestChain() call would add assumed-valid[m
[31m-                // blocks to the chain (based on how FindMostWorkChain() works). Obviously[m
[31m-                // we don't want this since the purpose of the background validation chain[m
[31m-                // is to validate assued-valid blocks.[m
[31m-                //[m
[31m-                // Note: This is considering all blocks whose height is greater or equal to[m
[31m-                // the first assumed-valid block to be assumed-valid blocks, and excluding[m
[31m-                // them from the background chainstate's setBlockIndexCandidates set. This[m
[31m-                // does mean that some blocks which are not technically assumed-valid[m
[31m-                // (later blocks on a fork beginning before the first assumed-valid block)[m
[31m-                // might not get added to the background chainstate, but this is ok,[m
[31m-                // because they will still be attached to the active chainstate if they[m
[31m-                // actually contain more work.[m
[31m-                //[m
[31m-                // Instead of this height-based approach, an earlier attempt was made at[m
[31m-                // detecting "holistically" whether the block index under consideration[m
[31m-                // relied on an assumed-valid ancestor, but this proved to be too slow to[m
[31m-                // be practical.[m
                 for (Chainstate* chainstate : GetAll()) {[m
[31m-                    if (chainstate->reliesOnAssumedValid() ||[m
[31m-                            pindex->nHeight < first_assumed_valid_height) {[m
[31m-                        chainstate->setBlockIndexCandidates.insert(pindex);[m
[31m-                    }[m
[32m+[m[32m                    chainstate->TryAddBlockIndexCandidate(pindex);[m
                 }[m
             }[m
             if (pindex->nStatus & BLOCK_FAILED_MASK && (!m_best_invalid || pindex->nChainWork > m_best_invalid->nChainWork)) {[m
[36m@@ -4496,12 +4486,12 @@[m [mbool Chainstate::LoadGenesisBlock()[m
 [m
     try {[m
         const CBlock& block = params.GenesisBlock();[m
[31m-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, 0, m_chain, nullptr)};[m
[32m+[m[32m        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, 0, nullptr)};[m
         if (blockPos.IsNull()) {[m
             return error("%s: writing genesis block to disk failed", __func__);[m
         }[m
         CBlockIndex* pindex = m_blockman.AddToBlockIndex(block, m_chainman.m_best_header);[m
[31m-        ReceivedBlockTransactions(block, pindex, blockPos);[m
[32m+[m[32m        m_chainman.ReceivedBlockTransactions(block, pindex, blockPos);[m
     } catch (const std::runtime_error& e) {[m
         return error("%s: failed to write genesis block: %s", __func__, e.what());[m
     }[m
[36m@@ -4509,18 +4499,16 @@[m [mbool Chainstate::LoadGenesisBlock()[m
     return true;[m
 }[m
 [m
[31m-void Chainstate::LoadExternalBlockFile([m
[32m+[m[32mvoid ChainstateManager::LoadExternalBlockFile([m
     FILE* fileIn,[m
     FlatFilePos* dbp,[m
     std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent)[m
 {[m
[31m-    AssertLockNotHeld(m_chainstate_mutex);[m
[31m-[m
     // Either both should be specified (-reindex), or neither (-loadblock).[m
     assert(!dbp == !blocks_with_unknown_parent);[m
 [m
     const auto start{SteadyClock::now()};[m
[31m-    const CChainParams& params{m_chainman.GetParams()};[m
[32m+[m[32m    const CChainParams& params{GetParams()};[m
 [m
     int nLoaded = 0;[m
     try {[m
[36m@@ -4530,7 +4518,7 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
         // such as a block fails to deserialize.[m
         uint64_t nRewind = blkdat.GetPos();[m
         while (!blkdat.eof()) {[m
[31m-            if (m_chainman.m_interrupt) return;[m
[32m+[m[32m            if (m_interrupt) return;[m
 [m
             blkdat.SetPos(nRewind);[m
             nRewind++; // start one byte further next time, in case of failure[m
[36m@@ -4606,7 +4594,14 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
                 // Activate the genesis block so normal node progress can continue[m
                 if (hash == params.GetConsensus().hashGenesisBlock) {[m
                     BlockValidationState state;[m
[31m-                    if (!ActivateBestChain(state, nullptr)) {[m
[32m+[m[32m                    bool genesis_activation_failure = false;[m
[32m+[m[32m                    for (auto c : GetAll()) {[m
[32m+[m[32m                        if (!c->ActivateBestChain(state, nullptr)) {[m
[32m+[m[32m                            genesis_activation_failure = true;[m
[32m+[m[32m                            break;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    if (genesis_activation_failure) {[m
                         break;[m
                     }[m
                 }[m
[36m@@ -4620,13 +4615,13 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
                     // called by concurrent network message processing. but, that is not[m
                     // reliable for the purpose of pruning while importing.[m
                     BlockValidationState state;[m
[31m-                    if (!ActivateBestChain(state, pblock)) {[m
[32m+[m[32m                    if (!ActiveChainstate().ActivateBestChain(state, pblock)) {[m
                         LogPrint(BCLog::REINDEX, "failed to activate chain (%s)\n", state.ToString());[m
                         break;[m
                     }[m
                 }[m
 [m
[31m-                NotifyHeaderTip(*this);[m
[32m+[m[32m                NotifyHeaderTip(ActiveChainstate());[m
 [m
                 if (!blocks_with_unknown_parent) continue;[m
 [m
[36m@@ -4652,7 +4647,7 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
                         }[m
                         range.first++;[m
                         blocks_with_unknown_parent->erase(it);[m
[31m-                        NotifyHeaderTip(*this);[m
[32m+[m[32m                        NotifyHeaderTip(ActiveChainstate());[m
                     }[m
                 }[m
             } catch (const std::exception& e) {[m
[36m@@ -4671,14 +4666,14 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
             }[m
         }[m
     } catch (const std::runtime_error& e) {[m
[31m-        m_chainman.GetNotifications().fatalError(std::string("System error: ") + e.what());[m
[32m+[m[32m        GetNotifications().fatalError(std::string("System error: ") + e.what());[m
     }[m
     LogPrintf("Loaded %i blocks from external file in %dms\n", nLoaded, Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));[m
 }[m
 [m
[31m-void Chainstate::CheckBlockIndex()[m
[32m+[m[32mvoid ChainstateManager::CheckBlockIndex()[m
 {[m
[31m-    if (!m_chainman.ShouldCheckBlockIndex()) {[m
[32m+[m[32m    if (!ShouldCheckBlockIndex()) {[m
         return;[m
     }[m
 [m
[36m@@ -4687,7 +4682,7 @@[m [mvoid Chainstate::CheckBlockIndex()[m
     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,[m
     // so we have the genesis block in m_blockman.m_block_index but no active chain. (A few of the[m
     // tests when iterating the block tree require that m_chain has been initialized.)[m
[31m-    if (m_chain.Height() < 0) {[m
[32m+[m[32m    if (ActiveChain().Height() < 0) {[m
         assert(m_blockman.m_block_index.size() <= 1);[m
         return;[m
     }[m
[36m@@ -4717,12 +4712,12 @@[m [mvoid Chainstate::CheckBlockIndex()[m
     CBlockIndex* pindexFirstNotTransactionsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).[m
     CBlockIndex* pindexFirstNotChainValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).[m
     CBlockIndex* pindexFirstNotScriptsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).[m
[32m+[m[32m    CBlockIndex* pindexFirstAssumeValid = nullptr; // Oldest ancestor of pindex which has BLOCK_ASSUMED_VALID[m
     while (pindex != nullptr) {[m
         nNodes++;[m
[32m+[m[32m        if (pindexFirstAssumeValid == nullptr && pindex->nStatus & BLOCK_ASSUMED_VALID) pindexFirstAssumeValid = pindex;[m
         if (pindexFirstInvalid == nullptr && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;[m
[31m-        // Assumed-valid index entries will not have data since we haven't downloaded the[m
[31m-        // full block yet.[m
[31m-        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA) && !pindex->IsAssumedValid()) {[m
[32m+[m[32m        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA)) {[m
             pindexFirstMissing = pindex;[m
         }[m
         if (pindexFirstNeverProcessed == nullptr && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;[m
[36m@@ -4751,8 +4746,8 @@[m [mvoid Chainstate::CheckBlockIndex()[m
         // Begin: actual consistency checks.[m
         if (pindex->pprev == nullptr) {[m
             // Genesis block checks.[m
[31m-            assert(pindex->GetBlockHash() == m_chainman.GetConsensus().hashGenesisBlock); // Genesis block's hash must match.[m
[31m-            assert(pindex == m_chain.Genesis()); // The current active chain's genesis block must be this block.[m
[32m+[m[32m            assert(pindex->GetBlockHash() == GetConsensus().hashGenesisBlock); // Genesis block's hash must match.[m
[32m+[m[32m            assert(pindex == ActiveChain().Genesis()); // The current active chain's genesis block must be this block.[m
         }[m
         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)[m
         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).[m
[36m@@ -4762,7 +4757,13 @@[m [mvoid Chainstate::CheckBlockIndex()[m
         if (!m_blockman.m_have_pruned && !pindex->IsAssumedValid()) {[m
             // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0[m
             assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));[m
[31m-            assert(pindexFirstMissing == pindexFirstNeverProcessed);[m
[32m+[m[32m            if (pindexFirstAssumeValid == nullptr) {[m
[32m+[m[32m                // If we've got some assume valid blocks, then we might have[m
[32m+[m[32m                // missing blocks (not HAVE_DATA) but still treat them as[m
[32m+[m[32m                // having been processed (with a fake nTx value). Otherwise, we[m
[32m+[m[32m                // can assert that these are the same.[m
[32m+[m[32m                assert(pindexFirstMissing == pindexFirstNeverProcessed);[m
[32m+[m[32m            }[m
         } else {[m
             // If we have pruned, then we can only say that HAVE_DATA implies nTx > 0[m
             if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);[m
[36m@@ -4792,27 +4793,32 @@[m [mvoid Chainstate::CheckBlockIndex()[m
             // Checks for not-invalid blocks.[m
             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.[m
         }[m
[31m-        if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {[m
[31m-            if (pindexFirstInvalid == nullptr) {[m
[31m-                const bool is_active = this == &m_chainman.ActiveChainstate();[m
[31m-[m
[31m-                // If this block sorts at least as good as the current tip and[m
[31m-                // is valid and we have all data for its parents, it must be in[m
[31m-                // setBlockIndexCandidates.  m_chain.Tip() must also be there[m
[31m-                // even if some data has been pruned.[m
[31m-                //[m
[31m-                // Don't perform this check for the background chainstate since[m
[31m-                // its setBlockIndexCandidates shouldn't have some entries (i.e. those past the[m
[31m-                // snapshot block) which do exist in the block index for the active chainstate.[m
[31m-                if (is_active && (pindexFirstMissing == nullptr || pindex == m_chain.Tip())) {[m
[31m-                    assert(setBlockIndexCandidates.count(pindex));[m
[32m+[m[32m        // Chainstate-specific checks on setBlockIndexCandidates[m
[32m+[m[32m        for (auto c : GetAll()) {[m
[32m+[m[32m            if (c->m_chain.Tip() == nullptr) continue;[m
[32m+[m[32m            if (!CBlockIndexWorkComparator()(pindex, c->m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {[m
[2m+[m[2m                if (pindexFirstInvalid == nullptr) {[m
[32m+[m[32m                    const bool is_active = c == &ActiveChainstate();[m
[32m+[m[32m                    // If this block sorts at least as good as the current tip and[m
[32m+[m[32m                    // is valid and we have all data for its parents, it must be in[m
[32m+[m[32m                    // setBlockIndexCandidates.  m_chain.Tip() must also be there[m
[32m+[m[32m                    // even if some data has been pruned.[m
[32m+[m[32m                    //[m
[32m+[m[32m                    if ((pindexFirstMissing == nullptr || pindex == c->m_chain.Tip())) {[m
[32m+[m[32m                        // The active chainstate should always have this block[m
[32m+[m[32m                        // as a candidate, but a background chainstate should[m
[32m+[m[32m                        // only have it if it is an ancestor of the snapshot base.[m
[32m+[m[32m                        if (is_active || GetSnapshotBaseBlock()->GetAncestor(pindex->nHeight) == pindex) {[m
[32m+[m[32m                            assert(c->setBlockIndexCandidates.count(pindex));[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                    // If some parent is missing, then it could be that this block was in[m
[32m+[m[32m                    // setBlockIndexCandidates but had to be removed because of the missing data.[m
[32m+[m[32m                    // In this case it must be in m_blocks_unlinked -- see test below.[m
                 }[m
[31m-                // If some parent is missing, then it could be that this block was in[m
[31m-                // setBlockIndexCandidates but had to be removed because of the missing data.[m
[31m-                // In this case it must be in m_blocks_unlinked -- see test below.[m
[32m+[m[32m            } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.[m
[32m+[m[32m                assert(c->setBlockIndexCandidates.count(pindex) == 0);[m
             }[m
[31m-        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.[m
[31m-            assert(setBlockIndexCandidates.count(pindex) == 0);[m
         }[m
         // Check whether this block is in m_blocks_unlinked.[m
         std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = m_blockman.m_blocks_unlinked.equal_range(pindex->pprev);[m
[36m@@ -4833,18 +4839,23 @@[m [mvoid Chainstate::CheckBlockIndex()[m
         if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.[m
         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {[m
             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.[m
[31m-            assert(m_blockman.m_have_pruned); // We must have pruned.[m
[32m+[m[32m            assert(m_blockman.m_have_pruned || pindexFirstAssumeValid != nullptr); // We must have pruned, or else we're using a snapshot (causing us to have faked the received data for some parent(s)).[m
             // This block may have entered m_blocks_unlinked if:[m
             //  - it has a descendant that at some point had more work than the[m
             //    tip, and[m
             //  - we tried switching to that descendant but were missing[m
             //    data for some intermediate block between m_chain and the[m
             //    tip.[m
[31m-            // So if this block is itself better than m_chain.Tip() and it wasn't in[m
[32m+[m[32m            // So if this block is itself better than any m_chain.Tip() and it wasn't in[m
             // setBlockIndexCandidates, then it must be in m_blocks_unlinked.[m
[31m-            if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {[m
[2m-                if (pindexFirstInvalid == nullptr) {[m
[31m-                    assert(foundInUnlinked);[m
[32m+[m[32m            for (auto c : GetAll()) {[m
[32m+[m[32m                const bool is_active = c == &ActiveChainstate();[m
[32m+[m[32m                if (!CBlockIndexWorkComparator()(pindex, c->m_chain.Tip()) && c->setBlockIndexCandidates.count(pindex) == 0) {[m
[32m+[m[32m                    if (pindexFirstInvalid == nullptr) {[m
[32m+[m[32m                        if (is_active || GetSnapshotBaseBlock()->GetAncestor(pindex->nHeight) == pindex) {[m
[32m+[m[32m                            assert(foundInUnlinked);[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
                 }[m
             }[m
         }[m
[36m@@ -4871,6 +4882,7 @@[m [mvoid Chainstate::CheckBlockIndex()[m
             if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = nullptr;[m
             if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = nullptr;[m
             if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = nullptr;[m
[32m+[m[32m            if (pindex == pindexFirstAssumeValid) pindexFirstAssumeValid = nullptr;[m
             // Find our parent.[m
             CBlockIndex* pindexPar = pindex->pprev;[m
             // Find which child we just visited.[m
[33mdiff --git a/src/validation.h b/src/validation.h[m
[33mindex af8ceb5dfa..2be6cf0643 100644[m
[33m--- a/src/validation.h[m
[33m+++ b/src/validation.h[m
[36m@@ -465,17 +465,6 @@[m [menum class CoinsCacheSizeState[m
 class Chainstate[m
 {[m
 protected:[m
[2m-    /**[m
[2m-     * Every received block is assigned a unique and increasing identifier, so we[m
[2m-     * know which one to give priority in case of a fork.[m
[2m-     */[m
[2m-    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */[m
[2m-    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;[m
[2m-    /** Decreasing counter (used by subsequent preciousblock calls). */[m
[2m-    int32_t nBlockReverseSequenceId = -1;[m
[2m-    /** chainwork for the last block that preciousblock has been applied to. */[m
[2m-    arith_uint256 nLastPreciousChainwork = 0;[m
[2m-[m
     /**[m
      * The ChainState Mutex[m
      * A lock that must be held when modifying this ChainState - held in ActivateBestChain() and[m
[36m@@ -511,6 +500,9 @@[m [mprotected:[m
     //! is set to true on the snapshot chainstate.[m
     bool m_disabled GUARDED_BY(::cs_main) {false};[m
 [m
[32m+[m[32m    //! Cached result of LookupBlockIndex(*m_from_snapshot_blockhash)[m
[32m+[m[32m    const CBlockIndex* m_cached_snapshot_base GUARDED_BY(::cs_main) {nullptr};[m
[32m+[m
 public:[m
     //! Reference to a BlockManager instance which itself is shared across all[m
     //! Chainstate instances.[m
[36m@@ -562,6 +554,13 @@[m [mpublic:[m
      */[m
     const std::optional<uint256> m_from_snapshot_blockhash;[m
 [m
[32m+[m[32m    /**[m
[32m+[m[32m     * The base of the snapshot this chainstate was created from.[m
[32m+[m[32m     *[m
[32m+[m[32m     * nullptr if this chainstate was not created from a snapshot.[m
[32m+[m[32m     */[m
[32m+[m[32m    const CBlockIndex* SnapshotBase() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[32m+[m
     //! Return true if this chainstate relies on blocks that are assumed-valid. In[m
     //! practice this means it was created based on a UTXO snapshot.[m
     bool reliesOnAssumedValid() { return m_from_snapshot_blockhash.has_value(); }[m
[36m@@ -620,37 +619,6 @@[m [mpublic:[m
     bool ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)[m
         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
 [m
[2m-    /**[m
[2m-     * Import blocks from an external file[m
[2m-     *[m
[2m-     * During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat).[m
[2m-     * It reads all blocks contained in the given file and attempts to process them (add them to the[m
[2m-     * block index). The blocks may be out of order within each file and across files. Often this[m
[2m-     * function reads a block but finds that its parent hasn't been read yet, so the block can't be[m
[2m-     * processed yet. The function will add an entry to the blocks_with_unknown_parent map (which is[m
[2m-     * passed as an argument), so that when the block's parent is later read and processed, this[m
[2m-     * function can re-read the child block from disk and process it.[m
[2m-     *[m
[2m-     * Because a block's parent may be in a later file, not just later in the same file, the[m
[2m-     * blocks_with_unknown_parent map must be passed in and out with each call. It's a multimap,[m
[2m-     * rather than just a map, because multiple blocks may have the same parent (when chain splits[m
[2m-     * or stale blocks exist). It maps from parent-hash to child-disk-position.[m
[2m-     *[m
[2m-     * This function can also be used to read blocks from user-specified block files using the[m
[2m-     * -loadblock= option. There's no unknown-parent tracking, so the last two arguments are omitted.[m
[2m-     *[m
[2m-     *[m
[2m-     * @param[in]     fileIn                        FILE handle to file containing blocks to read[m
[2m-     * @param[in]     dbp                           (optional) Disk block position (only for reindex)[m
[2m-     * @param[in,out] blocks_with_unknown_parent    (optional) Map of disk positions for blocks with[m
[2m-     *                                              unknown parent, key is parent block hash[m
[2m-     *                                              (only used for reindex)[m
[2m-     * */[m
[2m-    void LoadExternalBlockFile([m
[2m-        FILE* fileIn,[m
[2m-        FlatFilePos* dbp = nullptr,[m
[31m-        std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent = nullptr)[m
[31m-        EXCLUSIVE_LOCKS_REQUIRED(!m_chainstate_mutex);[m
 [m
     /**[m
      * Update the on-disk chain state.[m
[36m@@ -702,8 +670,6 @@[m [mpublic:[m
         EXCLUSIVE_LOCKS_REQUIRED(!m_chainstate_mutex)[m
         LOCKS_EXCLUDED(::cs_main);[m
 [m
[2m-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[2m-[m
     // Block (dis)connection on a given view:[m
     DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)[m
         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[36m@@ -738,9 +704,11 @@[m [mpublic:[m
     /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */[m
     bool LoadGenesisBlock();[m
 [m
[32m+[m[32m    void TryAddBlockIndexCandidate(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m
     void PruneBlockIndexCandidates();[m
 [m
[31m-    void UnloadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
[32m+[m[32m    void ClearBlockIndexCandidates() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
 [m
     /** Check whether we are doing an initial block download (synchronizing from disk or network) */[m
     bool IsInitialBlockDownload() const;[m
[36m@@ -748,13 +716,6 @@[m [mpublic:[m
     /** Find the last common block of this chain and a locator. */[m
     const CBlockIndex* FindForkInGlobalIndex(const CBlockLocator& locator) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[2m-    /**[m
[2m-     * Make various assertions about the state of the block index.[m
[2m-     *[m
[2m-     * By default this only executes fully when using the Regtest chain; see: m_options.check_block_index.[m
[2m-     */[m
[2m-    void CheckBlockIndex();[m
[2m-[m
     /** Load the persisted mempool from disk */[m
     void LoadMempool(const fs::path& load_path, fsbridge::FopenFn mockable_fopen_function = fsbridge::fopen);[m
 [m
[36m@@ -784,7 +745,6 @@[m [mprivate:[m
 [m
     void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[2m-    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
 [m
[36m@@ -970,6 +930,13 @@[m [mpublic:[m
     const uint256& AssumedValidBlock() const { return *Assert(m_options.assumed_valid_block); }[m
     kernel::Notifications& GetNotifications() const { return m_options.notifications; };[m
 [m
[2m+[m[2m    /**[m
[2m+[m[2m     * Make various assertions about the state of the block index.[m
[2m+[m[2m     *[m
[2m+[m[2m     * By default this only executes fully when using the Regtest chain; see: m_options.check_block_index.[m
[2m+[m[2m     */[m
[2m+[m[2m    void CheckBlockIndex();[m
[2m+[m
     /**[m
      * Alias for ::cs_main.[m
      * Should be used in new code to make it easier to make ::cs_main a member[m
[36m@@ -990,6 +957,25 @@[m [mpublic:[m
     //! chainstate to avoid duplicating block metadata.[m
     node::BlockManager m_blockman;[m
 [m
[2m+[m[2m    /**[m
[2m+[m[2m     * Every received block is assigned a unique and increasing identifier, so we[m
[2m+[m[2m     * know which one to give priority in case of a fork.[m
[2m+[m[2m     */[m
[2m+[m[2m    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */[m
[2m+[m[2m    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;[m
[2m+[m[2m    /** Decreasing counter (used by subsequent preciousblock calls). */[m
[2m+[m[2m    int32_t nBlockReverseSequenceId = -1;[m
[2m+[m[2m    /** chainwork for the last block that preciousblock has been applied to. */[m
[2m+[m[2m    arith_uint256 nLastPreciousChainwork = 0;[m
[2m+[m
[32m+[m[32m    void ResetBlockSequenceCounters() EXCLUSIVE_LOCKS_REQUIRED(::cs_main)[m
[32m+[m[32m    {[m
[32m+[m[32m        AssertLockHeld(::cs_main);[m
[32m+[m[32m        nBlockSequenceId = 1;[m
[32m+[m[32m        nBlockReverseSequenceId = -1;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m
     /**[m
      * In order to efficiently track invalidity of headers, we keep the set of[m
      * blocks which we tried to connect and found to be invalid here (ie which[m
[36m@@ -1085,6 +1071,42 @@[m [mpublic:[m
         return m_snapshot_chainstate && m_ibd_chainstate && m_ibd_chainstate->m_disabled;[m
     }[m
 [m
[32m+[m[32m    const CBlockIndex* ActiveSnapshotBase() const EXCLUSIVE_LOCKS_REQUIRED(::cs_main)[m
[32m+[m[32m    {[m
[32m+[m[32m        return m_active_chainstate ? m_active_chainstate->SnapshotBase() : nullptr;[m
[32m+[m[32m    }[m
[32m+[m
[2m+[m[2m    /**[m
[2m+[m[2m     * Import blocks from an external file[m
[2m+[m[2m     *[m
[2m+[m[2m     * During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat).[m
[2m+[m[2m     * It reads all blocks contained in the given file and attempts to process them (add them to the[m
[2m+[m[2m     * block index). The blocks may be out of order within each file and across files. Often this[m
[2m+[m[2m     * function reads a block but finds that its parent hasn't been read yet, so the block can't be[m
[2m+[m[2m     * processed yet. The function will add an entry to the blocks_with_unknown_parent map (which is[m
[2m+[m[2m     * passed as an argument), so that when the block's parent is later read and processed, this[m
[2m+[m[2m     * function can re-read the child block from disk and process it.[m
[2m+[m[2m     *[m
[2m+[m[2m     * Because a block's parent may be in a later file, not just later in the same file, the[m
[2m+[m[2m     * blocks_with_unknown_parent map must be passed in and out with each call. It's a multimap,[m
[2m+[m[2m     * rather than just a map, because multiple blocks may have the same parent (when chain splits[m
[2m+[m[2m     * or stale blocks exist). It maps from parent-hash to child-disk-position.[m
[2m+[m[2m     *[m
[2m+[m[2m     * This function can also be used to read blocks from user-specified block files using the[m
[2m+[m[2m     * -loadblock= option. There's no unknown-parent tracking, so the last two arguments are omitted.[m
[2m+[m[2m     *[m
[2m+[m[2m     *[m
[2m+[m[2m     * @param[in]     fileIn                        FILE handle to file containing blocks to read[m
[2m+[m[2m     * @param[in]     dbp                           (optional) Disk block position (only for reindex)[m
[2m+[m[2m     * @param[in,out] blocks_with_unknown_parent    (optional) Map of disk positions for blocks with[m
[2m+[m[2m     *                                              unknown parent, key is parent block hash[m
[2m+[m[2m     *                                              (only used for reindex)[m
[2m+[m[2m     * */[m
[2m+[m[2m    void LoadExternalBlockFile([m
[2m+[m[2m        FILE* fileIn,[m
[2m+[m[2m        FlatFilePos* dbp = nullptr,[m
[32m+[m[32m        std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent = nullptr);[m
[32m+[m
     /**[m
      * Process an incoming block. This only returns after the best known valid[m
      * block is made active. Note that it does not, however, guarantee that the[m
[36m@@ -1124,6 +1146,29 @@[m [mpublic:[m
      */[m
     bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, bool min_pow_checked, BlockValidationState& state, const CBlockIndex** ppindex = nullptr) LOCKS_EXCLUDED(cs_main);[m
 [m
[32m+[m[32m    /**[m
[32m+[m[32m     * Sufficiently validate a block for disk storage (and store on disk).[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param[in]   pblock          The block we want to process.[m
[32m+[m[32m     * @param[in]   fRequested      Whether we requested this block from a[m
[32m+[m[32m     *                              peer.[m
[32m+[m[32m     * @param[in]   dbp             The location on disk, if we are importing[m
[32m+[m[32m     *                              this block from prior storage.[m
[32m+[m[32m     * @param[in]   min_pow_checked True if proof-of-work anti-DoS checks have[m
[32m+[m[32m     *                              been done by caller for headers chain[m
[32m+[m[32m     *[m
[32m+[m[32m     * @param[out]  state       The state of the block validation.[m
[32m+[m[32m     * @param[out]  ppindex     Optional return parameter to get the[m
[32m+[m[32m     *                          CBlockIndex pointer for this block.[m
[32m+[m[32m     * @param[out]  fNewBlock   Optional return parameter to indicate if the[m
[32m+[m[32m     *                          block is new to our storage.[m
[32m+[m[32m     *[m
[32m+[m[32m     * @returns   False if the block or header is invalid, or if saving to disk fails (likely a fatal error); true otherwise.[m
[32m+[m[32m     */[m
[2m+[m[2m    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[1;36m+[m
[1;33m+[m[1;33m    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
[32m+[m
     /**[m
      * Try to add a transaction to the memory pool.[m
      *[m