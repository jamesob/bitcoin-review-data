--- /home/james/.ackr/27746.sdaftuar.rework_validation_logic/4.7c0b991/base.diff	2023-07-14 15:33:17.188065990 -0400
+++ /home/james/.ackr/27746.sdaftuar.rework_validation_logic/5.a733dd7/base.diff	2023-07-28 10:45:31.739747313 -0400
@@ -1,1321 +1,1381 @@
-[33mdiff --git a/doc/design/assumeutxo.md b/doc/design/assumeutxo.md[m
-[33mindex 469c551536..1492877e62 100644[m
-[33m--- a/doc/design/assumeutxo.md[m
-[33m+++ b/doc/design/assumeutxo.md[m
-[36m@@ -17,10 +17,9 @@[m [mrespectively generate and load UTXO snapshots. The utility script[m
- [m
- - A new block index `nStatus` flag is introduced, `BLOCK_ASSUMED_VALID`, to mark block[m
-   index entries that are required to be assumed-valid by a chainstate created[m
-[31m-  from a UTXO snapshot. This flag is mostly used as a way to modify certain[m
-[32m+[m[32m  from a UTXO snapshot. This flag is used as a way to modify certain[m
-   CheckBlockIndex() logic to account for index entries that are pending validation by a[m
-[31m-  chainstate running asynchronously in the background. We also use this flag to control[m
-[31m-  which index entries are added to setBlockIndexCandidates during LoadBlockIndex().[m
-[32m+[m[32m  chainstate running asynchronously in the background.[m
- [m
- - The concept of UTXO snapshots is treated as an implementation detail that lives[m
-   behind the ChainstateManager interface. The external presentation of the changes[m
-[33mdiff --git a/src/bench/load_external.cpp b/src/bench/load_external.cpp[m
-[33mindex 1378a7b20a..252cbb163b 100644[m
-[33m--- a/src/bench/load_external.cpp[m
-[33m+++ b/src/bench/load_external.cpp[m
-[36m@@ -49,14 +49,13 @@[m [mstatic void LoadExternalBlockFile(benchmark::Bench& bench)[m
-         fclose(file);[m
-     }[m
- [m
-[31m-    Chainstate& chainstate{testing_setup->m_node.chainman->ActiveChainstate()};[m
-     std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;[m
-     FlatFilePos pos;[m
-     bench.run([&] {[m
-         // "rb" is "binary, O_RDONLY", positioned to the start of the file.[m
-         // The file will be closed by LoadExternalBlockFile().[m
-         FILE* file{fsbridge::fopen(blkfile, "rb")};[m
-[31m-        chainstate.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
-[32m+[m[32m        testing_setup->m_node.chainman->LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
-     });[m
-     fs::remove(blkfile);[m
- }[m
-[33mdiff --git a/src/chain.h b/src/chain.h[m
-[33mindex f5dd0fd315..2ccd015e57 100644[m
-[33m--- a/src/chain.h[m
-[33m+++ b/src/chain.h[m
-[36m@@ -113,10 +113,10 @@[m [menum BlockStatus : uint32_t {[m
-     BLOCK_VALID_TRANSACTIONS =    3,[m
- [m
-     //! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30.[m
-[31m-    //! Implies all parents are also at least CHAIN.[m
-[32m+[m[32m    //! Implies all parents are either at least VALID_CHAIN, or are ASSUMED_VALID[m
-     BLOCK_VALID_CHAIN        =    4,[m
- [m
-[31m-    //! Scripts & signatures ok. Implies all parents are also at least SCRIPTS.[m
-[32m+[m[32m    //! Scripts & signatures ok. Implies all parents are either at least VALID_SCRIPTS, or are ASSUMED_VALID.[m
-     BLOCK_VALID_SCRIPTS      =    5,[m
- [m
-     //! All validity bits.[m
-[36m@@ -134,10 +134,18 @@[m [menum BlockStatus : uint32_t {[m
-     BLOCK_OPT_WITNESS        =   128, //!< block data in blk*.dat was received with a witness-enforcing client[m
- [m
-     /**[m
-[31m-     * If set, this indicates that the block index entry is assumed-valid.[m
-[31m-     * Certain diagnostics will be skipped in e.g. CheckBlockIndex().[m
-[31m-     * It almost certainly means that the block's full validation is pending[m
-[31m-     * on a background chainstate. See `doc/design/assumeutxo.md`.[m
-[32m+[m[32m     * If ASSUMED_VALID is set, it means that this block has not been validated[m
-[32m+[m[32m     * and has validity status less than VALID_SCRIPTS. Also that it has[m
-[32m+[m[32m     * descendant blocks with VALID_SCRIPTS set, because they were validated[m
-[32m+[m[32m     * based on an assumeutxo snapshot.[m
-[32m+[m[32m     *[m
-[32m+[m[32m     * When an assumeutxo snapshot is loaded, the ASSUMED_VALID flag is added to[m
-[32m+[m[32m     * unvalidated blocks below the snapshot height. Then, as the background[m
-[32m+[m[32m     * validation progresses, and these blocks are validated, the ASSUMED_VALID[m
-[32m+[m[32m     * flags are removed. See `doc/design/assumeutxo.md` for details.[m
-[32m+[m[32m     *[m
-[32m+[m[32m     * This flag is only used to implement checks in CheckBlockIndex() and[m
-[32m+[m[32m     * should not be used elsewhere.[m
-      */[m
-     BLOCK_ASSUMED_VALID      =   256,[m
- };[m
-[33mdiff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp[m
-[33mindex 78416ec576..0d25c798ce 100644[m
-[33m--- a/src/node/blockstorage.cpp[m
-[33m+++ b/src/node/blockstorage.cpp[m
-[36m@@ -618,7 +618,7 @@[m [mfs::path BlockManager::GetBlockPosFilename(const FlatFilePos& pos) const[m
-     return BlockFileSeq().FileName(pos);[m
- }[m
- [m
-[31m-bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown)[m
-[32m+[m[32mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown)[m
- {[m
-     LOCK(cs_LastBlockFile);[m
- [m
-[36m@@ -644,7 +644,7 @@[m [mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne[m
-             // when the undo file is keeping up with the block file, we want to flush it explicitly[m
-             // when it is lagging behind (more blocks arrive than are being connected), we let the[m
-             // undo block write case handle it[m
-[31m-            finalize_undo = (m_blockfile_info[nFile].nHeightLast == (unsigned int)active_chain.Tip()->nHeight);[m
-[32m+[m[32m            finalize_undo = (m_blockfile_info[nFile].nHeightLast == m_undo_height_in_last_blockfile);[m
-             nFile++;[m
-             if (m_blockfile_info.size() <= nFile) {[m
-                 m_blockfile_info.resize(nFile + 1);[m
-[36m@@ -660,6 +660,7 @@[m [mbool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne[m
-         }[m
-         FlushBlockFile(!fKnown, finalize_undo);[m
-         m_last_blockfile = nFile;[m
-[32m+[m[32m        m_undo_height_in_last_blockfile = 0; // No undo data yet in the new file, so reset our undo-height tracking.[m
-     }[m
- [m
-     m_blockfile_info[nFile].AddBlock(nHeight, nTime);[m
-[36m@@ -749,8 +750,9 @@[m [mbool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid[m
-         // the FindBlockPos function[m
-         if (_pos.nFile < m_last_blockfile && static_cast<uint32_t>(block.nHeight) == m_blockfile_info[_pos.nFile].nHeightLast) {[m
-             FlushUndoFile(_pos.nFile, true);[m
-[32m+[m[32m        } else if (_pos.nFile == m_last_blockfile && static_cast<uint32_t>(block.nHeight) > m_undo_height_in_last_blockfile) {[m
-[32m+[m[32m            m_undo_height_in_last_blockfile = block.nHeight;[m
-         }[m
-[31m-[m
-         // update nUndoPos in block index[m
-         block.nUndoPos = _pos.nPos;[m
-         block.nStatus |= BLOCK_HAVE_UNDO;[m
-[36m@@ -839,7 +841,7 @@[m [mbool BlockManager::ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatF[m
-     return true;[m
- }[m
- [m
-[31m-FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const FlatFilePos* dbp)[m
-[32m+[m[32mFlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, const FlatFilePos* dbp)[m
- {[m
-     unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);[m
-     FlatFilePos blockPos;[m
-[36m@@ -852,7 +854,7 @@[m [mFlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CCha[m
-         // we add BLOCK_SERIALIZATION_HEADER_SIZE only for new blocks since they will have the serialization header added when written to disk.[m
-         nBlockSize += static_cast<unsigned int>(BLOCK_SERIALIZATION_HEADER_SIZE);[m
-     }[m
-[31m-    if (!FindBlockPos(blockPos, nBlockSize, nHeight, active_chain, block.GetBlockTime(), position_known)) {[m
-[32m+[m[32m    if (!FindBlockPos(blockPos, nBlockSize, nHeight, block.GetBlockTime(), position_known)) {[m
-         error("%s: FindBlockPos failed", __func__);[m
-         return FlatFilePos();[m
-     }[m
-[36m@@ -905,7 +907,7 @@[m [mvoid ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFile[m
-                     break; // This error is logged in OpenBlockFile[m
-                 }[m
-                 LogPrintf("Reindexing block file blk%05u.dat...\n", (unsigned int)nFile);[m
-[31m-                chainman.ActiveChainstate().LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
-[32m+[m[32m                chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);[m
-                 if (chainman.m_interrupt) {[m
-                     LogPrintf("Interrupt requested. Exit %s\n", __func__);[m
-                     return;[m
-[36m@@ -924,7 +926,7 @@[m [mvoid ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFile[m
-             FILE* file = fsbridge::fopen(path, "rb");[m
-             if (file) {[m
-                 LogPrintf("Importing blocks file %s...\n", fs::PathToString(path));[m
-[31m-                chainman.ActiveChainstate().LoadExternalBlockFile(file);[m
-[32m+[m[32m                chainman.LoadExternalBlockFile(file);[m
-                 if (chainman.m_interrupt) {[m
-                     LogPrintf("Interrupt requested. Exit %s\n", __func__);[m
-                     return;[m
-[33mdiff --git a/src/node/blockstorage.h b/src/node/blockstorage.h[m
-[33mindex c2e903e470..eb40d45aba 100644[m
-[33m--- a/src/node/blockstorage.h[m
-[33m+++ b/src/node/blockstorage.h[m
-[36m@@ -24,7 +24,6 @@[m [mclass BlockValidationState;[m
- class CBlock;[m
- class CBlockFileInfo;[m
- class CBlockUndo;[m
-[31m-class CChain;[m
- class CChainParams;[m
- class Chainstate;[m
- class ChainstateManager;[m
-[36m@@ -94,7 +93,7 @@[m [mprivate:[m
-         EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-     void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);[m
-     void FlushUndoFile(int block_file, bool finalize = false);[m
-[31m-    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown);[m
-[32m+[m[32m    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);[m
-     bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize);[m
- [m
-     FlatFileSeq BlockFileSeq() const;[m
-[36m@@ -128,6 +127,19 @@[m [mprivate:[m
-     RecursiveMutex cs_LastBlockFile;[m
-     std::vector<CBlockFileInfo> m_blockfile_info;[m
-     int m_last_blockfile = 0;[m
-[32m+[m
-[32m+[m[32m    // Track the height of the highest block in m_last_blockfile whose undo[m
-[32m+[m[32m    // data has been written. Block data is written to block files in download[m
-[32m+[m[32m    // order, but is written to undo files in validation order, which is[m
-[32m+[m[32m    // usually in order by height. To avoid wasting disk space, undo files will[m
-[32m+[m[32m    // be trimmed whenever the corresponding block file is finalized and[m
-[32m+[m[32m    // the height of the highest block written to the block file equals the[m
-[32m+[m[32m    // height of the highest block written to the undo file. This is a[m
-[32m+[m[32m    // heuristic and can sometimes preemptively trim undo files that will write[m
-[32m+[m[32m    // more data later, and sometimes fail to trim undo files that can't have[m
-[32m+[m[32m    // more data written later.[m
-[32m+[m[32m    unsigned int m_undo_height_in_last_blockfile = 0;[m
-[32m+[m
-     /** Global flag to indicate we should check to see if there are[m
-      *  block/undo files that should be deleted.  Set on startup[m
-      *  or if we allocate more file space when we're in prune mode[m
-[36m@@ -202,7 +214,7 @@[m [mpublic:[m
-         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
- [m
-     /** Store block on disk. If dbp is not nullptr, then it provides the known position of the block within a block file on disk. */[m
-[31m-    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const FlatFilePos* dbp);[m
-[32m+[m[32m    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, const FlatFilePos* dbp);[m
- [m
-     /** Whether running in -prune mode. */[m
-     [[nodiscard]] bool IsPruneMode() const { return m_prune_mode; }[m
-[33mdiff --git a/src/node/chainstate.cpp b/src/node/chainstate.cpp[m
-[33mindex 255d8be0ec..0828f64856 100644[m
-[33m--- a/src/node/chainstate.cpp[m
-[33m+++ b/src/node/chainstate.cpp[m
-[36m@@ -221,7 +221,7 @@[m [mChainstateLoadResult LoadChainstate(ChainstateManager& chainman, const CacheSize[m
- [m
-         // A reload of the block index is required to recompute setBlockIndexCandidates[m
-         // for the fully validated chainstate.[m
-[31m-        chainman.ActiveChainstate().UnloadBlockIndex();[m
-[32m+[m[32m        chainman.ActiveChainstate().ClearBlockIndexCandidates();[m
- [m
-         auto [init_status, init_error] = CompleteChainstateInitialization(chainman, cache_sizes, options);[m
-         if (init_status != ChainstateLoadStatus::SUCCESS) {[m
-[33mdiff --git a/src/test/blockmanager_tests.cpp b/src/test/blockmanager_tests.cpp[m
-[33mindex e4ed861b12..f52c692649 100644[m
-[33m--- a/src/test/blockmanager_tests.cpp[m
-[33m+++ b/src/test/blockmanager_tests.cpp[m
-[36m@@ -30,22 +30,21 @@[m [mBOOST_AUTO_TEST_CASE(blockmanager_find_block_pos)[m
-         .notifications = notifications,[m
-     };[m
-     BlockManager blockman{m_node.kernel->interrupt, blockman_opts};[m
-[31m-    CChain chain {};[m
-     // simulate adding a genesis block normally[m
-[31m-    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, chain, nullptr).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, nullptr).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
-     // simulate what happens during reindex[m
-     // simulate a well-formed genesis block being found at offset 8 in the blk00000.dat file[m
-     // the block is found at offset 8 because there is an 8 byte serialization header[m
-     // consisting of 4 magic bytes + 4 length bytes before each block in a well-formed blk file.[m
-     FlatFilePos pos{0, BLOCK_SERIALIZATION_HEADER_SIZE};[m
-[31m-    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, chain, &pos).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, &pos).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);[m
-     // now simulate what happens after reindex for the first new block processed[m
-     // the actual block contents don't matter, just that it's a block.[m
-     // verify that the write position is at offset 0x12d.[m
-     // this is a check to make sure that https://github.com/bitcoin/bitcoin/issues/21379 does not recur[m
-     // 8 bytes (for serialization header) + 285 (for serialized genesis block) = 293[m
-     // add another 8 bytes for the second block's serialization header and we get 293 + 8 = 301[m
-[31m-    FlatFilePos actual{blockman.SaveBlockToDisk(params->GenesisBlock(), 1, chain, nullptr)};[m
-[32m+[m[32m    FlatFilePos actual{blockman.SaveBlockToDisk(params->GenesisBlock(), 1, nullptr)};[m
-     BOOST_CHECK_EQUAL(actual.nPos, BLOCK_SERIALIZATION_HEADER_SIZE + ::GetSerializeSize(params->GenesisBlock(), CLIENT_VERSION) + BLOCK_SERIALIZATION_HEADER_SIZE);[m
- }[m
- [m
-[33mdiff --git a/src/test/coinstatsindex_tests.cpp b/src/test/coinstatsindex_tests.cpp[m
-[33mindex 74d6d7231a..787a196a0c 100644[m
-[33m--- a/src/test/coinstatsindex_tests.cpp[m
-[33m+++ b/src/test/coinstatsindex_tests.cpp[m
-[36m@@ -98,7 +98,7 @@[m [mBOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)[m
-             LOCK(cs_main);[m
-             BlockValidationState state;[m
-             BOOST_CHECK(CheckBlock(block, state, params.GetConsensus()));[m
-[31m-            BOOST_CHECK(chainstate.AcceptBlock(new_block, state, &new_block_index, true, nullptr, nullptr, true));[m
-[32m+[m[32m            BOOST_CHECK(m_node.chainman->AcceptBlock(new_block, state, &new_block_index, true, nullptr, nullptr, true));[m
-             CCoinsViewCache view(&chainstate.CoinsTip());[m
-             BOOST_CHECK(chainstate.ConnectBlock(block, state, new_block_index, view));[m
-         }[m
-[33mdiff --git a/src/test/fuzz/load_external_block_file.cpp b/src/test/fuzz/load_external_block_file.cpp[m
-[33mindex f4b7dc08fd..7f8c9c4e71 100644[m
-[33m--- a/src/test/fuzz/load_external_block_file.cpp[m
-[33m+++ b/src/test/fuzz/load_external_block_file.cpp[m
-[36m@@ -35,9 +35,9 @@[m [mFUZZ_TARGET_INIT(load_external_block_file, initialize_load_external_block_file)[m
-         // Corresponds to the -reindex case (track orphan blocks across files).[m
-         FlatFilePos flat_file_pos;[m
-         std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;[m
-[31m-        g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);[m
-[32m+[m[32m        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);[m
-     } else {[m
-         // Corresponds to the -loadblock= case (orphan blocks aren't tracked across files).[m
-[31m-        g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file);[m
-[32m+[m[32m        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file);[m
-     }[m
- }[m
-[33mdiff --git a/src/test/util/chainstate.h b/src/test/util/chainstate.h[m
-[33mindex bf8f8b5819..61938346e5 100644[m
-[33m--- a/src/test/util/chainstate.h[m
-[33m+++ b/src/test/util/chainstate.h[m
-[36m@@ -71,6 +71,7 @@[m [mCreateAndActivateUTXOSnapshot([m
-             // This is a stripped-down version of node::LoadChainstate which[m
-             // preserves the block index.[m
-             LOCK(::cs_main);[m
-[32m+[m[32m            CBlockIndex *orig_tip = node.chainman->ActiveChainstate().m_chain.Tip();[m
-             uint256 gen_hash = node.chainman->ActiveChainstate().m_chain[0]->GetBlockHash();[m
-             node.chainman->ResetChainstates();[m
-             node.chainman->InitializeChainstate(node.mempool.get());[m
-[36m@@ -83,6 +84,18 @@[m [mCreateAndActivateUTXOSnapshot([m
-             chain.setBlockIndexCandidates.insert(node.chainman->m_blockman.LookupBlockIndex(gen_hash));[m
-             chain.LoadChainTip();[m
-             node.chainman->MaybeRebalanceCaches();[m
-[32m+[m
-[32m+[m[32m            // Reset the HAVE_DATA flags below the snapshot height, simulating[m
-[32m+[m[32m            // never-having-downloaded them in the first place.[m
-[32m+[m[32m            // TODO: perhaps we could improve this by using pruning to delete[m
-[32m+[m[32m            // these blocks instead[m
-[32m+[m[32m            CBlockIndex *pindex = orig_tip;[m
-[32m+[m[32m            while (pindex && pindex != chain.m_chain.Tip()) {[m
-[32m+[m[32m                pindex->nStatus &= ~BLOCK_HAVE_DATA;[m
-[32m+[m[32m                pindex->nStatus &= ~BLOCK_HAVE_UNDO;[m
-[32m+[m[32m                pindex->nStatus |= BLOCK_ASSUMED_VALID;[m
-[32m+[m[32m                pindex = pindex->pprev;[m
-[32m+[m[32m            }[m
-         }[m
-         BlockValidationState state;[m
-         if (!node.chainman->ActiveChainstate().ActivateBestChain(state)) {[m
-[33mdiff --git a/src/test/validation_chainstate_tests.cpp b/src/test/validation_chainstate_tests.cpp[m
-[33mindex 2078fcd8f8..fe2d2ba592 100644[m
-[33m--- a/src/test/validation_chainstate_tests.cpp[m
-[33m+++ b/src/test/validation_chainstate_tests.cpp[m
-[36m@@ -77,6 +77,13 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)[m
-     // After adding some blocks to the tip, best block should have changed.[m
-     BOOST_CHECK(::g_best_block != curr_tip);[m
- [m
-[32m+[m[32m    // Grab block 1 from disk; we'll add it to the background chain later.[m
-[32m+[m[32m    std::shared_ptr<CBlock> pblockone = std::make_shared<CBlock>();[m
-[32m+[m[32m    {[m
-[32m+[m[32m        LOCK(::cs_main);[m
-[32m+[m[32m        chainman.m_blockman.ReadBlockFromDisk(*pblockone, *chainman.ActiveChain()[1]);[m
-[32m+[m[32m    }[m
-[32m+[m
-     BOOST_REQUIRE(CreateAndActivateUTXOSnapshot([m
-         this, NoMalleation, /*reset_chainstate=*/ true));[m
- [m
-[36m@@ -104,11 +111,7 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)[m
-         assert(false);[m
-     }()};[m
- [m
-[31m-    // Create a block to append to the validation chain.[m
-[31m-    std::vector<CMutableTransaction> noTxns;[m
-[31m-    CScript scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;[m
-[31m-    CBlock validation_block = this->CreateBlock(noTxns, scriptPubKey, background_cs);[m
-[31m-    auto pblock = std::make_shared<const CBlock>(validation_block);[m
-[32m+[m[32m    // Append the first block to the background chain.[m
-     BlockValidationState state;[m
-     CBlockIndex* pindex = nullptr;[m
-     const CChainParams& chainparams = Params();[m
-[36m@@ -118,17 +121,18 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)[m
-     // once it is changed to support multiple chainstates.[m
-     {[m
-         LOCK(::cs_main);[m
-[31m-        bool checked = CheckBlock(*pblock, state, chainparams.GetConsensus());[m
-[32m+[m[32m        bool checked = CheckBlock(*pblockone, state, chainparams.GetConsensus());[m
-         BOOST_CHECK(checked);[m
-[31m-        bool accepted = background_cs.AcceptBlock([m
-[31m-            pblock, state, &pindex, true, nullptr, &newblock, true);[m
-[32m+[m[32m        bool accepted = chainman.AcceptBlock([m
-[32m+[m[32m            pblockone, state, &pindex, true, nullptr, &newblock, true);[m
-         BOOST_CHECK(accepted);[m
-     }[m
-[32m+[m
-     // UpdateTip is called here[m
-[31m-    bool block_added = background_cs.ActivateBestChain(state, pblock);[m
-[32m+[m[32m    bool block_added = background_cs.ActivateBestChain(state, pblockone);[m
- [m
-     // Ensure tip is as expected[m
-[31m-    BOOST_CHECK_EQUAL(background_cs.m_chain.Tip()->GetBlockHash(), validation_block.GetHash());[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(background_cs.m_chain.Tip()->GetBlockHash(), pblockone->GetHash());[m
- [m
-     // g_best_block should be unchanged after adding a block to the background[m
-     // validation chain.[m
-[33mdiff --git a/src/test/validation_chainstatemanager_tests.cpp b/src/test/validation_chainstatemanager_tests.cpp[m
-[33mindex 99860961a2..ece8c298cd 100644[m
-[33m--- a/src/test/validation_chainstatemanager_tests.cpp[m
-[33m+++ b/src/test/validation_chainstatemanager_tests.cpp[m
-[36m@@ -49,6 +49,9 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
-     c1.InitCoinsDB([m
-         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
-     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));[m
-[32m+[m[32m    c1.LoadGenesisBlock();[m
-[32m+[m[32m    BlockValidationState val_state;[m
-[32m+[m[32m    BOOST_CHECK(c1.ActivateBestChain(val_state, nullptr));[m
- [m
-     BOOST_CHECK(!manager.IsSnapshotActive());[m
-     BOOST_CHECK(WITH_LOCK(::cs_main, return !manager.IsSnapshotValidated()));[m
-[36m@@ -58,7 +61,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
-     auto& active_chain = WITH_LOCK(manager.GetMutex(), return manager.ActiveChain());[m
-     BOOST_CHECK_EQUAL(&active_chain, &c1.m_chain);[m
- [m
-[31m-    BOOST_CHECK_EQUAL(WITH_LOCK(manager.GetMutex(), return manager.ActiveHeight()), -1);[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(WITH_LOCK(manager.GetMutex(), return manager.ActiveHeight()), 0);[m
- [m
-     auto active_tip = WITH_LOCK(manager.GetMutex(), return manager.ActiveTip());[m
-     auto exp_tip = c1.m_chain.Tip();[m
-[36m@@ -68,7 +71,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
- [m
-     // Create a snapshot-based chainstate.[m
-     //[m
-[31m-    const uint256 snapshot_blockhash = GetRandHash();[m
-[32m+[m[32m    const uint256 snapshot_blockhash = active_tip->GetBlockHash();[m
-     Chainstate& c2 = WITH_LOCK(::cs_main, return manager.ActivateExistingSnapshot([m
-         &mempool, snapshot_blockhash));[m
-     chainstates.push_back(&c2);[m
-[36m@@ -78,8 +81,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
-     c2.InitCoinsDB([m
-         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
-     WITH_LOCK(::cs_main, c2.InitCoinsCache(1 << 23));[m
-[31m-    // Unlike c1, which doesn't have any blocks. Gets us different tip, height.[m
-[31m-    c2.LoadGenesisBlock();[m
-[32m+[m[32m    c2.m_chain.SetTip(*active_tip);[m
-     BlockValidationState _;[m
-     BOOST_CHECK(c2.ActivateBestChain(_, nullptr));[m
- [m
-[36m@@ -99,16 +101,12 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager)[m
-     auto exp_tip2 = c2.m_chain.Tip();[m
-     BOOST_CHECK_EQUAL(active_tip2, exp_tip2);[m
- [m
-[31m-    // Ensure that these pointers actually correspond to different[m
-[31m-    // CCoinsViewCache instances.[m
-[31m-    BOOST_CHECK(exp_tip != exp_tip2);[m
-[31m-[m
-     // Let scheduler events finish running to avoid accessing memory that is going to be unloaded[m
-     SyncWithValidationInterfaceQueue();[m
- }[m
- [m
- //! Test rebalancing the caches associated with each chainstate.[m
-[31m-BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
-[32m+[m[32mBOOST_FIXTURE_TEST_CASE(chainstatemanager_rebalance_caches, TestChain100Setup)[m
- {[m
-     ChainstateManager& manager = *m_node.chainman;[m
-     CTxMemPool& mempool = *m_node.mempool;[m
-[36m@@ -121,7 +119,7 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
- [m
-     // Create a legacy (IBD) chainstate.[m
-     //[m
-[31m-    Chainstate& c1 = WITH_LOCK(::cs_main, return manager.InitializeChainstate(&mempool));[m
-[32m+[m[32m    Chainstate& c1 = manager.ActiveChainstate();[m
-     chainstates.push_back(&c1);[m
-     c1.InitCoinsDB([m
-         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
-[36m@@ -129,8 +127,6 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
-     {[m
-         LOCK(::cs_main);[m
-         c1.InitCoinsCache(1 << 23);[m
-[31m-        BOOST_REQUIRE(c1.LoadGenesisBlock());[m
-[31m-        c1.CoinsTip().SetBestBlock(InsecureRand256());[m
-         manager.MaybeRebalanceCaches();[m
-     }[m
- [m
-[36m@@ -139,7 +135,8 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
- [m
-     // Create a snapshot-based chainstate.[m
-     //[m
-[31m-    Chainstate& c2 = WITH_LOCK(cs_main, return manager.ActivateExistingSnapshot(&mempool, GetRandHash()));[m
-[32m+[m[32m    CBlockIndex* snapshot_base{WITH_LOCK(manager.GetMutex(), return manager.ActiveChain()[manager.ActiveChain().Height() / 2])};[m
-[32m+[m[32m    Chainstate& c2 = WITH_LOCK(cs_main, return manager.ActivateExistingSnapshot(&mempool, *snapshot_base->phashBlock));[m
-     chainstates.push_back(&c2);[m
-     c2.InitCoinsDB([m
-         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);[m
-[36m@@ -147,8 +144,6 @@[m [mBOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)[m
-     {[m
-         LOCK(::cs_main);[m
-         c2.InitCoinsCache(1 << 23);[m
-[31m-        BOOST_REQUIRE(c2.LoadGenesisBlock());[m
-[31m-        c2.CoinsTip().SetBestBlock(InsecureRand256());[m
-         manager.MaybeRebalanceCaches();[m
-     }[m
- [m
-[36m@@ -430,28 +425,31 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)[m
-     const int assumed_valid_start_idx = last_assumed_valid_idx - expected_assumed_valid;[m
- [m
-     CBlockIndex* validated_tip{nullptr};[m
-[32m+[m[32m    CBlockIndex* assumed_base{nullptr};[m
-     CBlockIndex* assumed_tip{WITH_LOCK(chainman.GetMutex(), return chainman.ActiveChain().Tip())};[m
- [m
-     auto reload_all_block_indexes = [&]() {[m
-[32m+[m[32m        WITH_LOCK(::cs_main, return chainman.ResetBlockSequenceCounters());[m
-         for (Chainstate* cs : chainman.GetAll()) {[m
-             LOCK(::cs_main);[m
-[31m-            cs->UnloadBlockIndex();[m
-[32m+[m[32m            cs->ClearBlockIndexCandidates();[m
-             BOOST_CHECK(cs->setBlockIndexCandidates.empty());[m
-         }[m
- [m
-         WITH_LOCK(::cs_main, chainman.LoadBlockIndex());[m
-     };[m
- [m
-[31m-    // Ensure that without any assumed-valid BlockIndex entries, all entries are considered[m
-[31m-    // tip candidates.[m
-[32m+[m[32m    // Ensure that without any assumed-valid BlockIndex entries, only the current tip is[m
-[32m+[m[32m    // considered as a candidate.[m
-     reload_all_block_indexes();[m
-[31m-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), cs1.m_chain.Height() + 1);[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), 1);[m
- [m
-[31m-    // Mark some region of the chain assumed-valid.[m
-[32m+[m[32m    // Mark some region of the chain assumed-valid, and remove the HAVE_DATA flag.[m
-     for (int i = 0; i <= cs1.m_chain.Height(); ++i) {[m
-         LOCK(::cs_main);[m
-         auto index = cs1.m_chain[i];[m
- [m
-[32m+[m[32m        // Blocks with heights in range [20, 40) are marked ASSUMED_VALID[m
-         if (i < last_assumed_valid_idx && i >= assumed_valid_start_idx) {[m
-             index->nStatus = BlockStatus::BLOCK_VALID_TREE | BlockStatus::BLOCK_ASSUMED_VALID;[m
-         }[m
-[36m@@ -464,25 +462,36 @@[m [mBOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)[m
-             validated_tip = index;[m
-             BOOST_CHECK(!index->IsAssumedValid());[m
-         }[m
-[32m+[m[32m        // Note the last assumed valid block as the snapshot base[m
-[32m+[m[32m        if (i == last_assumed_valid_idx - 1) {[m
-[32m+[m[32m            assumed_base = index;[m
-[32m+[m[32m            BOOST_CHECK(index->IsAssumedValid());[m
-[32m+[m[32m        }[m
-     }[m
- [m
-     BOOST_CHECK_EQUAL(expected_assumed_valid, num_assumed_valid);[m
- [m
-[32m+[m[32m    // Note: cs2's tip is not set when ActivateExistingSnapshot is called.[m
-     Chainstate& cs2 = WITH_LOCK(::cs_main,[m
-[31m-        return chainman.ActivateExistingSnapshot(&mempool, GetRandHash()));[m
-[32m+[m[32m        return chainman.ActivateExistingSnapshot(&mempool, *assumed_base->phashBlock));[m
-[32m+[m
-[32m+[m[32m    // Set tip of the fully validated chain to be the validated tip[m
-[32m+[m[32m    cs1.m_chain.SetTip(*validated_tip);[m
- [m
-     reload_all_block_indexes();[m
- [m
-[31m-    // The fully validated chain only has candidates up to the start of the assumed-valid[m
-[31m-    // blocks.[m
-[32m+[m[32m    // The fully validated chain should have the current validated tip[m
-[32m+[m[32m    // and the assumed valid base as candidates.[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), 2);[m
-     BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(validated_tip), 1);[m
-[31m-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(assumed_tip), 0);[m
-[31m-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), assumed_valid_start_idx);[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(assumed_base), 1);[m
- [m
-[31m-    // The assumed-valid tolerant chain has all blocks as candidates.[m
-[32m+[m[32m    // The assumed-valid tolerant chain has the assumed valid base as a[m
-[32m+[m[32m    // candidate, but otherwise has none of the assumed-valid (which do not[m
-[32m+[m[32m    // HAVE_DATA) blocks as candidates.[m
-     BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(validated_tip), 1);[m
-     BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(assumed_tip), 1);[m
-[31m-    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes);[m
-[32m+[m[32m    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes - num_assumed_valid + 1);[m
- }[m
- [m
- //! Ensure that snapshot chainstates initialize properly when found on disk.[m
-[33mdiff --git a/src/validation.cpp b/src/validation.cpp[m
-[33mindex 5bf8bd70e2..3ace375149 100644[m
-[33m--- a/src/validation.cpp[m
-[33m+++ b/src/validation.cpp[m
-[36m@@ -1579,6 +1579,13 @@[m [mChainstate::Chainstate([m
-       m_chainman(chainman),[m
-       m_from_snapshot_blockhash(from_snapshot_blockhash) {}[m
- [m
-[32m+[m[32mconst CBlockIndex* Chainstate::SnapshotBase()[m
-[32m+[m[32m{[m
-[32m+[m[32m    if (!m_from_snapshot_blockhash) return nullptr;[m
-[32m+[m[32m    if (!m_cached_snapshot_base) m_cached_snapshot_base = Assert(m_chainman.m_blockman.LookupBlockIndex(*m_from_snapshot_blockhash));[m
-[32m+[m[32m    return m_cached_snapshot_base;[m
-[32m+[m[32m}[m
-[32m+[m
- void Chainstate::InitCoinsDB([m
-     size_t cache_size_bytes,[m
-     bool in_memory,[m
-[36m@@ -3193,7 +3200,8 @@[m [mbool Chainstate::ActivateBestChain(BlockValidationState& state, std::shared_ptr<[m
-         // that the best block hash is non-null.[m
-         if (m_chainman.m_interrupt) break;[m
-     } while (pindexNewTip != pindexMostWork);[m
-[31m-    CheckBlockIndex();[m
-[32m+[m
-[32m+[m[32m    m_chainman.CheckBlockIndex();[m
- [m
-     // Write changes periodically to disk, after relay.[m
-     if (!FlushStateToDisk(state, FlushStateMode::PERIODIC)) {[m
-[36m@@ -3213,17 +3221,17 @@[m [mbool Chainstate::PreciousBlock(BlockValidationState& state, CBlockIndex* pindex)[m
-             // Nothing to do, this block is not at the tip.[m
-             return true;[m
-         }[m
-[31m-        if (m_chain.Tip()->nChainWork > nLastPreciousChainwork) {[m
-[32m+[m[32m        if (m_chain.Tip()->nChainWork > m_chainman.nLastPreciousChainwork) {[m
-             // The chain has been extended since the last call, reset the counter.[m
-[31m-            nBlockReverseSequenceId = -1;[m
-[32m+[m[32m            m_chainman.nBlockReverseSequenceId = -1;[m
-         }[m
-[31m-        nLastPreciousChainwork = m_chain.Tip()->nChainWork;[m
-[32m+[m[32m        m_chainman.nLastPreciousChainwork = m_chain.Tip()->nChainWork;[m
-         setBlockIndexCandidates.erase(pindex);[m
-[31m-        pindex->nSequenceId = nBlockReverseSequenceId;[m
-[31m-        if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {[m
-[32m+[m[32m        pindex->nSequenceId = m_chainman.nBlockReverseSequenceId;[m
-[32m+[m[32m        if (m_chainman.nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {[m
-             // We can't keep reducing the counter if somebody really wants to[m
-             // call preciousblock 2**31-1 times on the same set of tips...[m
-[31m-            nBlockReverseSequenceId--;[m
-[32m+[m[32m            m_chainman.nBlockReverseSequenceId--;[m
-         }[m
-         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->HaveTxsDownloaded()) {[m
-             setBlockIndexCandidates.insert(pindex);[m
-[36m@@ -3339,7 +3347,7 @@[m [mbool Chainstate::InvalidateBlock(BlockValidationState& state, CBlockIndex* pinde[m
-         to_mark_failed = invalid_walk_tip;[m
-     }[m
- [m
-[31m-    CheckBlockIndex();[m
-[32m+[m[32m    m_chainman.CheckBlockIndex();[m
- [m
-     {[m
-         LOCK(cs_main);[m
-[36m@@ -3416,8 +3424,32 @@[m [mvoid Chainstate::ResetBlockFailureFlags(CBlockIndex *pindex) {[m
-     }[m
- }[m
- [m
-[32m+[m[32mvoid Chainstate::TryAddBlockIndexCandidate(CBlockIndex* pindex)[m
-[32m+[m[32m{[m
-[32m+[m[32m    AssertLockHeld(cs_main);[m
-[32m+[m[32m    // The block only is a candidate for the most-work-chain if it has more work than our current tip.[m
-[32m+[m[32m    if (m_chain.Tip() != nullptr && setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {[m
-[32m+[m[32m        return;[m
-[32m+[m[32m    }[m
-[32m+[m
-[32m+[m[32m    bool is_active_chainstate = this == &m_chainman.ActiveChainstate();[m
-[32m+[m[32m    if (is_active_chainstate) {[m
-[32m+[m[32m        // The active chainstate should always add entries that have more[m
-[32m+[m[32m        // work than the tip.[m
-[32m+[m[32m        setBlockIndexCandidates.insert(pindex);[m
-[32m+[m[32m    } else if (!m_disabled) {[m
-[32m+[m[32m        // For the background chainstate, we only consider connecting blocks[m
-[32m+[m[32m        // towards the snapshot base (which can't be nullptr or else we'll[m
-[32m+[m[32m        // never make progress).[m
-[32m+[m[32m        const CBlockIndex* snapshot_base{Assert(m_chainman.ActiveSnapshotBase())};[m
-[32m+[m[32m        if (snapshot_base->GetAncestor(pindex->nHeight) == pindex) {[m
-[32m+[m[32m            setBlockIndexCandidates.insert(pindex);[m
-[32m+[m[32m        }[m
-[32m+[m[32m    }[m
-[32m+[m[32m}[m
-[32m+[m
- /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */[m
-[31m-void Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)[m
-[32m+[m[32mvoid ChainstateManager::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)[m
- {[m
-     AssertLockHeld(cs_main);[m
-     pindexNew->nTx = block.vtx.size();[m
-[36m@@ -3426,7 +3458,7 @@[m [mvoid Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pin[m
-     pindexNew->nDataPos = pos.nPos;[m
-     pindexNew->nUndoPos = 0;[m
-     pindexNew->nStatus |= BLOCK_HAVE_DATA;[m
-[31m-    if (DeploymentActiveAt(*pindexNew, m_chainman, Consensus::DEPLOYMENT_SEGWIT)) {[m
-[32m+[m[32m    if (DeploymentActiveAt(*pindexNew, *this, Consensus::DEPLOYMENT_SEGWIT)) {[m
-         pindexNew->nStatus |= BLOCK_OPT_WITNESS;[m
-     }[m
-     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);[m
-[36m@@ -3443,8 +3475,8 @@[m [mvoid Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pin[m
-             queue.pop_front();[m
-             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;[m
-             pindex->nSequenceId = nBlockSequenceId++;[m
-[31m-            if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {[m
-[31m-                setBlockIndexCandidates.insert(pindex);[m
-[32m+[m[32m            for (Chainstate *c : GetAll()) {[m
-[32m+[m[32m                c->TryAddBlockIndexCandidate(pindex);[m
-             }[m
-             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = m_blockman.m_blocks_unlinked.equal_range(pindex);[m
-             while (range.first != range.second) {[m
-[36m@@ -3858,7 +3890,7 @@[m [mbool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&[m
-         for (const CBlockHeader& header : headers) {[m
-             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast[m
-             bool accepted{AcceptBlockHeader(header, state, &pindex, min_pow_checked)};[m
-[31m-            ActiveChainstate().CheckBlockIndex();[m
-[32m+[m[32m            CheckBlockIndex();[m
- [m
-             if (!accepted) {[m
-                 return false;[m
-[36m@@ -3905,7 +3937,7 @@[m [mvoid ChainstateManager::ReportHeadersPresync(const arith_uint256& work, int64_t[m
- }[m
- [m
- /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */[m
-[31m-bool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked)[m
-[32m+[m[32mbool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked)[m
- {[m
-     const CBlock& block = *pblock;[m
- [m
-[36m@@ -3915,7 +3947,7 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
-     CBlockIndex *pindexDummy = nullptr;[m
-     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;[m
- [m
-[31m-    bool accepted_header{m_chainman.AcceptBlockHeader(block, state, &pindex, min_pow_checked)};[m
-[32m+[m[32m    bool accepted_header{AcceptBlockHeader(block, state, &pindex, min_pow_checked)};[m
-     CheckBlockIndex();[m
- [m
-     if (!accepted_header)[m
-[36m@@ -3925,13 +3957,13 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
-     // process an unrequested block if it's new and has enough work to[m
-     // advance our tip, and isn't too many blocks ahead.[m
-     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;[m
-[31m-    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);[m
-[32m+[m[32m    bool fHasMoreOrSameWork = (ActiveTip() ? pindex->nChainWork >= ActiveTip()->nChainWork : true);[m
-     // Blocks that are too out-of-order needlessly limit the effectiveness of[m
-     // pruning, because pruning will not delete block files that contain any[m
-     // blocks which are too close in height to the tip.  Apply this test[m
-     // regardless of whether pruning is enabled; it should generally be safe to[m
-     // not process unrequested blocks.[m
-[31m-    bool fTooFarAhead{pindex->nHeight > m_chain.Height() + int(MIN_BLOCKS_TO_KEEP)};[m
-[32m+[m[32m    bool fTooFarAhead{pindex->nHeight > ActiveHeight() + int(MIN_BLOCKS_TO_KEEP)};[m
- [m
-     // TODO: Decouple this function from the block download logic by removing fRequested[m
-     // This requires some new chain data structure to efficiently look up if a[m
-[36m@@ -3951,13 +3983,13 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
-         // If our tip is behind, a peer could try to send us[m
-         // low-work blocks on a fake chain that we would never[m
-         // request; don't process these.[m
-[31m-        if (pindex->nChainWork < m_chainman.MinimumChainWork()) return true;[m
-[32m+[m[32m        if (pindex->nChainWork < MinimumChainWork()) return true;[m
-     }[m
- [m
-[31m-    const CChainParams& params{m_chainman.GetParams()};[m
-[32m+[m[32m    const CChainParams& params{GetParams()};[m
- [m
-     if (!CheckBlock(block, state, params.GetConsensus()) ||[m
-[31m-        !ContextualCheckBlock(block, state, m_chainman, pindex->pprev)) {[m
-[32m+[m[32m        !ContextualCheckBlock(block, state, *this, pindex->pprev)) {[m
-         if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {[m
-             pindex->nStatus |= BLOCK_FAILED_VALID;[m
-             m_blockman.m_dirty_blockindex.insert(pindex);[m
-[36m@@ -3967,23 +3999,30 @@[m [mbool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV[m
- [m
-     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW[m
-     // (but if it does not build on our best tip, let the SendMessages loop relay it)[m
-[31m-    if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)[m
-[32m+[m[32m    if (!ActiveChainstate().IsInitialBlockDownload() && ActiveTip() == pindex->pprev)[m
-         GetMainSignals().NewPoWValidBlock(pindex, pblock);[m
- [m
-     // Write block to history file[m
-     if (fNewBlock) *fNewBlock = true;[m
-     try {[m
-[31m-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, m_chain, dbp)};[m
-[32m+[m[32m        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};[m
-         if (blockPos.IsNull()) {[m
-             state.Error(strprintf("%s: Failed to find position to write new block to disk", __func__));[m
-             return false;[m
-         }[m
-         ReceivedBlockTransactions(block, pindex, blockPos);[m
-     } catch (const std::runtime_error& e) {[m
-[31m-        return FatalError(m_chainman.GetNotifications(), state, std::string("System error: ") + e.what());[m
-[32m+[m[32m        return FatalError(GetNotifications(), state, std::string("System error: ") + e.what());[m
-     }[m
- [m
-[31m-    FlushStateToDisk(state, FlushStateMode::NONE);[m
-[32m+[m[32m    // TODO: FlushStateToDisk() handles flushing of both block and chainstate[m
-[32m+[m[32m    // data, so we should move this to ChainstateManager so that we can be more[m
-[32m+[m[32m    // intelligent about how we flush.[m
-[32m+[m[32m    // For now, since FlushStateMode::NONE is used, all that can happen is that[m
-[32m+[m[32m    // the block files may be pruned, so we can just call this on one[m
-[32m+[m[32m    // chainstate (particularly if we haven't implemented pruning with[m
-[32m+[m[32m    // background validation yet).[m
-[32m+[m[32m    ActiveChainstate().FlushStateToDisk(state, FlushStateMode::NONE);[m
- [m
-     CheckBlockIndex();[m
- [m
-[36m@@ -4011,7 +4050,7 @@[m [mbool ChainstateManager::ProcessNewBlock(const std::shared_ptr<const CBlock>& blo[m
-         bool ret = CheckBlock(*block, state, GetConsensus());[m
-         if (ret) {[m
-             // Store to disk[m
-[31m-            ret = ActiveChainstate().AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block, min_pow_checked);[m
-[32m+[m[32m            ret = AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block, min_pow_checked);[m
-         }[m
-         if (!ret) {[m
-             GetMainSignals().BlockChecked(*block, state);[m
-[36m@@ -4379,10 +4418,9 @@[m [mbool Chainstate::NeedsRedownload() const[m
-     return false;[m
- }[m
- [m
-[31m-void Chainstate::UnloadBlockIndex()[m
-[32m+[m[32mvoid Chainstate::ClearBlockIndexCandidates()[m
- {[m
-     AssertLockHeld(::cs_main);[m
-[31m-    nBlockSequenceId = 1;[m
-     setBlockIndexCandidates.clear();[m
- }[m
- [m
-[36m@@ -4401,62 +4439,14 @@[m [mbool ChainstateManager::LoadBlockIndex()[m
-         std::sort(vSortedByHeight.begin(), vSortedByHeight.end(),[m
-                   CBlockIndexHeightOnlyComparator());[m
- [m
-[31m-        // Find start of assumed-valid region.[m
-[31m-        int first_assumed_valid_height = std::numeric_limits<int>::max();[m
-[31m-[m
-[31m-        for (const CBlockIndex* block : vSortedByHeight) {[m
-[31m-            if (block->IsAssumedValid()) {[m
-[31m-                auto chainstates = GetAll();[m
-[31m-[m
-[31m-                // If we encounter an assumed-valid block index entry, ensure that we have[m
-[31m-                // one chainstate that tolerates assumed-valid entries and another that does[m
-[31m-                // not (i.e. the background validation chainstate), since assumed-valid[m
-[31m-                // entries should always be pending validation by a fully-validated chainstate.[m
-[31m-                auto any_chain = [&](auto fnc) { return std::any_of(chainstates.cbegin(), chainstates.cend(), fnc); };[m
-[31m-                assert(any_chain([](auto chainstate) { return chainstate->reliesOnAssumedValid(); }));[m
-[31m-                assert(any_chain([](auto chainstate) { return !chainstate->reliesOnAssumedValid(); }));[m
-[31m-[m
-[31m-                first_assumed_valid_height = block->nHeight;[m
-[31m-                LogPrintf("Saw first assumedvalid block at height %d (%s)\n",[m
-[31m-                        first_assumed_valid_height, block->ToString());[m
-[31m-                break;[m
-[31m-            }[m
-[31m-        }[m
-[31m-[m
-         for (CBlockIndex* pindex : vSortedByHeight) {[m
-             if (m_interrupt) return false;[m
-[31m-            if (pindex->IsAssumedValid() ||[m
-[32m+[m[32m            if (pindex == GetSnapshotBaseBlock() ||[m
-                     (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) &&[m
-                      (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))) {[m
- [m
-[31m-                // Fill each chainstate's block candidate set. Only add assumed-valid[m
-[31m-                // blocks to the tip candidate set if the chainstate is allowed to rely on[m
-[31m-                // assumed-valid blocks.[m
-[31m-                //[m
-[31m-                // If all setBlockIndexCandidates contained the assumed-valid blocks, the[m
-[31m-                // background chainstate's ActivateBestChain() call would add assumed-valid[m
-[31m-                // blocks to the chain (based on how FindMostWorkChain() works). Obviously[m
-[31m-                // we don't want this since the purpose of the background validation chain[m
-[31m-                // is to validate assued-valid blocks.[m
-[31m-                //[m
-[31m-                // Note: This is considering all blocks whose height is greater or equal to[m
-[31m-                // the first assumed-valid block to be assumed-valid blocks, and excluding[m
-[31m-                // them from the background chainstate's setBlockIndexCandidates set. This[m
-[31m-                // does mean that some blocks which are not technically assumed-valid[m
-[31m-                // (later blocks on a fork beginning before the first assumed-valid block)[m
-[31m-                // might not get added to the background chainstate, but this is ok,[m
-[31m-                // because they will still be attached to the active chainstate if they[m
-[31m-                // actually contain more work.[m
-[31m-                //[m
-[31m-                // Instead of this height-based approach, an earlier attempt was made at[m
-[31m-                // detecting "holistically" whether the block index under consideration[m
-[31m-                // relied on an assumed-valid ancestor, but this proved to be too slow to[m
-[31m-                // be practical.[m
-                 for (Chainstate* chainstate : GetAll()) {[m
-[31m-                    if (chainstate->reliesOnAssumedValid() ||[m
-[31m-                            pindex->nHeight < first_assumed_valid_height) {[m
-[31m-                        chainstate->setBlockIndexCandidates.insert(pindex);[m
-[31m-                    }[m
-[32m+[m[32m                    chainstate->TryAddBlockIndexCandidate(pindex);[m
-                 }[m
-             }[m
-             if (pindex->nStatus & BLOCK_FAILED_MASK && (!m_best_invalid || pindex->nChainWork > m_best_invalid->nChainWork)) {[m
-[36m@@ -4496,12 +4486,12 @@[m [mbool Chainstate::LoadGenesisBlock()[m
- [m
-     try {[m
-         const CBlock& block = params.GenesisBlock();[m
-[31m-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, 0, m_chain, nullptr)};[m
-[32m+[m[32m        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, 0, nullptr)};[m
-         if (blockPos.IsNull()) {[m
-             return error("%s: writing genesis block to disk failed", __func__);[m
-         }[m
-         CBlockIndex* pindex = m_blockman.AddToBlockIndex(block, m_chainman.m_best_header);[m
-[31m-        ReceivedBlockTransactions(block, pindex, blockPos);[m
-[32m+[m[32m        m_chainman.ReceivedBlockTransactions(block, pindex, blockPos);[m
-     } catch (const std::runtime_error& e) {[m
-         return error("%s: failed to write genesis block: %s", __func__, e.what());[m
-     }[m
-[36m@@ -4509,18 +4499,16 @@[m [mbool Chainstate::LoadGenesisBlock()[m
-     return true;[m
- }[m
- [m
-[31m-void Chainstate::LoadExternalBlockFile([m
-[32m+[m[32mvoid ChainstateManager::LoadExternalBlockFile([m
-     FILE* fileIn,[m
-     FlatFilePos* dbp,[m
-     std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent)[m
- {[m
-[31m-    AssertLockNotHeld(m_chainstate_mutex);[m
-[31m-[m
-     // Either both should be specified (-reindex), or neither (-loadblock).[m
-     assert(!dbp == !blocks_with_unknown_parent);[m
- [m
-     const auto start{SteadyClock::now()};[m
-[31m-    const CChainParams& params{m_chainman.GetParams()};[m
-[32m+[m[32m    const CChainParams& params{GetParams()};[m
- [m
-     int nLoaded = 0;[m
-     try {[m
-[36m@@ -4530,7 +4518,7 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
-         // such as a block fails to deserialize.[m
-         uint64_t nRewind = blkdat.GetPos();[m
-         while (!blkdat.eof()) {[m
-[31m-            if (m_chainman.m_interrupt) return;[m
-[32m+[m[32m            if (m_interrupt) return;[m
- [m
-             blkdat.SetPos(nRewind);[m
-             nRewind++; // start one byte further next time, in case of failure[m
-[36m@@ -4606,7 +4594,14 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
-                 // Activate the genesis block so normal node progress can continue[m
-                 if (hash == params.GetConsensus().hashGenesisBlock) {[m
-                     BlockValidationState state;[m
-[31m-                    if (!ActivateBestChain(state, nullptr)) {[m
-[32m+[m[32m                    bool genesis_activation_failure = false;[m
-[32m+[m[32m                    for (auto c : GetAll()) {[m
-[32m+[m[32m                        if (!c->ActivateBestChain(state, nullptr)) {[m
-[32m+[m[32m                            genesis_activation_failure = true;[m
-[32m+[m[32m                            break;[m
-[32m+[m[32m                        }[m
-[32m+[m[32m                    }[m
-[32m+[m[32m                    if (genesis_activation_failure) {[m
-                         break;[m
-                     }[m
-                 }[m
-[36m@@ -4620,13 +4615,13 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
-                     // called by concurrent network message processing. but, that is not[m
-                     // reliable for the purpose of pruning while importing.[m
-                     BlockValidationState state;[m
-[31m-                    if (!ActivateBestChain(state, pblock)) {[m
-[32m+[m[32m                    if (!ActiveChainstate().ActivateBestChain(state, pblock)) {[m
-                         LogPrint(BCLog::REINDEX, "failed to activate chain (%s)\n", state.ToString());[m
-                         break;[m
-                     }[m
-                 }[m
- [m
-[31m-                NotifyHeaderTip(*this);[m
-[32m+[m[32m                NotifyHeaderTip(ActiveChainstate());[m
- [m
-                 if (!blocks_with_unknown_parent) continue;[m
- [m
-[36m@@ -4652,7 +4647,7 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
-                         }[m
-                         range.first++;[m
-                         blocks_with_unknown_parent->erase(it);[m
-[31m-                        NotifyHeaderTip(*this);[m
-[32m+[m[32m                        NotifyHeaderTip(ActiveChainstate());[m
-                     }[m
-                 }[m
-             } catch (const std::exception& e) {[m
-[36m@@ -4671,14 +4666,14 @@[m [mvoid Chainstate::LoadExternalBlockFile([m
-             }[m
-         }[m
-     } catch (const std::runtime_error& e) {[m
-[31m-        m_chainman.GetNotifications().fatalError(std::string("System error: ") + e.what());[m
-[32m+[m[32m        GetNotifications().fatalError(std::string("System error: ") + e.what());[m
-     }[m
-     LogPrintf("Loaded %i blocks from external file in %dms\n", nLoaded, Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));[m
- }[m
- [m
-[31m-void Chainstate::CheckBlockIndex()[m
-[32m+[m[32mvoid ChainstateManager::CheckBlockIndex()[m
- {[m
-[31m-    if (!m_chainman.ShouldCheckBlockIndex()) {[m
-[32m+[m[32m    if (!ShouldCheckBlockIndex()) {[m
-         return;[m
-     }[m
- [m
-[36m@@ -4687,7 +4682,7 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,[m
-     // so we have the genesis block in m_blockman.m_block_index but no active chain. (A few of the[m
-     // tests when iterating the block tree require that m_chain has been initialized.)[m
-[31m-    if (m_chain.Height() < 0) {[m
-[32m+[m[32m    if (ActiveChain().Height() < 0) {[m
-         assert(m_blockman.m_block_index.size() <= 1);[m
-         return;[m
-     }[m
-[36m@@ -4717,12 +4712,12 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-     CBlockIndex* pindexFirstNotTransactionsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).[m
-     CBlockIndex* pindexFirstNotChainValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).[m
-     CBlockIndex* pindexFirstNotScriptsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).[m
-[32m+[m[32m    CBlockIndex* pindexFirstAssumeValid = nullptr; // Oldest ancestor of pindex which has BLOCK_ASSUMED_VALID[m
-     while (pindex != nullptr) {[m
-         nNodes++;[m
-[32m+[m[32m        if (pindexFirstAssumeValid == nullptr && pindex->nStatus & BLOCK_ASSUMED_VALID) pindexFirstAssumeValid = pindex;[m
-         if (pindexFirstInvalid == nullptr && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;[m
-[31m-        // Assumed-valid index entries will not have data since we haven't downloaded the[m
-[31m-        // full block yet.[m
-[31m-        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA) && !pindex->IsAssumedValid()) {[m
-[32m+[m[32m        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA)) {[m
-             pindexFirstMissing = pindex;[m
-         }[m
-         if (pindexFirstNeverProcessed == nullptr && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;[m
-[36m@@ -4751,8 +4746,8 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-         // Begin: actual consistency checks.[m
-         if (pindex->pprev == nullptr) {[m
-             // Genesis block checks.[m
-[31m-            assert(pindex->GetBlockHash() == m_chainman.GetConsensus().hashGenesisBlock); // Genesis block's hash must match.[m
-[31m-            assert(pindex == m_chain.Genesis()); // The current active chain's genesis block must be this block.[m
-[32m+[m[32m            assert(pindex->GetBlockHash() == GetConsensus().hashGenesisBlock); // Genesis block's hash must match.[m
-[32m+[m[32m            assert(pindex == ActiveChain().Genesis()); // The current active chain's genesis block must be this block.[m
-         }[m
-         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)[m
-         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).[m
-[36m@@ -4762,7 +4757,13 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-         if (!m_blockman.m_have_pruned && !pindex->IsAssumedValid()) {[m
-             // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0[m
-             assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));[m
-[31m-            assert(pindexFirstMissing == pindexFirstNeverProcessed);[m
-[32m+[m[32m            if (pindexFirstAssumeValid == nullptr) {[m
-[32m+[m[32m                // If we've got some assume valid blocks, then we might have[m
-[32m+[m[32m                // missing blocks (not HAVE_DATA) but still treat them as[m
-[32m+[m[32m                // having been processed (with a fake nTx value). Otherwise, we[m
-[32m+[m[32m                // can assert that these are the same.[m
-[32m+[m[32m                assert(pindexFirstMissing == pindexFirstNeverProcessed);[m
-[32m+[m[32m            }[m
-         } else {[m
-             // If we have pruned, then we can only say that HAVE_DATA implies nTx > 0[m
-             if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);[m
-[36m@@ -4792,27 +4793,32 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-             // Checks for not-invalid blocks.[m
-             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.[m
-         }[m
-[31m-        if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {[m
-[31m-            if (pindexFirstInvalid == nullptr) {[m
-[31m-                const bool is_active = this == &m_chainman.ActiveChainstate();[m
-[31m-[m
-[31m-                // If this block sorts at least as good as the current tip and[m
-[31m-                // is valid and we have all data for its parents, it must be in[m
-[31m-                // setBlockIndexCandidates.  m_chain.Tip() must also be there[m
-[31m-                // even if some data has been pruned.[m
-[31m-                //[m
-[31m-                // Don't perform this check for the background chainstate since[m
-[31m-                // its setBlockIndexCandidates shouldn't have some entries (i.e. those past the[m
-[31m-                // snapshot block) which do exist in the block index for the active chainstate.[m
-[31m-                if (is_active && (pindexFirstMissing == nullptr || pindex == m_chain.Tip())) {[m
-[31m-                    assert(setBlockIndexCandidates.count(pindex));[m
-[32m+[m[32m        // Chainstate-specific checks on setBlockIndexCandidates[m
-[32m+[m[32m        for (auto c : GetAll()) {[m
-[32m+[m[32m            if (c->m_chain.Tip() == nullptr) continue;[m
-[32m+[m[32m            if (!CBlockIndexWorkComparator()(pindex, c->m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {[m
-[2m+[m[2m                if (pindexFirstInvalid == nullptr) {[m
-[32m+[m[32m                    const bool is_active = c == &ActiveChainstate();[m
-[32m+[m[32m                    // If this block sorts at least as good as the current tip and[m
-[32m+[m[32m                    // is valid and we have all data for its parents, it must be in[m
-[32m+[m[32m                    // setBlockIndexCandidates.  m_chain.Tip() must also be there[m
-[32m+[m[32m                    // even if some data has been pruned.[m
-[32m+[m[32m                    //[m
-[32m+[m[32m                    if ((pindexFirstMissing == nullptr || pindex == c->m_chain.Tip())) {[m
-[32m+[m[32m                        // The active chainstate should always have this block[m
-[32m+[m[32m                        // as a candidate, but a background chainstate should[m
-[32m+[m[32m                        // only have it if it is an ancestor of the snapshot base.[m
-[32m+[m[32m                        if (is_active || GetSnapshotBaseBlock()->GetAncestor(pindex->nHeight) == pindex) {[m
-[32m+[m[32m                            assert(c->setBlockIndexCandidates.count(pindex));[m
-[32m+[m[32m                        }[m
-[32m+[m[32m                    }[m
-[32m+[m[32m                    // If some parent is missing, then it could be that this block was in[m
-[32m+[m[32m                    // setBlockIndexCandidates but had to be removed because of the missing data.[m
-[32m+[m[32m                    // In this case it must be in m_blocks_unlinked -- see test below.[m
-                 }[m
-[31m-                // If some parent is missing, then it could be that this block was in[m
-[31m-                // setBlockIndexCandidates but had to be removed because of the missing data.[m
-[31m-                // In this case it must be in m_blocks_unlinked -- see test below.[m
-[32m+[m[32m            } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.[m
-[32m+[m[32m                assert(c->setBlockIndexCandidates.count(pindex) == 0);[m
-             }[m
-[31m-        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.[m
-[31m-            assert(setBlockIndexCandidates.count(pindex) == 0);[m
-         }[m
-         // Check whether this block is in m_blocks_unlinked.[m
-         std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = m_blockman.m_blocks_unlinked.equal_range(pindex->pprev);[m
-[36m@@ -4833,18 +4839,23 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-         if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.[m
-         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {[m
-             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.[m
-[31m-            assert(m_blockman.m_have_pruned); // We must have pruned.[m
-[32m+[m[32m            assert(m_blockman.m_have_pruned || pindexFirstAssumeValid != nullptr); // We must have pruned, or else we're using a snapshot (causing us to have faked the received data for some parent(s)).[m
-             // This block may have entered m_blocks_unlinked if:[m
-             //  - it has a descendant that at some point had more work than the[m
-             //    tip, and[m
-             //  - we tried switching to that descendant but were missing[m
-             //    data for some intermediate block between m_chain and the[m
-             //    tip.[m
-[31m-            // So if this block is itself better than m_chain.Tip() and it wasn't in[m
-[32m+[m[32m            // So if this block is itself better than any m_chain.Tip() and it wasn't in[m
-             // setBlockIndexCandidates, then it must be in m_blocks_unlinked.[m
-[31m-            if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {[m
-[2m-                if (pindexFirstInvalid == nullptr) {[m
-[31m-                    assert(foundInUnlinked);[m
-[32m+[m[32m            for (auto c : GetAll()) {[m
-[32m+[m[32m                const bool is_active = c == &ActiveChainstate();[m
-[32m+[m[32m                if (!CBlockIndexWorkComparator()(pindex, c->m_chain.Tip()) && c->setBlockIndexCandidates.count(pindex) == 0) {[m
-[32m+[m[32m                    if (pindexFirstInvalid == nullptr) {[m
-[32m+[m[32m                        if (is_active || GetSnapshotBaseBlock()->GetAncestor(pindex->nHeight) == pindex) {[m
-[32m+[m[32m                            assert(foundInUnlinked);[m
-[32m+[m[32m                        }[m
-[32m+[m[32m                    }[m
-                 }[m
-             }[m
-         }[m
-[36m@@ -4871,6 +4882,7 @@[m [mvoid Chainstate::CheckBlockIndex()[m
-             if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = nullptr;[m
-             if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = nullptr;[m
-             if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = nullptr;[m
-[32m+[m[32m            if (pindex == pindexFirstAssumeValid) pindexFirstAssumeValid = nullptr;[m
-             // Find our parent.[m
-             CBlockIndex* pindexPar = pindex->pprev;[m
-             // Find which child we just visited.[m
-[33mdiff --git a/src/validation.h b/src/validation.h[m
-[33mindex af8ceb5dfa..2be6cf0643 100644[m
-[33m--- a/src/validation.h[m
-[33m+++ b/src/validation.h[m
-[36m@@ -465,17 +465,6 @@[m [menum class CoinsCacheSizeState[m
- class Chainstate[m
- {[m
- protected:[m
-[2m-    /**[m
-[2m-     * Every received block is assigned a unique and increasing identifier, so we[m
-[2m-     * know which one to give priority in case of a fork.[m
-[2m-     */[m
-[2m-    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */[m
-[2m-    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;[m
-[2m-    /** Decreasing counter (used by subsequent preciousblock calls). */[m
-[2m-    int32_t nBlockReverseSequenceId = -1;[m
-[2m-    /** chainwork for the last block that preciousblock has been applied to. */[m
-[2m-    arith_uint256 nLastPreciousChainwork = 0;[m
-[2m-[m
-     /**[m
-      * The ChainState Mutex[m
-      * A lock that must be held when modifying this ChainState - held in ActivateBestChain() and[m
-[36m@@ -511,6 +500,9 @@[m [mprotected:[m
-     //! is set to true on the snapshot chainstate.[m
-     bool m_disabled GUARDED_BY(::cs_main) {false};[m
- [m
-[32m+[m[32m    //! Cached result of LookupBlockIndex(*m_from_snapshot_blockhash)[m
-[32m+[m[32m    const CBlockIndex* m_cached_snapshot_base GUARDED_BY(::cs_main) {nullptr};[m
-[32m+[m
- public:[m
-     //! Reference to a BlockManager instance which itself is shared across all[m
-     //! Chainstate instances.[m
-[36m@@ -562,6 +554,13 @@[m [mpublic:[m
-      */[m
-     const std::optional<uint256> m_from_snapshot_blockhash;[m
- [m
-[32m+[m[32m    /**[m
-[32m+[m[32m     * The base of the snapshot this chainstate was created from.[m
-[32m+[m[32m     *[m
-[32m+[m[32m     * nullptr if this chainstate was not created from a snapshot.[m
-[32m+[m[32m     */[m
-[32m+[m[32m    const CBlockIndex* SnapshotBase() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
-[32m+[m
-     //! Return true if this chainstate relies on blocks that are assumed-valid. In[m
-     //! practice this means it was created based on a UTXO snapshot.[m
-     bool reliesOnAssumedValid() { return m_from_snapshot_blockhash.has_value(); }[m
-[36m@@ -620,37 +619,6 @@[m [mpublic:[m
-     bool ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)[m
-         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
- [m
-[2m-    /**[m
-[2m-     * Import blocks from an external file[m
-[2m-     *[m
-[2m-     * During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat).[m
-[2m-     * It reads all blocks contained in the given file and attempts to process them (add them to the[m
-[2m-     * block index). The blocks may be out of order within each file and across files. Often this[m
-[2m-     * function reads a block but finds that its parent hasn't been read yet, so the block can't be[m
-[2m-     * processed yet. The function will add an entry to the blocks_with_unknown_parent map (which is[m
-[2m-     * passed as an argument), so that when the block's parent is later read and processed, this[m
-[2m-     * function can re-read the child block from disk and process it.[m
-[2m-     *[m
-[2m-     * Because a block's parent may be in a later file, not just later in the same file, the[m
-[2m-     * blocks_with_unknown_parent map must be passed in and out with each call. It's a multimap,[m
-[2m-     * rather than just a map, because multiple blocks may have the same parent (when chain splits[m
-[2m-     * or stale blocks exist). It maps from parent-hash to child-disk-position.[m
-[2m-     *[m
-[2m-     * This function can also be used to read blocks from user-specified block files using the[m
-[2m-     * -loadblock= option. There's no unknown-parent tracking, so the last two arguments are omitted.[m
-[2m-     *[m
-[2m-     *[m
-[2m-     * @param[in]     fileIn                        FILE handle to file containing blocks to read[m
-[2m-     * @param[in]     dbp                           (optional) Disk block position (only for reindex)[m
-[2m-     * @param[in,out] blocks_with_unknown_parent    (optional) Map of disk positions for blocks with[m
-[2m-     *                                              unknown parent, key is parent block hash[m
-[2m-     *                                              (only used for reindex)[m
-[2m-     * */[m
-[2m-    void LoadExternalBlockFile([m
-[2m-        FILE* fileIn,[m
-[2m-        FlatFilePos* dbp = nullptr,[m
-[31m-        std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent = nullptr)[m
-[31m-        EXCLUSIVE_LOCKS_REQUIRED(!m_chainstate_mutex);[m
- [m
-     /**[m
-      * Update the on-disk chain state.[m
-[36m@@ -702,8 +670,6 @@[m [mpublic:[m
-         EXCLUSIVE_LOCKS_REQUIRED(!m_chainstate_mutex)[m
-         LOCKS_EXCLUDED(::cs_main);[m
- [m
-[2m-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-[2m-[m
-     // Block (dis)connection on a given view:[m
-     DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)[m
-         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
-[36m@@ -738,9 +704,11 @@[m [mpublic:[m
-     /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */[m
-     bool LoadGenesisBlock();[m
- [m
-[32m+[m[32m    void TryAddBlockIndexCandidate(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-[32m+[m
-     void PruneBlockIndexCandidates();[m
- [m
-[31m-    void UnloadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
-[32m+[m[32m    void ClearBlockIndexCandidates() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);[m
- [m
-     /** Check whether we are doing an initial block download (synchronizing from disk or network) */[m
-     bool IsInitialBlockDownload() const;[m
-[36m@@ -748,13 +716,6 @@[m [mpublic:[m
-     /** Find the last common block of this chain and a locator. */[m
-     const CBlockIndex* FindForkInGlobalIndex(const CBlockLocator& locator) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
- [m
-[2m-    /**[m
-[2m-     * Make various assertions about the state of the block index.[m
-[2m-     *[m
-[2m-     * By default this only executes fully when using the Regtest chain; see: m_options.check_block_index.[m
-[2m-     */[m
-[2m-    void CheckBlockIndex();[m
-[2m-[m
-     /** Load the persisted mempool from disk */[m
-     void LoadMempool(const fs::path& load_path, fsbridge::FopenFn mockable_fopen_function = fsbridge::fopen);[m
- [m
-[36m@@ -784,7 +745,6 @@[m [mprivate:[m
- [m
-     void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-[2m-    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
- [m
-     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
- [m
-[36m@@ -970,6 +930,13 @@[m [mpublic:[m
-     const uint256& AssumedValidBlock() const { return *Assert(m_options.assumed_valid_block); }[m
-     kernel::Notifications& GetNotifications() const { return m_options.notifications; };[m
- [m
-[2m+[m[2m    /**[m
-[2m+[m[2m     * Make various assertions about the state of the block index.[m
-[2m+[m[2m     *[m
-[2m+[m[2m     * By default this only executes fully when using the Regtest chain; see: m_options.check_block_index.[m
-[2m+[m[2m     */[m
-[2m+[m[2m    void CheckBlockIndex();[m
-[2m+[m
-     /**[m
-      * Alias for ::cs_main.[m
-      * Should be used in new code to make it easier to make ::cs_main a member[m
-[36m@@ -990,6 +957,25 @@[m [mpublic:[m
-     //! chainstate to avoid duplicating block metadata.[m
-     node::BlockManager m_blockman;[m
- [m
-[2m+[m[2m    /**[m
-[2m+[m[2m     * Every received block is assigned a unique and increasing identifier, so we[m
-[2m+[m[2m     * know which one to give priority in case of a fork.[m
-[2m+[m[2m     */[m
-[2m+[m[2m    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */[m
-[2m+[m[2m    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;[m
-[2m+[m[2m    /** Decreasing counter (used by subsequent preciousblock calls). */[m
-[2m+[m[2m    int32_t nBlockReverseSequenceId = -1;[m
-[2m+[m[2m    /** chainwork for the last block that preciousblock has been applied to. */[m
-[2m+[m[2m    arith_uint256 nLastPreciousChainwork = 0;[m
-[2m+[m
-[32m+[m[32m    void ResetBlockSequenceCounters() EXCLUSIVE_LOCKS_REQUIRED(::cs_main)[m
-[32m+[m[32m    {[m
-[32m+[m[32m        AssertLockHeld(::cs_main);[m
-[32m+[m[32m        nBlockSequenceId = 1;[m
-[32m+[m[32m        nBlockReverseSequenceId = -1;[m
-[32m+[m[32m    }[m
-[32m+[m
-[32m+[m
-     /**[m
-      * In order to efficiently track invalidity of headers, we keep the set of[m
-      * blocks which we tried to connect and found to be invalid here (ie which[m
-[36m@@ -1085,6 +1071,42 @@[m [mpublic:[m
-         return m_snapshot_chainstate && m_ibd_chainstate && m_ibd_chainstate->m_disabled;[m
-     }[m
- [m
-[32m+[m[32m    const CBlockIndex* ActiveSnapshotBase() const EXCLUSIVE_LOCKS_REQUIRED(::cs_main)[m
-[32m+[m[32m    {[m
-[32m+[m[32m        return m_active_chainstate ? m_active_chainstate->SnapshotBase() : nullptr;[m
-[32m+[m[32m    }[m
-[32m+[m
-[2m+[m[2m    /**[m
-[2m+[m[2m     * Import blocks from an external file[m
-[2m+[m[2m     *[m
-[2m+[m[2m     * During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat).[m
-[2m+[m[2m     * It reads all blocks contained in the given file and attempts to process them (add them to the[m
-[2m+[m[2m     * block index). The blocks may be out of order within each file and across files. Often this[m
-[2m+[m[2m     * function reads a block but finds that its parent hasn't been read yet, so the block can't be[m
-[2m+[m[2m     * processed yet. The function will add an entry to the blocks_with_unknown_parent map (which is[m
-[2m+[m[2m     * passed as an argument), so that when the block's parent is later read and processed, this[m
-[2m+[m[2m     * function can re-read the child block from disk and process it.[m
-[2m+[m[2m     *[m
-[2m+[m[2m     * Because a block's parent may be in a later file, not just later in the same file, the[m
-[2m+[m[2m     * blocks_with_unknown_parent map must be passed in and out with each call. It's a multimap,[m
-[2m+[m[2m     * rather than just a map, because multiple blocks may have the same parent (when chain splits[m
-[2m+[m[2m     * or stale blocks exist). It maps from parent-hash to child-disk-position.[m
-[2m+[m[2m     *[m
-[2m+[m[2m     * This function can also be used to read blocks from user-specified block files using the[m
-[2m+[m[2m     * -loadblock= option. There's no unknown-parent tracking, so the last two arguments are omitted.[m
-[2m+[m[2m     *[m
-[2m+[m[2m     *[m
-[2m+[m[2m     * @param[in]     fileIn                        FILE handle to file containing blocks to read[m
-[2m+[m[2m     * @param[in]     dbp                           (optional) Disk block position (only for reindex)[m
-[2m+[m[2m     * @param[in,out] blocks_with_unknown_parent    (optional) Map of disk positions for blocks with[m
-[2m+[m[2m     *                                              unknown parent, key is parent block hash[m
-[2m+[m[2m     *                                              (only used for reindex)[m
-[2m+[m[2m     * */[m
-[2m+[m[2m    void LoadExternalBlockFile([m
-[2m+[m[2m        FILE* fileIn,[m
-[2m+[m[2m        FlatFilePos* dbp = nullptr,[m
-[32m+[m[32m        std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent = nullptr);[m
-[32m+[m
-     /**[m
-      * Process an incoming block. This only returns after the best known valid[m
-      * block is made active. Note that it does not, however, guarantee that the[m
-[36m@@ -1124,6 +1146,29 @@[m [mpublic:[m
-      */[m
-     bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, bool min_pow_checked, BlockValidationState& state, const CBlockIndex** ppindex = nullptr) LOCKS_EXCLUDED(cs_main);[m
- [m
-[32m+[m[32m    /**[m
-[32m+[m[32m     * Sufficiently validate a block for disk storage (and store on disk).[m
-[32m+[m[32m     *[m
-[32m+[m[32m     * @param[in]   pblock          The block we want to process.[m
-[32m+[m[32m     * @param[in]   fRequested      Whether we requested this block from a[m
-[32m+[m[32m     *                              peer.[m
-[32m+[m[32m     * @param[in]   dbp             The location on disk, if we are importing[m
-[32m+[m[32m     *                              this block from prior storage.[m
-[32m+[m[32m     * @param[in]   min_pow_checked True if proof-of-work anti-DoS checks have[m
-[32m+[m[32m     *                              been done by caller for headers chain[m
-[32m+[m[32m     *[m
-[32m+[m[32m     * @param[out]  state       The state of the block validation.[m
-[32m+[m[32m     * @param[out]  ppindex     Optional return parameter to get the[m
-[32m+[m[32m     *                          CBlockIndex pointer for this block.[m
-[32m+[m[32m     * @param[out]  fNewBlock   Optional return parameter to indicate if the[m
-[32m+[m[32m     *                          block is new to our storage.[m
-[32m+[m[32m     *[m
-[32m+[m[32m     * @returns   False if the block or header is invalid, or if saving to disk fails (likely a fatal error); true otherwise.[m
-[32m+[m[32m     */[m
-[2m+[m[2m    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-[1;36m+[m
-[1;33m+[m[1;33m    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);[m
-[32m+[m
-     /**[m
-      * Try to add a transaction to the memory pool.[m
-      *[m
\ No newline at end of file
+diff --git a/doc/design/assumeutxo.md b/doc/design/assumeutxo.md
+index 469c551536..1492877e62 100644
+--- a/doc/design/assumeutxo.md
++++ b/doc/design/assumeutxo.md
+@@ -17,10 +17,9 @@ respectively generate and load UTXO snapshots. The utility script
+ 
+ - A new block index `nStatus` flag is introduced, `BLOCK_ASSUMED_VALID`, to mark block
+   index entries that are required to be assumed-valid by a chainstate created
+-  from a UTXO snapshot. This flag is mostly used as a way to modify certain
++  from a UTXO snapshot. This flag is used as a way to modify certain
+   CheckBlockIndex() logic to account for index entries that are pending validation by a
+-  chainstate running asynchronously in the background. We also use this flag to control
+-  which index entries are added to setBlockIndexCandidates during LoadBlockIndex().
++  chainstate running asynchronously in the background.
+ 
+ - The concept of UTXO snapshots is treated as an implementation detail that lives
+   behind the ChainstateManager interface. The external presentation of the changes
+diff --git a/src/bench/load_external.cpp b/src/bench/load_external.cpp
+index 1378a7b20a..252cbb163b 100644
+--- a/src/bench/load_external.cpp
++++ b/src/bench/load_external.cpp
+@@ -49,14 +49,13 @@ static void LoadExternalBlockFile(benchmark::Bench& bench)
+         fclose(file);
+     }
+ 
+-    Chainstate& chainstate{testing_setup->m_node.chainman->ActiveChainstate()};
+     std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;
+     FlatFilePos pos;
+     bench.run([&] {
+         // "rb" is "binary, O_RDONLY", positioned to the start of the file.
+         // The file will be closed by LoadExternalBlockFile().
+         FILE* file{fsbridge::fopen(blkfile, "rb")};
+-        chainstate.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);
++        testing_setup->m_node.chainman->LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);
+     });
+     fs::remove(blkfile);
+ }
+diff --git a/src/chain.h b/src/chain.h
+index f5dd0fd315..2e1fb37bec 100644
+--- a/src/chain.h
++++ b/src/chain.h
+@@ -113,10 +113,10 @@ enum BlockStatus : uint32_t {
+     BLOCK_VALID_TRANSACTIONS =    3,
+ 
+     //! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30.
+-    //! Implies all parents are also at least CHAIN.
++    //! Implies all parents are either at least VALID_CHAIN, or are ASSUMED_VALID
+     BLOCK_VALID_CHAIN        =    4,
+ 
+-    //! Scripts & signatures ok. Implies all parents are also at least SCRIPTS.
++    //! Scripts & signatures ok. Implies all parents are either at least VALID_SCRIPTS, or are ASSUMED_VALID.
+     BLOCK_VALID_SCRIPTS      =    5,
+ 
+     //! All validity bits.
+@@ -134,10 +134,18 @@ enum BlockStatus : uint32_t {
+     BLOCK_OPT_WITNESS        =   128, //!< block data in blk*.dat was received with a witness-enforcing client
+ 
+     /**
+-     * If set, this indicates that the block index entry is assumed-valid.
+-     * Certain diagnostics will be skipped in e.g. CheckBlockIndex().
+-     * It almost certainly means that the block's full validation is pending
+-     * on a background chainstate. See `doc/design/assumeutxo.md`.
++     * If ASSUMED_VALID is set, it means that this block has not been validated
++     * and has validity status less than VALID_SCRIPTS. Also that it may have
++     * descendant blocks with VALID_SCRIPTS set, because they can be validated
++     * based on an assumeutxo snapshot.
++     *
++     * When an assumeutxo snapshot is loaded, the ASSUMED_VALID flag is added to
++     * unvalidated blocks at the snapshot height and below. Then, as the background
++     * validation progresses, and these blocks are validated, the ASSUMED_VALID
++     * flags are removed. See `doc/design/assumeutxo.md` for details.
++     *
++     * This flag is only used to implement checks in CheckBlockIndex() and
++     * should not be used elsewhere.
+      */
+     BLOCK_ASSUMED_VALID      =   256,
+ };
+diff --git a/src/node/blockstorage.cpp b/src/node/blockstorage.cpp
+index 78416ec576..0d25c798ce 100644
+--- a/src/node/blockstorage.cpp
++++ b/src/node/blockstorage.cpp
+@@ -618,7 +618,7 @@ fs::path BlockManager::GetBlockPosFilename(const FlatFilePos& pos) const
+     return BlockFileSeq().FileName(pos);
+ }
+ 
+-bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown)
++bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown)
+ {
+     LOCK(cs_LastBlockFile);
+ 
+@@ -644,7 +644,7 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne
+             // when the undo file is keeping up with the block file, we want to flush it explicitly
+             // when it is lagging behind (more blocks arrive than are being connected), we let the
+             // undo block write case handle it
+-            finalize_undo = (m_blockfile_info[nFile].nHeightLast == (unsigned int)active_chain.Tip()->nHeight);
++            finalize_undo = (m_blockfile_info[nFile].nHeightLast == m_undo_height_in_last_blockfile);
+             nFile++;
+             if (m_blockfile_info.size() <= nFile) {
+                 m_blockfile_info.resize(nFile + 1);
+@@ -660,6 +660,7 @@ bool BlockManager::FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigne
+         }
+         FlushBlockFile(!fKnown, finalize_undo);
+         m_last_blockfile = nFile;
++        m_undo_height_in_last_blockfile = 0; // No undo data yet in the new file, so reset our undo-height tracking.
+     }
+ 
+     m_blockfile_info[nFile].AddBlock(nHeight, nTime);
+@@ -749,8 +750,9 @@ bool BlockManager::WriteUndoDataForBlock(const CBlockUndo& blockundo, BlockValid
+         // the FindBlockPos function
+         if (_pos.nFile < m_last_blockfile && static_cast<uint32_t>(block.nHeight) == m_blockfile_info[_pos.nFile].nHeightLast) {
+             FlushUndoFile(_pos.nFile, true);
++        } else if (_pos.nFile == m_last_blockfile && static_cast<uint32_t>(block.nHeight) > m_undo_height_in_last_blockfile) {
++            m_undo_height_in_last_blockfile = block.nHeight;
+         }
+-
+         // update nUndoPos in block index
+         block.nUndoPos = _pos.nPos;
+         block.nStatus |= BLOCK_HAVE_UNDO;
+@@ -839,7 +841,7 @@ bool BlockManager::ReadRawBlockFromDisk(std::vector<uint8_t>& block, const FlatF
+     return true;
+ }
+ 
+-FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const FlatFilePos* dbp)
++FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, const FlatFilePos* dbp)
+ {
+     unsigned int nBlockSize = ::GetSerializeSize(block, CLIENT_VERSION);
+     FlatFilePos blockPos;
+@@ -852,7 +854,7 @@ FlatFilePos BlockManager::SaveBlockToDisk(const CBlock& block, int nHeight, CCha
+         // we add BLOCK_SERIALIZATION_HEADER_SIZE only for new blocks since they will have the serialization header added when written to disk.
+         nBlockSize += static_cast<unsigned int>(BLOCK_SERIALIZATION_HEADER_SIZE);
+     }
+-    if (!FindBlockPos(blockPos, nBlockSize, nHeight, active_chain, block.GetBlockTime(), position_known)) {
++    if (!FindBlockPos(blockPos, nBlockSize, nHeight, block.GetBlockTime(), position_known)) {
+         error("%s: FindBlockPos failed", __func__);
+         return FlatFilePos();
+     }
+@@ -905,7 +907,7 @@ void ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFile
+                     break; // This error is logged in OpenBlockFile
+                 }
+                 LogPrintf("Reindexing block file blk%05u.dat...\n", (unsigned int)nFile);
+-                chainman.ActiveChainstate().LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);
++                chainman.LoadExternalBlockFile(file, &pos, &blocks_with_unknown_parent);
+                 if (chainman.m_interrupt) {
+                     LogPrintf("Interrupt requested. Exit %s\n", __func__);
+                     return;
+@@ -924,7 +926,7 @@ void ImportBlocks(ChainstateManager& chainman, std::vector<fs::path> vImportFile
+             FILE* file = fsbridge::fopen(path, "rb");
+             if (file) {
+                 LogPrintf("Importing blocks file %s...\n", fs::PathToString(path));
+-                chainman.ActiveChainstate().LoadExternalBlockFile(file);
++                chainman.LoadExternalBlockFile(file);
+                 if (chainman.m_interrupt) {
+                     LogPrintf("Interrupt requested. Exit %s\n", __func__);
+                     return;
+diff --git a/src/node/blockstorage.h b/src/node/blockstorage.h
+index c2e903e470..eb40d45aba 100644
+--- a/src/node/blockstorage.h
++++ b/src/node/blockstorage.h
+@@ -24,7 +24,6 @@ class BlockValidationState;
+ class CBlock;
+ class CBlockFileInfo;
+ class CBlockUndo;
+-class CChain;
+ class CChainParams;
+ class Chainstate;
+ class ChainstateManager;
+@@ -94,7 +93,7 @@ private:
+         EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+     void FlushBlockFile(bool fFinalize = false, bool finalize_undo = false);
+     void FlushUndoFile(int block_file, bool finalize = false);
+-    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, CChain& active_chain, uint64_t nTime, bool fKnown);
++    bool FindBlockPos(FlatFilePos& pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown);
+     bool FindUndoPos(BlockValidationState& state, int nFile, FlatFilePos& pos, unsigned int nAddSize);
+ 
+     FlatFileSeq BlockFileSeq() const;
+@@ -128,6 +127,19 @@ private:
+     RecursiveMutex cs_LastBlockFile;
+     std::vector<CBlockFileInfo> m_blockfile_info;
+     int m_last_blockfile = 0;
++
++    // Track the height of the highest block in m_last_blockfile whose undo
++    // data has been written. Block data is written to block files in download
++    // order, but is written to undo files in validation order, which is
++    // usually in order by height. To avoid wasting disk space, undo files will
++    // be trimmed whenever the corresponding block file is finalized and
++    // the height of the highest block written to the block file equals the
++    // height of the highest block written to the undo file. This is a
++    // heuristic and can sometimes preemptively trim undo files that will write
++    // more data later, and sometimes fail to trim undo files that can't have
++    // more data written later.
++    unsigned int m_undo_height_in_last_blockfile = 0;
++
+     /** Global flag to indicate we should check to see if there are
+      *  block/undo files that should be deleted.  Set on startup
+      *  or if we allocate more file space when we're in prune mode
+@@ -202,7 +214,7 @@ public:
+         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
+ 
+     /** Store block on disk. If dbp is not nullptr, then it provides the known position of the block within a block file on disk. */
+-    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, CChain& active_chain, const FlatFilePos* dbp);
++    FlatFilePos SaveBlockToDisk(const CBlock& block, int nHeight, const FlatFilePos* dbp);
+ 
+     /** Whether running in -prune mode. */
+     [[nodiscard]] bool IsPruneMode() const { return m_prune_mode; }
+diff --git a/src/node/chainstate.cpp b/src/node/chainstate.cpp
+index 255d8be0ec..0828f64856 100644
+--- a/src/node/chainstate.cpp
++++ b/src/node/chainstate.cpp
+@@ -221,7 +221,7 @@ ChainstateLoadResult LoadChainstate(ChainstateManager& chainman, const CacheSize
+ 
+         // A reload of the block index is required to recompute setBlockIndexCandidates
+         // for the fully validated chainstate.
+-        chainman.ActiveChainstate().UnloadBlockIndex();
++        chainman.ActiveChainstate().ClearBlockIndexCandidates();
+ 
+         auto [init_status, init_error] = CompleteChainstateInitialization(chainman, cache_sizes, options);
+         if (init_status != ChainstateLoadStatus::SUCCESS) {
+diff --git a/src/test/blockmanager_tests.cpp b/src/test/blockmanager_tests.cpp
+index e4ed861b12..f52c692649 100644
+--- a/src/test/blockmanager_tests.cpp
++++ b/src/test/blockmanager_tests.cpp
+@@ -30,22 +30,21 @@ BOOST_AUTO_TEST_CASE(blockmanager_find_block_pos)
+         .notifications = notifications,
+     };
+     BlockManager blockman{m_node.kernel->interrupt, blockman_opts};
+-    CChain chain {};
+     // simulate adding a genesis block normally
+-    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, chain, nullptr).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);
++    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, nullptr).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);
+     // simulate what happens during reindex
+     // simulate a well-formed genesis block being found at offset 8 in the blk00000.dat file
+     // the block is found at offset 8 because there is an 8 byte serialization header
+     // consisting of 4 magic bytes + 4 length bytes before each block in a well-formed blk file.
+     FlatFilePos pos{0, BLOCK_SERIALIZATION_HEADER_SIZE};
+-    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, chain, &pos).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);
++    BOOST_CHECK_EQUAL(blockman.SaveBlockToDisk(params->GenesisBlock(), 0, &pos).nPos, BLOCK_SERIALIZATION_HEADER_SIZE);
+     // now simulate what happens after reindex for the first new block processed
+     // the actual block contents don't matter, just that it's a block.
+     // verify that the write position is at offset 0x12d.
+     // this is a check to make sure that https://github.com/bitcoin/bitcoin/issues/21379 does not recur
+     // 8 bytes (for serialization header) + 285 (for serialized genesis block) = 293
+     // add another 8 bytes for the second block's serialization header and we get 293 + 8 = 301
+-    FlatFilePos actual{blockman.SaveBlockToDisk(params->GenesisBlock(), 1, chain, nullptr)};
++    FlatFilePos actual{blockman.SaveBlockToDisk(params->GenesisBlock(), 1, nullptr)};
+     BOOST_CHECK_EQUAL(actual.nPos, BLOCK_SERIALIZATION_HEADER_SIZE + ::GetSerializeSize(params->GenesisBlock(), CLIENT_VERSION) + BLOCK_SERIALIZATION_HEADER_SIZE);
+ }
+ 
+diff --git a/src/test/coinstatsindex_tests.cpp b/src/test/coinstatsindex_tests.cpp
+index 74d6d7231a..787a196a0c 100644
+--- a/src/test/coinstatsindex_tests.cpp
++++ b/src/test/coinstatsindex_tests.cpp
+@@ -98,7 +98,7 @@ BOOST_FIXTURE_TEST_CASE(coinstatsindex_unclean_shutdown, TestChain100Setup)
+             LOCK(cs_main);
+             BlockValidationState state;
+             BOOST_CHECK(CheckBlock(block, state, params.GetConsensus()));
+-            BOOST_CHECK(chainstate.AcceptBlock(new_block, state, &new_block_index, true, nullptr, nullptr, true));
++            BOOST_CHECK(m_node.chainman->AcceptBlock(new_block, state, &new_block_index, true, nullptr, nullptr, true));
+             CCoinsViewCache view(&chainstate.CoinsTip());
+             BOOST_CHECK(chainstate.ConnectBlock(block, state, new_block_index, view));
+         }
+diff --git a/src/test/fuzz/load_external_block_file.cpp b/src/test/fuzz/load_external_block_file.cpp
+index f4b7dc08fd..7f8c9c4e71 100644
+--- a/src/test/fuzz/load_external_block_file.cpp
++++ b/src/test/fuzz/load_external_block_file.cpp
+@@ -35,9 +35,9 @@ FUZZ_TARGET_INIT(load_external_block_file, initialize_load_external_block_file)
+         // Corresponds to the -reindex case (track orphan blocks across files).
+         FlatFilePos flat_file_pos;
+         std::multimap<uint256, FlatFilePos> blocks_with_unknown_parent;
+-        g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);
++        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file, &flat_file_pos, &blocks_with_unknown_parent);
+     } else {
+         // Corresponds to the -loadblock= case (orphan blocks aren't tracked across files).
+-        g_setup->m_node.chainman->ActiveChainstate().LoadExternalBlockFile(fuzzed_block_file);
++        g_setup->m_node.chainman->LoadExternalBlockFile(fuzzed_block_file);
+     }
+ }
+diff --git a/src/test/util/chainstate.h b/src/test/util/chainstate.h
+index bf8f8b5819..9ff2c08807 100644
+--- a/src/test/util/chainstate.h
++++ b/src/test/util/chainstate.h
+@@ -71,6 +71,7 @@ CreateAndActivateUTXOSnapshot(
+             // This is a stripped-down version of node::LoadChainstate which
+             // preserves the block index.
+             LOCK(::cs_main);
++            CBlockIndex *orig_tip = node.chainman->ActiveChainstate().m_chain.Tip();
+             uint256 gen_hash = node.chainman->ActiveChainstate().m_chain[0]->GetBlockHash();
+             node.chainman->ResetChainstates();
+             node.chainman->InitializeChainstate(node.mempool.get());
+@@ -83,6 +84,22 @@ CreateAndActivateUTXOSnapshot(
+             chain.setBlockIndexCandidates.insert(node.chainman->m_blockman.LookupBlockIndex(gen_hash));
+             chain.LoadChainTip();
+             node.chainman->MaybeRebalanceCaches();
++
++            // Reset the HAVE_DATA flags below the snapshot height, simulating
++            // never-having-downloaded them in the first place.
++            // TODO: perhaps we could improve this by using pruning to delete
++            // these blocks instead
++            CBlockIndex *pindex = orig_tip;
++            while (pindex && pindex != chain.m_chain.Tip()) {
++                pindex->nStatus &= ~BLOCK_HAVE_DATA;
++                pindex->nStatus &= ~BLOCK_HAVE_UNDO;
++                // We have to set the ASSUMED_VALID flag, because otherwise it
++                // would not be possible to have a block index entry without HAVE_DATA
++                // and with nTx > 0 (since we aren't setting the pruned flag);
++                // see CheckBlockIndex().
++                pindex->nStatus |= BLOCK_ASSUMED_VALID;
++                pindex = pindex->pprev;
++            }
+         }
+         BlockValidationState state;
+         if (!node.chainman->ActiveChainstate().ActivateBestChain(state)) {
+diff --git a/src/test/validation_chainstate_tests.cpp b/src/test/validation_chainstate_tests.cpp
+index 2078fcd8f8..fe2d2ba592 100644
+--- a/src/test/validation_chainstate_tests.cpp
++++ b/src/test/validation_chainstate_tests.cpp
+@@ -77,6 +77,13 @@ BOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)
+     // After adding some blocks to the tip, best block should have changed.
+     BOOST_CHECK(::g_best_block != curr_tip);
+ 
++    // Grab block 1 from disk; we'll add it to the background chain later.
++    std::shared_ptr<CBlock> pblockone = std::make_shared<CBlock>();
++    {
++        LOCK(::cs_main);
++        chainman.m_blockman.ReadBlockFromDisk(*pblockone, *chainman.ActiveChain()[1]);
++    }
++
+     BOOST_REQUIRE(CreateAndActivateUTXOSnapshot(
+         this, NoMalleation, /*reset_chainstate=*/ true));
+ 
+@@ -104,11 +111,7 @@ BOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)
+         assert(false);
+     }()};
+ 
+-    // Create a block to append to the validation chain.
+-    std::vector<CMutableTransaction> noTxns;
+-    CScript scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;
+-    CBlock validation_block = this->CreateBlock(noTxns, scriptPubKey, background_cs);
+-    auto pblock = std::make_shared<const CBlock>(validation_block);
++    // Append the first block to the background chain.
+     BlockValidationState state;
+     CBlockIndex* pindex = nullptr;
+     const CChainParams& chainparams = Params();
+@@ -118,17 +121,18 @@ BOOST_FIXTURE_TEST_CASE(chainstate_update_tip, TestChain100Setup)
+     // once it is changed to support multiple chainstates.
+     {
+         LOCK(::cs_main);
+-        bool checked = CheckBlock(*pblock, state, chainparams.GetConsensus());
++        bool checked = CheckBlock(*pblockone, state, chainparams.GetConsensus());
+         BOOST_CHECK(checked);
+-        bool accepted = background_cs.AcceptBlock(
+-            pblock, state, &pindex, true, nullptr, &newblock, true);
++        bool accepted = chainman.AcceptBlock(
++            pblockone, state, &pindex, true, nullptr, &newblock, true);
+         BOOST_CHECK(accepted);
+     }
++
+     // UpdateTip is called here
+-    bool block_added = background_cs.ActivateBestChain(state, pblock);
++    bool block_added = background_cs.ActivateBestChain(state, pblockone);
+ 
+     // Ensure tip is as expected
+-    BOOST_CHECK_EQUAL(background_cs.m_chain.Tip()->GetBlockHash(), validation_block.GetHash());
++    BOOST_CHECK_EQUAL(background_cs.m_chain.Tip()->GetBlockHash(), pblockone->GetHash());
+ 
+     // g_best_block should be unchanged after adding a block to the background
+     // validation chain.
+diff --git a/src/test/validation_chainstatemanager_tests.cpp b/src/test/validation_chainstatemanager_tests.cpp
+index 99860961a2..160a807f69 100644
+--- a/src/test/validation_chainstatemanager_tests.cpp
++++ b/src/test/validation_chainstatemanager_tests.cpp
+@@ -49,6 +49,9 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)
+     c1.InitCoinsDB(
+         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);
+     WITH_LOCK(::cs_main, c1.InitCoinsCache(1 << 23));
++    c1.LoadGenesisBlock();
++    BlockValidationState val_state;
++    BOOST_CHECK(c1.ActivateBestChain(val_state, nullptr));
+ 
+     BOOST_CHECK(!manager.IsSnapshotActive());
+     BOOST_CHECK(WITH_LOCK(::cs_main, return !manager.IsSnapshotValidated()));
+@@ -58,7 +61,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)
+     auto& active_chain = WITH_LOCK(manager.GetMutex(), return manager.ActiveChain());
+     BOOST_CHECK_EQUAL(&active_chain, &c1.m_chain);
+ 
+-    BOOST_CHECK_EQUAL(WITH_LOCK(manager.GetMutex(), return manager.ActiveHeight()), -1);
++    BOOST_CHECK_EQUAL(WITH_LOCK(manager.GetMutex(), return manager.ActiveHeight()), 0);
+ 
+     auto active_tip = WITH_LOCK(manager.GetMutex(), return manager.ActiveTip());
+     auto exp_tip = c1.m_chain.Tip();
+@@ -68,7 +71,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)
+ 
+     // Create a snapshot-based chainstate.
+     //
+-    const uint256 snapshot_blockhash = GetRandHash();
++    const uint256 snapshot_blockhash = active_tip->GetBlockHash();
+     Chainstate& c2 = WITH_LOCK(::cs_main, return manager.ActivateExistingSnapshot(
+         &mempool, snapshot_blockhash));
+     chainstates.push_back(&c2);
+@@ -78,8 +81,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)
+     c2.InitCoinsDB(
+         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);
+     WITH_LOCK(::cs_main, c2.InitCoinsCache(1 << 23));
+-    // Unlike c1, which doesn't have any blocks. Gets us different tip, height.
+-    c2.LoadGenesisBlock();
++    c2.m_chain.SetTip(*active_tip);
+     BlockValidationState _;
+     BOOST_CHECK(c2.ActivateBestChain(_, nullptr));
+ 
+@@ -99,16 +101,14 @@ BOOST_AUTO_TEST_CASE(chainstatemanager)
+     auto exp_tip2 = c2.m_chain.Tip();
+     BOOST_CHECK_EQUAL(active_tip2, exp_tip2);
+ 
+-    // Ensure that these pointers actually correspond to different
+-    // CCoinsViewCache instances.
+-    BOOST_CHECK(exp_tip != exp_tip2);
++    BOOST_CHECK_EQUAL(exp_tip, exp_tip2);
+ 
+     // Let scheduler events finish running to avoid accessing memory that is going to be unloaded
+     SyncWithValidationInterfaceQueue();
+ }
+ 
+ //! Test rebalancing the caches associated with each chainstate.
+-BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)
++BOOST_FIXTURE_TEST_CASE(chainstatemanager_rebalance_caches, TestChain100Setup)
+ {
+     ChainstateManager& manager = *m_node.chainman;
+     CTxMemPool& mempool = *m_node.mempool;
+@@ -121,7 +121,7 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)
+ 
+     // Create a legacy (IBD) chainstate.
+     //
+-    Chainstate& c1 = WITH_LOCK(::cs_main, return manager.InitializeChainstate(&mempool));
++    Chainstate& c1 = manager.ActiveChainstate();
+     chainstates.push_back(&c1);
+     c1.InitCoinsDB(
+         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);
+@@ -129,8 +129,6 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)
+     {
+         LOCK(::cs_main);
+         c1.InitCoinsCache(1 << 23);
+-        BOOST_REQUIRE(c1.LoadGenesisBlock());
+-        c1.CoinsTip().SetBestBlock(InsecureRand256());
+         manager.MaybeRebalanceCaches();
+     }
+ 
+@@ -139,7 +137,8 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)
+ 
+     // Create a snapshot-based chainstate.
+     //
+-    Chainstate& c2 = WITH_LOCK(cs_main, return manager.ActivateExistingSnapshot(&mempool, GetRandHash()));
++    CBlockIndex* snapshot_base{WITH_LOCK(manager.GetMutex(), return manager.ActiveChain()[manager.ActiveChain().Height() / 2])};
++    Chainstate& c2 = WITH_LOCK(cs_main, return manager.ActivateExistingSnapshot(&mempool, *snapshot_base->phashBlock));
+     chainstates.push_back(&c2);
+     c2.InitCoinsDB(
+         /*cache_size_bytes=*/1 << 23, /*in_memory=*/true, /*should_wipe=*/false);
+@@ -147,8 +146,6 @@ BOOST_AUTO_TEST_CASE(chainstatemanager_rebalance_caches)
+     {
+         LOCK(::cs_main);
+         c2.InitCoinsCache(1 << 23);
+-        BOOST_REQUIRE(c2.LoadGenesisBlock());
+-        c2.CoinsTip().SetBestBlock(InsecureRand256());
+         manager.MaybeRebalanceCaches();
+     }
+ 
+@@ -415,7 +412,7 @@ BOOST_FIXTURE_TEST_CASE(chainstatemanager_activate_snapshot, SnapshotTestSetup)
+ //! - Then mark a region of the chain BLOCK_ASSUMED_VALID and introduce a second chainstate
+ //!   that will tolerate assumed-valid blocks. Run LoadBlockIndex() and ensure that the first
+ //!   chainstate only contains fully validated blocks and the other chainstate contains all blocks,
+-//!   even those assumed-valid.
++//!   except those marked assume-valid, because those entries don't HAVE_DATA.
+ //!
+ BOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)
+ {
+@@ -430,28 +427,34 @@ BOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)
+     const int assumed_valid_start_idx = last_assumed_valid_idx - expected_assumed_valid;
+ 
+     CBlockIndex* validated_tip{nullptr};
++    CBlockIndex* assumed_base{nullptr};
+     CBlockIndex* assumed_tip{WITH_LOCK(chainman.GetMutex(), return chainman.ActiveChain().Tip())};
+ 
+     auto reload_all_block_indexes = [&]() {
++        // For completeness, we also reset the block sequence counters to
++        // ensure that no state which affects the ranking of tip-candidates is
++        // retained (even though this isn't strictly necessary).
++        WITH_LOCK(::cs_main, return chainman.ResetBlockSequenceCounters());
+         for (Chainstate* cs : chainman.GetAll()) {
+             LOCK(::cs_main);
+-            cs->UnloadBlockIndex();
++            cs->ClearBlockIndexCandidates();
+             BOOST_CHECK(cs->setBlockIndexCandidates.empty());
+         }
+ 
+         WITH_LOCK(::cs_main, chainman.LoadBlockIndex());
+     };
+ 
+-    // Ensure that without any assumed-valid BlockIndex entries, all entries are considered
+-    // tip candidates.
++    // Ensure that without any assumed-valid BlockIndex entries, only the current tip is
++    // considered as a candidate.
+     reload_all_block_indexes();
+-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), cs1.m_chain.Height() + 1);
++    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), 1);
+ 
+-    // Mark some region of the chain assumed-valid.
++    // Mark some region of the chain assumed-valid, and remove the HAVE_DATA flag.
+     for (int i = 0; i <= cs1.m_chain.Height(); ++i) {
+         LOCK(::cs_main);
+         auto index = cs1.m_chain[i];
+ 
++        // Blocks with heights in range [20, 40) are marked ASSUMED_VALID
+         if (i < last_assumed_valid_idx && i >= assumed_valid_start_idx) {
+             index->nStatus = BlockStatus::BLOCK_VALID_TREE | BlockStatus::BLOCK_ASSUMED_VALID;
+         }
+@@ -464,25 +467,41 @@ BOOST_FIXTURE_TEST_CASE(chainstatemanager_loadblockindex, TestChain100Setup)
+             validated_tip = index;
+             BOOST_CHECK(!index->IsAssumedValid());
+         }
++        // Note the last assumed valid block as the snapshot base
++        if (i == last_assumed_valid_idx - 1) {
++            assumed_base = index;
++            BOOST_CHECK(index->IsAssumedValid());
++        } else if (i == last_assumed_valid_idx) {
++            BOOST_CHECK(!index->IsAssumedValid());
++        }
+     }
+ 
+     BOOST_CHECK_EQUAL(expected_assumed_valid, num_assumed_valid);
+ 
++    // Note: cs2's tip is not set when ActivateExistingSnapshot is called.
+     Chainstate& cs2 = WITH_LOCK(::cs_main,
+-        return chainman.ActivateExistingSnapshot(&mempool, GetRandHash()));
++        return chainman.ActivateExistingSnapshot(&mempool, *assumed_base->phashBlock));
++
++    // Set tip of the fully validated chain to be the validated tip
++    cs1.m_chain.SetTip(*validated_tip);
++
++    // Set tip of the assume-valid-based chain to the assume-valid block
++    cs2.m_chain.SetTip(*assumed_base);
+ 
+     reload_all_block_indexes();
+ 
+-    // The fully validated chain only has candidates up to the start of the assumed-valid
+-    // blocks.
++    // The fully validated chain should have the current validated tip
++    // and the assumed valid base as candidates.
++    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), 2);
+     BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(validated_tip), 1);
+-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(assumed_tip), 0);
+-    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.size(), assumed_valid_start_idx);
++    BOOST_CHECK_EQUAL(cs1.setBlockIndexCandidates.count(assumed_base), 1);
+ 
+-    // The assumed-valid tolerant chain has all blocks as candidates.
+-    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(validated_tip), 1);
++    // The assumed-valid tolerant chain has the assumed valid base as a
++    // candidate, but otherwise has none of the assumed-valid (which do not
++    // HAVE_DATA) blocks as candidates.
++    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(validated_tip), 0);
+     BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.count(assumed_tip), 1);
+-    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes);
++    BOOST_CHECK_EQUAL(cs2.setBlockIndexCandidates.size(), num_indexes - last_assumed_valid_idx + 1);
+ }
+ 
+ //! Ensure that snapshot chainstates initialize properly when found on disk.
+diff --git a/src/validation.cpp b/src/validation.cpp
+index 5bf8bd70e2..4321108bf8 100644
+--- a/src/validation.cpp
++++ b/src/validation.cpp
+@@ -1579,6 +1579,13 @@ Chainstate::Chainstate(
+       m_chainman(chainman),
+       m_from_snapshot_blockhash(from_snapshot_blockhash) {}
+ 
++const CBlockIndex* Chainstate::SnapshotBase()
++{
++    if (!m_from_snapshot_blockhash) return nullptr;
++    if (!m_cached_snapshot_base) m_cached_snapshot_base = Assert(m_chainman.m_blockman.LookupBlockIndex(*m_from_snapshot_blockhash));
++    return m_cached_snapshot_base;
++}
++
+ void Chainstate::InitCoinsDB(
+     size_t cache_size_bytes,
+     bool in_memory,
+@@ -3193,7 +3200,8 @@ bool Chainstate::ActivateBestChain(BlockValidationState& state, std::shared_ptr<
+         // that the best block hash is non-null.
+         if (m_chainman.m_interrupt) break;
+     } while (pindexNewTip != pindexMostWork);
+-    CheckBlockIndex();
++
++    m_chainman.CheckBlockIndex();
+ 
+     // Write changes periodically to disk, after relay.
+     if (!FlushStateToDisk(state, FlushStateMode::PERIODIC)) {
+@@ -3213,17 +3221,17 @@ bool Chainstate::PreciousBlock(BlockValidationState& state, CBlockIndex* pindex)
+             // Nothing to do, this block is not at the tip.
+             return true;
+         }
+-        if (m_chain.Tip()->nChainWork > nLastPreciousChainwork) {
++        if (m_chain.Tip()->nChainWork > m_chainman.nLastPreciousChainwork) {
+             // The chain has been extended since the last call, reset the counter.
+-            nBlockReverseSequenceId = -1;
++            m_chainman.nBlockReverseSequenceId = -1;
+         }
+-        nLastPreciousChainwork = m_chain.Tip()->nChainWork;
++        m_chainman.nLastPreciousChainwork = m_chain.Tip()->nChainWork;
+         setBlockIndexCandidates.erase(pindex);
+-        pindex->nSequenceId = nBlockReverseSequenceId;
+-        if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {
++        pindex->nSequenceId = m_chainman.nBlockReverseSequenceId;
++        if (m_chainman.nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {
+             // We can't keep reducing the counter if somebody really wants to
+             // call preciousblock 2**31-1 times on the same set of tips...
+-            nBlockReverseSequenceId--;
++            m_chainman.nBlockReverseSequenceId--;
+         }
+         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->HaveTxsDownloaded()) {
+             setBlockIndexCandidates.insert(pindex);
+@@ -3339,7 +3347,7 @@ bool Chainstate::InvalidateBlock(BlockValidationState& state, CBlockIndex* pinde
+         to_mark_failed = invalid_walk_tip;
+     }
+ 
+-    CheckBlockIndex();
++    m_chainman.CheckBlockIndex();
+ 
+     {
+         LOCK(cs_main);
+@@ -3416,8 +3424,32 @@ void Chainstate::ResetBlockFailureFlags(CBlockIndex *pindex) {
+     }
+ }
+ 
++void Chainstate::TryAddBlockIndexCandidate(CBlockIndex* pindex)
++{
++    AssertLockHeld(cs_main);
++    // The block only is a candidate for the most-work-chain if it has more work than our current tip.
++    if (m_chain.Tip() != nullptr && setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {
++        return;
++    }
++
++    bool is_active_chainstate = this == &m_chainman.ActiveChainstate();
++    if (is_active_chainstate) {
++        // The active chainstate should always add entries that have more
++        // work than the tip.
++        setBlockIndexCandidates.insert(pindex);
++    } else if (!m_disabled) {
++        // For the background chainstate, we only consider connecting blocks
++        // towards the snapshot base (which can't be nullptr or else we'll
++        // never make progress).
++        const CBlockIndex* snapshot_base{Assert(m_chainman.GetSnapshotBaseBlock())};
++        if (snapshot_base->GetAncestor(pindex->nHeight) == pindex) {
++            setBlockIndexCandidates.insert(pindex);
++        }
++    }
++}
++
+ /** Mark a block as having its data received and checked (up to BLOCK_VALID_TRANSACTIONS). */
+-void Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)
++void ChainstateManager::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos)
+ {
+     AssertLockHeld(cs_main);
+     pindexNew->nTx = block.vtx.size();
+@@ -3426,7 +3458,7 @@ void Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pin
+     pindexNew->nDataPos = pos.nPos;
+     pindexNew->nUndoPos = 0;
+     pindexNew->nStatus |= BLOCK_HAVE_DATA;
+-    if (DeploymentActiveAt(*pindexNew, m_chainman, Consensus::DEPLOYMENT_SEGWIT)) {
++    if (DeploymentActiveAt(*pindexNew, *this, Consensus::DEPLOYMENT_SEGWIT)) {
+         pindexNew->nStatus |= BLOCK_OPT_WITNESS;
+     }
+     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);
+@@ -3443,8 +3475,8 @@ void Chainstate::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pin
+             queue.pop_front();
+             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;
+             pindex->nSequenceId = nBlockSequenceId++;
+-            if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {
+-                setBlockIndexCandidates.insert(pindex);
++            for (Chainstate *c : GetAll()) {
++                c->TryAddBlockIndexCandidate(pindex);
+             }
+             std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = m_blockman.m_blocks_unlinked.equal_range(pindex);
+             while (range.first != range.second) {
+@@ -3858,7 +3890,7 @@ bool ChainstateManager::ProcessNewBlockHeaders(const std::vector<CBlockHeader>&
+         for (const CBlockHeader& header : headers) {
+             CBlockIndex *pindex = nullptr; // Use a temp pindex instead of ppindex to avoid a const_cast
+             bool accepted{AcceptBlockHeader(header, state, &pindex, min_pow_checked)};
+-            ActiveChainstate().CheckBlockIndex();
++            CheckBlockIndex();
+ 
+             if (!accepted) {
+                 return false;
+@@ -3905,7 +3937,7 @@ void ChainstateManager::ReportHeadersPresync(const arith_uint256& work, int64_t
+ }
+ 
+ /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */
+-bool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked)
++bool ChainstateManager::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked)
+ {
+     const CBlock& block = *pblock;
+ 
+@@ -3915,23 +3947,24 @@ bool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV
+     CBlockIndex *pindexDummy = nullptr;
+     CBlockIndex *&pindex = ppindex ? *ppindex : pindexDummy;
+ 
+-    bool accepted_header{m_chainman.AcceptBlockHeader(block, state, &pindex, min_pow_checked)};
++    bool accepted_header{AcceptBlockHeader(block, state, &pindex, min_pow_checked)};
+     CheckBlockIndex();
+ 
+     if (!accepted_header)
+         return false;
+ 
+-    // Try to process all requested blocks that we don't have, but only
+-    // process an unrequested block if it's new and has enough work to
+-    // advance our tip, and isn't too many blocks ahead.
++    // Check all requested blocks that we do not already have for validity and
++    // save them to disk. Skip processing of unrequested blocks as an anti-DoS
++    // measure, unless the blocks have more work than the active chain tip, and
++    // aren't too far ahead of it, so are likely to be attached soon.
+     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;
+-    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);
++    bool fHasMoreOrSameWork = (ActiveTip() ? pindex->nChainWork >= ActiveTip()->nChainWork : true);
+     // Blocks that are too out-of-order needlessly limit the effectiveness of
+     // pruning, because pruning will not delete block files that contain any
+     // blocks which are too close in height to the tip.  Apply this test
+     // regardless of whether pruning is enabled; it should generally be safe to
+     // not process unrequested blocks.
+-    bool fTooFarAhead{pindex->nHeight > m_chain.Height() + int(MIN_BLOCKS_TO_KEEP)};
++    bool fTooFarAhead{pindex->nHeight > ActiveHeight() + int(MIN_BLOCKS_TO_KEEP)};
+ 
+     // TODO: Decouple this function from the block download logic by removing fRequested
+     // This requires some new chain data structure to efficiently look up if a
+@@ -3951,13 +3984,13 @@ bool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV
+         // If our tip is behind, a peer could try to send us
+         // low-work blocks on a fake chain that we would never
+         // request; don't process these.
+-        if (pindex->nChainWork < m_chainman.MinimumChainWork()) return true;
++        if (pindex->nChainWork < MinimumChainWork()) return true;
+     }
+ 
+-    const CChainParams& params{m_chainman.GetParams()};
++    const CChainParams& params{GetParams()};
+ 
+     if (!CheckBlock(block, state, params.GetConsensus()) ||
+-        !ContextualCheckBlock(block, state, m_chainman, pindex->pprev)) {
++        !ContextualCheckBlock(block, state, *this, pindex->pprev)) {
+         if (state.IsInvalid() && state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {
+             pindex->nStatus |= BLOCK_FAILED_VALID;
+             m_blockman.m_dirty_blockindex.insert(pindex);
+@@ -3967,23 +4000,30 @@ bool Chainstate::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockV
+ 
+     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW
+     // (but if it does not build on our best tip, let the SendMessages loop relay it)
+-    if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)
++    if (!ActiveChainstate().IsInitialBlockDownload() && ActiveTip() == pindex->pprev)
+         GetMainSignals().NewPoWValidBlock(pindex, pblock);
+ 
+     // Write block to history file
+     if (fNewBlock) *fNewBlock = true;
+     try {
+-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, m_chain, dbp)};
++        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, pindex->nHeight, dbp)};
+         if (blockPos.IsNull()) {
+             state.Error(strprintf("%s: Failed to find position to write new block to disk", __func__));
+             return false;
+         }
+         ReceivedBlockTransactions(block, pindex, blockPos);
+     } catch (const std::runtime_error& e) {
+-        return FatalError(m_chainman.GetNotifications(), state, std::string("System error: ") + e.what());
++        return FatalError(GetNotifications(), state, std::string("System error: ") + e.what());
+     }
+ 
+-    FlushStateToDisk(state, FlushStateMode::NONE);
++    // TODO: FlushStateToDisk() handles flushing of both block and chainstate
++    // data, so we should move this to ChainstateManager so that we can be more
++    // intelligent about how we flush.
++    // For now, since FlushStateMode::NONE is used, all that can happen is that
++    // the block files may be pruned, so we can just call this on one
++    // chainstate (particularly if we haven't implemented pruning with
++    // background validation yet).
++    ActiveChainstate().FlushStateToDisk(state, FlushStateMode::NONE);
+ 
+     CheckBlockIndex();
+ 
+@@ -4011,7 +4051,7 @@ bool ChainstateManager::ProcessNewBlock(const std::shared_ptr<const CBlock>& blo
+         bool ret = CheckBlock(*block, state, GetConsensus());
+         if (ret) {
+             // Store to disk
+-            ret = ActiveChainstate().AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block, min_pow_checked);
++            ret = AcceptBlock(block, state, &pindex, force_processing, nullptr, new_block, min_pow_checked);
+         }
+         if (!ret) {
+             GetMainSignals().BlockChecked(*block, state);
+@@ -4379,10 +4419,9 @@ bool Chainstate::NeedsRedownload() const
+     return false;
+ }
+ 
+-void Chainstate::UnloadBlockIndex()
++void Chainstate::ClearBlockIndexCandidates()
+ {
+     AssertLockHeld(::cs_main);
+-    nBlockSequenceId = 1;
+     setBlockIndexCandidates.clear();
+ }
+ 
+@@ -4401,62 +4440,19 @@ bool ChainstateManager::LoadBlockIndex()
+         std::sort(vSortedByHeight.begin(), vSortedByHeight.end(),
+                   CBlockIndexHeightOnlyComparator());
+ 
+-        // Find start of assumed-valid region.
+-        int first_assumed_valid_height = std::numeric_limits<int>::max();
+-
+-        for (const CBlockIndex* block : vSortedByHeight) {
+-            if (block->IsAssumedValid()) {
+-                auto chainstates = GetAll();
+-
+-                // If we encounter an assumed-valid block index entry, ensure that we have
+-                // one chainstate that tolerates assumed-valid entries and another that does
+-                // not (i.e. the background validation chainstate), since assumed-valid
+-                // entries should always be pending validation by a fully-validated chainstate.
+-                auto any_chain = [&](auto fnc) { return std::any_of(chainstates.cbegin(), chainstates.cend(), fnc); };
+-                assert(any_chain([](auto chainstate) { return chainstate->reliesOnAssumedValid(); }));
+-                assert(any_chain([](auto chainstate) { return !chainstate->reliesOnAssumedValid(); }));
+-
+-                first_assumed_valid_height = block->nHeight;
+-                LogPrintf("Saw first assumedvalid block at height %d (%s)\n",
+-                        first_assumed_valid_height, block->ToString());
+-                break;
+-            }
+-        }
+-
+         for (CBlockIndex* pindex : vSortedByHeight) {
+             if (m_interrupt) return false;
+-            if (pindex->IsAssumedValid() ||
++            // If we have an assumeutxo-based chainstate, then the snapshot
++            // block will be a candidate for the tip, but it may not be
++            // VALID_TRANSACTIONS (eg if we haven't yet downloaded the block),
++            // so we special-case the snapshot block as a potential candidate
++            // here.
++            if (pindex == GetSnapshotBaseBlock() ||
+                     (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) &&
+                      (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))) {
+ 
+-                // Fill each chainstate's block candidate set. Only add assumed-valid
+-                // blocks to the tip candidate set if the chainstate is allowed to rely on
+-                // assumed-valid blocks.
+-                //
+-                // If all setBlockIndexCandidates contained the assumed-valid blocks, the
+-                // background chainstate's ActivateBestChain() call would add assumed-valid
+-                // blocks to the chain (based on how FindMostWorkChain() works). Obviously
+-                // we don't want this since the purpose of the background validation chain
+-                // is to validate assued-valid blocks.
+-                //
+-                // Note: This is considering all blocks whose height is greater or equal to
+-                // the first assumed-valid block to be assumed-valid blocks, and excluding
+-                // them from the background chainstate's setBlockIndexCandidates set. This
+-                // does mean that some blocks which are not technically assumed-valid
+-                // (later blocks on a fork beginning before the first assumed-valid block)
+-                // might not get added to the background chainstate, but this is ok,
+-                // because they will still be attached to the active chainstate if they
+-                // actually contain more work.
+-                //
+-                // Instead of this height-based approach, an earlier attempt was made at
+-                // detecting "holistically" whether the block index under consideration
+-                // relied on an assumed-valid ancestor, but this proved to be too slow to
+-                // be practical.
+                 for (Chainstate* chainstate : GetAll()) {
+-                    if (chainstate->reliesOnAssumedValid() ||
+-                            pindex->nHeight < first_assumed_valid_height) {
+-                        chainstate->setBlockIndexCandidates.insert(pindex);
+-                    }
++                    chainstate->TryAddBlockIndexCandidate(pindex);
+                 }
+             }
+             if (pindex->nStatus & BLOCK_FAILED_MASK && (!m_best_invalid || pindex->nChainWork > m_best_invalid->nChainWork)) {
+@@ -4496,12 +4492,12 @@ bool Chainstate::LoadGenesisBlock()
+ 
+     try {
+         const CBlock& block = params.GenesisBlock();
+-        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, 0, m_chain, nullptr)};
++        FlatFilePos blockPos{m_blockman.SaveBlockToDisk(block, 0, nullptr)};
+         if (blockPos.IsNull()) {
+             return error("%s: writing genesis block to disk failed", __func__);
+         }
+         CBlockIndex* pindex = m_blockman.AddToBlockIndex(block, m_chainman.m_best_header);
+-        ReceivedBlockTransactions(block, pindex, blockPos);
++        m_chainman.ReceivedBlockTransactions(block, pindex, blockPos);
+     } catch (const std::runtime_error& e) {
+         return error("%s: failed to write genesis block: %s", __func__, e.what());
+     }
+@@ -4509,18 +4505,16 @@ bool Chainstate::LoadGenesisBlock()
+     return true;
+ }
+ 
+-void Chainstate::LoadExternalBlockFile(
++void ChainstateManager::LoadExternalBlockFile(
+     FILE* fileIn,
+     FlatFilePos* dbp,
+     std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent)
+ {
+-    AssertLockNotHeld(m_chainstate_mutex);
+-
+     // Either both should be specified (-reindex), or neither (-loadblock).
+     assert(!dbp == !blocks_with_unknown_parent);
+ 
+     const auto start{SteadyClock::now()};
+-    const CChainParams& params{m_chainman.GetParams()};
++    const CChainParams& params{GetParams()};
+ 
+     int nLoaded = 0;
+     try {
+@@ -4530,7 +4524,7 @@ void Chainstate::LoadExternalBlockFile(
+         // such as a block fails to deserialize.
+         uint64_t nRewind = blkdat.GetPos();
+         while (!blkdat.eof()) {
+-            if (m_chainman.m_interrupt) return;
++            if (m_interrupt) return;
+ 
+             blkdat.SetPos(nRewind);
+             nRewind++; // start one byte further next time, in case of failure
+@@ -4605,8 +4599,15 @@ void Chainstate::LoadExternalBlockFile(
+ 
+                 // Activate the genesis block so normal node progress can continue
+                 if (hash == params.GetConsensus().hashGenesisBlock) {
+-                    BlockValidationState state;
+-                    if (!ActivateBestChain(state, nullptr)) {
++                    bool genesis_activation_failure = false;
++                    for (auto c : GetAll()) {
++                        BlockValidationState state;
++                        if (!c->ActivateBestChain(state, nullptr)) {
++                            genesis_activation_failure = true;
++                            break;
++                        }
++                    }
++                    if (genesis_activation_failure) {
+                         break;
+                     }
+                 }
+@@ -4619,14 +4620,21 @@ void Chainstate::LoadExternalBlockFile(
+                     // until after all of the block files are loaded. ActivateBestChain can be
+                     // called by concurrent network message processing. but, that is not
+                     // reliable for the purpose of pruning while importing.
+-                    BlockValidationState state;
+-                    if (!ActivateBestChain(state, pblock)) {
+-                        LogPrint(BCLog::REINDEX, "failed to activate chain (%s)\n", state.ToString());
++                    bool activation_failure = false;
++                    for (auto c : GetAll()) {
++                        BlockValidationState state;
++                        if (!c->ActivateBestChain(state, pblock)) {
++                            LogPrint(BCLog::REINDEX, "failed to activate chain (%s)\n", state.ToString());
++                            activation_failure = true;
++                            break;
++                        }
++                    }
++                    if (activation_failure) {
+                         break;
+                     }
+                 }
+ 
+-                NotifyHeaderTip(*this);
++                NotifyHeaderTip(ActiveChainstate());
+ 
+                 if (!blocks_with_unknown_parent) continue;
+ 
+@@ -4652,7 +4660,7 @@ void Chainstate::LoadExternalBlockFile(
+                         }
+                         range.first++;
+                         blocks_with_unknown_parent->erase(it);
+-                        NotifyHeaderTip(*this);
++                        NotifyHeaderTip(ActiveChainstate());
+                     }
+                 }
+             } catch (const std::exception& e) {
+@@ -4671,14 +4679,14 @@ void Chainstate::LoadExternalBlockFile(
+             }
+         }
+     } catch (const std::runtime_error& e) {
+-        m_chainman.GetNotifications().fatalError(std::string("System error: ") + e.what());
++        GetNotifications().fatalError(std::string("System error: ") + e.what());
+     }
+     LogPrintf("Loaded %i blocks from external file in %dms\n", nLoaded, Ticks<std::chrono::milliseconds>(SteadyClock::now() - start));
+ }
+ 
+-void Chainstate::CheckBlockIndex()
++void ChainstateManager::CheckBlockIndex()
+ {
+-    if (!m_chainman.ShouldCheckBlockIndex()) {
++    if (!ShouldCheckBlockIndex()) {
+         return;
+     }
+ 
+@@ -4687,7 +4695,7 @@ void Chainstate::CheckBlockIndex()
+     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,
+     // so we have the genesis block in m_blockman.m_block_index but no active chain. (A few of the
+     // tests when iterating the block tree require that m_chain has been initialized.)
+-    if (m_chain.Height() < 0) {
++    if (ActiveChain().Height() < 0) {
+         assert(m_blockman.m_block_index.size() <= 1);
+         return;
+     }
+@@ -4717,12 +4725,12 @@ void Chainstate::CheckBlockIndex()
+     CBlockIndex* pindexFirstNotTransactionsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).
+     CBlockIndex* pindexFirstNotChainValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).
+     CBlockIndex* pindexFirstNotScriptsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).
++    CBlockIndex* pindexFirstAssumeValid = nullptr; // Oldest ancestor of pindex which has BLOCK_ASSUMED_VALID
+     while (pindex != nullptr) {
+         nNodes++;
++        if (pindexFirstAssumeValid == nullptr && pindex->nStatus & BLOCK_ASSUMED_VALID) pindexFirstAssumeValid = pindex;
+         if (pindexFirstInvalid == nullptr && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;
+-        // Assumed-valid index entries will not have data since we haven't downloaded the
+-        // full block yet.
+-        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA) && !pindex->IsAssumedValid()) {
++        if (pindexFirstMissing == nullptr && !(pindex->nStatus & BLOCK_HAVE_DATA)) {
+             pindexFirstMissing = pindex;
+         }
+         if (pindexFirstNeverProcessed == nullptr && pindex->nTx == 0) pindexFirstNeverProcessed = pindex;
+@@ -4751,8 +4759,12 @@ void Chainstate::CheckBlockIndex()
+         // Begin: actual consistency checks.
+         if (pindex->pprev == nullptr) {
+             // Genesis block checks.
+-            assert(pindex->GetBlockHash() == m_chainman.GetConsensus().hashGenesisBlock); // Genesis block's hash must match.
+-            assert(pindex == m_chain.Genesis()); // The current active chain's genesis block must be this block.
++            assert(pindex->GetBlockHash() == GetConsensus().hashGenesisBlock); // Genesis block's hash must match.
++            for (auto c : GetAll()) {
++                if (c->m_chain.Genesis() != nullptr) {
++                    assert(pindex == c->m_chain.Genesis()); // The chain's genesis block must be this block.
++                }
++            }
+         }
+         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)
+         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).
+@@ -4762,7 +4774,13 @@ void Chainstate::CheckBlockIndex()
+         if (!m_blockman.m_have_pruned && !pindex->IsAssumedValid()) {
+             // If we've never pruned, then HAVE_DATA should be equivalent to nTx > 0
+             assert(!(pindex->nStatus & BLOCK_HAVE_DATA) == (pindex->nTx == 0));
+-            assert(pindexFirstMissing == pindexFirstNeverProcessed);
++            if (pindexFirstAssumeValid == nullptr) {
++                // If we've got some assume valid blocks, then we might have
++                // missing blocks (not HAVE_DATA) but still treat them as
++                // having been processed (with a fake nTx value). Otherwise, we
++                // can assert that these are the same.
++                assert(pindexFirstMissing == pindexFirstNeverProcessed);
++            }
+         } else {
+             // If we have pruned, then we can only say that HAVE_DATA implies nTx > 0
+             if (pindex->nStatus & BLOCK_HAVE_DATA) assert(pindex->nTx > 0);
+@@ -4792,27 +4810,32 @@ void Chainstate::CheckBlockIndex()
+             // Checks for not-invalid blocks.
+             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.
+         }
+-        if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {
+-            if (pindexFirstInvalid == nullptr) {
+-                const bool is_active = this == &m_chainman.ActiveChainstate();
+-
+-                // If this block sorts at least as good as the current tip and
+-                // is valid and we have all data for its parents, it must be in
+-                // setBlockIndexCandidates.  m_chain.Tip() must also be there
+-                // even if some data has been pruned.
+-                //
+-                // Don't perform this check for the background chainstate since
+-                // its setBlockIndexCandidates shouldn't have some entries (i.e. those past the
+-                // snapshot block) which do exist in the block index for the active chainstate.
+-                if (is_active && (pindexFirstMissing == nullptr || pindex == m_chain.Tip())) {
+-                    assert(setBlockIndexCandidates.count(pindex));
++        // Chainstate-specific checks on setBlockIndexCandidates
++        for (auto c : GetAll()) {
++            if (c->m_chain.Tip() == nullptr) continue;
++            if (!CBlockIndexWorkComparator()(pindex, c->m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {
++                if (pindexFirstInvalid == nullptr) {
++                    const bool is_active = c == &ActiveChainstate();
++                    // If this block sorts at least as good as the current tip and
++                    // is valid and we have all data for its parents, it must be in
++                    // setBlockIndexCandidates.  m_chain.Tip() must also be there
++                    // even if some data has been pruned.
++                    //
++                    if ((pindexFirstMissing == nullptr || pindex == c->m_chain.Tip())) {
++                        // The active chainstate should always have this block
++                        // as a candidate, but a background chainstate should
++                        // only have it if it is an ancestor of the snapshot base.
++                        if (is_active || GetSnapshotBaseBlock()->GetAncestor(pindex->nHeight) == pindex) {
++                            assert(c->setBlockIndexCandidates.count(pindex));
++                        }
++                    }
++                    // If some parent is missing, then it could be that this block was in
++                    // setBlockIndexCandidates but had to be removed because of the missing data.
++                    // In this case it must be in m_blocks_unlinked -- see test below.
+                 }
+-                // If some parent is missing, then it could be that this block was in
+-                // setBlockIndexCandidates but had to be removed because of the missing data.
+-                // In this case it must be in m_blocks_unlinked -- see test below.
++            } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.
++                assert(c->setBlockIndexCandidates.count(pindex) == 0);
+             }
+-        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.
+-            assert(setBlockIndexCandidates.count(pindex) == 0);
+         }
+         // Check whether this block is in m_blocks_unlinked.
+         std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = m_blockman.m_blocks_unlinked.equal_range(pindex->pprev);
+@@ -4833,18 +4856,23 @@ void Chainstate::CheckBlockIndex()
+         if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.
+         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {
+             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.
+-            assert(m_blockman.m_have_pruned); // We must have pruned.
++            assert(m_blockman.m_have_pruned || pindexFirstAssumeValid != nullptr); // We must have pruned, or else we're using a snapshot (causing us to have faked the received data for some parent(s)).
+             // This block may have entered m_blocks_unlinked if:
+             //  - it has a descendant that at some point had more work than the
+             //    tip, and
+             //  - we tried switching to that descendant but were missing
+             //    data for some intermediate block between m_chain and the
+             //    tip.
+-            // So if this block is itself better than m_chain.Tip() and it wasn't in
++            // So if this block is itself better than any m_chain.Tip() and it wasn't in
+             // setBlockIndexCandidates, then it must be in m_blocks_unlinked.
+-            if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {
+-                if (pindexFirstInvalid == nullptr) {
+-                    assert(foundInUnlinked);
++            for (auto c : GetAll()) {
++                const bool is_active = c == &ActiveChainstate();
++                if (!CBlockIndexWorkComparator()(pindex, c->m_chain.Tip()) && c->setBlockIndexCandidates.count(pindex) == 0) {
++                    if (pindexFirstInvalid == nullptr) {
++                        if (is_active || GetSnapshotBaseBlock()->GetAncestor(pindex->nHeight) == pindex) {
++                            assert(foundInUnlinked);
++                        }
++                    }
+                 }
+             }
+         }
+@@ -4871,6 +4899,7 @@ void Chainstate::CheckBlockIndex()
+             if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = nullptr;
+             if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = nullptr;
+             if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = nullptr;
++            if (pindex == pindexFirstAssumeValid) pindexFirstAssumeValid = nullptr;
+             // Find our parent.
+             CBlockIndex* pindexPar = pindex->pprev;
+             // Find which child we just visited.
+@@ -5682,9 +5711,7 @@ util::Result<void> Chainstate::InvalidateCoinsDBOnDisk()
+ 
+ const CBlockIndex* ChainstateManager::GetSnapshotBaseBlock() const
+ {
+-    const auto blockhash_op = this->SnapshotBlockhash();
+-    if (!blockhash_op) return nullptr;
+-    return Assert(m_blockman.LookupBlockIndex(*blockhash_op));
++    return m_active_chainstate ? m_active_chainstate->SnapshotBase() : nullptr;
+ }
+ 
+ std::optional<int> ChainstateManager::GetSnapshotBaseHeight() const
+diff --git a/src/validation.h b/src/validation.h
+index af8ceb5dfa..d7ad86a5e8 100644
+--- a/src/validation.h
++++ b/src/validation.h
+@@ -465,17 +465,6 @@ enum class CoinsCacheSizeState
+ class Chainstate
+ {
+ protected:
+-    /**
+-     * Every received block is assigned a unique and increasing identifier, so we
+-     * know which one to give priority in case of a fork.
+-     */
+-    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */
+-    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;
+-    /** Decreasing counter (used by subsequent preciousblock calls). */
+-    int32_t nBlockReverseSequenceId = -1;
+-    /** chainwork for the last block that preciousblock has been applied to. */
+-    arith_uint256 nLastPreciousChainwork = 0;
+-
+     /**
+      * The ChainState Mutex
+      * A lock that must be held when modifying this ChainState - held in ActivateBestChain() and
+@@ -511,6 +500,9 @@ protected:
+     //! is set to true on the snapshot chainstate.
+     bool m_disabled GUARDED_BY(::cs_main) {false};
+ 
++    //! Cached result of LookupBlockIndex(*m_from_snapshot_blockhash)
++    const CBlockIndex* m_cached_snapshot_base GUARDED_BY(::cs_main) {nullptr};
++
+ public:
+     //! Reference to a BlockManager instance which itself is shared across all
+     //! Chainstate instances.
+@@ -562,9 +554,12 @@ public:
+      */
+     const std::optional<uint256> m_from_snapshot_blockhash;
+ 
+-    //! Return true if this chainstate relies on blocks that are assumed-valid. In
+-    //! practice this means it was created based on a UTXO snapshot.
+-    bool reliesOnAssumedValid() { return m_from_snapshot_blockhash.has_value(); }
++    /**
++     * The base of the snapshot this chainstate was created from.
++     *
++     * nullptr if this chainstate was not created from a snapshot.
++     */
++    const CBlockIndex* SnapshotBase() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
+ 
+     /**
+      * The set of all CBlockIndex entries with either BLOCK_VALID_TRANSACTIONS (for
+@@ -620,37 +615,6 @@ public:
+     bool ResizeCoinsCaches(size_t coinstip_size, size_t coinsdb_size)
+         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
+ 
+-    /**
+-     * Import blocks from an external file
+-     *
+-     * During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat).
+-     * It reads all blocks contained in the given file and attempts to process them (add them to the
+-     * block index). The blocks may be out of order within each file and across files. Often this
+-     * function reads a block but finds that its parent hasn't been read yet, so the block can't be
+-     * processed yet. The function will add an entry to the blocks_with_unknown_parent map (which is
+-     * passed as an argument), so that when the block's parent is later read and processed, this
+-     * function can re-read the child block from disk and process it.
+-     *
+-     * Because a block's parent may be in a later file, not just later in the same file, the
+-     * blocks_with_unknown_parent map must be passed in and out with each call. It's a multimap,
+-     * rather than just a map, because multiple blocks may have the same parent (when chain splits
+-     * or stale blocks exist). It maps from parent-hash to child-disk-position.
+-     *
+-     * This function can also be used to read blocks from user-specified block files using the
+-     * -loadblock= option. There's no unknown-parent tracking, so the last two arguments are omitted.
+-     *
+-     *
+-     * @param[in]     fileIn                        FILE handle to file containing blocks to read
+-     * @param[in]     dbp                           (optional) Disk block position (only for reindex)
+-     * @param[in,out] blocks_with_unknown_parent    (optional) Map of disk positions for blocks with
+-     *                                              unknown parent, key is parent block hash
+-     *                                              (only used for reindex)
+-     * */
+-    void LoadExternalBlockFile(
+-        FILE* fileIn,
+-        FlatFilePos* dbp = nullptr,
+-        std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent = nullptr)
+-        EXCLUSIVE_LOCKS_REQUIRED(!m_chainstate_mutex);
+ 
+     /**
+      * Update the on-disk chain state.
+@@ -702,8 +666,6 @@ public:
+         EXCLUSIVE_LOCKS_REQUIRED(!m_chainstate_mutex)
+         LOCKS_EXCLUDED(::cs_main);
+ 
+-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+-
+     // Block (dis)connection on a given view:
+     DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)
+         EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
+@@ -738,9 +700,11 @@ public:
+     /** Ensures we have a genesis block in the block tree, possibly writing one to disk. */
+     bool LoadGenesisBlock();
+ 
++    void TryAddBlockIndexCandidate(CBlockIndex* pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
++
+     void PruneBlockIndexCandidates();
+ 
+-    void UnloadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
++    void ClearBlockIndexCandidates() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);
+ 
+     /** Check whether we are doing an initial block download (synchronizing from disk or network) */
+     bool IsInitialBlockDownload() const;
+@@ -748,13 +712,6 @@ public:
+     /** Find the last common block of this chain and a locator. */
+     const CBlockIndex* FindForkInGlobalIndex(const CBlockLocator& locator) const EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+ 
+-    /**
+-     * Make various assertions about the state of the block index.
+-     *
+-     * By default this only executes fully when using the Regtest chain; see: m_options.check_block_index.
+-     */
+-    void CheckBlockIndex();
+-
+     /** Load the persisted mempool from disk */
+     void LoadMempool(const fs::path& load_path, fsbridge::FopenFn mockable_fopen_function = fsbridge::fopen);
+ 
+@@ -784,7 +741,6 @@ private:
+ 
+     void InvalidBlockFound(CBlockIndex* pindex, const BlockValidationState& state) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+     CBlockIndex* FindMostWorkChain() EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+-    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+ 
+     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
+ 
+@@ -970,6 +926,13 @@ public:
+     const uint256& AssumedValidBlock() const { return *Assert(m_options.assumed_valid_block); }
+     kernel::Notifications& GetNotifications() const { return m_options.notifications; };
+ 
++    /**
++     * Make various assertions about the state of the block index.
++     *
++     * By default this only executes fully when using the Regtest chain; see: m_options.check_block_index.
++     */
++    void CheckBlockIndex();
++
+     /**
+      * Alias for ::cs_main.
+      * Should be used in new code to make it easier to make ::cs_main a member
+@@ -990,6 +953,27 @@ public:
+     //! chainstate to avoid duplicating block metadata.
+     node::BlockManager m_blockman;
+ 
++    /**
++     * Every received block is assigned a unique and increasing identifier, so we
++     * know which one to give priority in case of a fork.
++     */
++    /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */
++    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;
++    /** Decreasing counter (used by subsequent preciousblock calls). */
++    int32_t nBlockReverseSequenceId = -1;
++    /** chainwork for the last block that preciousblock has been applied to. */
++    arith_uint256 nLastPreciousChainwork = 0;
++
++    // Reset the memory-only sequence counters we use to track block arrival
++    // (used by tests to reset state)
++    void ResetBlockSequenceCounters() EXCLUSIVE_LOCKS_REQUIRED(::cs_main)
++    {
++        AssertLockHeld(::cs_main);
++        nBlockSequenceId = 1;
++        nBlockReverseSequenceId = -1;
++    }
++
++
+     /**
+      * In order to efficiently track invalidity of headers, we keep the set of
+      * blocks which we tried to connect and found to be invalid here (ie which
+@@ -1085,6 +1069,37 @@ public:
+         return m_snapshot_chainstate && m_ibd_chainstate && m_ibd_chainstate->m_disabled;
+     }
+ 
++    /**
++     * Import blocks from an external file
++     *
++     * During reindexing, this function is called for each block file (datadir/blocks/blk?????.dat).
++     * It reads all blocks contained in the given file and attempts to process them (add them to the
++     * block index). The blocks may be out of order within each file and across files. Often this
++     * function reads a block but finds that its parent hasn't been read yet, so the block can't be
++     * processed yet. The function will add an entry to the blocks_with_unknown_parent map (which is
++     * passed as an argument), so that when the block's parent is later read and processed, this
++     * function can re-read the child block from disk and process it.
++     *
++     * Because a block's parent may be in a later file, not just later in the same file, the
++     * blocks_with_unknown_parent map must be passed in and out with each call. It's a multimap,
++     * rather than just a map, because multiple blocks may have the same parent (when chain splits
++     * or stale blocks exist). It maps from parent-hash to child-disk-position.
++     *
++     * This function can also be used to read blocks from user-specified block files using the
++     * -loadblock= option. There's no unknown-parent tracking, so the last two arguments are omitted.
++     *
++     *
++     * @param[in]     fileIn                        FILE handle to file containing blocks to read
++     * @param[in]     dbp                           (optional) Disk block position (only for reindex)
++     * @param[in,out] blocks_with_unknown_parent    (optional) Map of disk positions for blocks with
++     *                                              unknown parent, key is parent block hash
++     *                                              (only used for reindex)
++     * */
++    void LoadExternalBlockFile(
++        FILE* fileIn,
++        FlatFilePos* dbp = nullptr,
++        std::multimap<uint256, FlatFilePos>* blocks_with_unknown_parent = nullptr);
++
+     /**
+      * Process an incoming block. This only returns after the best known valid
+      * block is made active. Note that it does not, however, guarantee that the
+@@ -1124,6 +1139,29 @@ public:
+      */
+     bool ProcessNewBlockHeaders(const std::vector<CBlockHeader>& block, bool min_pow_checked, BlockValidationState& state, const CBlockIndex** ppindex = nullptr) LOCKS_EXCLUDED(cs_main);
+ 
++    /**
++     * Sufficiently validate a block for disk storage (and store on disk).
++     *
++     * @param[in]   pblock          The block we want to process.
++     * @param[in]   fRequested      Whether we requested this block from a
++     *                              peer.
++     * @param[in]   dbp             The location on disk, if we are importing
++     *                              this block from prior storage.
++     * @param[in]   min_pow_checked True if proof-of-work anti-DoS checks have
++     *                              been done by caller for headers chain
++     *
++     * @param[out]  state       The state of the block validation.
++     * @param[out]  ppindex     Optional return parameter to get the
++     *                          CBlockIndex pointer for this block.
++     * @param[out]  fNewBlock   Optional return parameter to indicate if the
++     *                          block is new to our storage.
++     *
++     * @returns   False if the block or header is invalid, or if saving to disk fails (likely a fatal error); true otherwise.
++     */
++    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, BlockValidationState& state, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock, bool min_pow_checked) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
++
++    void ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pindexNew, const FlatFilePos& pos) EXCLUSIVE_LOCKS_REQUIRED(cs_main);
++
+     /**
+      * Try to add a transaction to the memory pool.
+      *
\ No newline at end of file
